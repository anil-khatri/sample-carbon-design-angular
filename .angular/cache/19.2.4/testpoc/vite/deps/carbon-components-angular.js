import {
  Router,
  RouterLink,
  RouterLinkActive,
  RouterModule
} from "./chunk-QB2557IP.js";
import {
  AsyncPipe,
  CommonModule,
  DOCUMENT,
  DomSanitizer,
  NgClass,
  NgForOf,
  NgIf,
  NgStyle,
  NgSwitch,
  NgSwitchCase,
  NgSwitchDefault,
  NgTemplateOutlet,
  getDOM
} from "./chunk-B7YMS3AF.js";
import {
  ApplicationRef,
  BehaviorSubject,
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  Component,
  ContentChild,
  ContentChildren,
  Directive,
  ElementRef,
  EnvironmentInjector,
  EventEmitter,
  Host,
  HostBinding,
  HostListener,
  Inject,
  Injectable,
  InjectionToken,
  Injector,
  Input,
  NgModule,
  NgZone,
  Observable,
  Optional,
  Output,
  Pipe,
  Renderer2,
  ReplaySubject,
  RuntimeError,
  Self,
  SkipSelf,
  Subject,
  Subscription,
  TemplateRef,
  Version,
  ViewChild,
  ViewChildren,
  ViewContainerRef,
  ViewEncapsulation,
  __async,
  __commonJS,
  __objRest,
  __spreadProps,
  __spreadValues,
  __toESM,
  booleanAttribute,
  combineLatest,
  computed,
  debounceTime,
  delay,
  filter,
  first,
  forkJoin,
  forwardRef,
  from,
  fromEvent,
  iif,
  inject,
  isObservable,
  isPromise,
  isSubscribable,
  map,
  merge,
  of,
  setClassMetadata,
  signal,
  takeUntil,
  tap,
  untracked,
  ɵɵInheritDefinitionFeature,
  ɵɵNgOnChangesFeature,
  ɵɵProvidersFeature,
  ɵɵadvance,
  ɵɵattribute,
  ɵɵclassMap,
  ɵɵclassMapInterpolate1,
  ɵɵclassProp,
  ɵɵcontentQuery,
  ɵɵdefineComponent,
  ɵɵdefineDirective,
  ɵɵdefineInjectable,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdefinePipe,
  ɵɵdirectiveInject,
  ɵɵelement,
  ɵɵelementContainer,
  ɵɵelementContainerEnd,
  ɵɵelementContainerStart,
  ɵɵelementEnd,
  ɵɵelementStart,
  ɵɵgetCurrentView,
  ɵɵgetInheritedFactory,
  ɵɵinject,
  ɵɵlistener,
  ɵɵloadQuery,
  ɵɵnamespaceHTML,
  ɵɵnamespaceSVG,
  ɵɵnextContext,
  ɵɵpipe,
  ɵɵpipeBind1,
  ɵɵpipeBind2,
  ɵɵprojection,
  ɵɵprojectionDef,
  ɵɵproperty,
  ɵɵpropertyInterpolate,
  ɵɵpropertyInterpolate1,
  ɵɵpureFunction0,
  ɵɵpureFunction1,
  ɵɵpureFunction2,
  ɵɵpureFunction3,
  ɵɵpureFunction4,
  ɵɵpureFunction5,
  ɵɵpureFunction6,
  ɵɵpureFunction7,
  ɵɵpureFunction8,
  ɵɵpureFunctionV,
  ɵɵqueryRefresh,
  ɵɵreference,
  ɵɵresetView,
  ɵɵresolveDocument,
  ɵɵrestoreView,
  ɵɵsanitizeHtml,
  ɵɵsanitizeUrl,
  ɵɵstyleProp,
  ɵɵtemplate,
  ɵɵtemplateRefExtractor,
  ɵɵtext,
  ɵɵtextInterpolate,
  ɵɵtextInterpolate1,
  ɵɵtwoWayBindingSet,
  ɵɵtwoWayListener,
  ɵɵtwoWayProperty,
  ɵɵviewQuery
} from "./chunk-LTMJ2FMB.js";

// node_modules/flatpickr/dist/plugins/rangePlugin.js
var require_rangePlugin = __commonJS({
  "node_modules/flatpickr/dist/plugins/rangePlugin.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.rangePlugin = factory());
    })(exports2, function() {
      "use strict";
      function __spreadArrays2() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];
        return r;
      }
      function rangePlugin2(config2) {
        if (config2 === void 0) {
          config2 = {};
        }
        return function(fp) {
          var dateFormat = "", secondInput, _secondInputFocused, _prevDates;
          var createSecondInput = function() {
            if (config2.input) {
              secondInput = config2.input instanceof Element ? config2.input : window.document.querySelector(config2.input);
              if (!secondInput) {
                fp.config.errorHandler(new Error("Invalid input element specified"));
                return;
              }
              if (fp.config.wrap) {
                secondInput = secondInput.querySelector("[data-input]");
              }
            } else {
              secondInput = fp._input.cloneNode();
              secondInput.removeAttribute("id");
              secondInput._flatpickr = void 0;
            }
            if (secondInput.value) {
              var parsedDate = fp.parseDate(secondInput.value);
              if (parsedDate) fp.selectedDates.push(parsedDate);
            }
            secondInput.setAttribute("data-fp-omit", "");
            if (fp.config.clickOpens) {
              fp._bind(secondInput, ["focus", "click"], function() {
                if (fp.selectedDates[1]) {
                  fp.latestSelectedDateObj = fp.selectedDates[1];
                  fp._setHoursFromDate(fp.selectedDates[1]);
                  fp.jumpToDate(fp.selectedDates[1]);
                }
                _secondInputFocused = true;
                fp.isOpen = false;
                fp.open(void 0, config2.position === "left" ? fp._input : secondInput);
              });
              fp._bind(fp._input, ["focus", "click"], function(e) {
                e.preventDefault();
                fp.isOpen = false;
                fp.open();
              });
            }
            if (fp.config.allowInput) fp._bind(secondInput, "keydown", function(e) {
              if (e.key === "Enter") {
                fp.setDate([fp.selectedDates[0], secondInput.value], true, dateFormat);
                secondInput.click();
              }
            });
            if (!config2.input) fp._input.parentNode && fp._input.parentNode.insertBefore(secondInput, fp._input.nextSibling);
          };
          var plugin = {
            onParseConfig: function() {
              fp.config.mode = "range";
              dateFormat = fp.config.altInput ? fp.config.altFormat : fp.config.dateFormat;
            },
            onReady: function() {
              createSecondInput();
              fp.config.ignoredFocusElements.push(secondInput);
              if (fp.config.allowInput) {
                fp._input.removeAttribute("readonly");
                secondInput.removeAttribute("readonly");
              } else {
                secondInput.setAttribute("readonly", "readonly");
              }
              fp._bind(fp._input, "focus", function() {
                fp.latestSelectedDateObj = fp.selectedDates[0];
                fp._setHoursFromDate(fp.selectedDates[0]);
                _secondInputFocused = false;
                fp.jumpToDate(fp.selectedDates[0]);
              });
              if (fp.config.allowInput) fp._bind(fp._input, "keydown", function(e) {
                if (e.key === "Enter") fp.setDate([fp._input.value, fp.selectedDates[1]], true, dateFormat);
              });
              fp.setDate(fp.selectedDates, false);
              plugin.onValueUpdate(fp.selectedDates);
              fp.loadedPlugins.push("range");
            },
            onPreCalendarPosition: function() {
              if (_secondInputFocused) {
                fp._positionElement = secondInput;
                setTimeout(function() {
                  fp._positionElement = fp._input;
                }, 0);
              }
            },
            onChange: function() {
              if (!fp.selectedDates.length) {
                setTimeout(function() {
                  if (fp.selectedDates.length) return;
                  secondInput.value = "";
                  _prevDates = [];
                }, 10);
              }
              if (_secondInputFocused) {
                setTimeout(function() {
                  secondInput.focus();
                }, 0);
              }
            },
            onDestroy: function() {
              if (!config2.input) secondInput.parentNode && secondInput.parentNode.removeChild(secondInput);
            },
            onValueUpdate: function(selDates) {
              var _a2, _b, _c;
              if (!secondInput) return;
              _prevDates = !_prevDates || selDates.length >= _prevDates.length ? __spreadArrays2(selDates) : _prevDates;
              if (_prevDates.length > selDates.length) {
                var newSelectedDate = selDates[0];
                var newDates = _secondInputFocused ? [_prevDates[0], newSelectedDate] : [newSelectedDate, _prevDates[1]];
                if (newDates[0].getTime() > newDates[1].getTime()) {
                  if (_secondInputFocused) {
                    newDates[0] = newDates[1];
                  } else {
                    newDates[1] = newDates[0];
                  }
                }
                fp.setDate(newDates, false);
                _prevDates = __spreadArrays2(newDates);
              }
              _a2 = fp.selectedDates.map(function(d) {
                return fp.formatDate(d, dateFormat);
              }), _b = _a2[0], fp._input.value = _b === void 0 ? "" : _b, _c = _a2[1], secondInput.value = _c === void 0 ? "" : _c;
            }
          };
          return plugin;
        };
      }
      return rangePlugin2;
    });
  }
});

// node_modules/flatpickr/dist/l10n/index.js
var require_l10n = __commonJS({
  "node_modules/flatpickr/dist/l10n/index.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.index = {}));
    })(exports2, function(exports3) {
      "use strict";
      var __assign2 = function() {
        __assign2 = Object.assign || function __assign3(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
          return t;
        };
        return __assign2.apply(this, arguments);
      };
      var fp = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Arabic = {
        weekdays: {
          shorthand: ["أحد", "اثنين", "ثلاثاء", "أربعاء", "خميس", "جمعة", "سبت"],
          longhand: ["الأحد", "الاثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت"]
        },
        months: {
          shorthand: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
          longhand: ["يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"]
        },
        firstDayOfWeek: 6,
        rangeSeparator: " إلى ",
        weekAbbreviation: "Wk",
        scrollTitle: "قم بالتمرير للزيادة",
        toggleTitle: "اضغط للتبديل",
        amPM: ["ص", "م"],
        yearAriaLabel: "سنة",
        monthAriaLabel: "شهر",
        hourAriaLabel: "ساعة",
        minuteAriaLabel: "دقيقة",
        time_24hr: false
      };
      fp.l10ns.ar = Arabic;
      fp.l10ns;
      var fp$1 = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Austria = {
        weekdays: {
          shorthand: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
          longhand: ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"]
        },
        months: {
          shorthand: ["Jän", "Feb", "Mär", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"],
          longhand: ["Jänner", "Februar", "März", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"]
        },
        firstDayOfWeek: 1,
        weekAbbreviation: "KW",
        rangeSeparator: " bis ",
        scrollTitle: "Zum Ändern scrollen",
        toggleTitle: "Zum Umschalten klicken",
        time_24hr: true
      };
      fp$1.l10ns.at = Austria;
      fp$1.l10ns;
      var fp$2 = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Azerbaijan = {
        weekdays: {
          shorthand: ["B.", "B.e.", "Ç.a.", "Ç.", "C.a.", "C.", "Ş."],
          longhand: ["Bazar", "Bazar ertəsi", "Çərşənbə axşamı", "Çərşənbə", "Cümə axşamı", "Cümə", "Şənbə"]
        },
        months: {
          shorthand: ["Yan", "Fev", "Mar", "Apr", "May", "İyn", "İyl", "Avq", "Sen", "Okt", "Noy", "Dek"],
          longhand: ["Yanvar", "Fevral", "Mart", "Aprel", "May", "İyun", "İyul", "Avqust", "Sentyabr", "Oktyabr", "Noyabr", "Dekabr"]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return ".";
        },
        rangeSeparator: " - ",
        weekAbbreviation: "Hf",
        scrollTitle: "Artırmaq üçün sürüşdürün",
        toggleTitle: "Aç / Bağla",
        amPM: ["GƏ", "GS"],
        time_24hr: true
      };
      fp$2.l10ns.az = Azerbaijan;
      fp$2.l10ns;
      var fp$3 = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Belarusian = {
        weekdays: {
          shorthand: ["Нд", "Пн", "Аў", "Ср", "Чц", "Пт", "Сб"],
          longhand: ["Нядзеля", "Панядзелак", "Аўторак", "Серада", "Чацвер", "Пятніца", "Субота"]
        },
        months: {
          shorthand: ["Сту", "Лют", "Сак", "Кра", "Тра", "Чэр", "Ліп", "Жні", "Вер", "Кас", "Ліс", "Сне"],
          longhand: ["Студзень", "Люты", "Сакавік", "Красавік", "Травень", "Чэрвень", "Ліпень", "Жнівень", "Верасень", "Кастрычнік", "Лістапад", "Снежань"]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return "";
        },
        rangeSeparator: " — ",
        weekAbbreviation: "Тыд.",
        scrollTitle: "Пракруціце для павелічэння",
        toggleTitle: "Націсніце для пераключэння",
        amPM: ["ДП", "ПП"],
        yearAriaLabel: "Год",
        time_24hr: true
      };
      fp$3.l10ns.be = Belarusian;
      fp$3.l10ns;
      var fp$4 = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Bosnian = {
        firstDayOfWeek: 1,
        weekdays: {
          shorthand: ["Ned", "Pon", "Uto", "Sri", "Čet", "Pet", "Sub"],
          longhand: ["Nedjelja", "Ponedjeljak", "Utorak", "Srijeda", "Četvrtak", "Petak", "Subota"]
        },
        months: {
          shorthand: ["Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Avg", "Sep", "Okt", "Nov", "Dec"],
          longhand: ["Januar", "Februar", "Mart", "April", "Maj", "Juni", "Juli", "Avgust", "Septembar", "Oktobar", "Novembar", "Decembar"]
        },
        time_24hr: true
      };
      fp$4.l10ns.bs = Bosnian;
      fp$4.l10ns;
      var fp$5 = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Bulgarian = {
        weekdays: {
          shorthand: ["Нд", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"],
          longhand: ["Неделя", "Понеделник", "Вторник", "Сряда", "Четвъртък", "Петък", "Събота"]
        },
        months: {
          shorthand: ["Яну", "Фев", "Март", "Апр", "Май", "Юни", "Юли", "Авг", "Сеп", "Окт", "Ное", "Дек"],
          longhand: ["Януари", "Февруари", "Март", "Април", "Май", "Юни", "Юли", "Август", "Септември", "Октомври", "Ноември", "Декември"]
        },
        time_24hr: true,
        firstDayOfWeek: 1
      };
      fp$5.l10ns.bg = Bulgarian;
      fp$5.l10ns;
      var fp$6 = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Bangla = {
        weekdays: {
          shorthand: ["রবি", "সোম", "মঙ্গল", "বুধ", "বৃহস্পতি", "শুক্র", "শনি"],
          longhand: ["রবিবার", "সোমবার", "মঙ্গলবার", "বুধবার", "বৃহস্পতিবার", "শুক্রবার", "শনিবার"]
        },
        months: {
          shorthand: ["জানু", "ফেব্রু", "মার্চ", "এপ্রিল", "মে", "জুন", "জুলাই", "আগ", "সেপ্টে", "অক্টো", "নভে", "ডিসে"],
          longhand: ["জানুয়ারী", "ফেব্রুয়ারী", "মার্চ", "এপ্রিল", "মে", "জুন", "জুলাই", "আগস্ট", "সেপ্টেম্বর", "অক্টোবর", "নভেম্বর", "ডিসেম্বর"]
        }
      };
      fp$6.l10ns.bn = Bangla;
      fp$6.l10ns;
      var fp$7 = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Catalan = {
        weekdays: {
          shorthand: ["Dg", "Dl", "Dt", "Dc", "Dj", "Dv", "Ds"],
          longhand: ["Diumenge", "Dilluns", "Dimarts", "Dimecres", "Dijous", "Divendres", "Dissabte"]
        },
        months: {
          shorthand: ["Gen", "Febr", "Març", "Abr", "Maig", "Juny", "Jul", "Ag", "Set", "Oct", "Nov", "Des"],
          longhand: ["Gener", "Febrer", "Març", "Abril", "Maig", "Juny", "Juliol", "Agost", "Setembre", "Octubre", "Novembre", "Desembre"]
        },
        ordinal: function(nth) {
          var s = nth % 100;
          if (s > 3 && s < 21) return "è";
          switch (s % 10) {
            case 1:
              return "r";
            case 2:
              return "n";
            case 3:
              return "r";
            case 4:
              return "t";
            default:
              return "è";
          }
        },
        firstDayOfWeek: 1,
        rangeSeparator: " a ",
        time_24hr: true
      };
      fp$7.l10ns.cat = fp$7.l10ns.ca = Catalan;
      fp$7.l10ns;
      var fp$8 = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Kurdish = {
        weekdays: {
          shorthand: ["یەکشەممە", "دووشەممە", "سێشەممە", "چوارشەممە", "پێنجشەممە", "هەینی", "شەممە"],
          longhand: ["یەکشەممە", "دووشەممە", "سێشەممە", "چوارشەممە", "پێنجشەممە", "هەینی", "شەممە"]
        },
        months: {
          shorthand: ["ڕێبەندان", "ڕەشەمە", "نەورۆز", "گوڵان", "جۆزەردان", "پووشپەڕ", "گەلاوێژ", "خەرمانان", "ڕەزبەر", "گەڵاڕێزان", "سەرماوەز", "بەفرانبار"],
          longhand: ["ڕێبەندان", "ڕەشەمە", "نەورۆز", "گوڵان", "جۆزەردان", "پووشپەڕ", "گەلاوێژ", "خەرمانان", "ڕەزبەر", "گەڵاڕێزان", "سەرماوەز", "بەفرانبار"]
        },
        firstDayOfWeek: 6,
        ordinal: function() {
          return "";
        }
      };
      fp$8.l10ns.ckb = Kurdish;
      fp$8.l10ns;
      var fp$9 = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Czech = {
        weekdays: {
          shorthand: ["Ne", "Po", "Út", "St", "Čt", "Pá", "So"],
          longhand: ["Neděle", "Pondělí", "Úterý", "Středa", "Čtvrtek", "Pátek", "Sobota"]
        },
        months: {
          shorthand: ["Led", "Ún", "Bře", "Dub", "Kvě", "Čer", "Čvc", "Srp", "Zář", "Říj", "Lis", "Pro"],
          longhand: ["Leden", "Únor", "Březen", "Duben", "Květen", "Červen", "Červenec", "Srpen", "Září", "Říjen", "Listopad", "Prosinec"]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return ".";
        },
        rangeSeparator: " do ",
        weekAbbreviation: "Týd.",
        scrollTitle: "Rolujte pro změnu",
        toggleTitle: "Přepnout dopoledne/odpoledne",
        amPM: ["dop.", "odp."],
        yearAriaLabel: "Rok",
        time_24hr: true
      };
      fp$9.l10ns.cs = Czech;
      fp$9.l10ns;
      var fp$a = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Welsh = {
        weekdays: {
          shorthand: ["Sul", "Llun", "Maw", "Mer", "Iau", "Gwe", "Sad"],
          longhand: ["Dydd Sul", "Dydd Llun", "Dydd Mawrth", "Dydd Mercher", "Dydd Iau", "Dydd Gwener", "Dydd Sadwrn"]
        },
        months: {
          shorthand: ["Ion", "Chwef", "Maw", "Ebr", "Mai", "Meh", "Gorff", "Awst", "Medi", "Hyd", "Tach", "Rhag"],
          longhand: ["Ionawr", "Chwefror", "Mawrth", "Ebrill", "Mai", "Mehefin", "Gorffennaf", "Awst", "Medi", "Hydref", "Tachwedd", "Rhagfyr"]
        },
        firstDayOfWeek: 1,
        ordinal: function(nth) {
          if (nth === 1) return "af";
          if (nth === 2) return "ail";
          if (nth === 3 || nth === 4) return "ydd";
          if (nth === 5 || nth === 6) return "ed";
          if (nth >= 7 && nth <= 10 || nth == 12 || nth == 15 || nth == 18 || nth == 20) return "fed";
          if (nth == 11 || nth == 13 || nth == 14 || nth == 16 || nth == 17 || nth == 19) return "eg";
          if (nth >= 21 && nth <= 39) return "ain";
          return "";
        },
        time_24hr: true
      };
      fp$a.l10ns.cy = Welsh;
      fp$a.l10ns;
      var fp$b = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Danish = {
        weekdays: {
          shorthand: ["søn", "man", "tir", "ons", "tors", "fre", "lør"],
          longhand: ["søndag", "mandag", "tirsdag", "onsdag", "torsdag", "fredag", "lørdag"]
        },
        months: {
          shorthand: ["jan", "feb", "mar", "apr", "maj", "jun", "jul", "aug", "sep", "okt", "nov", "dec"],
          longhand: ["januar", "februar", "marts", "april", "maj", "juni", "juli", "august", "september", "oktober", "november", "december"]
        },
        ordinal: function() {
          return ".";
        },
        firstDayOfWeek: 1,
        rangeSeparator: " til ",
        weekAbbreviation: "uge",
        time_24hr: true
      };
      fp$b.l10ns.da = Danish;
      fp$b.l10ns;
      var fp$c = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var German = {
        weekdays: {
          shorthand: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
          longhand: ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"]
        },
        months: {
          shorthand: ["Jan", "Feb", "Mär", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"],
          longhand: ["Januar", "Februar", "März", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"]
        },
        firstDayOfWeek: 1,
        weekAbbreviation: "KW",
        rangeSeparator: " bis ",
        scrollTitle: "Zum Ändern scrollen",
        toggleTitle: "Zum Umschalten klicken",
        time_24hr: true
      };
      fp$c.l10ns.de = German;
      fp$c.l10ns;
      var english2 = {
        weekdays: {
          shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
          longhand: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
        },
        months: {
          shorthand: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
          longhand: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
        },
        daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
        firstDayOfWeek: 0,
        ordinal: function(nth) {
          var s = nth % 100;
          if (s > 3 && s < 21) return "th";
          switch (s % 10) {
            case 1:
              return "st";
            case 2:
              return "nd";
            case 3:
              return "rd";
            default:
              return "th";
          }
        },
        rangeSeparator: " to ",
        weekAbbreviation: "Wk",
        scrollTitle: "Scroll to increment",
        toggleTitle: "Click to toggle",
        amPM: ["AM", "PM"],
        yearAriaLabel: "Year",
        monthAriaLabel: "Month",
        hourAriaLabel: "Hour",
        minuteAriaLabel: "Minute",
        time_24hr: false
      };
      var fp$d = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Esperanto = {
        firstDayOfWeek: 1,
        rangeSeparator: " ĝis ",
        weekAbbreviation: "Sem",
        scrollTitle: "Rulumu por pligrandigi la valoron",
        toggleTitle: "Klaku por ŝalti",
        weekdays: {
          shorthand: ["Dim", "Lun", "Mar", "Mer", "Ĵaŭ", "Ven", "Sab"],
          longhand: ["dimanĉo", "lundo", "mardo", "merkredo", "ĵaŭdo", "vendredo", "sabato"]
        },
        months: {
          shorthand: ["Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Aŭg", "Sep", "Okt", "Nov", "Dec"],
          longhand: ["januaro", "februaro", "marto", "aprilo", "majo", "junio", "julio", "aŭgusto", "septembro", "oktobro", "novembro", "decembro"]
        },
        ordinal: function() {
          return "-a";
        },
        time_24hr: true
      };
      fp$d.l10ns.eo = Esperanto;
      fp$d.l10ns;
      var fp$e = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Spanish = {
        weekdays: {
          shorthand: ["Dom", "Lun", "Mar", "Mié", "Jue", "Vie", "Sáb"],
          longhand: ["Domingo", "Lunes", "Martes", "Miércoles", "Jueves", "Viernes", "Sábado"]
        },
        months: {
          shorthand: ["Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"],
          longhand: ["Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"]
        },
        ordinal: function() {
          return "º";
        },
        firstDayOfWeek: 1,
        rangeSeparator: " a ",
        time_24hr: true
      };
      fp$e.l10ns.es = Spanish;
      fp$e.l10ns;
      var fp$f = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Estonian = {
        weekdays: {
          shorthand: ["P", "E", "T", "K", "N", "R", "L"],
          longhand: ["Pühapäev", "Esmaspäev", "Teisipäev", "Kolmapäev", "Neljapäev", "Reede", "Laupäev"]
        },
        months: {
          shorthand: ["Jaan", "Veebr", "Märts", "Apr", "Mai", "Juuni", "Juuli", "Aug", "Sept", "Okt", "Nov", "Dets"],
          longhand: ["Jaanuar", "Veebruar", "Märts", "Aprill", "Mai", "Juuni", "Juuli", "August", "September", "Oktoober", "November", "Detsember"]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return ".";
        },
        weekAbbreviation: "Näd",
        rangeSeparator: " kuni ",
        scrollTitle: "Keri, et suurendada",
        toggleTitle: "Klõpsa, et vahetada",
        time_24hr: true
      };
      fp$f.l10ns.et = Estonian;
      fp$f.l10ns;
      var fp$g = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Persian = {
        weekdays: {
          shorthand: ["یک", "دو", "سه", "چهار", "پنج", "جمعه", "شنبه"],
          longhand: ["یک‌شنبه", "دوشنبه", "سه‌شنبه", "چهارشنبه", "پنچ‌شنبه", "جمعه", "شنبه"]
        },
        months: {
          shorthand: ["ژانویه", "فوریه", "مارس", "آوریل", "مه", "ژوئن", "ژوئیه", "اوت", "سپتامبر", "اکتبر", "نوامبر", "دسامبر"],
          longhand: ["ژانویه", "فوریه", "مارس", "آوریل", "مه", "ژوئن", "ژوئیه", "اوت", "سپتامبر", "اکتبر", "نوامبر", "دسامبر"]
        },
        firstDayOfWeek: 6,
        ordinal: function() {
          return "";
        }
      };
      fp$g.l10ns.fa = Persian;
      fp$g.l10ns;
      var fp$h = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Finnish = {
        firstDayOfWeek: 1,
        weekdays: {
          shorthand: ["su", "ma", "ti", "ke", "to", "pe", "la"],
          longhand: ["sunnuntai", "maanantai", "tiistai", "keskiviikko", "torstai", "perjantai", "lauantai"]
        },
        months: {
          shorthand: ["tammi", "helmi", "maalis", "huhti", "touko", "kesä", "heinä", "elo", "syys", "loka", "marras", "joulu"],
          longhand: ["tammikuu", "helmikuu", "maaliskuu", "huhtikuu", "toukokuu", "kesäkuu", "heinäkuu", "elokuu", "syyskuu", "lokakuu", "marraskuu", "joulukuu"]
        },
        ordinal: function() {
          return ".";
        },
        time_24hr: true
      };
      fp$h.l10ns.fi = Finnish;
      fp$h.l10ns;
      var fp$i = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Faroese = {
        weekdays: {
          shorthand: ["Sun", "Mán", "Týs", "Mik", "Hós", "Frí", "Ley"],
          longhand: ["Sunnudagur", "Mánadagur", "Týsdagur", "Mikudagur", "Hósdagur", "Fríggjadagur", "Leygardagur"]
        },
        months: {
          shorthand: ["Jan", "Feb", "Mar", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Des"],
          longhand: ["Januar", "Februar", "Mars", "Apríl", "Mai", "Juni", "Juli", "August", "Septembur", "Oktobur", "Novembur", "Desembur"]
        },
        ordinal: function() {
          return ".";
        },
        firstDayOfWeek: 1,
        rangeSeparator: " til ",
        weekAbbreviation: "vika",
        scrollTitle: "Rulla fyri at broyta",
        toggleTitle: "Trýst fyri at skifta",
        yearAriaLabel: "Ár",
        time_24hr: true
      };
      fp$i.l10ns.fo = Faroese;
      fp$i.l10ns;
      var fp$j = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var French = {
        firstDayOfWeek: 1,
        weekdays: {
          shorthand: ["dim", "lun", "mar", "mer", "jeu", "ven", "sam"],
          longhand: ["dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi"]
        },
        months: {
          shorthand: ["janv", "févr", "mars", "avr", "mai", "juin", "juil", "août", "sept", "oct", "nov", "déc"],
          longhand: ["janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre"]
        },
        ordinal: function(nth) {
          if (nth > 1) return "";
          return "er";
        },
        rangeSeparator: " au ",
        weekAbbreviation: "Sem",
        scrollTitle: "Défiler pour augmenter la valeur",
        toggleTitle: "Cliquer pour basculer",
        time_24hr: true
      };
      fp$j.l10ns.fr = French;
      fp$j.l10ns;
      var fp$k = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Greek = {
        weekdays: {
          shorthand: ["Κυ", "Δε", "Τρ", "Τε", "Πέ", "Πα", "Σά"],
          longhand: ["Κυριακή", "Δευτέρα", "Τρίτη", "Τετάρτη", "Πέμπτη", "Παρασκευή", "Σάββατο"]
        },
        months: {
          shorthand: ["Ιαν", "Φεβ", "Μάρ", "Απρ", "Μάι", "Ιούν", "Ιούλ", "Αύγ", "Σεπ", "Οκτ", "Νοέ", "Δεκ"],
          longhand: ["Ιανουάριος", "Φεβρουάριος", "Μάρτιος", "Απρίλιος", "Μάιος", "Ιούνιος", "Ιούλιος", "Αύγουστος", "Σεπτέμβριος", "Οκτώβριος", "Νοέμβριος", "Δεκέμβριος"]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return "";
        },
        weekAbbreviation: "Εβδ",
        rangeSeparator: " έως ",
        scrollTitle: "Μετακυλήστε για προσαύξηση",
        toggleTitle: "Κάντε κλικ για αλλαγή",
        amPM: ["ΠΜ", "ΜΜ"],
        yearAriaLabel: "χρόνος",
        monthAriaLabel: "μήνας",
        hourAriaLabel: "ώρα",
        minuteAriaLabel: "λεπτό"
      };
      fp$k.l10ns.gr = Greek;
      fp$k.l10ns;
      var fp$l = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Hebrew = {
        weekdays: {
          shorthand: ["א", "ב", "ג", "ד", "ה", "ו", "ש"],
          longhand: ["ראשון", "שני", "שלישי", "רביעי", "חמישי", "שישי", "שבת"]
        },
        months: {
          shorthand: ["ינו׳", "פבר׳", "מרץ", "אפר׳", "מאי", "יוני", "יולי", "אוג׳", "ספט׳", "אוק׳", "נוב׳", "דצמ׳"],
          longhand: ["ינואר", "פברואר", "מרץ", "אפריל", "מאי", "יוני", "יולי", "אוגוסט", "ספטמבר", "אוקטובר", "נובמבר", "דצמבר"]
        },
        rangeSeparator: " אל ",
        time_24hr: true
      };
      fp$l.l10ns.he = Hebrew;
      fp$l.l10ns;
      var fp$m = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Hindi = {
        weekdays: {
          shorthand: ["रवि", "सोम", "मंगल", "बुध", "गुरु", "शुक्र", "शनि"],
          longhand: ["रविवार", "सोमवार", "मंगलवार", "बुधवार", "गुरुवार", "शुक्रवार", "शनिवार"]
        },
        months: {
          shorthand: ["जन", "फर", "मार्च", "अप्रेल", "मई", "जून", "जूलाई", "अग", "सित", "अक्ट", "नव", "दि"],
          longhand: ["जनवरी ", "फरवरी", "मार्च", "अप्रेल", "मई", "जून", "जूलाई", "अगस्त ", "सितम्बर", "अक्टूबर", "नवम्बर", "दिसम्बर"]
        }
      };
      fp$m.l10ns.hi = Hindi;
      fp$m.l10ns;
      var fp$n = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Croatian = {
        firstDayOfWeek: 1,
        weekdays: {
          shorthand: ["Ned", "Pon", "Uto", "Sri", "Čet", "Pet", "Sub"],
          longhand: ["Nedjelja", "Ponedjeljak", "Utorak", "Srijeda", "Četvrtak", "Petak", "Subota"]
        },
        months: {
          shorthand: ["Sij", "Velj", "Ožu", "Tra", "Svi", "Lip", "Srp", "Kol", "Ruj", "Lis", "Stu", "Pro"],
          longhand: ["Siječanj", "Veljača", "Ožujak", "Travanj", "Svibanj", "Lipanj", "Srpanj", "Kolovoz", "Rujan", "Listopad", "Studeni", "Prosinac"]
        },
        time_24hr: true
      };
      fp$n.l10ns.hr = Croatian;
      fp$n.l10ns;
      var fp$o = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Hungarian = {
        firstDayOfWeek: 1,
        weekdays: {
          shorthand: ["V", "H", "K", "Sz", "Cs", "P", "Szo"],
          longhand: ["Vasárnap", "Hétfő", "Kedd", "Szerda", "Csütörtök", "Péntek", "Szombat"]
        },
        months: {
          shorthand: ["Jan", "Feb", "Már", "Ápr", "Máj", "Jún", "Júl", "Aug", "Szep", "Okt", "Nov", "Dec"],
          longhand: ["Január", "Február", "Március", "Április", "Május", "Június", "Július", "Augusztus", "Szeptember", "Október", "November", "December"]
        },
        ordinal: function() {
          return ".";
        },
        weekAbbreviation: "Hét",
        scrollTitle: "Görgessen",
        toggleTitle: "Kattintson a váltáshoz",
        rangeSeparator: " - ",
        time_24hr: true
      };
      fp$o.l10ns.hu = Hungarian;
      fp$o.l10ns;
      var fp$p = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Armenian = {
        weekdays: {
          shorthand: ["Կիր", "Երկ", "Երք", "Չրք", "Հնգ", "Ուրբ", "Շբթ"],
          longhand: ["Կիրակի", "Եկուշաբթի", "Երեքշաբթի", "Չորեքշաբթի", "Հինգշաբթի", "Ուրբաթ", "Շաբաթ"]
        },
        months: {
          shorthand: ["Հնվ", "Փտր", "Մար", "Ապր", "Մայ", "Հնս", "Հլս", "Օգս", "Սեպ", "Հոկ", "Նմբ", "Դեկ"],
          longhand: ["Հունվար", "Փետրվար", "Մարտ", "Ապրիլ", "Մայիս", "Հունիս", "Հուլիս", "Օգոստոս", "Սեպտեմբեր", "Հոկտեմբեր", "Նոյեմբեր", "Դեկտեմբեր"]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return "";
        },
        rangeSeparator: " — ",
        weekAbbreviation: "ՇԲՏ",
        scrollTitle: "Ոլորեք՝ մեծացնելու համար",
        toggleTitle: "Սեղմեք՝ փոխելու համար",
        amPM: ["ՄԿ", "ԿՀ"],
        yearAriaLabel: "Տարի",
        monthAriaLabel: "Ամիս",
        hourAriaLabel: "Ժամ",
        minuteAriaLabel: "Րոպե",
        time_24hr: true
      };
      fp$p.l10ns.hy = Armenian;
      fp$p.l10ns;
      var fp$q = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Indonesian = {
        weekdays: {
          shorthand: ["Min", "Sen", "Sel", "Rab", "Kam", "Jum", "Sab"],
          longhand: ["Minggu", "Senin", "Selasa", "Rabu", "Kamis", "Jumat", "Sabtu"]
        },
        months: {
          shorthand: ["Jan", "Feb", "Mar", "Apr", "Mei", "Jun", "Jul", "Agu", "Sep", "Okt", "Nov", "Des"],
          longhand: ["Januari", "Februari", "Maret", "April", "Mei", "Juni", "Juli", "Agustus", "September", "Oktober", "November", "Desember"]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return "";
        },
        time_24hr: true,
        rangeSeparator: " - "
      };
      fp$q.l10ns.id = Indonesian;
      fp$q.l10ns;
      var fp$r = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Icelandic = {
        weekdays: {
          shorthand: ["Sun", "Mán", "Þri", "Mið", "Fim", "Fös", "Lau"],
          longhand: ["Sunnudagur", "Mánudagur", "Þriðjudagur", "Miðvikudagur", "Fimmtudagur", "Föstudagur", "Laugardagur"]
        },
        months: {
          shorthand: ["Jan", "Feb", "Mar", "Apr", "Maí", "Jún", "Júl", "Ágú", "Sep", "Okt", "Nóv", "Des"],
          longhand: ["Janúar", "Febrúar", "Mars", "Apríl", "Maí", "Júní", "Júlí", "Ágúst", "September", "Október", "Nóvember", "Desember"]
        },
        ordinal: function() {
          return ".";
        },
        firstDayOfWeek: 1,
        rangeSeparator: " til ",
        weekAbbreviation: "vika",
        yearAriaLabel: "Ár",
        time_24hr: true
      };
      fp$r.l10ns.is = Icelandic;
      fp$r.l10ns;
      var fp$s = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Italian = {
        weekdays: {
          shorthand: ["Dom", "Lun", "Mar", "Mer", "Gio", "Ven", "Sab"],
          longhand: ["Domenica", "Lunedì", "Martedì", "Mercoledì", "Giovedì", "Venerdì", "Sabato"]
        },
        months: {
          shorthand: ["Gen", "Feb", "Mar", "Apr", "Mag", "Giu", "Lug", "Ago", "Set", "Ott", "Nov", "Dic"],
          longhand: ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return "°";
        },
        rangeSeparator: " al ",
        weekAbbreviation: "Se",
        scrollTitle: "Scrolla per aumentare",
        toggleTitle: "Clicca per cambiare",
        time_24hr: true
      };
      fp$s.l10ns.it = Italian;
      fp$s.l10ns;
      var fp$t = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Japanese = {
        weekdays: {
          shorthand: ["日", "月", "火", "水", "木", "金", "土"],
          longhand: ["日曜日", "月曜日", "火曜日", "水曜日", "木曜日", "金曜日", "土曜日"]
        },
        months: {
          shorthand: ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"],
          longhand: ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"]
        },
        time_24hr: true,
        rangeSeparator: " から ",
        monthAriaLabel: "月",
        amPM: ["午前", "午後"],
        yearAriaLabel: "年",
        hourAriaLabel: "時間",
        minuteAriaLabel: "分"
      };
      fp$t.l10ns.ja = Japanese;
      fp$t.l10ns;
      var fp$u = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Georgian = {
        weekdays: {
          shorthand: ["კვ", "ორ", "სა", "ოთ", "ხუ", "პა", "შა"],
          longhand: ["კვირა", "ორშაბათი", "სამშაბათი", "ოთხშაბათი", "ხუთშაბათი", "პარასკევი", "შაბათი"]
        },
        months: {
          shorthand: ["იან", "თებ", "მარ", "აპრ", "მაი", "ივნ", "ივლ", "აგვ", "სექ", "ოქტ", "ნოე", "დეკ"],
          longhand: ["იანვარი", "თებერვალი", "მარტი", "აპრილი", "მაისი", "ივნისი", "ივლისი", "აგვისტო", "სექტემბერი", "ოქტომბერი", "ნოემბერი", "დეკემბერი"]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return "";
        },
        rangeSeparator: " — ",
        weekAbbreviation: "კვ.",
        scrollTitle: "დასქროლეთ გასადიდებლად",
        toggleTitle: "დააკლიკეთ გადართვისთვის",
        amPM: ["AM", "PM"],
        yearAriaLabel: "წელი",
        time_24hr: true
      };
      fp$u.l10ns.ka = Georgian;
      fp$u.l10ns;
      var fp$v = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Korean = {
        weekdays: {
          shorthand: ["일", "월", "화", "수", "목", "금", "토"],
          longhand: ["일요일", "월요일", "화요일", "수요일", "목요일", "금요일", "토요일"]
        },
        months: {
          shorthand: ["1월", "2월", "3월", "4월", "5월", "6월", "7월", "8월", "9월", "10월", "11월", "12월"],
          longhand: ["1월", "2월", "3월", "4월", "5월", "6월", "7월", "8월", "9월", "10월", "11월", "12월"]
        },
        ordinal: function() {
          return "일";
        },
        rangeSeparator: " ~ ",
        amPM: ["오전", "오후"]
      };
      fp$v.l10ns.ko = Korean;
      fp$v.l10ns;
      var fp$w = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Khmer = {
        weekdays: {
          shorthand: ["អាទិត្យ", "ចន្ទ", "អង្គារ", "ពុធ", "ព្រហស.", "សុក្រ", "សៅរ៍"],
          longhand: ["អាទិត្យ", "ចន្ទ", "អង្គារ", "ពុធ", "ព្រហស្បតិ៍", "សុក្រ", "សៅរ៍"]
        },
        months: {
          shorthand: ["មករា", "កុម្ភះ", "មីនា", "មេសា", "ឧសភា", "មិថុនា", "កក្កដា", "សីហា", "កញ្ញា", "តុលា", "វិច្ឆិកា", "ធ្នូ"],
          longhand: ["មករា", "កុម្ភះ", "មីនា", "មេសា", "ឧសភា", "មិថុនា", "កក្កដា", "សីហា", "កញ្ញា", "តុលា", "វិច្ឆិកា", "ធ្នូ"]
        },
        ordinal: function() {
          return "";
        },
        firstDayOfWeek: 1,
        rangeSeparator: " ដល់ ",
        weekAbbreviation: "សប្តាហ៍",
        scrollTitle: "រំកិលដើម្បីបង្កើន",
        toggleTitle: "ចុចដើម្បីផ្លាស់ប្ដូរ",
        yearAriaLabel: "ឆ្នាំ",
        time_24hr: true
      };
      fp$w.l10ns.km = Khmer;
      fp$w.l10ns;
      var fp$x = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Kazakh = {
        weekdays: {
          shorthand: ["Жс", "Дс", "Сc", "Ср", "Бс", "Жм", "Сб"],
          longhand: ["Жексенбi", "Дүйсенбi", "Сейсенбi", "Сәрсенбi", "Бейсенбi", "Жұма", "Сенбi"]
        },
        months: {
          shorthand: ["Қаң", "Ақп", "Нау", "Сәу", "Мам", "Мау", "Шiл", "Там", "Қыр", "Қаз", "Қар", "Жел"],
          longhand: ["Қаңтар", "Ақпан", "Наурыз", "Сәуiр", "Мамыр", "Маусым", "Шiлде", "Тамыз", "Қыркүйек", "Қазан", "Қараша", "Желтоқсан"]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return "";
        },
        rangeSeparator: " — ",
        weekAbbreviation: "Апта",
        scrollTitle: "Үлкейту үшін айналдырыңыз",
        toggleTitle: "Ауыстыру үшін басыңыз",
        amPM: ["ТД", "ТК"],
        yearAriaLabel: "Жыл"
      };
      fp$x.l10ns.kz = Kazakh;
      fp$x.l10ns;
      var fp$y = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Lithuanian = {
        weekdays: {
          shorthand: ["S", "Pr", "A", "T", "K", "Pn", "Š"],
          longhand: ["Sekmadienis", "Pirmadienis", "Antradienis", "Trečiadienis", "Ketvirtadienis", "Penktadienis", "Šeštadienis"]
        },
        months: {
          shorthand: ["Sau", "Vas", "Kov", "Bal", "Geg", "Bir", "Lie", "Rgp", "Rgs", "Spl", "Lap", "Grd"],
          longhand: ["Sausis", "Vasaris", "Kovas", "Balandis", "Gegužė", "Birželis", "Liepa", "Rugpjūtis", "Rugsėjis", "Spalis", "Lapkritis", "Gruodis"]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return "-a";
        },
        rangeSeparator: " iki ",
        weekAbbreviation: "Sav",
        scrollTitle: "Keisti laiką pelės rateliu",
        toggleTitle: "Perjungti laiko formatą",
        time_24hr: true
      };
      fp$y.l10ns.lt = Lithuanian;
      fp$y.l10ns;
      var fp$z = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Latvian = {
        firstDayOfWeek: 1,
        weekdays: {
          shorthand: ["Sv", "Pr", "Ot", "Tr", "Ce", "Pk", "Se"],
          longhand: ["Svētdiena", "Pirmdiena", "Otrdiena", "Trešdiena", "Ceturtdiena", "Piektdiena", "Sestdiena"]
        },
        months: {
          shorthand: ["Jan", "Feb", "Mar", "Apr", "Mai", "Jūn", "Jūl", "Aug", "Sep", "Okt", "Nov", "Dec"],
          longhand: ["Janvāris", "Februāris", "Marts", "Aprīlis", "Maijs", "Jūnijs", "Jūlijs", "Augusts", "Septembris", "Oktobris", "Novembris", "Decembris"]
        },
        rangeSeparator: " līdz ",
        time_24hr: true
      };
      fp$z.l10ns.lv = Latvian;
      fp$z.l10ns;
      var fp$A = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Macedonian = {
        weekdays: {
          shorthand: ["Не", "По", "Вт", "Ср", "Че", "Пе", "Са"],
          longhand: ["Недела", "Понеделник", "Вторник", "Среда", "Четврток", "Петок", "Сабота"]
        },
        months: {
          shorthand: ["Јан", "Фев", "Мар", "Апр", "Мај", "Јун", "Јул", "Авг", "Сеп", "Окт", "Ное", "Дек"],
          longhand: ["Јануари", "Февруари", "Март", "Април", "Мај", "Јуни", "Јули", "Август", "Септември", "Октомври", "Ноември", "Декември"]
        },
        firstDayOfWeek: 1,
        weekAbbreviation: "Нед.",
        rangeSeparator: " до ",
        time_24hr: true
      };
      fp$A.l10ns.mk = Macedonian;
      fp$A.l10ns;
      var fp$B = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Mongolian = {
        firstDayOfWeek: 1,
        weekdays: {
          shorthand: ["Да", "Мя", "Лх", "Пү", "Ба", "Бя", "Ня"],
          longhand: ["Даваа", "Мягмар", "Лхагва", "Пүрэв", "Баасан", "Бямба", "Ням"]
        },
        months: {
          shorthand: ["1-р сар", "2-р сар", "3-р сар", "4-р сар", "5-р сар", "6-р сар", "7-р сар", "8-р сар", "9-р сар", "10-р сар", "11-р сар", "12-р сар"],
          longhand: ["Нэгдүгээр сар", "Хоёрдугаар сар", "Гуравдугаар сар", "Дөрөвдүгээр сар", "Тавдугаар сар", "Зургаадугаар сар", "Долдугаар сар", "Наймдугаар сар", "Есдүгээр сар", "Аравдугаар сар", "Арваннэгдүгээр сар", "Арванхоёрдугаар сар"]
        },
        rangeSeparator: "-с ",
        time_24hr: true
      };
      fp$B.l10ns.mn = Mongolian;
      fp$B.l10ns;
      var fp$C = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Malaysian = {
        weekdays: {
          shorthand: ["Aha", "Isn", "Sel", "Rab", "Kha", "Jum", "Sab"],
          longhand: ["Ahad", "Isnin", "Selasa", "Rabu", "Khamis", "Jumaat", "Sabtu"]
        },
        months: {
          shorthand: ["Jan", "Feb", "Mac", "Apr", "Mei", "Jun", "Jul", "Ogo", "Sep", "Okt", "Nov", "Dis"],
          longhand: ["Januari", "Februari", "Mac", "April", "Mei", "Jun", "Julai", "Ogos", "September", "Oktober", "November", "Disember"]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return "";
        }
      };
      fp$C.l10ns;
      var fp$D = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Burmese = {
        weekdays: {
          shorthand: ["နွေ", "လာ", "ဂါ", "ဟူး", "ကြာ", "သော", "နေ"],
          longhand: ["တနင်္ဂနွေ", "တနင်္လာ", "အင်္ဂါ", "ဗုဒ္ဓဟူး", "ကြာသပတေး", "သောကြာ", "စနေ"]
        },
        months: {
          shorthand: ["ဇန်", "ဖေ", "မတ်", "ပြီ", "မေ", "ဇွန်", "လိုင်", "သြ", "စက်", "အောက်", "နို", "ဒီ"],
          longhand: ["ဇန်နဝါရီ", "ဖေဖော်ဝါရီ", "မတ်", "ဧပြီ", "မေ", "ဇွန်", "ဇူလိုင်", "သြဂုတ်", "စက်တင်ဘာ", "အောက်တိုဘာ", "နိုဝင်ဘာ", "ဒီဇင်ဘာ"]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return "";
        },
        time_24hr: true
      };
      fp$D.l10ns.my = Burmese;
      fp$D.l10ns;
      var fp$E = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Dutch = {
        weekdays: {
          shorthand: ["zo", "ma", "di", "wo", "do", "vr", "za"],
          longhand: ["zondag", "maandag", "dinsdag", "woensdag", "donderdag", "vrijdag", "zaterdag"]
        },
        months: {
          shorthand: ["jan", "feb", "mrt", "apr", "mei", "jun", "jul", "aug", "sept", "okt", "nov", "dec"],
          longhand: ["januari", "februari", "maart", "april", "mei", "juni", "juli", "augustus", "september", "oktober", "november", "december"]
        },
        firstDayOfWeek: 1,
        weekAbbreviation: "wk",
        rangeSeparator: " t/m ",
        scrollTitle: "Scroll voor volgende / vorige",
        toggleTitle: "Klik om te wisselen",
        time_24hr: true,
        ordinal: function(nth) {
          if (nth === 1 || nth === 8 || nth >= 20) return "ste";
          return "de";
        }
      };
      fp$E.l10ns.nl = Dutch;
      fp$E.l10ns;
      var fp$F = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var NorwegianNynorsk = {
        weekdays: {
          shorthand: ["Sø.", "Må.", "Ty.", "On.", "To.", "Fr.", "La."],
          longhand: ["Søndag", "Måndag", "Tysdag", "Onsdag", "Torsdag", "Fredag", "Laurdag"]
        },
        months: {
          shorthand: ["Jan", "Feb", "Mars", "Apr", "Mai", "Juni", "Juli", "Aug", "Sep", "Okt", "Nov", "Des"],
          longhand: ["Januar", "Februar", "Mars", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Desember"]
        },
        firstDayOfWeek: 1,
        rangeSeparator: " til ",
        weekAbbreviation: "Veke",
        scrollTitle: "Scroll for å endre",
        toggleTitle: "Klikk for å veksle",
        time_24hr: true,
        ordinal: function() {
          return ".";
        }
      };
      fp$F.l10ns.nn = NorwegianNynorsk;
      fp$F.l10ns;
      var fp$G = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Norwegian = {
        weekdays: {
          shorthand: ["Søn", "Man", "Tir", "Ons", "Tor", "Fre", "Lør"],
          longhand: ["Søndag", "Mandag", "Tirsdag", "Onsdag", "Torsdag", "Fredag", "Lørdag"]
        },
        months: {
          shorthand: ["Jan", "Feb", "Mar", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Des"],
          longhand: ["Januar", "Februar", "Mars", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Desember"]
        },
        firstDayOfWeek: 1,
        rangeSeparator: " til ",
        weekAbbreviation: "Uke",
        scrollTitle: "Scroll for å endre",
        toggleTitle: "Klikk for å veksle",
        time_24hr: true,
        ordinal: function() {
          return ".";
        }
      };
      fp$G.l10ns.no = Norwegian;
      fp$G.l10ns;
      var fp$H = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Punjabi = {
        weekdays: {
          shorthand: ["ਐਤ", "ਸੋਮ", "ਮੰਗਲ", "ਬੁੱਧ", "ਵੀਰ", "ਸ਼ੁੱਕਰ", "ਸ਼ਨਿੱਚਰ"],
          longhand: ["ਐਤਵਾਰ", "ਸੋਮਵਾਰ", "ਮੰਗਲਵਾਰ", "ਬੁੱਧਵਾਰ", "ਵੀਰਵਾਰ", "ਸ਼ੁੱਕਰਵਾਰ", "ਸ਼ਨਿੱਚਰਵਾਰ"]
        },
        months: {
          shorthand: ["ਜਨ", "ਫ਼ਰ", "ਮਾਰ", "ਅਪ੍ਰੈ", "ਮਈ", "ਜੂਨ", "ਜੁਲਾ", "ਅਗ", "ਸਤੰ", "ਅਕ", "ਨਵੰ", "ਦਸੰ"],
          longhand: ["ਜਨਵਰੀ", "ਫ਼ਰਵਰੀ", "ਮਾਰਚ", "ਅਪ੍ਰੈਲ", "ਮਈ", "ਜੂਨ", "ਜੁਲਾਈ", "ਅਗਸਤ", "ਸਤੰਬਰ", "ਅਕਤੂਬਰ", "ਨਵੰਬਰ", "ਦਸੰਬਰ"]
        },
        time_24hr: true
      };
      fp$H.l10ns.pa = Punjabi;
      fp$H.l10ns;
      var fp$I = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Polish = {
        weekdays: {
          shorthand: ["Nd", "Pn", "Wt", "Śr", "Cz", "Pt", "So"],
          longhand: ["Niedziela", "Poniedziałek", "Wtorek", "Środa", "Czwartek", "Piątek", "Sobota"]
        },
        months: {
          shorthand: ["Sty", "Lut", "Mar", "Kwi", "Maj", "Cze", "Lip", "Sie", "Wrz", "Paź", "Lis", "Gru"],
          longhand: ["Styczeń", "Luty", "Marzec", "Kwiecień", "Maj", "Czerwiec", "Lipiec", "Sierpień", "Wrzesień", "Październik", "Listopad", "Grudzień"]
        },
        rangeSeparator: " do ",
        weekAbbreviation: "tydz.",
        scrollTitle: "Przewiń, aby zwiększyć",
        toggleTitle: "Kliknij, aby przełączyć",
        firstDayOfWeek: 1,
        time_24hr: true,
        ordinal: function() {
          return ".";
        }
      };
      fp$I.l10ns.pl = Polish;
      fp$I.l10ns;
      var fp$J = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Portuguese = {
        weekdays: {
          shorthand: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sáb"],
          longhand: ["Domingo", "Segunda-feira", "Terça-feira", "Quarta-feira", "Quinta-feira", "Sexta-feira", "Sábado"]
        },
        months: {
          shorthand: ["Jan", "Fev", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"],
          longhand: ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"]
        },
        rangeSeparator: " até ",
        time_24hr: true
      };
      fp$J.l10ns.pt = Portuguese;
      fp$J.l10ns;
      var fp$K = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Romanian = {
        weekdays: {
          shorthand: ["Dum", "Lun", "Mar", "Mie", "Joi", "Vin", "Sâm"],
          longhand: ["Duminică", "Luni", "Marți", "Miercuri", "Joi", "Vineri", "Sâmbătă"]
        },
        months: {
          shorthand: ["Ian", "Feb", "Mar", "Apr", "Mai", "Iun", "Iul", "Aug", "Sep", "Oct", "Noi", "Dec"],
          longhand: ["Ianuarie", "Februarie", "Martie", "Aprilie", "Mai", "Iunie", "Iulie", "August", "Septembrie", "Octombrie", "Noiembrie", "Decembrie"]
        },
        firstDayOfWeek: 1,
        time_24hr: true,
        ordinal: function() {
          return "";
        }
      };
      fp$K.l10ns.ro = Romanian;
      fp$K.l10ns;
      var fp$L = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Russian = {
        weekdays: {
          shorthand: ["Вс", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"],
          longhand: ["Воскресенье", "Понедельник", "Вторник", "Среда", "Четверг", "Пятница", "Суббота"]
        },
        months: {
          shorthand: ["Янв", "Фев", "Март", "Апр", "Май", "Июнь", "Июль", "Авг", "Сен", "Окт", "Ноя", "Дек"],
          longhand: ["Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь"]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return "";
        },
        rangeSeparator: " — ",
        weekAbbreviation: "Нед.",
        scrollTitle: "Прокрутите для увеличения",
        toggleTitle: "Нажмите для переключения",
        amPM: ["ДП", "ПП"],
        yearAriaLabel: "Год",
        time_24hr: true
      };
      fp$L.l10ns.ru = Russian;
      fp$L.l10ns;
      var fp$M = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Sinhala = {
        weekdays: {
          shorthand: ["ඉ", "ස", "අ", "බ", "බ්‍ර", "සි", "සෙ"],
          longhand: ["ඉරිදා", "සඳුදා", "අඟහරුවාදා", "බදාදා", "බ්‍රහස්පතින්දා", "සිකුරාදා", "සෙනසුරාදා"]
        },
        months: {
          shorthand: ["ජන", "පෙබ", "මාර්", "අප්‍රේ", "මැයි", "ජුනි", "ජූලි", "අගෝ", "සැප්", "ඔක්", "නොවැ", "දෙසැ"],
          longhand: ["ජනවාරි", "පෙබරවාරි", "මාර්තු", "අප්‍රේල්", "මැයි", "ජුනි", "ජූලි", "අගෝස්තු", "සැප්තැම්බර්", "ඔක්තෝබර්", "නොවැම්බර්", "දෙසැම්බර්"]
        },
        time_24hr: true
      };
      fp$M.l10ns.si = Sinhala;
      fp$M.l10ns;
      var fp$N = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Slovak = {
        weekdays: {
          shorthand: ["Ned", "Pon", "Ut", "Str", "Štv", "Pia", "Sob"],
          longhand: ["Nedeľa", "Pondelok", "Utorok", "Streda", "Štvrtok", "Piatok", "Sobota"]
        },
        months: {
          shorthand: ["Jan", "Feb", "Mar", "Apr", "Máj", "Jún", "Júl", "Aug", "Sep", "Okt", "Nov", "Dec"],
          longhand: ["Január", "Február", "Marec", "Apríl", "Máj", "Jún", "Júl", "August", "September", "Október", "November", "December"]
        },
        firstDayOfWeek: 1,
        rangeSeparator: " do ",
        time_24hr: true,
        ordinal: function() {
          return ".";
        }
      };
      fp$N.l10ns.sk = Slovak;
      fp$N.l10ns;
      var fp$O = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Slovenian = {
        weekdays: {
          shorthand: ["Ned", "Pon", "Tor", "Sre", "Čet", "Pet", "Sob"],
          longhand: ["Nedelja", "Ponedeljek", "Torek", "Sreda", "Četrtek", "Petek", "Sobota"]
        },
        months: {
          shorthand: ["Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Avg", "Sep", "Okt", "Nov", "Dec"],
          longhand: ["Januar", "Februar", "Marec", "April", "Maj", "Junij", "Julij", "Avgust", "September", "Oktober", "November", "December"]
        },
        firstDayOfWeek: 1,
        rangeSeparator: " do ",
        time_24hr: true,
        ordinal: function() {
          return ".";
        }
      };
      fp$O.l10ns.sl = Slovenian;
      fp$O.l10ns;
      var fp$P = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Albanian = {
        weekdays: {
          shorthand: ["Di", "Hë", "Ma", "Më", "En", "Pr", "Sh"],
          longhand: ["E Diel", "E Hënë", "E Martë", "E Mërkurë", "E Enjte", "E Premte", "E Shtunë"]
        },
        months: {
          shorthand: ["Jan", "Shk", "Mar", "Pri", "Maj", "Qer", "Kor", "Gus", "Sht", "Tet", "Nën", "Dhj"],
          longhand: ["Janar", "Shkurt", "Mars", "Prill", "Maj", "Qershor", "Korrik", "Gusht", "Shtator", "Tetor", "Nëntor", "Dhjetor"]
        },
        firstDayOfWeek: 1,
        rangeSeparator: " deri ",
        weekAbbreviation: "Java",
        yearAriaLabel: "Viti",
        monthAriaLabel: "Muaji",
        hourAriaLabel: "Ora",
        minuteAriaLabel: "Minuta",
        time_24hr: true
      };
      fp$P.l10ns.sq = Albanian;
      fp$P.l10ns;
      var fp$Q = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Serbian = {
        weekdays: {
          shorthand: ["Ned", "Pon", "Uto", "Sre", "Čet", "Pet", "Sub"],
          longhand: ["Nedelja", "Ponedeljak", "Utorak", "Sreda", "Četvrtak", "Petak", "Subota"]
        },
        months: {
          shorthand: ["Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Avg", "Sep", "Okt", "Nov", "Dec"],
          longhand: ["Januar", "Februar", "Mart", "April", "Maj", "Jun", "Jul", "Avgust", "Septembar", "Oktobar", "Novembar", "Decembar"]
        },
        firstDayOfWeek: 1,
        weekAbbreviation: "Ned.",
        rangeSeparator: " do ",
        time_24hr: true
      };
      fp$Q.l10ns.sr = Serbian;
      fp$Q.l10ns;
      var fp$R = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Swedish = {
        firstDayOfWeek: 1,
        weekAbbreviation: "v",
        weekdays: {
          shorthand: ["sön", "mån", "tis", "ons", "tor", "fre", "lör"],
          longhand: ["söndag", "måndag", "tisdag", "onsdag", "torsdag", "fredag", "lördag"]
        },
        months: {
          shorthand: ["jan", "feb", "mar", "apr", "maj", "jun", "jul", "aug", "sep", "okt", "nov", "dec"],
          longhand: ["januari", "februari", "mars", "april", "maj", "juni", "juli", "augusti", "september", "oktober", "november", "december"]
        },
        rangeSeparator: " till ",
        time_24hr: true,
        ordinal: function() {
          return ".";
        }
      };
      fp$R.l10ns.sv = Swedish;
      fp$R.l10ns;
      var fp$S = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Thai = {
        weekdays: {
          shorthand: ["อา", "จ", "อ", "พ", "พฤ", "ศ", "ส"],
          longhand: ["อาทิตย์", "จันทร์", "อังคาร", "พุธ", "พฤหัสบดี", "ศุกร์", "เสาร์"]
        },
        months: {
          shorthand: ["ม.ค.", "ก.พ.", "มี.ค.", "เม.ย.", "พ.ค.", "มิ.ย.", "ก.ค.", "ส.ค.", "ก.ย.", "ต.ค.", "พ.ย.", "ธ.ค."],
          longhand: ["มกราคม", "กุมภาพันธ์", "มีนาคม", "เมษายน", "พฤษภาคม", "มิถุนายน", "กรกฎาคม", "สิงหาคม", "กันยายน", "ตุลาคม", "พฤศจิกายน", "ธันวาคม"]
        },
        firstDayOfWeek: 1,
        rangeSeparator: " ถึง ",
        scrollTitle: "เลื่อนเพื่อเพิ่มหรือลด",
        toggleTitle: "คลิกเพื่อเปลี่ยน",
        time_24hr: true,
        ordinal: function() {
          return "";
        }
      };
      fp$S.l10ns.th = Thai;
      fp$S.l10ns;
      var fp$T = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Turkish = {
        weekdays: {
          shorthand: ["Paz", "Pzt", "Sal", "Çar", "Per", "Cum", "Cmt"],
          longhand: ["Pazar", "Pazartesi", "Salı", "Çarşamba", "Perşembe", "Cuma", "Cumartesi"]
        },
        months: {
          shorthand: ["Oca", "Şub", "Mar", "Nis", "May", "Haz", "Tem", "Ağu", "Eyl", "Eki", "Kas", "Ara"],
          longhand: ["Ocak", "Şubat", "Mart", "Nisan", "Mayıs", "Haziran", "Temmuz", "Ağustos", "Eylül", "Ekim", "Kasım", "Aralık"]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return ".";
        },
        rangeSeparator: " - ",
        weekAbbreviation: "Hf",
        scrollTitle: "Artırmak için kaydırın",
        toggleTitle: "Aç/Kapa",
        amPM: ["ÖÖ", "ÖS"],
        time_24hr: true
      };
      fp$T.l10ns.tr = Turkish;
      fp$T.l10ns;
      var fp$U = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Ukrainian = {
        firstDayOfWeek: 1,
        weekdays: {
          shorthand: ["Нд", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"],
          longhand: ["Неділя", "Понеділок", "Вівторок", "Середа", "Четвер", "П'ятниця", "Субота"]
        },
        months: {
          shorthand: ["Січ", "Лют", "Бер", "Кві", "Тра", "Чер", "Лип", "Сер", "Вер", "Жов", "Лис", "Гру"],
          longhand: ["Січень", "Лютий", "Березень", "Квітень", "Травень", "Червень", "Липень", "Серпень", "Вересень", "Жовтень", "Листопад", "Грудень"]
        },
        time_24hr: true
      };
      fp$U.l10ns.uk = Ukrainian;
      fp$U.l10ns;
      var fp$V = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Uzbek = {
        weekdays: {
          shorthand: ["Якш", "Душ", "Сеш", "Чор", "Пай", "Жум", "Шан"],
          longhand: ["Якшанба", "Душанба", "Сешанба", "Чоршанба", "Пайшанба", "Жума", "Шанба"]
        },
        months: {
          shorthand: ["Янв", "Фев", "Мар", "Апр", "Май", "Июн", "Июл", "Авг", "Сен", "Окт", "Ноя", "Дек"],
          longhand: ["Январ", "Феврал", "Март", "Апрел", "Май", "Июн", "Июл", "Август", "Сентябр", "Октябр", "Ноябр", "Декабр"]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return "";
        },
        rangeSeparator: " — ",
        weekAbbreviation: "Ҳафта",
        scrollTitle: "Катталаштириш учун айлантиринг",
        toggleTitle: "Ўтиш учун босинг",
        amPM: ["AM", "PM"],
        yearAriaLabel: "Йил",
        time_24hr: true
      };
      fp$V.l10ns.uz = Uzbek;
      fp$V.l10ns;
      var fp$W = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var UzbekLatin = {
        weekdays: {
          shorthand: ["Ya", "Du", "Se", "Cho", "Pa", "Ju", "Sha"],
          longhand: ["Yakshanba", "Dushanba", "Seshanba", "Chorshanba", "Payshanba", "Juma", "Shanba"]
        },
        months: {
          shorthand: ["Yan", "Fev", "Mar", "Apr", "May", "Iyun", "Iyul", "Avg", "Sen", "Okt", "Noy", "Dek"],
          longhand: ["Yanvar", "Fevral", "Mart", "Aprel", "May", "Iyun", "Iyul", "Avgust", "Sentabr", "Oktabr", "Noyabr", "Dekabr"]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return "";
        },
        rangeSeparator: " — ",
        weekAbbreviation: "Hafta",
        scrollTitle: "Kattalashtirish uchun aylantiring",
        toggleTitle: "O‘tish uchun bosing",
        amPM: ["AM", "PM"],
        yearAriaLabel: "Yil",
        time_24hr: true
      };
      fp$W.l10ns["uz_latn"] = UzbekLatin;
      fp$W.l10ns;
      var fp$X = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Vietnamese = {
        weekdays: {
          shorthand: ["CN", "T2", "T3", "T4", "T5", "T6", "T7"],
          longhand: ["Chủ nhật", "Thứ hai", "Thứ ba", "Thứ tư", "Thứ năm", "Thứ sáu", "Thứ bảy"]
        },
        months: {
          shorthand: ["Th1", "Th2", "Th3", "Th4", "Th5", "Th6", "Th7", "Th8", "Th9", "Th10", "Th11", "Th12"],
          longhand: ["Tháng một", "Tháng hai", "Tháng ba", "Tháng tư", "Tháng năm", "Tháng sáu", "Tháng bảy", "Tháng tám", "Tháng chín", "Tháng mười", "Tháng mười một", "Tháng mười hai"]
        },
        firstDayOfWeek: 1,
        rangeSeparator: " đến "
      };
      fp$X.l10ns.vn = Vietnamese;
      fp$X.l10ns;
      var fp$Y = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Mandarin = {
        weekdays: {
          shorthand: ["周日", "周一", "周二", "周三", "周四", "周五", "周六"],
          longhand: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"]
        },
        months: {
          shorthand: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"],
          longhand: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"]
        },
        rangeSeparator: " 至 ",
        weekAbbreviation: "周",
        scrollTitle: "滚动切换",
        toggleTitle: "点击切换 12/24 小时时制"
      };
      fp$Y.l10ns.zh = Mandarin;
      fp$Y.l10ns;
      var fp$Z = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var MandarinTraditional = {
        weekdays: {
          shorthand: ["週日", "週一", "週二", "週三", "週四", "週五", "週六"],
          longhand: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"]
        },
        months: {
          shorthand: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"],
          longhand: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"]
        },
        rangeSeparator: " 至 ",
        weekAbbreviation: "週",
        scrollTitle: "滾動切換",
        toggleTitle: "點擊切換 12/24 小時時制"
      };
      fp$Z.l10ns.zh_tw = MandarinTraditional;
      fp$Z.l10ns;
      var l10n = {
        ar: Arabic,
        at: Austria,
        az: Azerbaijan,
        be: Belarusian,
        bg: Bulgarian,
        bn: Bangla,
        bs: Bosnian,
        ca: Catalan,
        ckb: Kurdish,
        cat: Catalan,
        cs: Czech,
        cy: Welsh,
        da: Danish,
        de: German,
        default: __assign2({}, english2),
        en: english2,
        eo: Esperanto,
        es: Spanish,
        et: Estonian,
        fa: Persian,
        fi: Finnish,
        fo: Faroese,
        fr: French,
        gr: Greek,
        he: Hebrew,
        hi: Hindi,
        hr: Croatian,
        hu: Hungarian,
        hy: Armenian,
        id: Indonesian,
        is: Icelandic,
        it: Italian,
        ja: Japanese,
        ka: Georgian,
        ko: Korean,
        km: Khmer,
        kz: Kazakh,
        lt: Lithuanian,
        lv: Latvian,
        mk: Macedonian,
        mn: Mongolian,
        ms: Malaysian,
        my: Burmese,
        nl: Dutch,
        nn: NorwegianNynorsk,
        no: Norwegian,
        pa: Punjabi,
        pl: Polish,
        pt: Portuguese,
        ro: Romanian,
        ru: Russian,
        si: Sinhala,
        sk: Slovak,
        sl: Slovenian,
        sq: Albanian,
        sr: Serbian,
        sv: Swedish,
        th: Thai,
        tr: Turkish,
        uk: Ukrainian,
        vn: Vietnamese,
        zh: Mandarin,
        zh_tw: MandarinTraditional,
        uz: Uzbek,
        uz_latn: UzbekLatin
      };
      exports3.default = l10n;
      Object.defineProperty(exports3, "__esModule", {
        value: true
      });
    });
  }
});

// node_modules/@carbon/icon-helpers/es/index.js
function ownKeys(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
var _excluded = ["width", "height", "viewBox"];
var _excluded2 = ["tabindex"];
var defaultAttributes = {
  // Reference:
  // https://github.com/IBM/carbon-components-react/issues/1392
  // https://github.com/PolymerElements/iron-iconset-svg/pull/47
  // `focusable` is a string attribute which is why we do not use a boolean here
  focusable: "false",
  preserveAspectRatio: "xMidYMid meet"
};
function getAttributes() {
  var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, width = _ref.width, height = _ref.height, _ref$viewBox = _ref.viewBox, viewBox = _ref$viewBox === void 0 ? "0 0 ".concat(width, " ").concat(height) : _ref$viewBox, attributes = _objectWithoutProperties(_ref, _excluded);
  var tabindex = attributes.tabindex, rest = _objectWithoutProperties(attributes, _excluded2);
  var iconAttributes = _objectSpread2(_objectSpread2(_objectSpread2({}, defaultAttributes), rest), {}, {
    width,
    height,
    viewBox
  });
  if (iconAttributes["aria-label"] || iconAttributes["aria-labelledby"] || iconAttributes.title) {
    iconAttributes.role = "img";
    if (tabindex !== void 0 && tabindex !== null) {
      iconAttributes.focusable = "true";
      iconAttributes.tabindex = tabindex;
    }
  } else {
    iconAttributes["aria-hidden"] = true;
  }
  return iconAttributes;
}
function toString(descriptor) {
  var _descriptor$elem = descriptor.elem, elem = _descriptor$elem === void 0 ? "svg" : _descriptor$elem, _descriptor$attrs = descriptor.attrs, attrs = _descriptor$attrs === void 0 ? {} : _descriptor$attrs, _descriptor$content = descriptor.content, content = _descriptor$content === void 0 ? [] : _descriptor$content;
  var children = content.map(toString).join("");
  if (elem !== "svg") {
    return "<".concat(elem, " ").concat(formatAttributes(attrs), ">").concat(children, "</").concat(elem, ">");
  }
  return "<".concat(elem, " ").concat(formatAttributes(getAttributes(attrs)), ">").concat(children, "</").concat(elem, ">");
}
function formatAttributes(attrs) {
  return Object.keys(attrs).reduce(function(acc, key, index) {
    var attribute = "".concat(key, '="').concat(attrs[key], '"');
    if (index === 0) {
      return attribute;
    }
    return acc + " " + attribute;
  }, "");
}

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/add/16.js
var _16 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M17 15L17 8 15 8 15 15 8 15 8 17 15 17 15 24 17 24 17 17 24 17 24 15z"
    }
  }],
  "name": "add",
  "size": 16
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/add/20.js
var _20 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 20,
    "height": 20
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M17 15L17 8 15 8 15 15 8 15 8 17 15 17 15 24 17 24 17 17 24 17 24 15z"
    }
  }],
  "name": "add",
  "size": 20
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/bee/16.js
var _162 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M16 10a6 6 0 00-6 6v8a6 6 0 0012 0V16A6 6 0 0016 10zm-4.25 7.87h8.5v4.25h-8.5zM16 28.25A4.27 4.27 0 0111.75 24v-.13h8.5V24A4.27 4.27 0 0116 28.25zm4.25-12.13h-8.5V16a4.25 4.25 0 018.5 0zM30.66 19.21L24 13v9.1a4 4 0 008 0A3.83 3.83 0 0030.66 19.21zM28 24.35a2.25 2.25 0 01-2.25-2.25V17l3.72 3.47h0A2.05 2.05 0 0130.2 22 2.25 2.25 0 0128 24.35zM0 22.1a4 4 0 008 0V13L1.34 19.21A3.88 3.88 0 000 22.1zm2.48-1.56h0L6.25 17v5.1a2.25 2.25 0 01-4.5 0A2.05 2.05 0 012.48 20.54zM15 5.5A3.5 3.5 0 1011.5 9 3.5 3.5 0 0015 5.5zm-5.25 0A1.75 1.75 0 1111.5 7.25 1.77 1.77 0 019.75 5.5zM20.5 2A3.5 3.5 0 1024 5.5 3.5 3.5 0 0020.5 2zm0 5.25A1.75 1.75 0 1122.25 5.5 1.77 1.77 0 0120.5 7.25z"
    }
  }],
  "name": "bee",
  "size": 16
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/bee/20.js
var _202 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 20,
    "height": 20
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M16 10a6 6 0 00-6 6v8a6 6 0 0012 0V16A6 6 0 0016 10zm-4.25 7.87h8.5v4.25h-8.5zM16 28.25A4.27 4.27 0 0111.75 24v-.13h8.5V24A4.27 4.27 0 0116 28.25zm4.25-12.13h-8.5V16a4.25 4.25 0 018.5 0zM30.66 19.21L24 13v9.1a4 4 0 008 0A3.83 3.83 0 0030.66 19.21zM28 24.35a2.25 2.25 0 01-2.25-2.25V17l3.72 3.47h0A2.05 2.05 0 0130.2 22 2.25 2.25 0 0128 24.35zM0 22.1a4 4 0 008 0V13L1.34 19.21A3.88 3.88 0 000 22.1zm2.48-1.56h0L6.25 17v5.1a2.25 2.25 0 01-4.5 0A2.05 2.05 0 012.48 20.54zM15 5.5A3.5 3.5 0 1011.5 9 3.5 3.5 0 0015 5.5zm-5.25 0A1.75 1.75 0 1111.5 7.25 1.77 1.77 0 019.75 5.5zM20.5 2A3.5 3.5 0 1024 5.5 3.5 3.5 0 0020.5 2zm0 5.25A1.75 1.75 0 1122.25 5.5 1.77 1.77 0 0120.5 7.25z"
    }
  }],
  "name": "bee",
  "size": 20
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/calendar/16.js
var _163 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M26,4h-4V2h-2v2h-8V2h-2v2H6C4.9,4,4,4.9,4,6v20c0,1.1,0.9,2,2,2h20c1.1,0,2-0.9,2-2V6C28,4.9,27.1,4,26,4z M26,26H6V12h20	V26z M26,10H6V6h4v2h2V6h8v2h2V6h4V10z"
    }
  }],
  "name": "calendar",
  "size": 16
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/carbon/16.js
var _164 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M13.5,30.8149a1.0011,1.0011,0,0,1-.4927-.13l-8.5-4.815A1,1,0,0,1,4,25V15a1,1,0,0,1,.5073-.87l8.5-4.815a1.0013,1.0013,0,0,1,.9854,0l8.5,4.815A1,1,0,0,1,23,15V25a1,1,0,0,1-.5073.87l-8.5,4.815A1.0011,1.0011,0,0,1,13.5,30.8149ZM6,24.417l7.5,4.2485L21,24.417V15.583l-7.5-4.2485L6,15.583Z"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M28,17H26V7.583L18.5,3.3345,10.4927,7.87,9.5073,6.13l8.5-4.815a1.0013,1.0013,0,0,1,.9854,0l8.5,4.815A1,1,0,0,1,28,7Z"
    }
  }],
  "name": "carbon",
  "size": 16
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/carbon/20.js
var _203 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 20,
    "height": 20
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M13.5,30.8149a1.0011,1.0011,0,0,1-.4927-.13l-8.5-4.815A1,1,0,0,1,4,25V15a1,1,0,0,1,.5073-.87l8.5-4.815a1.0013,1.0013,0,0,1,.9854,0l8.5,4.815A1,1,0,0,1,23,15V25a1,1,0,0,1-.5073.87l-8.5,4.815A1.0011,1.0011,0,0,1,13.5,30.8149ZM6,24.417l7.5,4.2485L21,24.417V15.583l-7.5-4.2485L6,15.583Z"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M28,17H26V7.583L18.5,3.3345,10.4927,7.87,9.5073,6.13l8.5-4.815a1.0013,1.0013,0,0,1,.9854,0l8.5,4.815A1,1,0,0,1,28,7Z"
    }
  }],
  "name": "carbon",
  "size": 20
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/caret--down/16.js
var _165 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M24 12L16 22 8 12z"
    }
  }],
  "name": "caret--down",
  "size": 16
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/caret--left/16.js
var _166 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M20 24L10 16 20 8z"
    }
  }],
  "name": "caret--left",
  "size": 16
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/caret--right/16.js
var _167 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M12 8L22 16 12 24z"
    }
  }],
  "name": "caret--right",
  "size": 16
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/caret--up/16.js
var _168 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M8 20L16 10 24 20z"
    }
  }],
  "name": "caret--up",
  "size": 16
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/checkmark/16.js
var _169 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M13 24L4 15 5.414 13.586 13 21.171 26.586 7.586 28 9 13 24z"
    }
  }],
  "name": "checkmark",
  "size": 16
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/checkmark--filled/16.js
var _1610 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 16 16",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M8,1C4.1,1,1,4.1,1,8c0,3.9,3.1,7,7,7s7-3.1,7-7C15,4.1,11.9,1,8,1z M7,11L4.3,8.3l0.9-0.8L7,9.3l4-3.9l0.9,0.8L7,11z"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M7,11L4.3,8.3l0.9-0.8L7,9.3l4-3.9l0.9,0.8L7,11z",
      "data-icon-path": "inner-path",
      "opacity": "0"
    }
  }],
  "name": "checkmark--filled",
  "size": 16
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/checkmark--filled/20.js
var _204 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 20 20",
    "fill": "currentColor",
    "width": 20,
    "height": 20
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M10,1c-4.9,0-9,4.1-9,9s4.1,9,9,9s9-4,9-9S15,1,10,1z M8.7,13.5l-3.2-3.2l1-1l2.2,2.2l4.8-4.8l1,1L8.7,13.5z"
    }
  }, {
    "elem": "path",
    "attrs": {
      "fill": "none",
      "d": "M8.7,13.5l-3.2-3.2l1-1l2.2,2.2l4.8-4.8l1,1L8.7,13.5z",
      "data-icon-path": "inner-path",
      "opacity": "0"
    }
  }],
  "name": "checkmark--filled",
  "size": 20
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/checkmark--outline/16.js
var _1611 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M14 21.414L9 16.413 10.413 15 14 18.586 21.585 11 23 12.415 14 21.414z"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M16,2A14,14,0,1,0,30,16,14,14,0,0,0,16,2Zm0,26A12,12,0,1,1,28,16,12,12,0,0,1,16,28Z"
    }
  }],
  "name": "checkmark--outline",
  "size": 16
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/checkbox/16.js
var _1612 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M26,4H6A2,2,0,0,0,4,6V26a2,2,0,0,0,2,2H26a2,2,0,0,0,2-2V6A2,2,0,0,0,26,4ZM6,26V6H26V26Z"
    }
  }],
  "name": "checkbox",
  "size": 16
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/checkbox--checked--filled/16.js
var _1613 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M26,4H6A2,2,0,0,0,4,6V26a2,2,0,0,0,2,2H26a2,2,0,0,0,2-2V6A2,2,0,0,0,26,4ZM14,21.5,9,16.5427,10.5908,15,14,18.3456,21.4087,11l1.5918,1.5772Z"
    }
  }, {
    "elem": "path",
    "attrs": {
      "fill": "none",
      "d": "M14,21.5,9,16.5427,10.5908,15,14,18.3456,21.4087,11l1.5918,1.5772Z",
      "data-icon-path": "inner-path"
    }
  }],
  "name": "checkbox--checked--filled",
  "size": 16
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/chevron--down/16.js
var _1614 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 16 16",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M8 11L3 6 3.7 5.3 8 9.6 12.3 5.3 13 6z"
    }
  }],
  "name": "chevron--down",
  "size": 16
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/chevron--right/16.js
var _1615 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 16 16",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M11 8L6 13 5.3 12.3 9.6 8 5.3 3.7 6 3z"
    }
  }],
  "name": "chevron--right",
  "size": 16
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/circle-dash/16.js
var _1616 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M7.7 4.7a14.7 14.7 0 00-3 3.1L6.3 9A13.26 13.26 0 018.9 6.3zM4.6 12.3l-1.9-.6A12.51 12.51 0 002 16H4A11.48 11.48 0 014.6 12.3zM2.7 20.4a14.4 14.4 0 002 3.9l1.6-1.2a12.89 12.89 0 01-1.7-3.3zM7.8 27.3a14.4 14.4 0 003.9 2l.6-1.9A12.89 12.89 0 019 25.7zM11.7 2.7l.6 1.9A11.48 11.48 0 0116 4V2A12.51 12.51 0 0011.7 2.7zM24.2 27.3a15.18 15.18 0 003.1-3.1L25.7 23A11.53 11.53 0 0123 25.7zM27.4 19.7l1.9.6A15.47 15.47 0 0030 16H28A11.48 11.48 0 0127.4 19.7zM29.2 11.6a14.4 14.4 0 00-2-3.9L25.6 8.9a12.89 12.89 0 011.7 3.3zM24.1 4.6a14.4 14.4 0 00-3.9-2l-.6 1.9a12.89 12.89 0 013.3 1.7zM20.3 29.3l-.6-1.9A11.48 11.48 0 0116 28v2A21.42 21.42 0 0020.3 29.3z"
    }
  }],
  "name": "circle-dash",
  "size": 16
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/close/16.js
var _1617 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M24 9.4L22.6 8 16 14.6 9.4 8 8 9.4 14.6 16 8 22.6 9.4 24 16 17.4 22.6 24 24 22.6 17.4 16 24 9.4z"
    }
  }],
  "name": "close",
  "size": 16
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/close/20.js
var _205 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 20,
    "height": 20
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M24 9.4L22.6 8 16 14.6 9.4 8 8 9.4 14.6 16 8 22.6 9.4 24 16 17.4 22.6 24 24 22.6 17.4 16 24 9.4z"
    }
  }],
  "name": "close",
  "size": 20
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/copy/16.js
var _1618 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M28,10V28H10V10H28m0-2H10a2,2,0,0,0-2,2V28a2,2,0,0,0,2,2H28a2,2,0,0,0,2-2V10a2,2,0,0,0-2-2Z"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M4,18H2V4A2,2,0,0,1,4,2H18V4H4Z"
    }
  }],
  "name": "copy",
  "size": 16
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/copy/20.js
var _206 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 20,
    "height": 20
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M28,10V28H10V10H28m0-2H10a2,2,0,0,0-2,2V28a2,2,0,0,0,2,2H28a2,2,0,0,0,2-2V10a2,2,0,0,0-2-2Z"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M4,18H2V4A2,2,0,0,1,4,2H18V4H4Z"
    }
  }],
  "name": "copy",
  "size": 20
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/data--2/16.js
var _1619 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M4 6H15V8H4zM18 6H28V8H18zM21 12H28V14H21zM11 12H18V14H11zM4 12H8V14H4zM4 18H28V20H4zM4 24H21V26H4zM24 24H28V26H24z"
    }
  }],
  "name": "data--2",
  "size": 16
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/data--2/20.js
var _207 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 20,
    "height": 20
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M4 6H15V8H4zM18 6H28V8H18zM21 12H28V14H21zM11 12H18V14H11zM4 12H8V14H4zM4 18H28V20H4zM4 24H21V26H4zM24 24H28V26H24z"
    }
  }],
  "name": "data--2",
  "size": 20
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/document/16.js
var _1620 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M25.7,9.3l-7-7C18.5,2.1,18.3,2,18,2H8C6.9,2,6,2.9,6,4v24c0,1.1,0.9,2,2,2h16c1.1,0,2-0.9,2-2V10C26,9.7,25.9,9.5,25.7,9.3	z M18,4.4l5.6,5.6H18V4.4z M24,28H8V4h8v6c0,1.1,0.9,2,2,2h6V28z"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M10 22H22V24H10zM10 16H22V18H10z"
    }
  }],
  "name": "document",
  "size": 16
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/document/20.js
var _208 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 20,
    "height": 20
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M25.7,9.3l-7-7C18.5,2.1,18.3,2,18,2H8C6.9,2,6,2.9,6,4v24c0,1.1,0.9,2,2,2h16c1.1,0,2-0.9,2-2V10C26,9.7,25.9,9.5,25.7,9.3	z M18,4.4l5.6,5.6H18V4.4z M24,28H8V4h8v6c0,1.1,0.9,2,2,2h6V28z"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M10 22H22V24H10zM10 16H22V18H10z"
    }
  }],
  "name": "document",
  "size": 20
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/download/16.js
var _1621 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 16 16",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M13 7L12.3 6.3 8.5 10.1 8.5 1 7.5 1 7.5 10.1 3.7 6.3 3 7 8 12zM13 12v2H3v-2H2v2l0 0c0 .6.4 1 1 1h10c.6 0 1-.4 1-1l0 0v-2H13z"
    }
  }],
  "name": "download",
  "size": 16
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/error--filled/16.js
var _1622 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 16 16",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M8,1C4.1,1,1,4.1,1,8s3.1,7,7,7s7-3.1,7-7S11.9,1,8,1z M10.7,11.5L4.5,5.3l0.8-0.8l6.2,6.2L10.7,11.5z"
    }
  }, {
    "elem": "path",
    "attrs": {
      "fill": "none",
      "d": "M10.7,11.5L4.5,5.3l0.8-0.8l6.2,6.2L10.7,11.5z",
      "data-icon-path": "inner-path",
      "opacity": "0"
    }
  }],
  "name": "error--filled",
  "size": 16
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/error--filled/20.js
var _209 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 20 20",
    "fill": "currentColor",
    "width": 20,
    "height": 20
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M10,1c-5,0-9,4-9,9s4,9,9,9s9-4,9-9S15,1,10,1z M13.5,14.5l-8-8l1-1l8,8L13.5,14.5z"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M13.5,14.5l-8-8l1-1l8,8L13.5,14.5z",
      "data-icon-path": "inner-path",
      "opacity": "0"
    }
  }],
  "name": "error--filled",
  "size": 20
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/fade/16.js
var _1623 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 16 16",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M4.1 12.6l-.6.8c.6.5 1.3.9 2.1 1.2l.3-.9C5.3 13.4 4.7 13 4.1 12.6zM2.1 9l-1 .2c.1.8.4 1.6.8 2.3L2.8 11C2.4 10.4 2.2 9.7 2.1 9zM5.9 2.4L5.6 1.4C4.8 1.7 4.1 2.1 3.5 2.7l.6.8C4.7 3 5.3 2.6 5.9 2.4zM2.8 5L1.9 4.5C1.5 5.2 1.3 6 1.1 6.8l1 .2C2.2 6.3 2.5 5.6 2.8 5zM8 1v1c3.3 0 6 2.7 6 6s-2.7 6-6 6v1c3.9 0 7-3.1 7-7S11.9 1 8 1z"
    }
  }],
  "name": "fade",
  "size": 16
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/fade/20.js
var _2010 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 20,
    "height": 20
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M8.24 25.14L7 26.67a13.79 13.79 0 004.18 2.44l.69-1.87A12 12 0 018.24 25.14zM4.19 18l-2 .41A14.09 14.09 0 003.86 23L5.59 22A12.44 12.44 0 014.19 18zM11.82 4.76l-.69-1.87A13.79 13.79 0 007 5.33L8.24 6.86A12 12 0 0111.82 4.76zM5.59 10L3.86 9a14.37 14.37 0 00-1.64 4.59l2 .34A12.05 12.05 0 015.59 10zM16 2V4a12 12 0 010 24v2A14 14 0 0016 2z"
    }
  }],
  "name": "fade",
  "size": 20
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/folder/16.js
var _1624 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M11.17,6l3.42,3.41.58.59H28V26H4V6h7.17m0-2H4A2,2,0,0,0,2,6V26a2,2,0,0,0,2,2H28a2,2,0,0,0,2-2V10a2,2,0,0,0-2-2H16L12.59,4.59A2,2,0,0,0,11.17,4Z"
    }
  }],
  "name": "folder",
  "size": 16
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/incomplete/16.js
var _1625 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M23.7642 6.8593l1.2851-1.5315A13.976 13.976 0 0020.8672 2.887l-.6836 1.8776A11.9729 11.9729 0 0123.7642 6.8593zM27.81 14l1.9677-.4128A13.8888 13.8888 0 0028.14 9.0457L26.4087 10A12.52 12.52 0 0127.81 14zM20.1836 27.2354l.6836 1.8776a13.976 13.976 0 004.1821-2.4408l-1.2851-1.5315A11.9729 11.9729 0 0120.1836 27.2354zM26.4087 22L28.14 23a14.14 14.14 0 001.6382-4.5872L27.81 18.0659A12.1519 12.1519 0 0126.4087 22zM16 30V2a14 14 0 000 28z"
    }
  }],
  "name": "incomplete",
  "size": 16
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/information--filled/16.js
var _1626 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "fill": "none",
      "d": "M16,8a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,16,8Zm4,13.875H17.125v-8H13v2.25h1.875v5.75H12v2.25h8Z",
      "data-icon-path": "inner-path"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M16,2A14,14,0,1,0,30,16,14,14,0,0,0,16,2Zm0,6a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,16,8Zm4,16.125H12v-2.25h2.875v-5.75H13v-2.25h4.125v8H20Z"
    }
  }],
  "name": "information--filled",
  "size": 16
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/information--filled/20.js
var _2011 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 20,
    "height": 20
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "fill": "none",
      "d": "M16,8a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,16,8Zm4,13.875H17.125v-8H13v2.25h1.875v5.75H12v2.25h8Z",
      "data-icon-path": "inner-path"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M16,2A14,14,0,1,0,30,16,14,14,0,0,0,16,2Zm0,6a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,16,8Zm4,16.125H12v-2.25h2.875v-5.75H13v-2.25h4.125v8H20Z"
    }
  }],
  "name": "information--filled",
  "size": 20
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/information--square--filled/20.js
var _2012 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 20,
    "height": 20
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "fill": "none",
      "d": "M16,8a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,16,8Zm4,13.875H17.125v-8H13v2.25h1.875v5.75H12v2.25h8Z",
      "data-icon-path": "inner-path"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M26,4H6A2,2,0,0,0,4,6V26a2,2,0,0,0,2,2H26a2,2,0,0,0,2-2V6A2,2,0,0,0,26,4ZM16,8a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,16,8Zm4,16.125H12v-2.25h2.875v-5.75H13v-2.25h4.125v8H20Z"
    }
  }],
  "name": "information--square--filled",
  "size": 20
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/menu/16.js
var _1627 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 16 16",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M2 12H14V13H2zM2 9H14V10H2zM2 6H14V7H2zM2 3H14V4H2z"
    }
  }],
  "name": "menu",
  "size": 16
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/menu/20.js
var _2013 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 20 20",
    "fill": "currentColor",
    "width": 20,
    "height": 20
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M2 14.8H18V16H2zM2 11.2H18V12.399999999999999H2zM2 7.6H18V8.799999999999999H2zM2 4H18V5.2H2z"
    }
  }],
  "name": "menu",
  "size": 20
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/overflow-menu--vertical/16.js
var _1628 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "circle",
    "attrs": {
      "cx": "16",
      "cy": "8",
      "r": "2"
    }
  }, {
    "elem": "circle",
    "attrs": {
      "cx": "16",
      "cy": "16",
      "r": "2"
    }
  }, {
    "elem": "circle",
    "attrs": {
      "cx": "16",
      "cy": "24",
      "r": "2"
    }
  }],
  "name": "overflow-menu--vertical",
  "size": 16
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/overflow-menu--horizontal/16.js
var _1629 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "circle",
    "attrs": {
      "cx": "8",
      "cy": "16",
      "r": "2"
    }
  }, {
    "elem": "circle",
    "attrs": {
      "cx": "16",
      "cy": "16",
      "r": "2"
    }
  }, {
    "elem": "circle",
    "attrs": {
      "cx": "24",
      "cy": "16",
      "r": "2"
    }
  }],
  "name": "overflow-menu--horizontal",
  "size": 16
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/save/16.js
var _1630 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 16 16",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M13.9,4.6l-2.5-2.5C11.3,2.1,11.1,2,11,2H3C2.4,2,2,2.4,2,3v10c0,0.6,0.4,1,1,1h10c0.6,0,1-0.4,1-1V5	C14,4.9,13.9,4.7,13.9,4.6z M6,3h4v2H6V3z M10,13H6V9h4V13z M11,13V9c0-0.6-0.4-1-1-1H6C5.4,8,5,8.4,5,9v4H3V3h2v2c0,0.6,0.4,1,1,1	h4c0.6,0,1-0.4,1-1V3.2l2,2V13H11z"
    }
  }],
  "name": "save",
  "size": 16
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/search/16.js
var _1631 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 16 16",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M15,14.3L10.7,10c1.9-2.3,1.6-5.8-0.7-7.7S4.2,0.7,2.3,3S0.7,8.8,3,10.7c2,1.7,5,1.7,7,0l4.3,4.3L15,14.3z M2,6.5	C2,4,4,2,6.5,2S11,4,11,6.5S9,11,6.5,11S2,9,2,6.5z"
    }
  }],
  "name": "search",
  "size": 16
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/settings/16.js
var _1632 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 16 16",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M13.5,8.4c0-0.1,0-0.3,0-0.4c0-0.1,0-0.3,0-0.4l1-0.8c0.4-0.3,0.4-0.9,0.2-1.3l-1.2-2C13.3,3.2,13,3,12.6,3	c-0.1,0-0.2,0-0.3,0.1l-1.2,0.4c-0.2-0.1-0.4-0.3-0.7-0.4l-0.3-1.3C10.1,1.3,9.7,1,9.2,1H6.8c-0.5,0-0.9,0.3-1,0.8L5.6,3.1	C5.3,3.2,5.1,3.3,4.9,3.4L3.7,3C3.6,3,3.5,3,3.4,3C3,3,2.7,3.2,2.5,3.5l-1.2,2C1.1,5.9,1.2,6.4,1.6,6.8l0.9,0.9c0,0.1,0,0.3,0,0.4	c0,0.1,0,0.3,0,0.4L1.6,9.2c-0.4,0.3-0.5,0.9-0.2,1.3l1.2,2C2.7,12.8,3,13,3.4,13c0.1,0,0.2,0,0.3-0.1l1.2-0.4	c0.2,0.1,0.4,0.3,0.7,0.4l0.3,1.3c0.1,0.5,0.5,0.8,1,0.8h2.4c0.5,0,0.9-0.3,1-0.8l0.3-1.3c0.2-0.1,0.4-0.2,0.7-0.4l1.2,0.4	c0.1,0,0.2,0.1,0.3,0.1c0.4,0,0.7-0.2,0.9-0.5l1.1-2c0.2-0.4,0.2-0.9-0.2-1.3L13.5,8.4z M12.6,12l-1.7-0.6c-0.4,0.3-0.9,0.6-1.4,0.8	L9.2,14H6.8l-0.4-1.8c-0.5-0.2-0.9-0.5-1.4-0.8L3.4,12l-1.2-2l1.4-1.2c-0.1-0.5-0.1-1.1,0-1.6L2.2,6l1.2-2l1.7,0.6	C5.5,4.2,6,4,6.5,3.8L6.8,2h2.4l0.4,1.8c0.5,0.2,0.9,0.5,1.4,0.8L12.6,4l1.2,2l-1.4,1.2c0.1,0.5,0.1,1.1,0,1.6l1.4,1.2L12.6,12z"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M8,11c-1.7,0-3-1.3-3-3s1.3-3,3-3s3,1.3,3,3C11,9.6,9.7,11,8,11C8,11,8,11,8,11z M8,6C6.9,6,6,6.8,6,7.9C6,7.9,6,8,6,8	c0,1.1,0.8,2,1.9,2c0,0,0.1,0,0.1,0c1.1,0,2-0.8,2-1.9c0,0,0-0.1,0-0.1C10,6.9,9.2,6,8,6C8.1,6,8,6,8,6z"
    }
  }],
  "name": "settings",
  "size": 16
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/settings--adjust/16.js
var _1633 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M30 8h-4.1c-.5-2.3-2.5-4-4.9-4s-4.4 1.7-4.9 4H2v2h14.1c.5 2.3 2.5 4 4.9 4s4.4-1.7 4.9-4H30V8zM21 12c-1.7 0-3-1.3-3-3s1.3-3 3-3 3 1.3 3 3S22.7 12 21 12zM2 24h4.1c.5 2.3 2.5 4 4.9 4s4.4-1.7 4.9-4H30v-2H15.9c-.5-2.3-2.5-4-4.9-4s-4.4 1.7-4.9 4H2V24zM11 20c1.7 0 3 1.3 3 3s-1.3 3-3 3-3-1.3-3-3S9.3 20 11 20z"
    }
  }],
  "name": "settings--adjust",
  "size": 16
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/subtract/16.js
var _1634 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M8 15H24V17H8z"
    }
  }],
  "name": "subtract",
  "size": 16
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/trash-can/16.js
var _1635 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M12 12H14V24H12zM18 12H20V24H18z"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M4 6V8H6V28a2 2 0 002 2H24a2 2 0 002-2V8h2V6zM8 28V8H24V28zM12 2H20V4H12z"
    }
  }],
  "name": "trash-can",
  "size": 16
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/warning/16.js
var _1636 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 16 16",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M8,1C4.1,1,1,4.1,1,8s3.1,7,7,7s7-3.1,7-7S11.9,1,8,1z M8,14c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S11.3,14,8,14z"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M7.5 4H8.5V9H7.5zM8 10.2c-.4 0-.8.3-.8.8s.3.8.8.8c.4 0 .8-.3.8-.8S8.4 10.2 8 10.2z"
    }
  }],
  "name": "warning",
  "size": 16
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/warning--filled/16.js
var _1637 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 16 16",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M8,1C4.2,1,1,4.2,1,8s3.2,7,7,7s7-3.1,7-7S11.9,1,8,1z M7.5,4h1v5h-1C7.5,9,7.5,4,7.5,4z M8,12.2	c-0.4,0-0.8-0.4-0.8-0.8s0.3-0.8,0.8-0.8c0.4,0,0.8,0.4,0.8,0.8S8.4,12.2,8,12.2z"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M7.5,4h1v5h-1C7.5,9,7.5,4,7.5,4z M8,12.2c-0.4,0-0.8-0.4-0.8-0.8s0.3-0.8,0.8-0.8	c0.4,0,0.8,0.4,0.8,0.8S8.4,12.2,8,12.2z",
      "data-icon-path": "inner-path",
      "opacity": "0"
    }
  }],
  "name": "warning--filled",
  "size": 16
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/warning--filled/20.js
var _2014 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 20 20",
    "fill": "currentColor",
    "width": 20,
    "height": 20
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M10,1c-5,0-9,4-9,9s4,9,9,9s9-4,9-9S15,1,10,1z M9.2,5h1.5v7H9.2V5z M10,16c-0.6,0-1-0.4-1-1s0.4-1,1-1	s1,0.4,1,1S10.6,16,10,16z"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M9.2,5h1.5v7H9.2V5z M10,16c-0.6,0-1-0.4-1-1s0.4-1,1-1s1,0.4,1,1S10.6,16,10,16z",
      "data-icon-path": "inner-path",
      "opacity": "0"
    }
  }],
  "name": "warning--filled",
  "size": 20
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/warning--alt--filled/16.js
var _1638 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "fill": "none",
      "d": "M16,26a1.5,1.5,0,1,1,1.5-1.5A1.5,1.5,0,0,1,16,26Zm-1.125-5h2.25V12h-2.25Z",
      "data-icon-path": "inner-path"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M16.002,6.1714h-.004L4.6487,27.9966,4.6506,28H27.3494l.0019-.0034ZM14.875,12h2.25v9h-2.25ZM16,26a1.5,1.5,0,1,1,1.5-1.5A1.5,1.5,0,0,1,16,26Z"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M29,30H3a1,1,0,0,1-.8872-1.4614l13-25a1,1,0,0,1,1.7744,0l13,25A1,1,0,0,1,29,30ZM4.6507,28H27.3493l.002-.0033L16.002,6.1714h-.004L4.6487,27.9967Z"
    }
  }],
  "name": "warning--alt--filled",
  "size": 16
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/warning--alt--filled/20.js
var _2015 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 20,
    "height": 20
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "fill": "none",
      "d": "M16,26a1.5,1.5,0,1,1,1.5-1.5A1.5,1.5,0,0,1,16,26Zm-1.125-5h2.25V12h-2.25Z",
      "data-icon-path": "inner-path"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M16.002,6.1714h-.004L4.6487,27.9966,4.6506,28H27.3494l.0019-.0034ZM14.875,12h2.25v9h-2.25ZM16,26a1.5,1.5,0,1,1,1.5-1.5A1.5,1.5,0,0,1,16,26Z"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M29,30H3a1,1,0,0,1-.8872-1.4614l13-25a1,1,0,0,1,1.7744,0l13,25A1,1,0,0,1,29,30ZM4.6507,28H27.3493l.002-.0033L16.002,6.1714h-.004L4.6487,27.9967Z"
    }
  }],
  "name": "warning--alt--filled",
  "size": 20
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/view/16.js
var _1639 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 16 16",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M15.5,7.8C14.3,4.7,11.3,2.6,8,2.5C4.7,2.6,1.7,4.7,0.5,7.8c0,0.1,0,0.2,0,0.3c1.2,3.1,4.1,5.2,7.5,5.3	c3.3-0.1,6.3-2.2,7.5-5.3C15.5,8.1,15.5,7.9,15.5,7.8z M8,12.5c-2.7,0-5.4-2-6.5-4.5c1-2.5,3.8-4.5,6.5-4.5s5.4,2,6.5,4.5	C13.4,10.5,10.6,12.5,8,12.5z"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M8,5C6.3,5,5,6.3,5,8s1.3,3,3,3s3-1.3,3-3S9.7,5,8,5z M8,10c-1.1,0-2-0.9-2-2s0.9-2,2-2s2,0.9,2,2S9.1,10,8,10z"
    }
  }],
  "name": "view",
  "size": 16
};

// node_modules/carbon-components-angular/node_modules/@carbon/icons/es/view--off/16.js
var _1640 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 16 16",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M2.6,11.3l0.7-0.7C2.6,9.8,1.9,9,1.5,8c1-2.5,3.8-4.5,6.5-4.5c0.7,0,1.4,0.1,2,0.4l0.8-0.8C9.9,2.7,9,2.5,8,2.5	C4.7,2.6,1.7,4.7,0.5,7.8c0,0.1,0,0.2,0,0.3C1,9.3,1.7,10.4,2.6,11.3z"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M6 7.9c.1-1 .9-1.8 1.8-1.8l.9-.9C7.2 4.7 5.5 5.6 5.1 7.2 5 7.7 5 8.3 5.1 8.8L6 7.9zM15.5 7.8c-.6-1.5-1.6-2.8-2.9-3.7L15 1.7 14.3 1 1 14.3 1.7 15l2.6-2.6c1.1.7 2.4 1 3.7 1.1 3.3-.1 6.3-2.2 7.5-5.3C15.5 8.1 15.5 7.9 15.5 7.8zM10 8c0 1.1-.9 2-2 2-.3 0-.7-.1-1-.3L9.7 7C9.9 7.3 10 7.6 10 8zM8 12.5c-1 0-2.1-.3-3-.8l1.3-1.3c1.4.9 3.2.6 4.2-.8.7-1 .7-2.4 0-3.4l1.4-1.4c1.1.8 2 1.9 2.6 3.2C13.4 10.5 10.6 12.5 8 12.5z"
    }
  }],
  "name": "view--off",
  "size": 16
};

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-icon.mjs
var IconCache = class {
};
var IconNameNotFoundError = class extends Error {
  constructor(name) {
    super(`Icon ${name} not found`);
  }
};
var IconSizeNotFoundError = class extends Error {
  constructor(size2, name) {
    super("Size ${size} for ${name} not found");
  }
};
var IconMemoryCache = class extends IconCache {
  constructor() {
    super(...arguments);
    this.iconMap = /* @__PURE__ */ new Map();
  }
  get(name, size2) {
    if (!this.iconMap.has(name)) {
      throw new IconNameNotFoundError(name);
    }
    const sizeMap = this.iconMap.get(name);
    if (!sizeMap.has(size2)) {
      throw new IconSizeNotFoundError(size2, name);
    }
    return sizeMap.get(size2);
  }
  set(name, size2, descriptor) {
    if (!this.iconMap.has(name)) {
      this.iconMap.set(name, /* @__PURE__ */ new Map());
    }
    const sizeMap = this.iconMap.get(name);
    sizeMap.set(size2, descriptor);
  }
};
var IconService = class {
  constructor() {
    this.iconCache = new IconMemoryCache();
  }
  /**
   * Registers an array of icons based on the metadata provided by `@carbon/icons`
   */
  registerAll(descriptors) {
    descriptors.forEach((icon) => this.register(icon));
  }
  /**
   * Registers an icon based on the metadata provided by `@carbon/icons`
   */
  register(descriptor) {
    const {
      name
    } = descriptor;
    this.registerAs(name, descriptor);
  }
  /**
   * Registers an icon based on a uniqe name and metadata provided by `@carbon/icons`
   */
  registerAs(name, descriptor) {
    const {
      size: size2
    } = descriptor;
    this.iconCache.set(name, size2.toString(), descriptor);
  }
  /**
   * Gets an icon, converts it to a string, and caches the result
   */
  get(name, size2) {
    try {
      const icon = this.iconCache.get(name, size2.toString());
      if (!icon.svg) {
        icon.svg = toString(icon);
      }
      return icon;
    } catch (e) {
      throw e;
    }
  }
  /**
   * Configure various service settings (caching strategy ...)
   */
  configure(options) {
    this.iconCache = options.cache;
  }
};
IconService.ɵfac = function IconService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || IconService)();
};
IconService.ɵprov = ɵɵdefineInjectable({
  token: IconService,
  factory: IconService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IconService, [{
    type: Injectable
  }], null, null);
})();
var IconDirective = class _IconDirective {
  constructor(elementRef, iconService) {
    this.elementRef = elementRef;
    this.iconService = iconService;
    this.cdsIcon = "";
    this.size = "16";
    this.title = "";
    this.ariaLabel = "";
    this.ariaLabelledBy = "";
    this.ariaHidden = "";
    this.isFocusable = false;
  }
  /**
   * @deprecated since v5 - Use `cdsIcon` input property instead
   */
  set ibmIcon(iconName) {
    this.cdsIcon = iconName;
  }
  renderIcon(iconName) {
    const root2 = this.elementRef.nativeElement;
    let icon;
    try {
      icon = this.iconService.get(iconName, this.size.toString());
    } catch (error) {
      console.warn(error);
      return;
    }
    const domParser = new DOMParser();
    const rawSVG = icon.svg;
    const svgElement = domParser.parseFromString(rawSVG, "image/svg+xml").documentElement;
    let node = root2.tagName.toUpperCase() !== "SVG" ? svgElement : svgElement.firstChild;
    root2.innerHTML = "";
    while (node) {
      root2.appendChild(root2.ownerDocument.importNode(node, true));
      node = node.nextSibling;
    }
    const svg = root2.tagName.toUpperCase() !== "SVG" ? svgElement : root2;
    const xmlns = "http://www.w3.org/2000/svg";
    svg.setAttribute("xmlns", xmlns);
    const attributes = getAttributes({
      width: icon.attrs.width,
      height: icon.attrs.height,
      viewBox: icon.attrs.viewBox,
      title: this.title,
      "aria-label": this.ariaLabel,
      "aria-labelledby": this.ariaLabelledBy,
      "aria-hidden": this.ariaHidden,
      focusable: this.isFocusable.toString(),
      fill: icon.attrs.fill
    });
    const attrKeys = Object.keys(attributes);
    for (let i = 0; i < attrKeys.length; i++) {
      const key = attrKeys[i];
      const value = attributes[key];
      if (key === "title") {
        continue;
      }
      if (value) {
        svg.setAttribute(key, value);
      }
    }
    if (attributes["title"]) {
      const title = document.createElementNS(xmlns, "title");
      title.textContent = attributes.title;
      _IconDirective.titleIdCounter++;
      title.setAttribute("id", `${icon.name}-title-${_IconDirective.titleIdCounter}`);
      svg.insertBefore(title, svg.firstElementChild);
      svg.setAttribute("aria-labelledby", `${icon.name}-title-${_IconDirective.titleIdCounter}`);
    }
  }
  ngAfterViewInit() {
    this.renderIcon(this.cdsIcon);
  }
  ngOnChanges({
    cdsIcon
  }) {
    if (cdsIcon && !cdsIcon.isFirstChange()) {
      this.renderIcon(this.cdsIcon);
    }
  }
};
IconDirective.titleIdCounter = 0;
IconDirective.ɵfac = function IconDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || IconDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(IconService));
};
IconDirective.ɵdir = ɵɵdefineDirective({
  type: IconDirective,
  selectors: [["", "cdsIcon", ""], ["", "ibmIcon", ""]],
  inputs: {
    ibmIcon: "ibmIcon",
    cdsIcon: "cdsIcon",
    size: "size",
    title: "title",
    ariaLabel: "ariaLabel",
    ariaLabelledBy: "ariaLabelledBy",
    ariaHidden: "ariaHidden",
    isFocusable: "isFocusable"
  },
  standalone: false,
  features: [ɵɵNgOnChangesFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IconDirective, [{
    type: Directive,
    args: [{
      selector: "[cdsIcon], [ibmIcon]"
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: IconService
    }];
  }, {
    ibmIcon: [{
      type: Input
    }],
    cdsIcon: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    ariaLabelledBy: [{
      type: Input
    }],
    ariaHidden: [{
      type: Input
    }],
    isFocusable: [{
      type: Input
    }]
  });
})();
function ICON_SERVICE_PROVIDER_FACTORY(parentService) {
  return parentService || new IconService();
}
var ICON_SERVICE_PROVIDER = {
  provide: IconService,
  deps: [[new Optional(), new SkipSelf(), IconService]],
  useFactory: ICON_SERVICE_PROVIDER_FACTORY
};
var IconModule = class {
  constructor(iconService) {
    this.iconService = iconService;
    iconService.registerAll([_16, _20, _162, _202, _163, _164, _203, _165, _166, _167, _168, _169, _1610, _204, _1611, _1612, _1613, _1614, _1615, _1616, _1617, _205, _1618, _206, _1619, _207, _1620, _208, _1621, _1622, _209, _1623, _2010, _1624, _1625, _1626, _2011, _2012, _1627, _2013, _1628, _1629, _1630, _1631, _1632, _1633, _1634, _1635, _1639, _1640, _1636, _1637, _2014, _1638, _2015]);
  }
};
IconModule.ɵfac = function IconModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || IconModule)(ɵɵinject(IconService));
};
IconModule.ɵmod = ɵɵdefineNgModule({
  type: IconModule,
  declarations: [IconDirective],
  imports: [CommonModule],
  exports: [IconDirective]
});
IconModule.ɵinj = ɵɵdefineInjector({
  providers: [ICON_SERVICE_PROVIDER],
  imports: [CommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IconModule, [{
    type: NgModule,
    args: [{
      declarations: [IconDirective],
      exports: [IconDirective],
      imports: [CommonModule],
      providers: [ICON_SERVICE_PROVIDER]
    }]
  }], function() {
    return [{
      type: IconService
    }];
  }, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-accordion.mjs
var _c0 = ["*"];
var _c1 = (a0) => ({
  "cds--skeleton__text": a0
});
function AccordionItem_p_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "p", 8);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngClass", ɵɵpureFunction1(2, _c1, ctx_r1.skeleton));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", !ctx_r1.skeleton ? ctx_r1.title : null, " ");
  }
}
function AccordionItem_3_ng_template_0_Template(rf, ctx) {
}
function AccordionItem_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, AccordionItem_3_ng_template_0_Template, 0, 0, "ng-template", 9);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.title)("ngTemplateOutletContext", ctx_r1.context);
  }
}
function AccordionItem_ng_content_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 0, ["*ngIf", "!skeleton; else skeletonTemplate"]);
  }
}
function AccordionItem_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "p", 10)(1, "p", 11)(2, "p", 12);
  }
}
var _c2 = (a0, a1, a2, a3, a4, a5, a6, a7) => ({
  "cds--accordion--end": a0,
  "cds--accordion--start": a1,
  "cds--accordion--sm": a2,
  "cds--accordion--md": a3,
  "cds--accordion--lg": a4,
  "cds--layout--size-sm": a5,
  "cds--layout--size-md": a6,
  "cds--layout--size-lg": a7
});
var AccordionItem = class _AccordionItem {
  constructor() {
    this.context = null;
    this.id = `accordion-item-${_AccordionItem.accordionItemCount++}`;
    this.skeleton = false;
    this.selected = new EventEmitter();
    this.itemClass = true;
    this.expanded = false;
    this.disabled = false;
    this.role = "listitem";
  }
  toggleExpanded() {
    if (!this.skeleton) {
      this.expanded = !this.expanded;
      this.selected.emit({
        id: this.id,
        expanded: this.expanded
      });
    }
  }
  isTemplate(value) {
    return value instanceof TemplateRef;
  }
};
AccordionItem.accordionItemCount = 0;
AccordionItem.ɵfac = function AccordionItem_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || AccordionItem)();
};
AccordionItem.ɵcmp = ɵɵdefineComponent({
  type: AccordionItem,
  selectors: [["cds-accordion-item"], ["ibm-accordion-item"]],
  hostVars: 7,
  hostBindings: function AccordionItem_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", ctx.role);
      ɵɵclassProp("cds--accordion__item", ctx.itemClass)("cds--accordion__item--active", ctx.expanded)("cds--accordion__item--disabled", ctx.disabled);
    }
  },
  inputs: {
    title: "title",
    context: "context",
    id: "id",
    skeleton: "skeleton",
    expanded: "expanded",
    disabled: "disabled"
  },
  outputs: {
    selected: "selected"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 9,
  vars: 8,
  consts: [["skeletonTemplate", ""], ["type", "button", 1, "cds--accordion__heading", 3, "click", "disabled"], ["cdsIcon", "chevron--right", "size", "16", 1, "cds--accordion__arrow"], ["class", "cds--accordion__title", 3, "ngClass", 4, "ngIf"], [4, "ngIf"], [1, "cds--accordion__wrapper"], [1, "cds--accordion__content", 3, "id"], [4, "ngIf", "ngIfElse"], [1, "cds--accordion__title", 3, "ngClass"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "cds--skeleton__text", 2, "width", "90%"], [1, "cds--skeleton__text", 2, "width", "80%"], [1, "cds--skeleton__text", 2, "width", "95%"]],
  template: function AccordionItem_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵprojectionDef();
      ɵɵelementStart(0, "button", 1);
      ɵɵlistener("click", function AccordionItem_Template_button_click_0_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.toggleExpanded());
      });
      ɵɵnamespaceSVG();
      ɵɵelement(1, "svg", 2);
      ɵɵtemplate(2, AccordionItem_p_2_Template, 2, 4, "p", 3)(3, AccordionItem_3_Template, 1, 2, null, 4);
      ɵɵelementEnd();
      ɵɵnamespaceHTML();
      ɵɵelementStart(4, "div", 5)(5, "div", 6);
      ɵɵtemplate(6, AccordionItem_ng_content_6_Template, 1, 0, "ng-content", 7)(7, AccordionItem_ng_template_7_Template, 3, 0, "ng-template", null, 0, ɵɵtemplateRefExtractor);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      const skeletonTemplate_r3 = ɵɵreference(8);
      ɵɵproperty("disabled", ctx.disabled);
      ɵɵattribute("aria-expanded", ctx.expanded)("aria-controls", ctx.id);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", !ctx.isTemplate(ctx.title));
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.isTemplate(ctx.title));
      ɵɵadvance(2);
      ɵɵproperty("id", ctx.id);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.skeleton)("ngIfElse", skeletonTemplate_r3);
    }
  },
  dependencies: [NgClass, NgIf, NgTemplateOutlet, IconDirective],
  styles: ["[_nghost-%COMP%]{display:list-item}"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AccordionItem, [{
    type: Component,
    args: [{
      selector: "cds-accordion-item, ibm-accordion-item",
      template: `
		<button
			type="button"
			[disabled]="disabled"
			[attr.aria-expanded]="expanded"
			[attr.aria-controls]="id"
			(click)="toggleExpanded()"
			class="cds--accordion__heading">
			<svg cdsIcon="chevron--right" size="16" class="cds--accordion__arrow"></svg>
			<p *ngIf="!isTemplate(title)"
				class="cds--accordion__title"
				[ngClass]="{
					'cds--skeleton__text': skeleton
				}">
				{{!skeleton ? title : null}}
			</p>
			<ng-template
				*ngIf="isTemplate(title)"
				[ngTemplateOutlet]="title"
				[ngTemplateOutletContext]="context">
			</ng-template>
		</button>
		<div class="cds--accordion__wrapper">
			<div [id]="id" class="cds--accordion__content">
				<ng-content *ngIf="!skeleton; else skeletonTemplate"></ng-content>
				<ng-template #skeletonTemplate>
					<p class="cds--skeleton__text" style="width: 90%"></p>
					<p class="cds--skeleton__text" style="width: 80%"></p>
					<p class="cds--skeleton__text" style="width: 95%"></p>
				</ng-template>
			</div>
		</div>
	`,
      styles: [":host{display:list-item}\n"]
    }]
  }], null, {
    title: [{
      type: Input
    }],
    context: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    skeleton: [{
      type: Input
    }],
    selected: [{
      type: Output
    }],
    itemClass: [{
      type: HostBinding,
      args: ["class.cds--accordion__item"]
    }],
    expanded: [{
      type: HostBinding,
      args: ["class.cds--accordion__item--active"]
    }, {
      type: Input
    }],
    disabled: [{
      type: HostBinding,
      args: ["class.cds--accordion__item--disabled"]
    }, {
      type: Input
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }]
  });
})();
var Accordion = class {
  constructor() {
    this.align = "end";
    this.size = "md";
    this._skeleton = false;
  }
  set skeleton(value) {
    this._skeleton = value;
    this.updateChildren();
  }
  get skeleton() {
    return this._skeleton;
  }
  ngAfterContentInit() {
    this.updateChildren();
  }
  updateChildren() {
    if (this.children) {
      this.children.toArray().forEach((child) => child.skeleton = this.skeleton);
    }
  }
};
Accordion.ɵfac = function Accordion_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Accordion)();
};
Accordion.ɵcmp = ɵɵdefineComponent({
  type: Accordion,
  selectors: [["cds-accordion"], ["ibm-accordion"]],
  contentQueries: function Accordion_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, AccordionItem, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  inputs: {
    align: "align",
    size: "size",
    skeleton: "skeleton"
  },
  standalone: false,
  ngContentSelectors: _c0,
  decls: 2,
  vars: 10,
  consts: [["role", "list", 1, "cds--accordion", 3, "ngClass"]],
  template: function Accordion_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 0);
      ɵɵprojection(1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngClass", ɵɵpureFunction8(1, _c2, ctx.align === "end", ctx.align === "start", ctx.size === "sm", ctx.size === "md", ctx.size === "lg", ctx.size === "sm", ctx.size === "md", ctx.size === "lg"));
    }
  },
  dependencies: [NgClass],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Accordion, [{
    type: Component,
    args: [{
      selector: "cds-accordion, ibm-accordion",
      template: `
		<div class="cds--accordion"
			[ngClass]="{
				'cds--accordion--end': align === 'end',
				'cds--accordion--start': align === 'start',
				'cds--accordion--sm': size === 'sm',
				'cds--accordion--md': size ==='md',
				'cds--accordion--lg': size === 'lg',
				'cds--layout--size-sm': size === 'sm',
				'cds--layout--size-md': size === 'md',
				'cds--layout--size-lg': size === 'lg'
			}"
			role="list">
			<ng-content></ng-content>
		</div>
	`
    }]
  }], null, {
    align: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    children: [{
      type: ContentChildren,
      args: [AccordionItem]
    }],
    skeleton: [{
      type: Input
    }]
  });
})();
var AccordionModule = class {
};
AccordionModule.ɵfac = function AccordionModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || AccordionModule)();
};
AccordionModule.ɵmod = ɵɵdefineNgModule({
  type: AccordionModule,
  declarations: [Accordion, AccordionItem],
  imports: [CommonModule, IconModule],
  exports: [Accordion, AccordionItem]
});
AccordionModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, IconModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AccordionModule, [{
    type: NgModule,
    args: [{
      declarations: [Accordion, AccordionItem],
      exports: [Accordion, AccordionItem],
      imports: [CommonModule, IconModule]
    }]
  }], null, null);
})();

// node_modules/@carbon/utils-position/index.js
var _a;
var PLACEMENTS;
(function(PLACEMENTS2) {
  PLACEMENTS2["LEFT"] = "left";
  PLACEMENTS2["RIGHT"] = "right";
  PLACEMENTS2["TOP"] = "top";
  PLACEMENTS2["BOTTOM"] = "bottom";
})(PLACEMENTS || (PLACEMENTS = {}));
var defaultPositions = (_a = {}, _a[PLACEMENTS.LEFT] = function(referenceOffset, target, referenceRect) {
  return {
    top: referenceOffset.top - Math.round(target.offsetHeight / 2) + Math.round(referenceRect.height / 2),
    left: Math.round(referenceOffset.left - target.offsetWidth)
  };
}, _a[PLACEMENTS.RIGHT] = function(referenceOffset, target, referenceRect) {
  return {
    top: referenceOffset.top - Math.round(target.offsetHeight / 2) + Math.round(referenceRect.height / 2),
    left: Math.round(referenceOffset.left + referenceRect.width)
  };
}, _a[PLACEMENTS.TOP] = function(referenceOffset, target, referenceRect) {
  return {
    top: Math.round(referenceOffset.top - target.offsetHeight),
    left: referenceOffset.left - Math.round(target.offsetWidth / 2) + Math.round(referenceRect.width / 2)
  };
}, _a[PLACEMENTS.BOTTOM] = function(referenceOffset, target, referenceRect) {
  return {
    top: Math.round(referenceOffset.top + referenceRect.height),
    left: referenceOffset.left - Math.round(target.offsetWidth / 2) + Math.round(referenceRect.width / 2)
  };
}, _a);
var windowRef = typeof window !== "undefined" ? window : {
  innerHeight: 0,
  scrollY: 0,
  innerWidth: 0,
  scrollX: 0
};
var Position = (
  /** @class */
  function() {
    function Position2(positions) {
      if (positions === void 0) {
        positions = {};
      }
      this.positions = defaultPositions;
      this.positions = Object.assign({}, defaultPositions, positions);
    }
    Position2.prototype.getRelativeOffset = function(target) {
      var offsets = {
        left: target.offsetLeft,
        top: target.offsetTop
      };
      while (target.offsetParent && getComputedStyle(target.offsetParent).position === "static") {
        offsets.left += target.offsetLeft;
        offsets.top += target.offsetTop;
        target = target.offsetParent;
      }
      return offsets;
    };
    Position2.prototype.getAbsoluteOffset = function(target) {
      var currentNode = target;
      var margins = {
        top: 0,
        left: 0
      };
      while (currentNode.offsetParent) {
        var computed2 = getComputedStyle(currentNode.offsetParent);
        if (computed2.position === "static" && computed2.marginLeft && computed2.marginTop) {
          if (parseInt(computed2.marginTop, 10)) {
            margins.top += parseInt(computed2.marginTop, 10);
          }
          if (parseInt(computed2.marginLeft, 10)) {
            margins.left += parseInt(computed2.marginLeft, 10);
          }
        }
        currentNode = currentNode.offsetParent;
      }
      var targetRect = target.getBoundingClientRect();
      var relativeRect = document.body.getBoundingClientRect();
      return {
        top: targetRect.top - relativeRect.top + margins.top,
        left: targetRect.left - relativeRect.left + margins.left
      };
    };
    Position2.prototype.findRelative = function(reference, target, placement) {
      var referenceOffset = this.getRelativeOffset(reference);
      var referenceRect = reference.getBoundingClientRect();
      return this.calculatePosition(referenceOffset, referenceRect, target, placement);
    };
    Position2.prototype.findAbsolute = function(reference, target, placement) {
      var referenceOffset = this.getAbsoluteOffset(reference);
      var referenceRect = reference.getBoundingClientRect();
      return this.calculatePosition(referenceOffset, referenceRect, target, placement);
    };
    Position2.prototype.findPosition = function(reference, target, placement, offsetFunction) {
      if (offsetFunction === void 0) {
        offsetFunction = this.getAbsoluteOffset.bind(this);
      }
      var referenceOffset = offsetFunction(reference);
      var referenceRect = reference.getBoundingClientRect();
      return this.calculatePosition(referenceOffset, referenceRect, target, placement);
    };
    Position2.prototype.findPositionAt = function(offset3, target, placement) {
      return this.calculatePosition(offset3, {
        top: 0,
        left: 0,
        height: 0,
        width: 0
      }, target, placement);
    };
    Position2.prototype.getPlacementBox = function(target, position2) {
      var targetBottom = target.offsetHeight + position2.top;
      var targetRight = target.offsetWidth + position2.left;
      return {
        top: position2.top,
        bottom: targetBottom,
        left: position2.left,
        right: targetRight
      };
    };
    Position2.prototype.addOffset = function(position2, top, left) {
      if (top === void 0) {
        top = 0;
      }
      if (left === void 0) {
        left = 0;
      }
      return Object.assign({}, position2, {
        top: position2.top + top,
        left: position2.left + left
      });
    };
    Position2.prototype.setElement = function(element, position2) {
      element.style.top = position2.top + "px";
      element.style.left = position2.left + "px";
    };
    Position2.prototype.findBestPlacement = function(reference, target, placements2, containerFunction, positionFunction) {
      var _this = this;
      if (containerFunction === void 0) {
        containerFunction = this.defaultContainerFunction.bind(this);
      }
      if (positionFunction === void 0) {
        positionFunction = this.findPosition.bind(this);
      }
      var weightedPlacements = placements2.map(function(placement) {
        var pos = positionFunction(reference, target, placement);
        var box = _this.getPlacementBox(target, pos);
        var hiddenHeight = 0;
        var hiddenWidth = 0;
        var container = containerFunction();
        if (box.top < container.top) {
          hiddenHeight = container.top - box.top;
        } else if (box.bottom > container.height) {
          hiddenHeight = box.bottom - container.height;
        }
        if (box.left < container.left) {
          hiddenWidth = container.left - box.left;
        } else if (box.right > container.width) {
          hiddenWidth = box.right - container.width;
        }
        if (hiddenHeight && !hiddenWidth) {
          hiddenWidth = 1;
        } else if (hiddenWidth && !hiddenHeight) {
          hiddenHeight = 1;
        }
        var area = target.offsetHeight * target.offsetWidth;
        var hiddenArea = hiddenHeight * hiddenWidth;
        var visibleArea = area - hiddenArea;
        var visiblePercent = visibleArea / area;
        return {
          placement,
          weight: visiblePercent
        };
      });
      weightedPlacements.sort(function(a, b) {
        return b.weight - a.weight;
      });
      return weightedPlacements[0].placement;
    };
    Position2.prototype.findBestPlacementAt = function(offset3, target, placements2, containerFunction) {
      var _this = this;
      if (containerFunction === void 0) {
        containerFunction = this.defaultContainerFunction.bind(this);
      }
      var positionAt = function(_, target2, placement) {
        return _this.findPositionAt(offset3, target2, placement);
      };
      return this.findBestPlacement(null, target, placements2, containerFunction, positionAt);
    };
    Position2.prototype.defaultContainerFunction = function() {
      return {
        // we go with window here, because that's going to be the simple/common case
        top: 0,
        left: 0,
        height: windowRef.innerHeight,
        width: windowRef.innerWidth
      };
    };
    Position2.prototype.calculatePosition = function(referenceOffset, referenceRect, target, placement) {
      if (this.positions[placement]) {
        return this.positions[placement](referenceOffset, target, referenceRect);
      }
      console.error("No function found for placement, defaulting to 0,0");
      return {
        left: 0,
        top: 0
      };
    };
    return Position2;
  }()
);
var position = new Position();
var utils_position_default = Position;

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-utils.mjs
function findSiblingElem(target, direction) {
  if (target[direction]) {
    if (target[direction].classList.contains("disabled")) {
      return findSiblingElem(target[direction], direction);
    }
    return target[direction];
  }
}
function findNextElem(target) {
  return findSiblingElem(target, "nextElementSibling");
}
function findPrevElem(target) {
  return findSiblingElem(target, "previousElementSibling");
}
function HcModeChecker() {
  let colorTest = "rgb(255, 0, 0)";
  let htmlChecker = document.createElement("div");
  htmlChecker.classList.add("hc-checker");
  document.body.appendChild(htmlChecker);
  if (window.getComputedStyle(htmlChecker).backgroundColor.toString() !== colorTest) {
    document.body.classList.add("a11y");
  }
  document.body.removeChild(htmlChecker);
}
function focusNextTree(elem, rootElem = null) {
  if (elem) {
    let focusable = elem.querySelector("[tabindex='0']");
    if (focusable) {
      focusable.focus();
    } else {
      focusNextElem(elem, rootElem);
    }
  }
}
function focusNextElem(elem, rootElem = null) {
  if (elem) {
    let nextElem = elem.nextElementSibling;
    if (nextElem) {
      let focusableElem = nextElem.querySelector("[tabindex='0']");
      if (focusableElem) {
        focusableElem.focus();
      } else {
        focusNextElem(nextElem, rootElem);
      }
    } else {
      if (rootElem) {
        let nextRootElem = rootElem.nextElementSibling;
        if (nextRootElem) {
          focusNextTree(nextRootElem, rootElem);
        }
      }
    }
  }
}
function focusPrevElem(elem, parentRef = null) {
  if (elem) {
    let prevElem = elem.previousElementSibling;
    if (prevElem) {
      let focusableElem = prevElem.querySelector("[tabindex='0']");
      if (focusableElem) {
        if (focusableElem.getAttribute("aria-expanded") === "true") {
          let lastFocElms = prevElem.querySelectorAll("[tabindex='0']");
          let arrLen = lastFocElms.length - 1;
          for (let i = arrLen; i >= 0; i--) {
            if (!!(lastFocElms[i].offsetWidth || lastFocElms[i].offsetHeight || lastFocElms[i].getClientRects().length)) {
              focusableElem = lastFocElms[i];
              break;
            }
          }
        }
        focusableElem.focus();
      } else {
        focusPrevElem(prevElem, parentRef);
      }
    } else {
      if (parentRef) {
        parentRef.querySelector("[tabindex='0']").focus();
      }
    }
  }
}
var AnimationFrameServiceSingleton = class {
  constructor(ngZone) {
    this.ngZone = ngZone;
    this.frameSource = new Subject();
    this.tick = this.frameSource.asObservable();
    this.ngZone.runOutsideAngular(() => {
      this.animationFrameId = requestAnimationFrame(this.doTick.bind(this));
    });
  }
  ngOnDestroy() {
    cancelAnimationFrame(this.animationFrameId);
  }
  doTick(frame) {
    this.frameSource.next(frame);
    this.ngZone.runOutsideAngular(() => {
      requestAnimationFrame(this.doTick.bind(this));
    });
  }
};
AnimationFrameServiceSingleton.ɵfac = function AnimationFrameServiceSingleton_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || AnimationFrameServiceSingleton)(ɵɵinject(NgZone));
};
AnimationFrameServiceSingleton.ɵprov = ɵɵdefineInjectable({
  token: AnimationFrameServiceSingleton,
  factory: AnimationFrameServiceSingleton.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AnimationFrameServiceSingleton, [{
    type: Injectable
  }], function() {
    return [{
      type: NgZone
    }];
  }, null);
})();
var AnimationFrameService = class {
  constructor(singleton) {
    this.singleton = singleton;
    this.tick = from(this.singleton.tick);
  }
};
AnimationFrameService.ɵfac = function AnimationFrameService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || AnimationFrameService)(ɵɵinject(AnimationFrameServiceSingleton));
};
AnimationFrameService.ɵprov = ɵɵdefineInjectable({
  token: AnimationFrameService,
  factory: AnimationFrameService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AnimationFrameService, [{
    type: Injectable
  }], function() {
    return [{
      type: AnimationFrameServiceSingleton
    }];
  }, null);
})();
var merge2 = (target, ...objects) => {
  for (const object of objects) {
    for (const key in object) {
      if (object.hasOwnProperty(key)) {
        if (object[key] instanceof Object) {
          if (!target[key]) {
            target[key] = {};
          }
          target[key] = merge2(target[key], object[key]);
        } else {
          target[key] = object[key];
        }
      }
    }
  }
  return target;
};
var isScrollableElement = (element) => {
  const computedStyle = getComputedStyle(element);
  return computedStyle.overflow === "auto" || computedStyle.overflow === "scroll" || computedStyle["overflow-y"] === "auto" || computedStyle["overflow-y"] === "scroll" || computedStyle["overflow-x"] === "auto" || computedStyle["overflow-x"] === "scroll";
};
var isVisibleInContainer = (element, container) => {
  const elementRect = element.getBoundingClientRect();
  const containerRect = container.getBoundingClientRect();
  if (container.tagName === "BODY" || container.tagName === "HTML") {
    const isAboveViewport = elementRect.top < 0 && elementRect.top + element.clientHeight < 0;
    const isLeftOfViewport = elementRect.left < 0;
    const isBelowViewport = elementRect.bottom - element.clientHeight > (window.innerHeight || document.documentElement.clientHeight);
    const isRightOfViewport = elementRect.right > (window.innerWidth || document.documentElement.clientWidth);
    const isVisibleInViewport = !(isAboveViewport || isBelowViewport || isLeftOfViewport || isRightOfViewport);
    return isVisibleInViewport;
  }
  return (
    // This also accounts for partial visibility. It will still return true if the element is partially visible inside the container.
    elementRect.bottom - element.clientHeight <= containerRect.bottom + (container.offsetHeight - container.clientHeight) / 2 && elementRect.top >= -element.clientHeight
  );
};
var getScrollableParents = (node) => {
  const elements = [document.body];
  while (node.parentElement && node !== document.body) {
    if (isScrollableElement(node)) {
      elements.push(node);
    }
    node = node.parentElement;
  }
  return elements;
};
var hasScrollableParents = (node) => {
  while (node.parentElement && node !== document.body) {
    if (isScrollableElement(node)) {
      return true;
    }
    node = node.parentElement;
  }
  return false;
};
var scrollableParentsObservable = (node) => {
  const windowScroll = fromEvent(window, "scroll", {
    passive: true
  }).pipe(map((event) => (
    // update the event target to be something useful. In this case `body` is a sensible replacement
    Object.assign({}, event, {
      target: document.body
    })
  )));
  let observables = [windowScroll];
  while (node.parentElement && node !== document.body) {
    if (isScrollableElement(node)) {
      observables.push(fromEvent(node, "scroll", {
        passive: true
      }));
    }
    node = node.parentElement;
  }
  return merge(...observables);
};
function clone(obj) {
  return JSON.parse(JSON.stringify(obj));
}
function matchesAttr(el, attr, val) {
  const styles = window.getComputedStyle(el);
  return val.includes(styles[attr]);
}
function closestAttr(s, t, element) {
  let el = element;
  if (!element) {
    return null;
  }
  do {
    if (matchesAttr(el, s, t)) {
      return el;
    }
    el = el.parentElement || el.parentNode;
  } while (el !== null && el.nodeType === 1);
  return null;
}
var ElementService = class {
  constructor(singleton) {
    this.singleton = singleton;
    this.tick = from(this.singleton.tick);
  }
  visibility(target, parentElement = target) {
    const scrollableParents = getScrollableParents(parentElement);
    return this.tick.pipe(map(() => {
      for (const parent of scrollableParents) {
        if (!isVisibleInContainer(target, parent)) {
          return {
            visible: false
          };
        }
      }
      return {
        visible: true
      };
    }));
  }
};
ElementService.ɵfac = function ElementService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ElementService)(ɵɵinject(AnimationFrameServiceSingleton));
};
ElementService.ɵprov = ɵɵdefineInjectable({
  token: ElementService,
  factory: ElementService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ElementService, [{
    type: Injectable
  }], function() {
    return [{
      type: AnimationFrameServiceSingleton
    }];
  }, null);
})();
var getEventObservable = (targetElement, eventType) => {
  switch (eventType) {
    case "scroll":
    case "resize":
    case "touchstart":
    case "touchmove":
    case "touchend":
      return fromEvent(targetElement, eventType, {
        passive: true
      });
    default:
      return fromEvent(targetElement, eventType);
  }
};
var DocumentService = class {
  constructor() {
    this.globalEvents = /* @__PURE__ */ new Map();
    this.documentRef = document;
    this.subscriptions = new Subscription();
  }
  handleEvent(eventType, callback) {
    if (!this.globalEvents.has(eventType)) {
      if (this.documentRef) {
        this.globalEvents.set(eventType, getEventObservable(this.documentRef, eventType));
      } else {
        this.globalEvents.set(eventType, new Observable());
      }
    }
    const observable = this.globalEvents.get(eventType);
    this.subscriptions.add(observable.subscribe(callback));
  }
  handleClick(callback) {
    this.handleEvent("click", callback);
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
    this.globalEvents = null;
  }
};
DocumentService.ɵfac = function DocumentService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || DocumentService)();
};
DocumentService.ɵprov = ɵɵdefineInjectable({
  token: DocumentService,
  factory: DocumentService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DocumentService, [{
    type: Injectable
  }], null, null);
})();
var EventService = class {
  constructor(documentService) {
    this.documentService = documentService;
    this.subscriptions = new Subscription();
    this.targets = /* @__PURE__ */ new WeakMap();
  }
  on(targetElement, eventType, callback) {
    if (!this.targets.has(targetElement)) {
      this.targets.set(targetElement, /* @__PURE__ */ new Map());
    }
    const eventMap = this.targets.get(targetElement);
    if (!eventMap.has(eventType)) {
      eventMap.set(eventType, getEventObservable(targetElement, eventType));
    }
    const subscription = eventMap.get(eventType).subscribe(callback);
    this.subscriptions.add(subscription);
  }
  onDocument(eventType, callback) {
    this.documentService.handleEvent(eventType, callback);
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
};
EventService.ɵfac = function EventService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || EventService)(ɵɵinject(DocumentService));
};
EventService.ɵprov = ɵɵdefineInjectable({
  token: EventService,
  factory: EventService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EventService, [{
    type: Injectable
  }], function() {
    return [{
      type: DocumentService
    }];
  }, null);
})();
function DOCUMENT_SERVICE_PROVIDER_FACTORY(parentService) {
  return parentService || new DocumentService();
}
var DOCUMENT_SERVICE_PROVIDER = {
  provide: DocumentService,
  deps: [[new Optional(), new SkipSelf(), DocumentService]],
  useFactory: DOCUMENT_SERVICE_PROVIDER_FACTORY
};
function ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER_FACTORY(parentService, ngZone) {
  return parentService || new AnimationFrameServiceSingleton(ngZone);
}
var ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER = {
  provide: AnimationFrameServiceSingleton,
  deps: [[new Optional(), new SkipSelf(), AnimationFrameServiceSingleton], NgZone],
  useFactory: ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER_FACTORY
};
var UtilsModule = class {
};
UtilsModule.ɵfac = function UtilsModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || UtilsModule)();
};
UtilsModule.ɵmod = ɵɵdefineNgModule({
  type: UtilsModule
});
UtilsModule.ɵinj = ɵɵdefineInjector({
  providers: [DOCUMENT_SERVICE_PROVIDER, ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER, AnimationFrameServiceSingleton, DocumentService, AnimationFrameService, ElementService, EventService]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UtilsModule, [{
    type: NgModule,
    args: [{
      providers: [DOCUMENT_SERVICE_PROVIDER, ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER, AnimationFrameServiceSingleton, DocumentService, AnimationFrameService, ElementService, EventService]
    }]
  }], null, null);
})();
var _scrollbarWidth = -1;
function getScrollbarWidth() {
  if (_scrollbarWidth >= 0) {
    return _scrollbarWidth;
  }
  const outer = document.createElement("div");
  outer.style.visibility = "hidden";
  outer.style.width = "100px";
  outer.style["msOverflowStyle"] = "scrollbar";
  document.body.appendChild(outer);
  const widthNoScroll = outer.offsetWidth;
  outer.style.overflow = "scroll";
  const inner = document.createElement("div");
  inner.style.width = "100%";
  outer.appendChild(inner);
  const widthWithScroll = inner.offsetWidth;
  outer.parentNode.removeChild(outer);
  _scrollbarWidth = widthNoScroll - widthWithScroll;
  return _scrollbarWidth;
}

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-i18n.mjs
var EN = {
  "BREADCRUMB": {
    "LABEL": "Breadcrumb",
    "OVERFLOW_MENU_DESCRIPTION": "Options"
  },
  "CODE_SNIPPET": {
    "CODE_SNIPPET_TEXT": "Code Snippet Text",
    "SHOW_MORE": "Show more",
    "SHOW_LESS": "Show less",
    "SHOW_MORE_ICON": "Show more icon",
    "COPY_CODE": "Copy code",
    "COPIED": "Copied!"
  },
  "COMBOBOX": {
    "PLACEHOLDER": "Filter...",
    "CLEAR_SELECTIONS": "Clear all selected items",
    "CLEAR_SELECTED": "Clear selected item",
    "A11Y": {
      "OPEN_MENU": "Open menu",
      "CLOSE_MENU": "Close menu",
      "CLEAR_SELECTIONS": "Clear all selected items",
      "CLEAR_SELECTED": "Clear Selection"
    }
  },
  "DROPDOWN": {
    "OPEN": "Open menu",
    "SELECTED": "Selected",
    "CLEAR": "Clear all selected items",
    "FILTER": {
      "SELECTED_ONLY": "Show selected only",
      "SEARCH": "Search",
      "NO_RESULTS": "No search results",
      "RESET_SEARCH": "Reset search"
    }
  },
  "DROPDOWN_LIST": {
    "LABEL": "Listbox"
  },
  "FILE_UPLOADER": {
    "CHECKMARK": "Checkmark",
    "OPEN": "Add file",
    "REMOVE_BUTTON": "Close button"
  },
  "LOADING": {
    "TITLE": "Loading"
  },
  "MODAL": {
    "CLOSE": "Close modal"
  },
  "NOTIFICATION": {
    "CLOSE_BUTTON": "Close alert notification"
  },
  "NUMBER": {
    "INCREMENT": "Increment value",
    "DECREMENT": "Decrement value"
  },
  "OVERFLOW_MENU": {
    "OVERFLOW": "Overflow",
    "ICON_DESCRIPTION": "Options"
  },
  "SEARCH": {
    "LABEL": "Search",
    "PLACEHOLDER": "Search",
    "CLEAR_BUTTON": "Clear search input"
  },
  "PAGINATION": {
    "ITEMS_PER_PAGE": "Items per page:",
    "OPEN_LIST_OF_OPTIONS": "Open list of options",
    "BACKWARD": "Backward",
    "FORWARD": "Forward",
    "TOTAL_ITEMS_UNKNOWN": "{{start}}-{{end}} items",
    "TOTAL_ITEMS": "{{start}}-{{end}} of {{total}} items",
    "TOTAL_ITEM": "{{start}}-{{end}} of {{total}} item",
    "PAGE": "page",
    "OF_LAST_PAGES": "of {{last}} pages",
    "OF_LAST_PAGE": "of {{last}} page",
    "NEXT": "Next",
    "PREVIOUS": "Previous",
    "SELECT_ARIA": "Select page number"
  },
  "PROGRESS_INDICATOR": {
    "CURRENT": "Current",
    "INCOMPLETE": "Incomplete",
    "COMPLETE": "Complete",
    "INVALID": "Invalid"
  },
  "TABLE": {
    "FILTER": "Filter",
    "END_OF_DATA": "You've reached the end of your content",
    "SCROLL_TOP": "Scroll to top",
    "CHECKBOX_HEADER": "Select all rows",
    "CHECKBOX_ROW": "Select {{value}}",
    "EXPAND_BUTTON": "Expand row",
    "EXPAND_ALL_BUTTON": "Expand all rows",
    "SORT_DESCENDING": "Sort rows by this header in descending order",
    "SORT_ASCENDING": "Sort rows by this header in ascending order",
    "ROW": "row"
  },
  "TABLE_TOOLBAR": {
    "ACTION_BAR": "Table action bar",
    "BATCH_TEXT": "",
    "BATCH_TEXT_SINGLE": "1 item selected",
    "BATCH_TEXT_MULTIPLE": "{{count}} items selected",
    "CANCEL": "Cancel"
  },
  "TABS": {
    "BUTTON_ARIA_LEFT": "Go to the previous tab",
    "BUTTON_ARIA_RIGHT": "Go to the next tab",
    "HEADER_ARIA_LABEL": "List of tabs"
  },
  "TILES": {
    "TILE": "tile",
    "EXPAND": "Expand",
    "COLLAPSE": "Collapse"
  },
  "TOGGLE": {
    "OFF": "Off",
    "ON": "On"
  },
  "UI_SHELL": {
    "SKIP_TO": "Skip to content",
    "HEADER": {
      "OPEN_MENU": "Open menu",
      "CLOSE_MENU": "Close menu"
    },
    "SIDE_NAV": {
      "TOGGLE_OPEN": "Open",
      "TOGGLE_CLOSE": "Close"
    }
  }
};
var replace = (subject, variables) => subject.pipe(map((str) => {
  const keys2 = Object.keys(variables);
  for (const key of keys2) {
    const value = variables[key];
    str = str.replace(new RegExp(`{{\\s*${key}\\s*}}`, "g"), value);
  }
  return str;
}));
var Overridable = class {
  constructor(path, i18n) {
    this.path = path;
    this.i18n = i18n;
    this.baseTranslation = this.i18n.get(this.path);
    this.isOverridden = false;
    const value = this.i18n.getValueFromPath(this.path);
    this.$override = new BehaviorSubject(value);
    this._value = value;
  }
  /**
   * The raw value of the translation. Defaults to the string value, but will return the value passed to `override`
   *
   * @readonly
   */
  get value() {
    return this._value;
  }
  set value(v) {
    this.override(v);
  }
  /**
   * The translation subject. Returns either a stream of overridden values, or our base translation values.
   *
   * @readonly
   */
  get subject() {
    return iif(() => this.isOverridden, this.$override, this.baseTranslation);
  }
  /**
   * Takes a string or an `Observable` that emits strings.
   * Overrides the value provided by the `I18n` service.
   */
  override(value) {
    this.isOverridden = true;
    if (this.subscription) {
      this.subscription.unsubscribe();
      this.subscription = null;
    }
    this._value = value;
    if (isObservable(value)) {
      this.subscription = value.subscribe((v) => {
        this.$override.next(v);
      });
    } else {
      this.$override.next(value);
    }
  }
};
var I18n = class {
  constructor() {
    this.translationStrings = EN;
    this.translations = /* @__PURE__ */ new Map();
    this.locale = new BehaviorSubject("en");
  }
  /**
   * Sets the locale and optionally the translation strings. Locale is used by components that
   * are already locale aware (datepicker for example) while the translation strings are used
   * for components that are not.
   *
   * Locales set here will override locales/languages set in components
   * @param language an ISO 639-1 language code - https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes
   * @param strings an object of strings, optional
   */
  setLocale(language, strings) {
    this.locale.next(language);
    if (strings) {
      this.set(strings);
    }
  }
  /**
   * Returns the current locale
   */
  getLocale() {
    return this.locale.value;
  }
  /**
   * Returns an observable that resolves to the current locale, and will update when changed
   */
  getLocaleObservable() {
    return this.locale.asObservable();
  }
  /**
   * Set/update the translations from an object. Also notifies all participating components of the update.
   *
   * @param strings an object of strings, should follow the same format as src/i18n/en.json
   */
  set(strings) {
    this.translationStrings = merge2({}, EN, strings);
    const translations = Array.from(this.translations);
    for (const [path, subject] of translations) {
      subject.next(this.getValueFromPath(path));
    }
  }
  /**
   * When a path is specified returns an observable that will resolve to the translation string value.
   *
   * Returns the full translations object if path is not specified.
   *
   * @param path optional, looks like `"NOTIFICATION.CLOSE_BUTTON"`
   */
  get(path) {
    if (!path) {
      return this.translationStrings;
    }
    return this.getSubject(path);
  }
  /**
   * Returns all descendents of some path fragment as an object.
   *
   * @param partialPath a path fragment, for example `"NOTIFICATION"`
   */
  getMultiple(partialPath) {
    const values = this.getValueFromPath(partialPath);
    const subjects = {};
    for (const key of Object.keys(values)) {
      if (values[key] === Object(values[key])) {
        subjects[key] = this.getMultiple(`${partialPath}.${key}`);
      } else {
        subjects[key] = this.getSubject(`${partialPath}.${key}`);
      }
    }
    return subjects;
  }
  /**
   * Returns an instance of `Overridable` that can be used to optionally override the value provided by `I18n`
   * @param path looks like `"NOTIFICATION.CLOSE_BUTTON"`
   */
  getOverridable(path) {
    return new Overridable(path, this);
  }
  /**
   * Takes the `Observable` returned from `i18n.get` and an object of variables to replace.
   *
   * The keys specify the variable name in the string.
   *
   * Example:
   * ```
   * service.set({ "TEST": "{{foo}} {{bar}}" });
   *
   * service.replace(service.get("TEST"), { foo: "test", bar: "asdf" })
   * ```
   *
   * Produces: `"test asdf"`
   *
   * @param subject the translation to replace variables on
   * @param variables object of variables to replace
   */
  replace(subject, variables) {
    return replace(subject, variables);
  }
  /**
   * Trys to resolve a value from the provided path.
   *
   * @param path looks like `"NOTIFICATION.CLOSE_BUTTON"`
   */
  getValueFromPath(path) {
    let value = this.translationStrings;
    for (const segment of path.split(".")) {
      if (value[segment] !== void 0 && value[segment] !== null) {
        value = value[segment];
      } else {
        throw new Error(`no key ${segment} at ${path}`);
      }
    }
    return value;
  }
  /**
   * Helper method that returns an observable from the internal cache based on the path
   *
   * @param path looks like `"NOTIFICATION.CLOSE_BUTTON"`
   */
  getSubject(path) {
    try {
      const value = this.getValueFromPath(path);
      if (this.translations.has(path)) {
        return this.translations.get(path);
      }
      const translation = new BehaviorSubject(value);
      this.translations.set(path, translation);
      return translation;
    } catch (error) {
      console.error(error);
    }
  }
};
I18n.ɵfac = function I18n_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || I18n)();
};
I18n.ɵprov = ɵɵdefineInjectable({
  token: I18n,
  factory: I18n.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(I18n, [{
    type: Injectable
  }], null, null);
})();
var ReplacePipe = class {
  transform(value, variables) {
    return replace(value, variables);
  }
};
ReplacePipe.ɵfac = function ReplacePipe_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ReplacePipe)();
};
ReplacePipe.ɵpipe = ɵɵdefinePipe({
  name: "i18nReplace",
  type: ReplacePipe,
  pure: true,
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ReplacePipe, [{
    type: Pipe,
    args: [{
      name: "i18nReplace"
    }]
  }], null, null);
})();
function I18N_SERVICE_PROVIDER_FACTORY(parentService) {
  return parentService || new I18n();
}
var I18N_SERVICE_PROVIDER = {
  provide: I18n,
  deps: [[new Optional(), new SkipSelf(), I18n]],
  useFactory: I18N_SERVICE_PROVIDER_FACTORY
};
var I18nModule = class {
};
I18nModule.ɵfac = function I18nModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || I18nModule)();
};
I18nModule.ɵmod = ɵɵdefineNgModule({
  type: I18nModule,
  declarations: [ReplacePipe],
  exports: [ReplacePipe]
});
I18nModule.ɵinj = ɵɵdefineInjector({
  providers: [I18n, I18N_SERVICE_PROVIDER]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(I18nModule, [{
    type: NgModule,
    args: [{
      declarations: [ReplacePipe],
      exports: [ReplacePipe],
      providers: [I18n, I18N_SERVICE_PROVIDER]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-common.mjs
var tabbableSelector = "a[href], area[href], input:not([disabled]):not([tabindex='-1']), button:not([disabled]):not([tabindex='-1']),select:not([disabled]):not([tabindex='-1']), textarea:not([disabled]):not([tabindex='-1']), iframe, object, embed, *[tabindex]:not([tabindex='-1']), *[contenteditable=true]";
var tabbableSelectorIgnoreTabIndex = "a[href], area[href], input:not([disabled]), button:not([disabled]),select:not([disabled]), textarea:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable=true]";
function getFocusElementList(element, selector = tabbableSelector) {
  let elements = element.querySelectorAll(selector);
  return elements ? Array.prototype.filter.call(elements, (el) => isVisible(el)) : elements;
}
function isFocusInFirstItem(event, list) {
  if (list.length > 0) {
    return (event.target || event.srcElement) === list[0];
  }
  return false;
}
function isFocusInLastItem(event, list) {
  if (list.length > 0) {
    return (event.target || event.srcElement) === list[list.length - 1];
  }
  return false;
}
function isElementFocused(event, element) {
  return (event.target || event.srcElement) === element;
}
function focusFirstFocusableElement(list) {
  if (list.length > 0) {
    list[0].focus();
    return true;
  }
  return false;
}
function focusLastFocusableElement(list) {
  if (list.length > 0) {
    list[list.length - 1].focus();
    return true;
  }
  return false;
}
function isVisible(element) {
  return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);
}
function cycleTabs(event, element) {
  if (event.key === "Tab") {
    let list = getFocusElementList(element);
    let focusChanged = false;
    if (event.shiftKey) {
      if (isFocusInFirstItem(event, list) || isElementFocused(event, element)) {
        focusChanged = focusLastFocusableElement(list);
      }
    } else {
      if (isFocusInLastItem(event, list)) {
        focusChanged = focusFirstFocusableElement(list);
      }
    }
    if (focusChanged) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
}
function range(stop, start = 0, step = 1) {
  return Array(Math.ceil((stop - start) / step)).fill(0).map((x, i) => i * step + start);
}

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-placeholder.mjs
var _c02 = ["placeholder"];
var PlaceholderService = class {
  constructor() {
    this.viewContainerRef = null;
    this.viewContainerMap = /* @__PURE__ */ new Map();
  }
  /**
   * Used by `Placeholder` to register view-container reference.
   */
  registerViewContainerRef(vcRef, id) {
    if (id) {
      this.viewContainerMap.set(id, vcRef);
    } else {
      this.viewContainerRef = vcRef;
    }
  }
  /**
   * Creates and returns component in the view.
   */
  createComponent(component, injector, id, environment = void 0) {
    if (id) {
      if (!this.viewContainerMap.has(id)) {
        console.error(`No view container with id ${id} found`);
        return;
      }
      return this.viewContainerMap.get(id).createComponent(component, {
        index: this.viewContainerMap.size,
        injector
      });
    }
    if (!this.viewContainerRef) {
      console.error("No view container defined! Likely due to a missing `cds-placeholder`");
      return;
    }
    return this.viewContainerRef.createComponent(component, {
      index: this.viewContainerRef.length,
      injector,
      environmentInjector: environment
    });
  }
  destroyComponent(component) {
    component.destroy();
  }
  hasComponentRef(component, id) {
    if (id) {
      return !(this.viewContainerMap.get(id).indexOf(component.hostView) < 0);
    }
    return !(this.viewContainerRef.indexOf(component.hostView) < 0);
  }
  hasPlaceholderRef(id) {
    if (id) {
      return this.viewContainerMap.has(id);
    }
    return !!this.viewContainerRef;
  }
  appendElement(element, id) {
    if (id) {
      return this.viewContainerMap.get(id).element.nativeElement.appendChild(element);
    }
    return this.viewContainerRef.element.nativeElement.appendChild(element);
  }
  removeElement(element, id) {
    if (id) {
      return this.viewContainerMap.get(id).element.nativeElement.removeChild(element);
    }
    return this.viewContainerRef.element.nativeElement.removeChild(element);
  }
  hasElement(element, id) {
    if (id) {
      return this.viewContainerMap.get(id).element.nativeElement.contains(element);
    }
    return this.viewContainerRef.element.nativeElement.contains(element);
  }
};
PlaceholderService.ɵfac = function PlaceholderService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || PlaceholderService)();
};
PlaceholderService.ɵprov = ɵɵdefineInjectable({
  token: PlaceholderService,
  factory: PlaceholderService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlaceholderService, [{
    type: Injectable
  }], null, null);
})();
var Placeholder = class {
  /**
   * Creates an instance of `Placeholder`.
   */
  constructor(placeholderService) {
    this.placeholderService = placeholderService;
  }
  /**
   * Registers the components view with `PlaceholderService`
   */
  ngOnInit() {
    this.placeholderService.registerViewContainerRef(this.viewContainerRef);
  }
};
Placeholder.ɵfac = function Placeholder_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Placeholder)(ɵɵdirectiveInject(PlaceholderService));
};
Placeholder.ɵcmp = ɵɵdefineComponent({
  type: Placeholder,
  selectors: [["cds-placeholder"], ["ibm-placeholder"]],
  viewQuery: function Placeholder_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c02, 7, ViewContainerRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.viewContainerRef = _t.first);
    }
  },
  inputs: {
    id: "id"
  },
  standalone: false,
  decls: 2,
  vars: 0,
  consts: [["placeholder", ""]],
  template: function Placeholder_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelement(0, "div", null, 0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Placeholder, [{
    type: Component,
    args: [{
      selector: "cds-placeholder, ibm-placeholder",
      template: `<div #placeholder></div>`
    }]
  }], function() {
    return [{
      type: PlaceholderService
    }];
  }, {
    id: [{
      type: Input
    }],
    viewContainerRef: [{
      type: ViewChild,
      args: ["placeholder", {
        read: ViewContainerRef,
        static: true
      }]
    }]
  });
})();
function PLACEHOLDER_SERVICE_PROVIDER_FACTORY(parentService) {
  return parentService || new PlaceholderService();
}
var PLACEHOLDER_SERVICE_PROVIDER = {
  provide: PlaceholderService,
  deps: [[new Optional(), new SkipSelf(), PlaceholderService]],
  useFactory: PLACEHOLDER_SERVICE_PROVIDER_FACTORY
};
var PlaceholderModule = class {
};
PlaceholderModule.ɵfac = function PlaceholderModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || PlaceholderModule)();
};
PlaceholderModule.ɵmod = ɵɵdefineNgModule({
  type: PlaceholderModule,
  declarations: [Placeholder],
  imports: [CommonModule],
  exports: [Placeholder]
});
PlaceholderModule.ɵinj = ɵɵdefineInjector({
  providers: [PLACEHOLDER_SERVICE_PROVIDER],
  imports: [CommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlaceholderModule, [{
    type: NgModule,
    args: [{
      declarations: [Placeholder],
      exports: [Placeholder],
      providers: [PLACEHOLDER_SERVICE_PROVIDER],
      imports: [CommonModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-experimental.mjs
var ExperimentalService = class {
  constructor() {
    this.experiments = /* @__PURE__ */ new Map();
  }
  /**
   * Adds an experiment if it doesn't exist.
   */
  addExperiment(name, options = {
    enabled: false
  }) {
    if (!this.experiments.has(name)) {
      this.experiments.set(name, options);
    }
  }
  /**
   * Enables an experiment by name
   * @param name name of the experiment to enable
   */
  enableExperiment(name) {
    const experiment = this.getExperiment(name);
    experiment.enabled = true;
  }
  /**
   * Disables an experiment by name
   * @param name name of the experiment to disable
   */
  disableExperiment(name) {
    const experiment = this.getExperiment(name);
    experiment.enabled = false;
  }
  /**
   * Get the options for an experiment by name
   * @param name name of experiment to get
   */
  getExperiment(name) {
    if (!this.experiments.has(name)) {
      this.addExperiment(name);
      return this.getExperiment(name);
    }
    return this.experiments.get(name);
  }
  /**
   * Get an array of tuples representing an experiment and it's options
   */
  getExperiments() {
    return Array.from(this.experiments.entries());
  }
};
ExperimentalService.ɵfac = function ExperimentalService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ExperimentalService)();
};
ExperimentalService.ɵprov = ɵɵdefineInjectable({
  token: ExperimentalService,
  factory: ExperimentalService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExperimentalService, [{
    type: Injectable
  }], null, null);
})();
function EXPERIMENTAL_SERVICE_PROVIDER_FACTORY(parentService) {
  return parentService || new ExperimentalService();
}
var EXPERIMENTAL_SERVICE_PROVIDER = {
  provide: ExperimentalService,
  deps: [[new Optional(), new SkipSelf(), ExperimentalService]],
  useFactory: EXPERIMENTAL_SERVICE_PROVIDER_FACTORY
};
var ExperimentalModule = class {
};
ExperimentalModule.ɵfac = function ExperimentalModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ExperimentalModule)();
};
ExperimentalModule.ɵmod = ɵɵdefineNgModule({
  type: ExperimentalModule
});
ExperimentalModule.ɵinj = ɵɵdefineInjector({
  providers: [ExperimentalService, EXPERIMENTAL_SERVICE_PROVIDER]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExperimentalModule, [{
    type: NgModule,
    args: [{
      providers: [ExperimentalService, EXPERIMENTAL_SERVICE_PROVIDER]
    }]
  }], null, null);
})();

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return __spreadValues({
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }, padding);
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = (reference, floating, config2) => __async(void 0, null, function* () {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config2;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = yield platform2.isRTL == null ? void 0 : platform2.isRTL(floating);
  let rects = yield platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = yield fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = __spreadProps(__spreadValues({}, middlewareData), {
      [name]: __spreadValues(__spreadValues({}, middlewareData[name]), data)
    });
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? yield platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
});
function detectOverflow(state, options) {
  return __async(this, null, function* () {
    var _await$platform$isEle;
    if (options === void 0) {
      options = {};
    }
    const {
      x,
      y,
      platform: platform2,
      rects,
      elements,
      strategy
    } = state;
    const {
      boundary = "clippingAncestors",
      rootBoundary = "viewport",
      elementContext = "floating",
      altBoundary = false,
      padding = 0
    } = evaluate(options, state);
    const paddingObject = getPaddingObject(padding);
    const altContext = elementContext === "floating" ? "reference" : "floating";
    const element = elements[altBoundary ? altContext : elementContext];
    const clippingClientRect = rectToClientRect(yield platform2.getClippingRect({
      element: ((_await$platform$isEle = yield platform2.isElement == null ? void 0 : platform2.isElement(element)) != null ? _await$platform$isEle : true) ? element : element.contextElement || (yield platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
      boundary,
      rootBoundary,
      strategy
    }));
    const rect = elementContext === "floating" ? {
      x,
      y,
      width: rects.floating.width,
      height: rects.floating.height
    } : rects.reference;
    const offsetParent = yield platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating);
    const offsetScale = (yield platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? (yield platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
      x: 1,
      y: 1
    } : {
      x: 1,
      y: 1
    };
    const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? yield platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
      elements,
      rect,
      offsetParent,
      strategy
    }) : rect);
    return {
      top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
      bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
      left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
      right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
    };
  });
}
var arrow = (options) => ({
  name: "arrow",
  options,
  fn(state) {
    return __async(this, null, function* () {
      const {
        x,
        y,
        placement,
        rects,
        platform: platform2,
        elements,
        middlewareData
      } = state;
      const {
        element,
        padding = 0
      } = evaluate(options, state) || {};
      if (element == null) {
        return {};
      }
      const paddingObject = getPaddingObject(padding);
      const coords = {
        x,
        y
      };
      const axis = getAlignmentAxis(placement);
      const length = getAxisLength(axis);
      const arrowDimensions = yield platform2.getDimensions(element);
      const isYAxis = axis === "y";
      const minProp = isYAxis ? "top" : "left";
      const maxProp = isYAxis ? "bottom" : "right";
      const clientProp = isYAxis ? "clientHeight" : "clientWidth";
      const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
      const startDiff = coords[axis] - rects.reference[axis];
      const arrowOffsetParent = yield platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element);
      let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
      if (!clientSize || !(yield platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
        clientSize = elements.floating[clientProp] || rects.floating[length];
      }
      const centerToReference = endDiff / 2 - startDiff / 2;
      const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
      const minPadding = min(paddingObject[minProp], largestPossiblePadding);
      const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
      const min$1 = minPadding;
      const max2 = clientSize - arrowDimensions[length] - maxPadding;
      const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
      const offset3 = clamp(min$1, center, max2);
      const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset3 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
      const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
      return {
        [axis]: coords[axis] + alignmentOffset,
        data: __spreadValues({
          [axis]: offset3,
          centerOffset: center - offset3 - alignmentOffset
        }, shouldAddOffset && {
          alignmentOffset
        }),
        reset: shouldAddOffset
      };
    });
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    fn(state) {
      return __async(this, null, function* () {
        var _middlewareData$arrow, _middlewareData$flip;
        const {
          placement,
          middlewareData,
          rects,
          initialPlacement,
          platform: platform2,
          elements
        } = state;
        const _a3 = evaluate(options, state), {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = true,
          fallbackPlacements: specifiedFallbackPlacements,
          fallbackStrategy = "bestFit",
          fallbackAxisSideDirection = "none",
          flipAlignment = true
        } = _a3, detectOverflowOptions = __objRest(_a3, [
          "mainAxis",
          "crossAxis",
          "fallbackPlacements",
          "fallbackStrategy",
          "fallbackAxisSideDirection",
          "flipAlignment"
        ]);
        if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
          return {};
        }
        const side = getSide(placement);
        const initialSideAxis = getSideAxis(initialPlacement);
        const isBasePlacement = getSide(initialPlacement) === initialPlacement;
        const rtl = yield platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating);
        const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
        const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
        if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
          fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
        }
        const placements2 = [initialPlacement, ...fallbackPlacements];
        const overflow = yield detectOverflow(state, detectOverflowOptions);
        const overflows = [];
        let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
        if (checkMainAxis) {
          overflows.push(overflow[side]);
        }
        if (checkCrossAxis) {
          const sides2 = getAlignmentSides(placement, rects, rtl);
          overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
        }
        overflowsData = [...overflowsData, {
          placement,
          overflows
        }];
        if (!overflows.every((side2) => side2 <= 0)) {
          var _middlewareData$flip2, _overflowsData$filter;
          const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
          const nextPlacement = placements2[nextIndex];
          if (nextPlacement) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
          let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
          if (!resetPlacement) {
            switch (fallbackStrategy) {
              case "bestFit": {
                var _overflowsData$filter2;
                const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                  if (hasFallbackAxisSideDirection) {
                    const currentSideAxis = getSideAxis(d.placement);
                    return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                    // reading directions favoring greater width.
                    currentSideAxis === "y";
                  }
                  return true;
                }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
                if (placement2) {
                  resetPlacement = placement2;
                }
                break;
              }
              case "initialPlacement":
                resetPlacement = initialPlacement;
                break;
            }
          }
          if (placement !== resetPlacement) {
            return {
              reset: {
                placement: resetPlacement
              }
            };
          }
        }
        return {};
      });
    }
  };
};
function convertValueToCoords(state, options) {
  return __async(this, null, function* () {
    const {
      placement,
      platform: platform2,
      elements
    } = state;
    const rtl = yield platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating);
    const side = getSide(placement);
    const alignment = getAlignment(placement);
    const isVertical = getSideAxis(placement) === "y";
    const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
    const crossAxisMulti = rtl && isVertical ? -1 : 1;
    const rawValue = evaluate(options, state);
    let {
      mainAxis,
      crossAxis,
      alignmentAxis
    } = typeof rawValue === "number" ? {
      mainAxis: rawValue,
      crossAxis: 0,
      alignmentAxis: null
    } : {
      mainAxis: rawValue.mainAxis || 0,
      crossAxis: rawValue.crossAxis || 0,
      alignmentAxis: rawValue.alignmentAxis
    };
    if (alignment && typeof alignmentAxis === "number") {
      crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
    }
    return isVertical ? {
      x: crossAxis * crossAxisMulti,
      y: mainAxis * mainAxisMulti
    } : {
      x: mainAxis * mainAxisMulti,
      y: crossAxis * crossAxisMulti
    };
  });
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    fn(state) {
      return __async(this, null, function* () {
        var _middlewareData$offse, _middlewareData$arrow;
        const {
          x,
          y,
          placement,
          middlewareData
        } = state;
        const diffCoords = yield convertValueToCoords(state, options);
        if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
          return {};
        }
        return {
          x: x + diffCoords.x,
          y: y + diffCoords.y,
          data: __spreadProps(__spreadValues({}, diffCoords), {
            placement
          })
        };
      });
    }
  };
};

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle2(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = function(data) {
  return __async(this, null, function* () {
    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
    const getDimensionsFn = this.getDimensions;
    const floatingDimensions = yield getDimensionsFn(data.floating);
    return {
      reference: getRectRelativeToOffsetParent(data.reference, yield getOffsetParentFn(data.floating), data.strategy),
      floating: {
        x: 0,
        y: 0,
        width: floatingDimensions.width,
        height: floatingDimensions.height
      }
    };
  });
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a, b) {
  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root2 = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root2.clientWidth - (left + width));
    const insetBottom = floor(root2.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, __spreadProps(__spreadValues({}, options), {
        // Handle <iframe>s
        root: root2.ownerDocument
      }));
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var flip2 = flip;
var arrow2 = arrow;
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = __spreadValues({
    platform
  }, options);
  const platformWithCache = __spreadProps(__spreadValues({}, mergedOptions.platform), {
    _c: cache
  });
  return computePosition(reference, floating, __spreadProps(__spreadValues({}, mergedOptions), {
    platform: platformWithCache
  }));
};

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-popover.mjs
var _c03 = ["content"];
var _c12 = ["*"];
function PopoverContent_span_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 4);
  }
}
function PopoverContent_span_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 5);
  }
}
var PopoverContainer = class {
  constructor(elementRef, ngZone, renderer, changeDetectorRef) {
    this.elementRef = elementRef;
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.changeDetectorRef = changeDetectorRef;
    this._align = "bottom";
    this.alignmentClassPrefix = "cds--popover--";
    this.onClose = new EventEmitter();
    this.onOpen = new EventEmitter();
    this.isOpenChange = new EventEmitter();
    this.caret = true;
    this.dropShadow = true;
    this.highContrast = false;
    this.autoAlign = false;
    this.containerClass = true;
    this.isOpen = false;
  }
  /**
   * Set alignment of popover
   * As of v5, `oldPlacements` are now deprecated in favor of Placements
   *
   * When `autoAlign` is set to `true`, alignment may change for best placement
   */
  set align(alignment) {
    if (!alignment) {
      return;
    }
    const previousAlignment = this._align;
    switch (alignment) {
      case "top-left":
        this._align = "top-start";
        break;
      case "top-right":
        this._align = "top-end";
        break;
      case "bottom-left":
        this._align = "bottom-start";
        break;
      case "bottom-right":
        this._align = "bottom-end";
        break;
      case "left-top":
        this._align = "left-start";
        break;
      case "left-bottom":
        this._align = "left-end";
        break;
      case "right-top":
        this._align = "right-start";
        break;
      case "right-bottom":
        this._align = "right-end";
        break;
      default:
        this._align = alignment;
        break;
    }
    this.updateAlignmentClass(this._align, previousAlignment);
  }
  /**
   * Handles emitting open/close event
   * @param open - Is the popover container open
   * @param event - Event
   */
  handleChange(open2, event) {
    if (this.isOpen !== open2 && event) {
      this.isOpenChange.emit(open2);
    }
    if (open2) {
      if (event) {
        this.onOpen.emit(event);
      }
      if (this.autoAlign) {
        if (this.caretRef) {
          const computedStyle = getComputedStyle(this.caretRef);
          const offset3 = computedStyle.getPropertyValue("--cds-popover-offset");
          const height = computedStyle.getPropertyValue("--cds-popover-caret-height");
          this.caretOffset = (offset3?.includes("px") ? Number(offset3.split("px", 1)[0]) : Number(offset3.split("rem", 1)[0]) * 16) || 10;
          this.caretHeight = (height?.includes("px") ? Number(height.split("px", 1)[0]) : Number(height.split("rem", 1)[0]) * 16) || 6;
        }
        if (this.elementRef.nativeElement && this.popoverContentRef) {
          this.unmountFloatingElement = autoUpdate(this.elementRef.nativeElement, this.popoverContentRef, this.recomputePosition.bind(this));
        }
      }
    } else {
      this.cleanUp();
      if (event) {
        this.onClose.emit(event);
      }
    }
    this.isOpen = open2;
    this.changeDetectorRef.markForCheck();
  }
  roundByDPR(value) {
    const dpr = window.devicePixelRatio || 1;
    return Math.round(value * dpr) / dpr;
  }
  /**
   * Compute position of tooltip when autoAlign is enabled
   */
  recomputePosition() {
    this.ngZone.runOutsideAngular(() => __async(this, null, function* () {
      const {
        x,
        y,
        placement,
        middlewareData
      } = yield computePosition2(this.elementRef.nativeElement, this.popoverContentRef, {
        placement: this._align,
        strategy: "fixed",
        middleware: [offset2(this.caretOffset), flip2({
          fallbackAxisSideDirection: "start"
        }), arrow2({
          element: this.caretRef
        })]
      });
      const previousAlignment = this._align;
      this._align = placement;
      this.updateAlignmentClass(this._align, previousAlignment);
      Object.assign(this.popoverContentRef.style, {
        position: "fixed",
        top: "0",
        left: "0",
        // Using transform instead of top/left position to improve performance
        transform: `translate(${this.roundByDPR(x)}px,${this.roundByDPR(y)}px)`
      });
      if (middlewareData.arrow) {
        const {
          x: arrowX,
          y: arrowY
        } = middlewareData.arrow;
        const staticSide = {
          top: "bottom",
          right: "left",
          bottom: "top",
          left: "right"
        }[placement.split("-")[0]];
        this.caretRef.style.left = arrowX != null ? `${arrowX}px` : "";
        this.caretRef.style.top = arrowY != null ? `${arrowY}px` : "";
        this.caretRef.style.right = "";
        this.caretRef.style.bottom = "";
        if (staticSide) {
          this.caretRef.style[staticSide] = `${-this.caretHeight}px`;
        }
      }
    }));
  }
  /**
   * Close the popover and reopen it with updated values without emitting an event
   * @param changes
   */
  ngOnChanges(changes) {
    const originalState = this.isOpen;
    this.handleChange(false);
    if (changes.autoAlign && !changes.autoAlign.firstChange) {
      this.popoverContentRef = this.elementRef.nativeElement.querySelector(".cds--popover-content");
      this.popoverContentRef.setAttribute("style", "");
      this.caretRef = this.elementRef.nativeElement.querySelector("span.cds--popover-caret");
    }
    this.handleChange(originalState);
  }
  /**
   * Handle initialization of element
   */
  ngAfterViewInit() {
    this.initializeReferences();
  }
  initializeReferences() {
    this.updateAlignmentClass(this._align);
    this.popoverContentRef = this.elementRef.nativeElement.querySelector(".cds--popover-content");
    this.caretRef = this.elementRef.nativeElement.querySelector("span.cds--popover-caret");
    this.handleChange(this.isOpen);
  }
  /**
   * Clean up
   */
  ngOnDestroy() {
    this.cleanUp();
  }
  /**
   * Clean up `autoUpdate` if auto alignment is enabled
   */
  cleanUp() {
    if (this.unmountFloatingElement) {
      this.unmountFloatingElement();
    }
    this.unmountFloatingElement = void 0;
  }
  /**
   * Replace existing previous alignment class with new
   * @param previousAlignment
   */
  updateAlignmentClass(newAlignment, previousAlignment) {
    if (this.elementRef.nativeElement && previousAlignment !== newAlignment) {
      const regexp = new RegExp("right|top|left|bottom");
      this.elementRef.nativeElement.classList.forEach((className) => {
        if (regexp.test(className)) {
          this.renderer.removeClass(this.elementRef.nativeElement, `${className}`);
        }
      });
      this.renderer.addClass(this.elementRef.nativeElement, `${this.alignmentClassPrefix}${newAlignment}`);
    }
  }
};
PopoverContainer.ɵfac = function PopoverContainer_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || PopoverContainer)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef));
};
PopoverContainer.ɵdir = ɵɵdefineDirective({
  type: PopoverContainer,
  selectors: [["", "cdsPopover", ""], ["", "ibmPopover", ""]],
  hostVars: 12,
  hostBindings: function PopoverContainer_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--popover--caret", ctx.caret)("cds--popover--drop-shadow", ctx.dropShadow)("cds--popover--high-contrast", ctx.highContrast)("cds--popover--auto-align", ctx.autoAlign)("cds--popover-container", ctx.containerClass)("cds--popover--open", ctx.isOpen);
    }
  },
  inputs: {
    align: "align",
    caret: "caret",
    dropShadow: "dropShadow",
    highContrast: "highContrast",
    autoAlign: "autoAlign",
    isOpen: "isOpen"
  },
  outputs: {
    onClose: "onClose",
    onOpen: "onOpen",
    isOpenChange: "isOpenChange"
  },
  standalone: false,
  features: [ɵɵNgOnChangesFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PopoverContainer, [{
    type: Directive,
    args: [{
      selector: "[cdsPopover], [ibmPopover]"
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    align: [{
      type: Input
    }],
    onClose: [{
      type: Output
    }],
    onOpen: [{
      type: Output
    }],
    isOpenChange: [{
      type: Output
    }],
    caret: [{
      type: HostBinding,
      args: ["class.cds--popover--caret"]
    }, {
      type: Input
    }],
    dropShadow: [{
      type: HostBinding,
      args: ["class.cds--popover--drop-shadow"]
    }, {
      type: Input
    }],
    highContrast: [{
      type: HostBinding,
      args: ["class.cds--popover--high-contrast"]
    }, {
      type: Input
    }],
    autoAlign: [{
      type: HostBinding,
      args: ["class.cds--popover--auto-align"]
    }, {
      type: Input
    }],
    containerClass: [{
      type: HostBinding,
      args: ["class.cds--popover-container"]
    }],
    isOpen: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.cds--popover--open"]
    }]
  });
})();
var PopoverContent = class {
  constructor(changeDetectorRef) {
    this.changeDetectorRef = changeDetectorRef;
    this.popoverClass = true;
    this.autoAlign = false;
  }
  ngAfterViewInit() {
    if (this.popoverContent) {
      this.autoAlign = !!this.popoverContent.nativeElement.closest(".cds--popover--auto-align");
      this.changeDetectorRef.detectChanges();
    }
  }
};
PopoverContent.ɵfac = function PopoverContent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || PopoverContent)(ɵɵdirectiveInject(ChangeDetectorRef));
};
PopoverContent.ɵcmp = ɵɵdefineComponent({
  type: PopoverContent,
  selectors: [["cds-popover-content"], ["ibm-popover-content"]],
  viewQuery: function PopoverContent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c03, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.popoverContent = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function PopoverContent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--popover", ctx.popoverClass);
    }
  },
  standalone: false,
  ngContentSelectors: _c12,
  decls: 6,
  vars: 2,
  consts: [["content", ""], [1, "cds--popover-content"], ["class", "cds--popover-caret cds--popover--auto-align", 4, "ngIf"], ["class", "cds--popover-caret", 4, "ngIf"], [1, "cds--popover-caret", "cds--popover--auto-align"], [1, "cds--popover-caret"]],
  template: function PopoverContent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "span", 1, 0)(2, "div");
      ɵɵprojection(3);
      ɵɵelementEnd();
      ɵɵtemplate(4, PopoverContent_span_4_Template, 1, 0, "span", 2);
      ɵɵelementEnd();
      ɵɵtemplate(5, PopoverContent_span_5_Template, 1, 0, "span", 3);
    }
    if (rf & 2) {
      ɵɵadvance(4);
      ɵɵproperty("ngIf", ctx.autoAlign);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.autoAlign);
    }
  },
  dependencies: [NgIf],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PopoverContent, [{
    type: Component,
    args: [{
      selector: "cds-popover-content, ibm-popover-content",
      template: `
		<span class="cds--popover-content" #content>
			<div>
				<ng-content></ng-content>
			</div>
			<span *ngIf="autoAlign" class="cds--popover-caret cds--popover--auto-align"></span>
		</span>
		<span *ngIf="!autoAlign" class="cds--popover-caret"></span>
	`
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }];
  }, {
    popoverClass: [{
      type: HostBinding,
      args: ["class.cds--popover"]
    }],
    popoverContent: [{
      type: ViewChild,
      args: ["content"]
    }]
  });
})();
var PopoverModule = class {
};
PopoverModule.ɵfac = function PopoverModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || PopoverModule)();
};
PopoverModule.ɵmod = ɵɵdefineNgModule({
  type: PopoverModule,
  declarations: [PopoverContainer, PopoverContent],
  imports: [CommonModule],
  exports: [PopoverContainer, PopoverContent]
});
PopoverModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PopoverModule, [{
    type: NgModule,
    args: [{
      declarations: [PopoverContainer, PopoverContent],
      exports: [PopoverContainer, PopoverContent],
      imports: [CommonModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-tooltip.mjs
var _c04 = ["contentWrapper"];
var _c13 = ["*"];
var _c22 = (a0) => ({
  $implicit: a0
});
function Tooltip_span_3_ng_container_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.description);
  }
}
function Tooltip_span_3_ng_container_1_3_ng_template_0_Template(rf, ctx) {
}
function Tooltip_span_3_ng_container_1_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, Tooltip_span_3_ng_container_1_3_ng_template_0_Template, 0, 0, "ng-template", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.description)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c22, ctx_r0.templateContext));
  }
}
function Tooltip_span_3_ng_container_1_span_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 8);
  }
}
function Tooltip_span_3_ng_container_1_span_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 9);
  }
}
function Tooltip_span_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "span", 4);
    ɵɵtemplate(2, Tooltip_span_3_ng_container_1_ng_container_2_Template, 2, 1, "ng-container", 3)(3, Tooltip_span_3_ng_container_1_3_Template, 1, 4, null, 3)(4, Tooltip_span_3_ng_container_1_span_4_Template, 1, 0, "span", 5);
    ɵɵelementEnd();
    ɵɵtemplate(5, Tooltip_span_3_ng_container_1_span_5_Template, 1, 0, "span", 6);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.description));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.description));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.autoAlign);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.autoAlign);
  }
}
function Tooltip_span_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 2);
    ɵɵtemplate(1, Tooltip_span_3_ng_container_1_Template, 6, 4, "ng-container", 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("id", ctx_r0.id);
    ɵɵattribute("aria-hidden", !ctx_r0.isOpen);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.disabled);
  }
}
function TooltipDefinition_span_2_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.description);
  }
}
function TooltipDefinition_span_2_3_ng_template_0_Template(rf, ctx) {
}
function TooltipDefinition_span_2_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TooltipDefinition_span_2_3_ng_template_0_Template, 0, 0, "ng-template", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.description)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c22, ctx_r0.templateContext));
  }
}
function TooltipDefinition_span_2_span_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 8);
  }
}
function TooltipDefinition_span_2_span_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 9);
  }
}
function TooltipDefinition_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 2)(1, "span", 3);
    ɵɵtemplate(2, TooltipDefinition_span_2_ng_container_2_Template, 2, 1, "ng-container", 4)(3, TooltipDefinition_span_2_3_Template, 1, 4, null, 4)(4, TooltipDefinition_span_2_span_4_Template, 1, 0, "span", 5);
    ɵɵelementEnd();
    ɵɵtemplate(5, TooltipDefinition_span_2_span_5_Template, 1, 0, "span", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("id", ctx_r0.id);
    ɵɵattribute("aria-hidden", ctx_r0.isOpen);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.description));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.description));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.autoAlign);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.autoAlign);
  }
}
var DEFAULT_TOOLTIP_CONFIG = {
  align: "bottom",
  caret: true,
  dropShadow: true,
  highContrast: true,
  isOpen: false,
  enterDelayMs: 100,
  leaveDelayMs: 300
};
var Tooltip = class _Tooltip extends PopoverContainer {
  constructor(elementRef, ngZone, renderer, changeDetectorRef) {
    super(elementRef, ngZone, renderer, changeDetectorRef);
    this.elementRef = elementRef;
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.changeDetectorRef = changeDetectorRef;
    this.tooltipClass = true;
    this.id = `tooltip-${_Tooltip.tooltipCount++}`;
    this.enterDelayMs = 100;
    this.leaveDelayMs = 300;
    this.disabled = false;
    this.highContrast = true;
    this.dropShadow = false;
  }
  mouseenter(event) {
    clearTimeout(this.timeoutId);
    this.timeoutId = setTimeout(() => {
      this.handleChange(true, event);
    }, this.enterDelayMs);
  }
  mouseleave(event) {
    clearTimeout(this.timeoutId);
    this.timeoutId = setTimeout(() => {
      this.handleChange(false, event);
    }, this.leaveDelayMs);
  }
  hostkeys(event) {
    if (open && event.key === "Escape") {
      event.stopPropagation();
      this.handleChange(false, event);
    }
  }
  // We are not focusing on entire popover, only the trigger
  handleFocus(event) {
    this.handleChange(true, event);
  }
  handleFocusOut(event) {
    this.handleChange(false, event);
  }
  isTemplate(value) {
    return value instanceof TemplateRef;
  }
  /**
   * Close the popover and reopen it with updated values without emitting an event
   * @param changes
   */
  ngOnChanges(changes) {
    const originalState = this.isOpen;
    this.handleChange(false);
    if (changes.autoAlign && !changes.autoAlign.firstChange || changes.disabled && !changes.disabled.firstChange && !changes.disabled.currentValue || changes.description) {
      this.changeDetectorRef.detectChanges();
      this.popoverContentRef = this.elementRef.nativeElement.querySelector(".cds--popover-content");
      this.popoverContentRef?.setAttribute("style", "");
      this.caretRef = this.elementRef.nativeElement.querySelector("span.cds--popover-caret");
    }
    this.handleChange(originalState);
  }
  /**
   * Check for any changes in the projected content & apply accessibility attribute if needed
   */
  ngAfterContentChecked() {
    if (this.wrapper) {
      const buttonElement = this.wrapper.nativeElement.querySelector("button");
      if (buttonElement && !buttonElement.getAttribute("aria-labelledby")) {
        buttonElement.setAttribute("aria-labelledby", this.id);
      }
    }
  }
};
Tooltip.tooltipCount = 0;
Tooltip.ɵfac = function Tooltip_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Tooltip)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef));
};
Tooltip.ɵcmp = ɵɵdefineComponent({
  type: Tooltip,
  selectors: [["cds-tooltip"], ["ibm-tooltip"]],
  viewQuery: function Tooltip_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c04, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.wrapper = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function Tooltip_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("mouseenter", function Tooltip_mouseenter_HostBindingHandler($event) {
        return ctx.mouseenter($event);
      })("mouseleave", function Tooltip_mouseleave_HostBindingHandler($event) {
        return ctx.mouseleave($event);
      })("keyup", function Tooltip_keyup_HostBindingHandler($event) {
        return ctx.hostkeys($event);
      })("focusin", function Tooltip_focusin_HostBindingHandler($event) {
        return ctx.handleFocus($event);
      })("focusout", function Tooltip_focusout_HostBindingHandler($event) {
        return ctx.handleFocusOut($event);
      });
    }
    if (rf & 2) {
      ɵɵclassProp("cds--tooltip", ctx.tooltipClass);
    }
  },
  inputs: {
    id: "id",
    enterDelayMs: "enterDelayMs",
    leaveDelayMs: "leaveDelayMs",
    disabled: "disabled",
    description: "description",
    templateContext: "templateContext"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
  ngContentSelectors: _c13,
  decls: 4,
  vars: 1,
  consts: [["contentWrapper", ""], ["class", "cds--popover", "role", "tooltip", 3, "id", 4, "ngIf"], ["role", "tooltip", 1, "cds--popover", 3, "id"], [4, "ngIf"], [1, "cds--popover-content", "cds--tooltip-content"], ["class", "cds--popover-caret cds--popover--auto-align", 4, "ngIf"], ["class", "cds--popover-caret", 4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "cds--popover-caret", "cds--popover--auto-align"], [1, "cds--popover-caret"]],
  template: function Tooltip_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "span", null, 0);
      ɵɵprojection(2);
      ɵɵelementEnd();
      ɵɵtemplate(3, Tooltip_span_3_Template, 2, 3, "span", 1);
    }
    if (rf & 2) {
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.description);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet],
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Tooltip, [{
    type: Component,
    args: [{
      selector: "cds-tooltip, ibm-tooltip",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
		<span #contentWrapper>
			<ng-content></ng-content>
		</span>
		<span
			*ngIf="description"
			class="cds--popover"
			[id]="id"
			[attr.aria-hidden]="!isOpen"
			role="tooltip">
			<ng-container *ngIf="!disabled">
				<span class="cds--popover-content cds--tooltip-content">
					<ng-container *ngIf="!isTemplate(description)">{{description}}</ng-container>
					<ng-template *ngIf="isTemplate(description)" [ngTemplateOutlet]="description" [ngTemplateOutletContext]="{ $implicit: templateContext }"></ng-template>
					<span *ngIf="autoAlign" class="cds--popover-caret cds--popover--auto-align"></span>
				</span>
				<span *ngIf="!autoAlign" class="cds--popover-caret"></span>
			</ng-container>
		</span>
	`
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    tooltipClass: [{
      type: HostBinding,
      args: ["class.cds--tooltip"]
    }],
    id: [{
      type: Input
    }],
    enterDelayMs: [{
      type: Input
    }],
    leaveDelayMs: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    description: [{
      type: Input
    }],
    templateContext: [{
      type: Input
    }],
    wrapper: [{
      type: ViewChild,
      args: ["contentWrapper"]
    }],
    mouseenter: [{
      type: HostListener,
      args: ["mouseenter", ["$event"]]
    }],
    mouseleave: [{
      type: HostListener,
      args: ["mouseleave", ["$event"]]
    }],
    hostkeys: [{
      type: HostListener,
      args: ["keyup", ["$event"]]
    }],
    handleFocus: [{
      type: HostListener,
      args: ["focusin", ["$event"]]
    }],
    handleFocusOut: [{
      type: HostListener,
      args: ["focusout", ["$event"]]
    }]
  });
})();
var TooltipDefinition = class _TooltipDefinition extends PopoverContainer {
  constructor(elementRef, ngZone, renderer, changeDetectorRef) {
    super(elementRef, ngZone, renderer, changeDetectorRef);
    this.elementRef = elementRef;
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.changeDetectorRef = changeDetectorRef;
    this.id = `tooltip-definition-${_TooltipDefinition.tooltipCount++}`;
    this.highContrast = true;
    this.dropShadow = false;
  }
  onBlur(event) {
    this.handleChange(false, event);
  }
  onClick(event) {
    this.handleChange(!this.isOpen, event);
  }
  hostkeys(event) {
    if (this.isOpen && event.key === "Escape") {
      event.stopPropagation();
      this.handleChange(false, event);
    }
  }
  mouseleave(event) {
    this.handleChange(false, event);
  }
  isTemplate(value) {
    return value instanceof TemplateRef;
  }
};
TooltipDefinition.tooltipCount = 0;
TooltipDefinition.ɵfac = function TooltipDefinition_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TooltipDefinition)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef));
};
TooltipDefinition.ɵcmp = ɵɵdefineComponent({
  type: TooltipDefinition,
  selectors: [["cds-tooltip-definition"], ["ibm-tooltip-definition"]],
  hostBindings: function TooltipDefinition_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("keyup", function TooltipDefinition_keyup_HostBindingHandler($event) {
        return ctx.hostkeys($event);
      })("mouseleave", function TooltipDefinition_mouseleave_HostBindingHandler($event) {
        return ctx.mouseleave($event);
      });
    }
  },
  inputs: {
    id: "id",
    description: "description",
    templateContext: "templateContext"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c13,
  decls: 3,
  vars: 3,
  consts: [["type", "button", 1, "cds--definition-term", 3, "blur", "click"], ["class", "cds--popover", "role", "tooltip", 3, "id", 4, "ngIf"], ["role", "tooltip", 1, "cds--popover", 3, "id"], [1, "cds--popover-content", "cds--definition-tooltip"], [4, "ngIf"], ["class", "cds--popover-caret cds--popover--auto-align", 4, "ngIf"], ["class", "cds--popover-caret", 4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "cds--popover-caret", "cds--popover--auto-align"], [1, "cds--popover-caret"]],
  template: function TooltipDefinition_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "button", 0);
      ɵɵlistener("blur", function TooltipDefinition_Template_button_blur_0_listener($event) {
        return ctx.onBlur($event);
      })("click", function TooltipDefinition_Template_button_click_0_listener($event) {
        return ctx.onClick($event);
      });
      ɵɵprojection(1);
      ɵɵelementEnd();
      ɵɵtemplate(2, TooltipDefinition_span_2_Template, 6, 6, "span", 1);
    }
    if (rf & 2) {
      ɵɵattribute("aria-controls", ctx.id)("aria-expanded", ctx.isOpen);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.description);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet],
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TooltipDefinition, [{
    type: Component,
    args: [{
      selector: "cds-tooltip-definition, ibm-tooltip-definition",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
		<button
			class="cds--definition-term"
			[attr.aria-controls]="id"
			[attr.aria-expanded]="isOpen"
			(blur)="onBlur($event)"
			(click)="onClick($event)"
			type="button">
			<ng-content></ng-content>
		</button>
		<span
			*ngIf="description"
			class="cds--popover"
			[id]="id"
			[attr.aria-hidden]="isOpen"
			role="tooltip">
			<span class="cds--popover-content cds--definition-tooltip">
				<ng-container *ngIf="!isTemplate(description)">{{description}}</ng-container>
				<ng-template *ngIf="isTemplate(description)" [ngTemplateOutlet]="description" [ngTemplateOutletContext]="{ $implicit: templateContext }"></ng-template>
				<span *ngIf="autoAlign" class="cds--popover-caret cds--popover--auto-align"></span>
			</span>
			<span *ngIf="!autoAlign" class="cds--popover-caret"></span>
		</span>
	`
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    id: [{
      type: Input
    }],
    description: [{
      type: Input
    }],
    templateContext: [{
      type: Input
    }],
    hostkeys: [{
      type: HostListener,
      args: ["keyup", ["$event"]]
    }],
    mouseleave: [{
      type: HostListener,
      args: ["mouseleave", ["$event"]]
    }]
  });
})();
var TooltipModule = class {
};
TooltipModule.ɵfac = function TooltipModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TooltipModule)();
};
TooltipModule.ɵmod = ɵɵdefineNgModule({
  type: TooltipModule,
  declarations: [Tooltip, TooltipDefinition],
  imports: [CommonModule, PopoverModule],
  exports: [Tooltip, TooltipDefinition]
});
TooltipModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, PopoverModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TooltipModule, [{
    type: NgModule,
    args: [{
      declarations: [Tooltip, TooltipDefinition],
      exports: [Tooltip, TooltipDefinition],
      imports: [CommonModule, PopoverModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-button.mjs
var _c05 = ["*"];
var _c14 = ["button"];
var Button = class {
  constructor() {
    this.cdsButton = "primary";
    this.skeleton = false;
    this.iconOnly = false;
    this.isExpressive = false;
    this.baseClass = true;
  }
  /**
   * @deprecated as of v5 - Use `cdsButton` input property instead
   */
  set ibmButton(type) {
    this.cdsButton = type;
  }
  get primaryButton() {
    return this.cdsButton === "primary" || !this.cdsButton;
  }
  get secondaryButton() {
    return this.cdsButton === "secondary";
  }
  get tertiaryButton() {
    return this.cdsButton === "tertiary";
  }
  get ghostButton() {
    return this.cdsButton === "ghost";
  }
  get dangerButton() {
    return this.cdsButton === "danger" || this.cdsButton === "danger--primary";
  }
  get dangerTertiary() {
    return this.cdsButton === "danger--tertiary";
  }
  get dangerGhost() {
    return this.cdsButton === "danger--ghost";
  }
  /**
   * @todo remove `cds--btn--${size}` classes in v12
   */
  get smallSize() {
    return this.size === "sm" && !this.isExpressive;
  }
  get mediumSize() {
    return this.size === "md" && !this.isExpressive;
  }
  get largeSize() {
    return this.size === "lg";
  }
  get extraLargeSize() {
    return this.size === "xl";
  }
  get twoExtraLargeSize() {
    return this.size === "2xl";
  }
  // Size classes
  get smallLayoutSize() {
    return this.size === "sm" && !this.isExpressive;
  }
  get mediumLayoutSize() {
    return this.size === "md" && !this.isExpressive;
  }
  get largeLayoutSize() {
    return this.size === "lg";
  }
  get extraLargeLayoutSize() {
    return this.size === "xl";
  }
  get twoExtraLargeLayoutSize() {
    return this.size === "2xl";
  }
};
Button.ɵfac = function Button_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Button)();
};
Button.ɵdir = ɵɵdefineDirective({
  type: Button,
  selectors: [["", "cdsButton", ""], ["", "ibmButton", ""]],
  hostVars: 42,
  hostBindings: function Button_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--skeleton", ctx.skeleton)("cds--btn--icon-only", ctx.iconOnly)("cds--btn--expressive", ctx.isExpressive)("cds--btn", ctx.baseClass)("cds--btn--primary", ctx.primaryButton)("cds--btn--secondary", ctx.secondaryButton)("cds--btn--tertiary", ctx.tertiaryButton)("cds--btn--ghost", ctx.ghostButton)("cds--btn--danger", ctx.dangerButton)("cds--btn--danger--tertiary", ctx.dangerTertiary)("cds--btn--danger--ghost", ctx.dangerGhost)("cds--btn--sm", ctx.smallSize)("cds--btn--md", ctx.mediumSize)("cds--btn--lg", ctx.largeSize)("cds--btn--xl", ctx.extraLargeSize)("cds--btn--2xl", ctx.twoExtraLargeSize)("cds--layout--size-sm", ctx.smallLayoutSize)("cds--layout--size-md", ctx.mediumLayoutSize)("cds--layout--size-lg", ctx.largeLayoutSize)("cds--layout--size-xl", ctx.extraLargeLayoutSize)("cds--layout--size-2xl", ctx.twoExtraLargeLayoutSize);
    }
  },
  inputs: {
    ibmButton: "ibmButton",
    cdsButton: "cdsButton",
    size: "size",
    skeleton: "skeleton",
    iconOnly: "iconOnly",
    isExpressive: "isExpressive"
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Button, [{
    type: Directive,
    args: [{
      selector: "[cdsButton], [ibmButton]"
    }]
  }], null, {
    ibmButton: [{
      type: Input
    }],
    cdsButton: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    skeleton: [{
      type: HostBinding,
      args: ["class.cds--skeleton"]
    }, {
      type: Input
    }],
    iconOnly: [{
      type: HostBinding,
      args: ["class.cds--btn--icon-only"]
    }, {
      type: Input
    }],
    isExpressive: [{
      type: HostBinding,
      args: ["class.cds--btn--expressive"]
    }, {
      type: Input
    }],
    baseClass: [{
      type: HostBinding,
      args: ["class.cds--btn"]
    }],
    primaryButton: [{
      type: HostBinding,
      args: ["class.cds--btn--primary"]
    }],
    secondaryButton: [{
      type: HostBinding,
      args: ["class.cds--btn--secondary"]
    }],
    tertiaryButton: [{
      type: HostBinding,
      args: ["class.cds--btn--tertiary"]
    }],
    ghostButton: [{
      type: HostBinding,
      args: ["class.cds--btn--ghost"]
    }],
    dangerButton: [{
      type: HostBinding,
      args: ["class.cds--btn--danger"]
    }],
    dangerTertiary: [{
      type: HostBinding,
      args: ["class.cds--btn--danger--tertiary"]
    }],
    dangerGhost: [{
      type: HostBinding,
      args: ["class.cds--btn--danger--ghost"]
    }],
    smallSize: [{
      type: HostBinding,
      args: ["class.cds--btn--sm"]
    }],
    mediumSize: [{
      type: HostBinding,
      args: ["class.cds--btn--md"]
    }],
    largeSize: [{
      type: HostBinding,
      args: ["class.cds--btn--lg"]
    }],
    extraLargeSize: [{
      type: HostBinding,
      args: ["class.cds--btn--xl"]
    }],
    twoExtraLargeSize: [{
      type: HostBinding,
      args: ["class.cds--btn--2xl"]
    }],
    smallLayoutSize: [{
      type: HostBinding,
      args: ["class.cds--layout--size-sm"]
    }],
    mediumLayoutSize: [{
      type: HostBinding,
      args: ["class.cds--layout--size-md"]
    }],
    largeLayoutSize: [{
      type: HostBinding,
      args: ["class.cds--layout--size-lg"]
    }],
    extraLargeLayoutSize: [{
      type: HostBinding,
      args: ["class.cds--layout--size-xl"]
    }],
    twoExtraLargeLayoutSize: [{
      type: HostBinding,
      args: ["class.cds--layout--size-2xl"]
    }]
  });
})();
var ButtonSet = class {
  constructor() {
    this.buttonSetClass = true;
  }
};
ButtonSet.ɵfac = function ButtonSet_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ButtonSet)();
};
ButtonSet.ɵcmp = ɵɵdefineComponent({
  type: ButtonSet,
  selectors: [["cds-button-set"], ["ibm-button-set"]],
  hostVars: 2,
  hostBindings: function ButtonSet_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--btn-set", ctx.buttonSetClass);
    }
  },
  standalone: false,
  ngContentSelectors: _c05,
  decls: 1,
  vars: 0,
  template: function ButtonSet_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ButtonSet, [{
    type: Component,
    args: [{
      selector: "cds-button-set, ibm-button-set",
      template: "<ng-content></ng-content>"
    }]
  }], null, {
    buttonSetClass: [{
      type: HostBinding,
      args: ["class.cds--btn-set"]
    }]
  });
})();
var BaseIconButton = class {
  constructor() {
    this.caret = true;
    this.dropShadow = true;
    this.highContrast = true;
    this.isOpen = false;
    this.align = "bottom";
    this.autoAlign = false;
    this.enterDelayMs = 100;
    this.leaveDelayMs = 300;
  }
};
BaseIconButton.ɵfac = function BaseIconButton_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || BaseIconButton)();
};
BaseIconButton.ɵcmp = ɵɵdefineComponent({
  type: BaseIconButton,
  selectors: [["ng-component"]],
  inputs: {
    caret: "caret",
    dropShadow: "dropShadow",
    highContrast: "highContrast",
    isOpen: "isOpen",
    align: "align",
    autoAlign: "autoAlign",
    enterDelayMs: "enterDelayMs",
    leaveDelayMs: "leaveDelayMs"
  },
  standalone: false,
  decls: 0,
  vars: 0,
  template: function BaseIconButton_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseIconButton, [{
    type: Component,
    args: [{
      template: ""
    }]
  }], null, {
    caret: [{
      type: Input
    }],
    dropShadow: [{
      type: Input
    }],
    highContrast: [{
      type: Input
    }],
    isOpen: [{
      type: Input
    }],
    align: [{
      type: Input
    }],
    autoAlign: [{
      type: Input
    }],
    enterDelayMs: [{
      type: Input
    }],
    leaveDelayMs: [{
      type: Input
    }]
  });
})();
var IconButton = class _IconButton extends BaseIconButton {
  constructor(renderer) {
    super();
    this.renderer = renderer;
    this.buttonId = `icon-btn-${_IconButton.iconButtonCounter++}`;
    this.kind = "primary";
    this.size = "lg";
    this.type = "button";
    this.isExpressive = false;
    this.disabled = false;
    this.showTooltipWhenDisabled = false;
    this.click = new EventEmitter();
    this.focus = new EventEmitter();
    this.blur = new EventEmitter();
    this.tooltipClick = new EventEmitter();
    this.classList = {};
    this.attributeList = {};
  }
  /**
   * Pass global carbon classes to icon button
   */
  set buttonNgClass(obj) {
    this.classList = Object.assign({
      "cds--btn--disabled": this.disabled
    }, obj);
  }
  get buttonNgClass() {
    return this.classList;
  }
  /**
   * @param obj: { [key: string]: string
   * User can pass additional button attributes if component property does not already exist
   * Key is the attribute name & value is the attribute value for the button
   */
  set buttonAttributes(obj) {
    if (this.button) {
      Object.keys(this.attributeList).forEach((key) => {
        this.renderer.removeAttribute(this.button.nativeElement, key);
      });
      Object.keys(obj).forEach((key) => {
        this.renderer.setAttribute(this.button.nativeElement, key, obj[key]);
      });
    }
    this.attributeList = obj;
  }
  get buttonAttributes() {
    return this.buttonAttributes;
  }
  ngAfterViewInit() {
    this.buttonAttributes = this.attributeList;
  }
  /**
   * Stop propogation of click event
   * Else double fires (click) event
   */
  emitClickEvent(event, element = "button") {
    event.preventDefault();
    event.stopPropagation();
    if (element === "tooltip") {
      this.tooltipClick.emit(event);
      return;
    }
    this.click.emit(event);
  }
};
IconButton.iconButtonCounter = 0;
IconButton.ɵfac = function IconButton_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || IconButton)(ɵɵdirectiveInject(Renderer2));
};
IconButton.ɵcmp = ɵɵdefineComponent({
  type: IconButton,
  selectors: [["cds-icon-button"], ["ibm-icon-button"]],
  viewQuery: function IconButton_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c14, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.button = _t.first);
    }
  },
  inputs: {
    buttonNgClass: "buttonNgClass",
    buttonAttributes: "buttonAttributes",
    buttonId: "buttonId",
    kind: "kind",
    size: "size",
    type: "type",
    isExpressive: "isExpressive",
    disabled: "disabled",
    description: "description",
    showTooltipWhenDisabled: "showTooltipWhenDisabled"
  },
  outputs: {
    click: "click",
    focus: "focus",
    blur: "blur",
    tooltipClick: "tooltipClick"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c05,
  decls: 4,
  vars: 18,
  consts: [["button", ""], [1, "cds--icon-tooltip", 3, "click", "description", "disabled", "caret", "dropShadow", "highContrast", "isOpen", "align", "autoAlign", "enterDelayMs", "leaveDelayMs"], [3, "click", "focus", "blur", "id", "disabled", "iconOnly", "ngClass", "cdsButton", "size", "isExpressive"]],
  template: function IconButton_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵprojectionDef();
      ɵɵelementStart(0, "cds-tooltip", 1);
      ɵɵlistener("click", function IconButton_Template_cds_tooltip_click_0_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.emitClickEvent($event, "tooltip"));
      });
      ɵɵelementStart(1, "button", 2, 0);
      ɵɵlistener("click", function IconButton_Template_button_click_1_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.emitClickEvent($event));
      })("focus", function IconButton_Template_button_focus_1_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.focus.emit($event));
      })("blur", function IconButton_Template_button_blur_1_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.blur.emit($event));
      });
      ɵɵprojection(3);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵproperty("description", ctx.description)("disabled", ctx.showTooltipWhenDisabled ? false : ctx.disabled)("caret", ctx.caret)("dropShadow", ctx.dropShadow)("highContrast", ctx.highContrast)("isOpen", ctx.isOpen)("align", ctx.align)("autoAlign", ctx.autoAlign)("enterDelayMs", ctx.enterDelayMs)("leaveDelayMs", ctx.leaveDelayMs);
      ɵɵadvance();
      ɵɵproperty("id", ctx.buttonId)("disabled", ctx.disabled)("iconOnly", true)("ngClass", ctx.buttonNgClass)("cdsButton", ctx.kind)("size", ctx.size)("isExpressive", ctx.isExpressive);
      ɵɵattribute("type", ctx.type);
    }
  },
  dependencies: [NgClass, Tooltip, Button],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IconButton, [{
    type: Component,
    args: [{
      selector: "cds-icon-button, ibm-icon-button",
      template: `
	<cds-tooltip
		class="cds--icon-tooltip"
		[description]="description"
		[disabled]="showTooltipWhenDisabled ? false : disabled"
		[caret]="caret"
		[dropShadow]="dropShadow"
		[highContrast]="highContrast"
		[isOpen]="isOpen"
		[align]="align"
		[autoAlign]="autoAlign"
		[enterDelayMs]="enterDelayMs"
		[leaveDelayMs]="leaveDelayMs"
		(click)="emitClickEvent($event, 'tooltip')">
		<button
			#button
			[id]="buttonId"
			[disabled]="disabled"
			[attr.type]="type"
			[iconOnly]="true"
			[ngClass]="buttonNgClass"
			[cdsButton]="kind"
			[size]="size"
			[isExpressive]="isExpressive"
			(click)="emitClickEvent($event)"
			(focus)="focus.emit($event)"
			(blur)="blur.emit($event)">
			<ng-content></ng-content>
		</button>
	</cds-tooltip>
	`
    }]
  }], function() {
    return [{
      type: Renderer2
    }];
  }, {
    buttonNgClass: [{
      type: Input
    }],
    buttonAttributes: [{
      type: Input
    }],
    button: [{
      type: ViewChild,
      args: ["button"]
    }],
    buttonId: [{
      type: Input
    }],
    kind: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    isExpressive: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    description: [{
      type: Input
    }],
    showTooltipWhenDisabled: [{
      type: Input
    }],
    click: [{
      type: Output
    }],
    focus: [{
      type: Output
    }],
    blur: [{
      type: Output
    }],
    tooltipClick: [{
      type: Output
    }]
  });
})();
var ButtonModule = class {
};
ButtonModule.ɵfac = function ButtonModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ButtonModule)();
};
ButtonModule.ɵmod = ɵɵdefineNgModule({
  type: ButtonModule,
  declarations: [Button, ButtonSet, BaseIconButton, IconButton],
  imports: [CommonModule, TooltipModule],
  exports: [Button, ButtonSet, IconButton]
});
ButtonModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, TooltipModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ButtonModule, [{
    type: NgModule,
    args: [{
      declarations: [Button, ButtonSet, BaseIconButton, IconButton],
      exports: [Button, ButtonSet, IconButton],
      imports: [CommonModule, TooltipModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-dialog.mjs
var _c06 = ["dialog"];
var _c15 = (a0) => ({
  "cds--overflow-menu--flip": a0
});
var _c23 = (a0) => ({
  overflowMenu: a0
});
function OverflowMenuPane_ng_template_2_Template(rf, ctx) {
}
function OverflowMenuCustomPane_ng_template_2_Template(rf, ctx) {
}
var _c3 = ["*"];
var _c4 = (a0) => ({
  "cds--overflow-menu--open": a0
});
function OverflowMenu_2_ng_template_0_Template(rf, ctx) {
}
function OverflowMenu_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, OverflowMenu_2_ng_template_0_Template, 0, 0, "ng-template", 5);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.customTrigger);
  }
}
function OverflowMenu_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
function OverflowMenu_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 6);
  }
}
function OverflowMenuOption_button_0_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function OverflowMenuOption_button_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 3);
    ɵɵlistener("focus", function OverflowMenuOption_button_0_Template_button_focus_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onFocus());
    })("blur", function OverflowMenuOption_button_0_Template_button_blur_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onBlur());
    })("click", function OverflowMenuOption_button_0_Template_button_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onClick());
    });
    ɵɵtemplate(1, OverflowMenuOption_button_0_ng_container_1_Template, 1, 0, "ng-container", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const tempOutlet_r3 = ɵɵreference(3);
    ɵɵclassMapInterpolate1("cds--overflow-menu-options__btn ", ctx_r1.innerClass, "");
    ɵɵproperty("tabindex", ctx_r1.tabIndex)("disabled", ctx_r1.disabled);
    ɵɵattribute("title", ctx_r1.title);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", tempOutlet_r3);
  }
}
function OverflowMenuOption_a_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function OverflowMenuOption_a_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 5);
    ɵɵlistener("focus", function OverflowMenuOption_a_1_Template_a_focus_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onFocus());
    })("blur", function OverflowMenuOption_a_1_Template_a_blur_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onBlur());
    })("click", function OverflowMenuOption_a_1_Template_a_click_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onClick());
    });
    ɵɵtemplate(1, OverflowMenuOption_a_1_ng_container_1_Template, 1, 0, "ng-container", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const tempOutlet_r3 = ɵɵreference(3);
    ɵɵclassMapInterpolate1("cds--overflow-menu-options__btn ", ctx_r1.innerClass, "");
    ɵɵproperty("tabindex", ctx_r1.tabIndex)("href", ctx_r1.href, ɵɵsanitizeUrl);
    ɵɵattribute("disabled", ctx_r1.disabled)("target", ctx_r1.target)("rel", ctx_r1.rel)("title", ctx_r1.title);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", tempOutlet_r3);
  }
}
function OverflowMenuOption_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 6);
    ɵɵprojection(1);
    ɵɵelementEnd();
  }
}
var CloseReasons;
(function(CloseReasons2) {
  CloseReasons2[CloseReasons2["destroyed"] = 0] = "destroyed";
  CloseReasons2[CloseReasons2["programmatic"] = 1] = "programmatic";
  CloseReasons2[CloseReasons2["interaction"] = 2] = "interaction";
  CloseReasons2[CloseReasons2["hidden"] = 3] = "hidden";
})(CloseReasons || (CloseReasons = {}));
var DialogService = class _DialogService {
  /**
   * Creates an instance of `DialogService`.
   */
  constructor(injector, placeholderService) {
    this.injector = injector;
    this.placeholderService = placeholderService;
  }
  /**
   * Closes all known `Dialog`s. Does not focus any previous elements, since we can't know which would be correct
   */
  static closeAll() {
    _DialogService.dialogRefs.forEach((ref) => ref.instance.doClose({
      reason: CloseReasons.programmatic
    }));
    _DialogService.dialogRefs.clear();
  }
  /**
   * If `dialogRef` is defined, the Dialog is already open. If
   * `dialogRef` is undefined, we create the `Dialog` component and reference to it.
   * A subscription is created to track if the `Dialog` should close.
   *
   * @param viewContainer a `ViewContainerRef` to instantiate the component against.
   * May be `null` if an `cds-placeholder` exists and `dialogConfig.appendInline` is false
   * @param dialogConfig the `DialogConfig` for the component
   */
  open(viewContainer, dialogConfig, component) {
    if (!component) {
      return;
    }
    let dialogRef;
    if (dialogConfig.appendInline) {
      dialogRef = viewContainer.createComponent(component, {
        index: 0,
        injector: this.injector
      });
    } else if (!this.placeholderService.hasPlaceholderRef()) {
      dialogRef = viewContainer.createComponent(component, {
        index: 0,
        injector: this.injector
      });
      if (dialogRef) {
        setTimeout(() => {
          window.document.querySelector("body").appendChild(dialogRef.location.nativeElement);
        });
      }
    } else {
      dialogRef = this.placeholderService.createComponent(component, this.injector);
    }
    _DialogService.dialogRefs.add(dialogRef);
    dialogConfig["previouslyFocusedElement"] = document.activeElement;
    dialogRef.instance.dialogConfig = dialogConfig;
    dialogRef.instance.elementRef.nativeElement.focus();
    return dialogRef;
  }
  /**
   * On close of `Dialog` item, sets focus back to previous item, unsets
   * the current `dialogRef` item. Unsubscribes to the event of `Dialog` close.
   *
   * @param dialogRef the dialogRef to close
   */
  close(dialogRef) {
    if (!dialogRef) {
      return;
    }
    const elementToFocus = dialogRef.instance.dialogConfig["previouslyFocusedElement"];
    dialogRef.destroy();
    if (_DialogService.dialogRefs.has(dialogRef)) {
      _DialogService.dialogRefs.delete(dialogRef);
    }
    if (!dialogRef.location.nativeElement.querySelectorAll(tabbableSelector)) {
      elementToFocus.focus();
    }
  }
  /**
   * Fix for safari hijacking clicks.
   *
   * Runs on `ngOnInit` of every dialog. Ensures we don't have multiple listeners
   * because having many of them could degrade performance in certain cases (and is
   * not necessary for our use case)
   *
   * This is an internally used function, can change at any point (even get removed)
   * and changes to it won't be considered a breaking change. Use at your own risk.
   */
  singletonClickListen() {
    if (!_DialogService.listeningForBodyClicks) {
      document.body.firstElementChild.addEventListener("click", () => null, true);
      _DialogService.listeningForBodyClicks = true;
    }
  }
};
DialogService.listeningForBodyClicks = false;
DialogService.dialogRefs = /* @__PURE__ */ new Set();
DialogService.ɵfac = function DialogService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || DialogService)(ɵɵinject(Injector), ɵɵinject(PlaceholderService));
};
DialogService.ɵprov = ɵɵdefineInjectable({
  token: DialogService,
  factory: DialogService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DialogService, [{
    type: Injectable
  }], function() {
    return [{
      type: Injector
    }, {
      type: PlaceholderService
    }];
  }, null);
})();
var Dialog = class {
  /**
   * Creates an instance of `Dialog`.
   * @param elementRef
   * @param elementService
   */
  constructor(elementRef, elementService, animationFrameService = null) {
    this.elementRef = elementRef;
    this.elementService = elementService;
    this.animationFrameService = animationFrameService;
    this.close = new EventEmitter();
    this.data = {};
    this.visibilitySubscription = new Subscription();
    this.animationFrameSubscription = new Subscription();
    this.addGap = {
      "left": (pos) => position.addOffset(pos, 0, -this.dialogConfig.gap),
      "right": (pos) => position.addOffset(pos, 0, this.dialogConfig.gap),
      "top": (pos) => position.addOffset(pos, -this.dialogConfig.gap),
      "bottom": (pos) => position.addOffset(pos, this.dialogConfig.gap),
      "left-bottom": (pos) => position.addOffset(pos, 0, -this.dialogConfig.gap),
      "right-bottom": (pos) => position.addOffset(pos, 0, this.dialogConfig.gap)
    };
    this.placements = {};
  }
  /**
   * Initialize the `Dialog`, set the placement and gap, and add a `Subscription` to resize events.
   */
  ngOnInit() {
    this.placement = this.dialogConfig.placement.split(",")[0];
    this.data = this.dialogConfig.data;
    this.onDialogInit();
  }
  /**
   * After the DOM is ready, focus is set and dialog is placed
   * in respect to the parent element.
   */
  ngAfterViewInit() {
    const dialogElement = this.dialog.nativeElement;
    if (this.dialogConfig.wrapperClass) {
      for (const extraClass of this.dialogConfig.wrapperClass.split(" ")) {
        dialogElement.classList.add(extraClass);
      }
    }
    if (getFocusElementList(this.dialog.nativeElement).length > 0) {
      dialogElement.focus();
    }
    const parentElement = this.dialogConfig.parentRef.nativeElement;
    if (this.animationFrameService) {
      this.animationFrameSubscription = this.animationFrameService.tick.subscribe(() => {
        this.placeDialog();
      });
    }
    if (this.dialogConfig.closeWhenHidden) {
      this.visibilitySubscription = this.elementService.visibility(parentElement, parentElement).subscribe((value) => {
        this.placeDialog();
        if (!value.visible) {
          this.doClose({
            reason: CloseReasons.hidden
          });
        }
      });
    }
    this.placeDialog();
    setTimeout(() => this.afterDialogViewInit());
  }
  /**
   * Empty method to be overridden by consuming classes to run any additional initialization code.
   */
  onDialogInit() {
  }
  /**
   * Empty method to be overridden by consuming classes to run any additional initialization code after the view is available.
   * NOTE: this does _not_ guarantee the dialog will be positioned, simply that it will exist in the DOM
   */
  afterDialogViewInit() {
  }
  /**
   * Uses the position service to position the `Dialog` in screen space
   */
  placeDialog() {
    const positionService = new utils_position_default(this.placements);
    const findPosition = (reference, target, placement) => {
      let pos2;
      if (this.dialogConfig.appendInline) {
        pos2 = this.addGap[placement](positionService.findRelative(reference, target, placement));
      } else {
        pos2 = this.addGap[placement](positionService.findAbsolute(reference, target, placement));
      }
      if (this.dialogConfig.offset) {
        pos2.top = pos2.top + this.dialogConfig.offset.y;
        pos2.left = pos2.left + this.dialogConfig.offset.x;
      }
      return pos2;
    };
    let parentEl = this.dialogConfig.parentRef.nativeElement;
    let el = this.dialog.nativeElement;
    let dialogPlacement = this.placement;
    const placements2 = this.dialogConfig.placement.split(",");
    dialogPlacement = positionService.findBestPlacement(parentEl, el, placements2);
    const pos = findPosition(parentEl, el, dialogPlacement);
    positionService.setElement(el, pos);
    setTimeout(() => {
      this.placement = dialogPlacement;
    });
  }
  /**
   * Sets up a KeyboardEvent to close `Dialog` with Escape key.
   * @param event
   */
  escapeClose(event) {
    switch (event.key) {
      case "Escape": {
        event.stopImmediatePropagation();
        this.doClose({
          reason: CloseReasons.interaction,
          target: event.target
        });
        break;
      }
      case "Tab": {
        cycleTabs(event, this.elementRef.nativeElement);
        break;
      }
    }
  }
  /**
   * Sets up a event Listener to close `Dialog` if click event occurs outside
   * `Dialog` object.
   * @param event
   */
  clickClose(event) {
    if (!this.elementRef.nativeElement.contains(event.target) && !this.dialogConfig.parentRef.nativeElement.contains(event.target)) {
      this.doClose({
        reason: CloseReasons.interaction,
        target: event.target
      });
    }
  }
  /**
   * Closes `Dialog` object by emitting the close event upwards to parents.
   */
  doClose(meta = {
    reason: CloseReasons.interaction
  }) {
    this.close.emit(meta);
  }
  /**
   * At destruction of component, `Dialog` unsubscribes from all the subscriptions.
   */
  ngOnDestroy() {
    this.visibilitySubscription.unsubscribe();
    if (this.animationFrameSubscription) {
      this.animationFrameSubscription.unsubscribe();
    }
  }
};
Dialog.ɵfac = function Dialog_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Dialog)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ElementService), ɵɵdirectiveInject(AnimationFrameService, 8));
};
Dialog.ɵcmp = ɵɵdefineComponent({
  type: Dialog,
  selectors: [["cds-dialog"], ["ibm-dialog"]],
  viewQuery: function Dialog_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c06, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dialog = _t.first);
    }
  },
  hostBindings: function Dialog_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("keydown", function Dialog_keydown_HostBindingHandler($event) {
        return ctx.escapeClose($event);
      })("click", function Dialog_click_HostBindingHandler($event) {
        return ctx.clickClose($event);
      }, false, ɵɵresolveDocument);
    }
  },
  inputs: {
    dialogConfig: "dialogConfig"
  },
  outputs: {
    close: "close"
  },
  standalone: false,
  decls: 0,
  vars: 0,
  template: function Dialog_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Dialog, [{
    type: Component,
    args: [{
      selector: "cds-dialog, ibm-dialog",
      template: ""
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: ElementService
    }, {
      type: AnimationFrameService,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    close: [{
      type: Output
    }],
    dialogConfig: [{
      type: Input
    }],
    dialog: [{
      type: ViewChild,
      args: ["dialog"]
    }],
    escapeClose: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }],
    clickClose: [{
      type: HostListener,
      args: ["document:click", ["$event"]]
    }]
  });
})();
var DialogDirective = class _DialogDirective {
  /**
   * Creates an instance of DialogDirective.
   * @param elementRef
   * @param viewContainerRef
   * @param dialogService
   * @param eventService
   */
  constructor(elementRef, viewContainerRef, dialogService, eventService) {
    this.elementRef = elementRef;
    this.viewContainerRef = viewContainerRef;
    this.dialogService = dialogService;
    this.eventService = eventService;
    this.title = "";
    this.trigger = "click";
    this.closeTrigger = "mouseleave";
    this.placement = "left";
    this.gap = 0;
    this.appendInline = false;
    this.data = {};
    this.isOpen = false;
    this.disabled = false;
    this.onClose = new EventEmitter();
    this.onOpen = new EventEmitter();
    this.isOpenChange = new EventEmitter();
    this.role = "button";
    this.hasPopup = true;
    this.subscriptions = [];
  }
  /**
   * @deprecated as of v5, use `cdsDialog` instead
   * Dialog body content.
   */
  set ibmDialog(body) {
    this.cdsDialog = body;
  }
  get ariaOwns() {
    return this.isOpen ? this.dialogConfig.compID : null;
  }
  ngOnChanges(changes) {
    this.dialogConfig = {
      title: this.title,
      content: this.cdsDialog,
      placement: this.placement,
      parentRef: this.elementRef,
      gap: this.gap,
      trigger: this.trigger,
      closeTrigger: this.closeTrigger,
      shouldClose: this.shouldClose || (() => true),
      appendInline: this.appendInline,
      wrapperClass: this.wrapperClass,
      data: this.data,
      offset: this.offset,
      disabled: this.disabled
    };
    if (changes.isOpen) {
      if (changes.isOpen.currentValue) {
        this.open();
      } else if (!changes.isOpen.firstChange) {
        this.close({
          reason: CloseReasons.programmatic
        });
      }
    }
    this.onDialogChanges(changes);
    this.updateConfig();
  }
  /**
   * Sets the config object and binds events for hovering or clicking before
   * running code from child class.
   */
  ngOnInit() {
    this.dialogService.singletonClickListen();
    const element = this.elementRef.nativeElement;
    this.subscriptions.push(fromEvent(element, "keydown").subscribe((event) => {
      if (event.target === this.dialogConfig.parentRef.nativeElement && (event.key === "Tab" || event.key === "Tab" && event.shiftKey) || event.key === "Escape") {
        this.close({
          reason: CloseReasons.interaction,
          target: event.target
        });
      }
    }));
    if (this.trigger === "hover" || this.trigger === "mouseenter") {
      this.subscriptions.push(fromEvent(element, "mouseenter").subscribe(() => this.open()), fromEvent(element, this.closeTrigger).subscribe((event) => {
        this.close({
          reason: CloseReasons.interaction,
          target: event.target
        });
      }), fromEvent(element, "focus").subscribe(() => this.open()), fromEvent(element, "blur").subscribe((event) => {
        this.close({
          reason: CloseReasons.interaction,
          target: event.target
        });
      }));
    } else {
      this.subscriptions.push(fromEvent(element, "click").subscribe((event) => {
        this.toggle({
          reason: CloseReasons.interaction,
          target: event.target
        });
      }), fromEvent(element, "keydown").subscribe((event) => {
        if (event.key === "Enter" || event.key === " ") {
          setTimeout(() => {
            this.open();
          });
        }
      }));
    }
    _DialogDirective.dialogCounter++;
    this.dialogConfig.compID = "dialog-" + _DialogDirective.dialogCounter;
    this.onDialogInit();
    this.updateConfig();
  }
  /**
   * When the host dies, kill the popover.
   * - Useful for use in a modal or similar.
   */
  ngOnDestroy() {
    this.close({
      reason: CloseReasons.destroyed
    });
    this.subscriptions.forEach((subscription) => subscription.unsubscribe());
  }
  /**
   * Helper method to call dialogService 'open'.
   * - Enforce accessibility by updating an aria attr for nativeElement.
   */
  open(component) {
    if (this.dialogRef || this.disabled) {
      return;
    }
    this.dialogRef = this.dialogService.open(this.viewContainerRef, this.dialogConfig, component);
    this.isOpen = true;
    this.onOpen.emit();
    this.isOpenChange.emit(true);
    const subscription = this.dialogRef.instance.close.subscribe((meta) => {
      if (!this.dialogRef) {
        return;
      }
      if (this.dialogConfig.shouldClose && this.dialogConfig.shouldClose(meta)) {
        this.dialogService.close(this.dialogRef);
        this.dialogRef = null;
        this.isOpen = false;
        this.onClose.emit();
        this.isOpenChange.emit(false);
        subscription.unsubscribe();
      }
    });
    return this.dialogRef;
  }
  /**
   * Helper method to toggle the open state of the dialog
   */
  toggle(meta = {
    reason: CloseReasons.interaction
  }) {
    if (!this.isOpen) {
      this.open();
    } else {
      this.close(meta);
    }
  }
  /**
   * Helper method to close the dialogRef.
   */
  close(meta = {
    reason: CloseReasons.interaction
  }) {
    if (this.dialogRef) {
      this.dialogRef.instance.doClose(meta);
    }
  }
  /**
   * Empty method for child classes to override and specify additional init steps.
   * Run after DialogDirective completes it's ngOnInit.
   */
  onDialogInit() {
  }
  /**
   * Empty method for child to override and specify additional on changes steps.
   * run after DialogDirective completes it's ngOnChanges.
   */
  onDialogChanges(_changes) {
  }
  updateConfig() {
  }
};
DialogDirective.dialogCounter = 0;
DialogDirective.ɵfac = function DialogDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || DialogDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(DialogService), ɵɵdirectiveInject(EventService));
};
DialogDirective.ɵdir = ɵɵdefineDirective({
  type: DialogDirective,
  selectors: [["", "cdsDialog", ""], ["", "ibmDialog", ""]],
  hostVars: 4,
  hostBindings: function DialogDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("aria-expanded", ctx.isOpen)("role", ctx.role)("aria-haspopup", ctx.hasPopup)("aria-owns", ctx.ariaOwns);
    }
  },
  inputs: {
    title: "title",
    ibmDialog: "ibmDialog",
    cdsDialog: "cdsDialog",
    trigger: "trigger",
    closeTrigger: "closeTrigger",
    placement: "placement",
    offset: "offset",
    wrapperClass: "wrapperClass",
    gap: "gap",
    appendInline: "appendInline",
    data: "data",
    isOpen: "isOpen",
    disabled: "disabled",
    shouldClose: "shouldClose"
  },
  outputs: {
    onClose: "onClose",
    onOpen: "onOpen",
    isOpenChange: "isOpenChange"
  },
  exportAs: ["dialog"],
  standalone: false,
  features: [ɵɵProvidersFeature([DialogService]), ɵɵNgOnChangesFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DialogDirective, [{
    type: Directive,
    args: [{
      selector: "[cdsDialog], [ibmDialog]",
      exportAs: "dialog",
      providers: [DialogService]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: ViewContainerRef
    }, {
      type: DialogService
    }, {
      type: EventService
    }];
  }, {
    title: [{
      type: Input
    }],
    ibmDialog: [{
      type: Input
    }],
    cdsDialog: [{
      type: Input
    }],
    trigger: [{
      type: Input
    }],
    closeTrigger: [{
      type: Input
    }],
    placement: [{
      type: Input
    }],
    offset: [{
      type: Input
    }],
    wrapperClass: [{
      type: Input
    }],
    gap: [{
      type: Input
    }],
    appendInline: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    isOpen: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.aria-expanded"]
    }],
    disabled: [{
      type: Input
    }],
    shouldClose: [{
      type: Input
    }],
    onClose: [{
      type: Output
    }],
    onOpen: [{
      type: Output
    }],
    isOpenChange: [{
      type: Output
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    hasPopup: [{
      type: HostBinding,
      args: ["attr.aria-haspopup"]
    }],
    ariaOwns: [{
      type: HostBinding,
      args: ["attr.aria-owns"]
    }]
  });
})();
var OverflowMenuPane = class extends Dialog {
  constructor(elementRef, i18n, experimental, animationFrameService = null, elementService = null) {
    super(elementRef, elementService, animationFrameService);
    this.elementRef = elementRef;
    this.i18n = i18n;
    this.experimental = experimental;
    this.animationFrameService = animationFrameService;
    this.elementService = elementService;
  }
  onDialogInit() {
    const positionOverflowMenu = (pos) => {
      let offset3;
      const closestRel = closestAttr("position", ["relative", "fixed", "absolute"], this.elementRef.nativeElement);
      const topFix = closestRel ? closestRel.getBoundingClientRect().top * -1 : 0;
      const leftFix = closestRel ? closestRel.getBoundingClientRect().left * -1 : 0;
      offset3 = Math.round(this.dialog.nativeElement.offsetWidth / 2) - 20;
      if (this.dialogConfig.flip) {
        return position.addOffset(pos, topFix, -offset3 + leftFix);
      }
      return position.addOffset(pos, topFix, offset3 + leftFix);
    };
    this.addGap["bottom"] = positionOverflowMenu;
    this.addGap["top"] = positionOverflowMenu;
    if (!this.dialogConfig.menuLabel) {
      this.dialogConfig.menuLabel = this.i18n.get().OVERFLOW_MENU.OVERFLOW;
    }
  }
  hostkeys(event) {
    const listItems = this.listItems();
    switch (event.key) {
      case "ArrowDown":
        event.preventDefault();
        if (!isFocusInLastItem(event, listItems)) {
          const index = listItems.findIndex((item) => item === event.target);
          listItems[index + 1].focus();
        } else {
          listItems[0].focus();
        }
        break;
      case "ArrowUp":
        event.preventDefault();
        if (!isFocusInFirstItem(event, listItems)) {
          const index = listItems.findIndex((item) => item === event.target);
          listItems[index - 1].focus();
        } else {
          listItems[listItems.length - 1].focus();
        }
        break;
      case "Home":
        event.preventDefault();
        listItems[0].focus();
        break;
      case "End":
        event.preventDefault();
        listItems[listItems.length - 1].focus();
        break;
      case "Escape":
      case "Tab":
        event.stopImmediatePropagation();
        this.doClose({
          reason: CloseReasons.interaction,
          target: event.target
        });
        break;
      default:
        break;
    }
  }
  onClose(event) {
    this.doClose({
      reason: CloseReasons.interaction,
      target: event.target
    });
  }
  afterDialogViewInit() {
    const focusElementList = this.listItems();
    focusElementList.forEach((button) => {
      if (button.getAttribute("tabindex") === null) {
        button.tabIndex = -1;
      }
    });
    if (focusElementList[0]) {
      focusElementList[0].tabIndex = 0;
      focusElementList[0].focus();
    }
  }
  listItems() {
    const selector = ".cds--overflow-menu-options__option:not([disabled]) .cds--overflow-menu-options__btn";
    return Array.from(this.elementRef.nativeElement.querySelectorAll(selector));
  }
};
OverflowMenuPane.ɵfac = function OverflowMenuPane_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || OverflowMenuPane)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(I18n), ɵɵdirectiveInject(ExperimentalService), ɵɵdirectiveInject(AnimationFrameService, 8), ɵɵdirectiveInject(ElementService, 8));
};
OverflowMenuPane.ɵcmp = ɵɵdefineComponent({
  type: OverflowMenuPane,
  selectors: [["cds-overflow-menu-pane"], ["ibm-overflow-menu-pane"]],
  hostBindings: function OverflowMenuPane_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("keydown", function OverflowMenuPane_keydown_HostBindingHandler($event) {
        return ctx.hostkeys($event);
      });
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature],
  decls: 3,
  vars: 11,
  consts: [["dialog", ""], ["role", "menu", 1, "cds--overflow-menu-options", "cds--overflow-menu-options--open", 3, "click", "ngClass"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
  template: function OverflowMenuPane_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵelementStart(0, "ul", 1, 0);
      ɵɵlistener("click", function OverflowMenuPane_Template_ul_click_0_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onClose($event));
      });
      ɵɵtemplate(2, OverflowMenuPane_ng_template_2_Template, 0, 0, "ng-template", 2);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngClass", ɵɵpureFunction1(7, _c15, ctx.dialogConfig.flip));
      ɵɵattribute("id", ctx.dialogConfig.compID)("aria-label", ctx.dialogConfig.menuLabel)("data-floating-menu-direction", ctx.placement ? ctx.placement : null)("aria-label", ctx.dialogConfig.menuLabel);
      ɵɵadvance(2);
      ɵɵproperty("ngTemplateOutlet", ctx.dialogConfig.content)("ngTemplateOutletContext", ɵɵpureFunction1(9, _c23, ctx));
    }
  },
  dependencies: [NgClass, NgTemplateOutlet],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OverflowMenuPane, [{
    type: Component,
    args: [{
      selector: "cds-overflow-menu-pane, ibm-overflow-menu-pane",
      template: `
		<ul
			[attr.id]="dialogConfig.compID"
			[attr.aria-label]="dialogConfig.menuLabel"
			[attr.data-floating-menu-direction]="placement ? placement : null"
			[ngClass]="{'cds--overflow-menu--flip': dialogConfig.flip}"
			role="menu"
			#dialog
			class="cds--overflow-menu-options cds--overflow-menu-options--open"
			(click)="onClose($event)"
			[attr.aria-label]="dialogConfig.menuLabel">
			<ng-template
				[ngTemplateOutlet]="dialogConfig.content"
				[ngTemplateOutletContext]="{overflowMenu: this}">
			</ng-template>
		</ul>
	`
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: I18n
    }, {
      type: ExperimentalService
    }, {
      type: AnimationFrameService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ElementService,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    hostkeys: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }]
  });
})();
var OverflowMenuCustomPane = class extends Dialog {
  constructor(elementRef, i18n, animationFrameService = null, elementService = null) {
    super(elementRef, elementService, animationFrameService);
    this.elementRef = elementRef;
    this.i18n = i18n;
    this.animationFrameService = animationFrameService;
    this.elementService = elementService;
  }
  onClick(event) {
    this.doClose({
      reason: CloseReasons.interaction,
      target: event.target
    });
  }
  onDialogInit() {
    const positionOverflowMenu = (pos) => {
      let offset3;
      const closestRel = closestAttr("position", ["relative", "fixed", "absolute"], this.elementRef.nativeElement);
      const topFix = closestRel ? closestRel.getBoundingClientRect().top * -1 : 0;
      const leftFix = closestRel ? closestRel.getBoundingClientRect().left * -1 : 0;
      offset3 = Math.round(this.dialog.nativeElement.offsetWidth / 2) - 20;
      if (this.dialogConfig.flip) {
        return position.addOffset(pos, topFix, -offset3 + leftFix);
      }
      return position.addOffset(pos, topFix, offset3 + leftFix);
    };
    this.addGap["bottom"] = positionOverflowMenu;
    this.addGap["top"] = positionOverflowMenu;
    if (!this.dialogConfig.menuLabel) {
      this.dialogConfig.menuLabel = this.i18n.get().OVERFLOW_MENU.OVERFLOW;
    }
  }
};
OverflowMenuCustomPane.ɵfac = function OverflowMenuCustomPane_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || OverflowMenuCustomPane)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(I18n), ɵɵdirectiveInject(AnimationFrameService, 8), ɵɵdirectiveInject(ElementService, 8));
};
OverflowMenuCustomPane.ɵcmp = ɵɵdefineComponent({
  type: OverflowMenuCustomPane,
  selectors: [["cds-overflow-custom-menu-pane"], ["ibm-overflow-custom-menu-pane"]],
  standalone: false,
  features: [ɵɵInheritDefinitionFeature],
  decls: 3,
  vars: 11,
  consts: [["dialog", ""], ["role", "menu", 1, "cds--overflow-menu-options", "cds--overflow-menu-options--open", 3, "click", "ngClass"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
  template: function OverflowMenuCustomPane_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵelementStart(0, "div", 1, 0);
      ɵɵlistener("click", function OverflowMenuCustomPane_Template_div_click_0_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onClick($event));
      });
      ɵɵtemplate(2, OverflowMenuCustomPane_ng_template_2_Template, 0, 0, "ng-template", 2);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngClass", ɵɵpureFunction1(7, _c15, ctx.dialogConfig.flip));
      ɵɵattribute("id", ctx.dialogConfig.compID)("aria-label", ctx.dialogConfig.menuLabel)("data-floating-menu-direction", ctx.placement ? ctx.placement : null)("aria-label", ctx.dialogConfig.menuLabel);
      ɵɵadvance(2);
      ɵɵproperty("ngTemplateOutlet", ctx.dialogConfig.content)("ngTemplateOutletContext", ɵɵpureFunction1(9, _c23, ctx));
    }
  },
  dependencies: [NgClass, NgTemplateOutlet],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OverflowMenuCustomPane, [{
    type: Component,
    args: [{
      selector: "cds-overflow-custom-menu-pane, ibm-overflow-custom-menu-pane",
      template: `
		<div
			[attr.id]="dialogConfig.compID"
			[attr.aria-label]="dialogConfig.menuLabel"
			[attr.data-floating-menu-direction]="placement ? placement : null"
			[ngClass]="{'cds--overflow-menu--flip': dialogConfig.flip}"
			class="cds--overflow-menu-options cds--overflow-menu-options--open"
			role="menu"
			(click)="onClick($event)"
			#dialog
			[attr.aria-label]="dialogConfig.menuLabel">
			<ng-template
				[ngTemplateOutlet]="dialogConfig.content"
				[ngTemplateOutletContext]="{overflowMenu: this}">
			</ng-template>
		</div>
	`
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: I18n
    }, {
      type: AnimationFrameService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ElementService,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var OverflowMenuDirective = class extends DialogDirective {
  /**
   * Creates an instance of `OverflowMenuDirective`.
   */
  constructor(elementRef, viewContainerRef, dialogService, eventService) {
    super(elementRef, viewContainerRef, dialogService, eventService);
    this.elementRef = elementRef;
    this.viewContainerRef = viewContainerRef;
    this.dialogService = dialogService;
    this.eventService = eventService;
    this.flip = false;
    this.wrapperClass = "";
    this.customPane = false;
  }
  /**
   * @deprecated as of v5
   * Takes a template ref of `OverflowMenuOptions`s
   */
  set ibmOverflowMenu(template) {
    this.cdsOverflowMenu = template;
  }
  updateConfig() {
    this.dialogConfig.content = this.cdsOverflowMenu;
    this.dialogConfig.flip = this.flip;
    this.dialogConfig.offset = this.offset;
    this.dialogConfig.wrapperClass = this.wrapperClass;
  }
  hostkeys(event) {
    switch (event.key) {
      case "Enter":
      case " ":
        event.preventDefault();
        break;
    }
  }
  open() {
    return super.open(this.customPane ? OverflowMenuCustomPane : OverflowMenuPane);
  }
};
OverflowMenuDirective.ɵfac = function OverflowMenuDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || OverflowMenuDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(DialogService), ɵɵdirectiveInject(EventService));
};
OverflowMenuDirective.ɵdir = ɵɵdefineDirective({
  type: OverflowMenuDirective,
  selectors: [["", "cdsOverflowMenu", ""], ["", "ibmOverflowMenu", ""]],
  hostBindings: function OverflowMenuDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("keydown", function OverflowMenuDirective_keydown_HostBindingHandler($event) {
        return ctx.hostkeys($event);
      });
    }
  },
  inputs: {
    ibmOverflowMenu: "ibmOverflowMenu",
    cdsOverflowMenu: "cdsOverflowMenu",
    flip: "flip",
    offset: "offset",
    wrapperClass: "wrapperClass",
    customPane: "customPane"
  },
  exportAs: ["overflowMenu"],
  standalone: false,
  features: [ɵɵProvidersFeature([DialogService]), ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OverflowMenuDirective, [{
    type: Directive,
    args: [{
      selector: "[cdsOverflowMenu], [ibmOverflowMenu]",
      exportAs: "overflowMenu",
      providers: [DialogService]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: ViewContainerRef
    }, {
      type: DialogService
    }, {
      type: EventService
    }];
  }, {
    ibmOverflowMenu: [{
      type: Input
    }],
    cdsOverflowMenu: [{
      type: Input
    }],
    flip: [{
      type: Input
    }],
    offset: [{
      type: Input
    }],
    wrapperClass: [{
      type: Input
    }],
    customPane: [{
      type: Input
    }],
    hostkeys: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }]
  });
})();
var OverflowMenu = class extends BaseIconButton {
  constructor(elementRef, i18n) {
    super();
    this.elementRef = elementRef;
    this.i18n = i18n;
    this.buttonLabel = this.i18n.get().OVERFLOW_MENU.OVERFLOW;
    this.description = this.i18n.get().OVERFLOW_MENU.ICON_DESCRIPTION;
    this.flip = false;
    this.placement = "bottom";
    this.open = false;
    this.openChange = new EventEmitter();
    this.wrapperClass = "";
    this.triggerClass = "";
  }
  handleOpenChange(event) {
    this.open = event;
    this.openChange.emit(event);
  }
};
OverflowMenu.ɵfac = function OverflowMenu_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || OverflowMenu)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(I18n));
};
OverflowMenu.ɵcmp = ɵɵdefineComponent({
  type: OverflowMenu,
  selectors: [["cds-overflow-menu"], ["ibm-overflow-menu"]],
  contentQueries: function OverflowMenu_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, OverflowMenuDirective, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.overflowMenuDirective = _t.first);
    }
  },
  inputs: {
    buttonLabel: "buttonLabel",
    description: "description",
    flip: "flip",
    placement: "placement",
    open: "open",
    customTrigger: "customTrigger",
    offset: "offset",
    wrapperClass: "wrapperClass",
    triggerClass: "triggerClass"
  },
  outputs: {
    openChange: "openChange"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c3,
  decls: 7,
  vars: 25,
  consts: [["options", ""], ["defaultIcon", ""], [1, "cds--icon-tooltip", 3, "description", "caret", "dropShadow", "highContrast", "isOpen", "align", "autoAlign", "enterDelayMs", "leaveDelayMs"], ["cdsButton", "ghost", "aria-haspopup", "true", "type", "button", 3, "isOpenChange", "cdsOverflowMenu", "ngClass", "iconOnly", "flip", "isOpen", "offset", "wrapperClass", "placement"], [4, "ngIf", "ngIfElse"], [3, "ngTemplateOutlet"], ["cdsIcon", "overflow-menu--vertical", "size", "16", 1, "cds--overflow-menu__icon"]],
  template: function OverflowMenu_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵprojectionDef();
      ɵɵelementStart(0, "cds-tooltip", 2)(1, "button", 3);
      ɵɵlistener("isOpenChange", function OverflowMenu_Template_button_isOpenChange_1_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.handleOpenChange($event));
      });
      ɵɵtemplate(2, OverflowMenu_2_Template, 1, 1, null, 4);
      ɵɵelementEnd()();
      ɵɵtemplate(3, OverflowMenu_ng_template_3_Template, 1, 0, "ng-template", null, 0, ɵɵtemplateRefExtractor)(5, OverflowMenu_ng_template_5_Template, 1, 0, "ng-template", null, 1, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      const options_r3 = ɵɵreference(4);
      const defaultIcon_r4 = ɵɵreference(6);
      ɵɵproperty("description", ctx.description)("caret", ctx.caret)("dropShadow", ctx.dropShadow)("highContrast", ctx.highContrast)("isOpen", ctx.isOpen)("align", ctx.align)("autoAlign", ctx.autoAlign)("enterDelayMs", ctx.enterDelayMs)("leaveDelayMs", ctx.leaveDelayMs);
      ɵɵadvance();
      ɵɵclassMapInterpolate1("cds--overflow-menu ", ctx.triggerClass, "");
      ɵɵproperty("cdsOverflowMenu", options_r3)("ngClass", ɵɵpureFunction1(23, _c4, ctx.open))("iconOnly", true)("flip", ctx.flip)("isOpen", ctx.open)("offset", ctx.offset)("wrapperClass", ctx.wrapperClass)("placement", ctx.placement);
      ɵɵattribute("aria-label", ctx.buttonLabel);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.customTrigger)("ngIfElse", defaultIcon_r4);
    }
  },
  dependencies: [NgClass, NgIf, NgTemplateOutlet, IconDirective, Button, Tooltip, OverflowMenuDirective],
  styles: [".cds--overflow-menu--open{opacity:1}.cds--data-table-v2 .cds--overflow-menu{transform:rotate(90deg)}.cds--data-table-v2 .cds--overflow-menu__icon{transform:rotate(180deg)}\n"],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OverflowMenu, [{
    type: Component,
    args: [{
      selector: "cds-overflow-menu, ibm-overflow-menu",
      template: `
		<cds-tooltip
			class="cds--icon-tooltip"
			[description]="description"
			[caret]="caret"
			[dropShadow]="dropShadow"
			[highContrast]="highContrast"
			[isOpen]="isOpen"
			[align]="align"
			[autoAlign]="autoAlign"
			[enterDelayMs]="enterDelayMs"
			[leaveDelayMs]="leaveDelayMs">
			<button
				cdsButton="ghost"
				[cdsOverflowMenu]="options"
				[ngClass]="{'cds--overflow-menu--open': open}"
				class="cds--overflow-menu {{triggerClass}}"
				[iconOnly]="true"
				[attr.aria-label]="buttonLabel"
				[flip]="flip"
				[isOpen]="open"
				(isOpenChange)="handleOpenChange($event)"
				[offset]="offset"
				[wrapperClass]="wrapperClass"
				aria-haspopup="true"
				type="button"
				[placement]="placement">
				<ng-template *ngIf="customTrigger; else defaultIcon" [ngTemplateOutlet]="customTrigger"></ng-template>
			</button>
		</cds-tooltip>

		<ng-template #options>
			<ng-content></ng-content>
		</ng-template>
		<ng-template #defaultIcon>
			<svg cdsIcon="overflow-menu--vertical" size="16" class="cds--overflow-menu__icon"></svg>
		</ng-template>
	`,
      encapsulation: ViewEncapsulation.None,
      styles: [".cds--overflow-menu--open{opacity:1}.cds--data-table-v2 .cds--overflow-menu{transform:rotate(90deg)}.cds--data-table-v2 .cds--overflow-menu__icon{transform:rotate(180deg)}\n"]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: I18n
    }];
  }, {
    buttonLabel: [{
      type: Input
    }],
    description: [{
      type: Input
    }],
    flip: [{
      type: Input
    }],
    placement: [{
      type: Input
    }],
    open: [{
      type: Input
    }],
    openChange: [{
      type: Output
    }],
    customTrigger: [{
      type: Input
    }],
    offset: [{
      type: Input
    }],
    wrapperClass: [{
      type: Input
    }],
    triggerClass: [{
      type: Input
    }],
    overflowMenuDirective: [{
      type: ContentChild,
      args: [OverflowMenuDirective]
    }]
  });
})();
var Target;
(function(Target2) {
  Target2["self"] = "_self";
  Target2["blank"] = "_blank";
  Target2["parent"] = "_parent";
  Target2["top"] = "_top";
})(Target || (Target = {}));
var REL = "noreferrer noopener";
var OverflowMenuOption = class {
  constructor(elementRef) {
    this.elementRef = elementRef;
    this.optionClass = true;
    this.role = "presentation";
    this.divider = false;
    this.type = "normal";
    this.disabled = false;
    this.innerClass = "";
    this.selected = new EventEmitter();
    this.tabIndex = -1;
    this.title = null;
  }
  get isDanger() {
    return this.type === "danger";
  }
  get isDisabled() {
    return this.disabled;
  }
  /**
   * Allows to add a target to the anchor
   */
  set target(value) {
    if (!Object.values(Target).includes(value)) {
      console.warn(`\`target\` must have one of the following values: ${Object.values(Target).join(", ")}.
Please use the \`Target\` enum exported by carbon-components-angular`);
      return;
    }
    this._target = value;
  }
  get target() {
    return this._target;
  }
  /**
   * rel only returns its value if target is defined
   */
  get rel() {
    return this._target ? REL : null;
  }
  onClick() {
    this.selected.emit();
  }
  onFocus() {
    setTimeout(() => this.tabIndex = 0);
  }
  onBlur() {
    setTimeout(() => this.tabIndex = -1);
  }
  ngAfterViewInit() {
    const button = this.elementRef.nativeElement.querySelector("button, a");
    const textContainer = button.querySelector(".cds--overflow-menu-options__option-content");
    if (textContainer.scrollWidth > textContainer.offsetWidth) {
      this.title = button.textContent;
    }
  }
};
OverflowMenuOption.ɵfac = function OverflowMenuOption_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || OverflowMenuOption)(ɵɵdirectiveInject(ElementRef));
};
OverflowMenuOption.ɵcmp = ɵɵdefineComponent({
  type: OverflowMenuOption,
  selectors: [["cds-overflow-menu-option"], ["ibm-overflow-menu-option"]],
  hostVars: 9,
  hostBindings: function OverflowMenuOption_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", ctx.role);
      ɵɵclassProp("cds--overflow-menu-options__option", ctx.optionClass)("cds--overflow-menu-options__option--danger", ctx.isDanger)("cds--overflow-menu-options__option--disabled", ctx.isDisabled)("cds--overflow-menu--divider", ctx.divider);
    }
  },
  inputs: {
    divider: "divider",
    type: "type",
    disabled: "disabled",
    href: "href",
    target: "target",
    innerClass: "innerClass"
  },
  outputs: {
    selected: "selected"
  },
  standalone: false,
  ngContentSelectors: _c3,
  decls: 4,
  vars: 2,
  consts: [["tempOutlet", ""], ["role", "menuitem", 3, "class", "tabindex", "disabled", "focus", "blur", "click", 4, "ngIf"], ["role", "menuitem", 3, "class", "tabindex", "href", "focus", "blur", "click", 4, "ngIf"], ["role", "menuitem", 3, "focus", "blur", "click", "tabindex", "disabled"], [4, "ngTemplateOutlet"], ["role", "menuitem", 3, "focus", "blur", "click", "tabindex", "href"], [1, "cds--overflow-menu-options__option-content"]],
  template: function OverflowMenuOption_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, OverflowMenuOption_button_0_Template, 2, 7, "button", 1)(1, OverflowMenuOption_a_1_Template, 2, 10, "a", 2)(2, OverflowMenuOption_ng_template_2_Template, 2, 0, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", !ctx.href);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.href);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OverflowMenuOption, [{
    type: Component,
    args: [{
      selector: "cds-overflow-menu-option, ibm-overflow-menu-option",
      template: `
		<button
			*ngIf="!href"
			class="cds--overflow-menu-options__btn {{innerClass}}"
			role="menuitem"
			[tabindex]="tabIndex"
			(focus)="onFocus()"
			(blur)="onBlur()"
			(click)="onClick()"
			[disabled]="disabled"
			[attr.title]="title">
			<ng-container *ngTemplateOutlet="tempOutlet"></ng-container>
		</button>

		<a
			*ngIf="href"
			class="cds--overflow-menu-options__btn {{innerClass}}"
			role="menuitem"
			[tabindex]="tabIndex"
			(focus)="onFocus()"
			(blur)="onBlur()"
			(click)="onClick()"
			[attr.disabled]="disabled"
			[href]="href"
			[attr.target]="target"
			[attr.rel]="rel"
			[attr.title]="title">
			<ng-container *ngTemplateOutlet="tempOutlet"></ng-container>
		</a>

		<ng-template #tempOutlet>
			<div class="cds--overflow-menu-options__option-content">
				<ng-content></ng-content>
			</div>
		</ng-template>
	`
    }]
  }], function() {
    return [{
      type: ElementRef
    }];
  }, {
    optionClass: [{
      type: HostBinding,
      args: ["class.cds--overflow-menu-options__option"]
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    isDanger: [{
      type: HostBinding,
      args: ["class.cds--overflow-menu-options__option--danger"]
    }],
    isDisabled: [{
      type: HostBinding,
      args: ["class.cds--overflow-menu-options__option--disabled"]
    }],
    divider: [{
      type: HostBinding,
      args: ["class.cds--overflow-menu--divider"]
    }, {
      type: Input
    }],
    type: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    href: [{
      type: Input
    }],
    target: [{
      type: Input
    }],
    innerClass: [{
      type: Input
    }],
    selected: [{
      type: Output
    }]
  });
})();
var DialogModule = class {
};
DialogModule.ɵfac = function DialogModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || DialogModule)();
};
DialogModule.ɵmod = ɵɵdefineNgModule({
  type: DialogModule,
  declarations: [Dialog, OverflowMenu, OverflowMenuPane, OverflowMenuCustomPane, DialogDirective, OverflowMenuDirective, OverflowMenuOption],
  imports: [CommonModule, I18nModule, PlaceholderModule, ExperimentalModule, UtilsModule, IconModule, ButtonModule, TooltipModule],
  exports: [Dialog, OverflowMenu, OverflowMenuPane, OverflowMenuCustomPane, DialogDirective, OverflowMenuDirective, OverflowMenuOption]
});
DialogModule.ɵinj = ɵɵdefineInjector({
  providers: [DialogService],
  imports: [CommonModule, I18nModule, PlaceholderModule, ExperimentalModule, UtilsModule, IconModule, ButtonModule, TooltipModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DialogModule, [{
    type: NgModule,
    args: [{
      declarations: [Dialog, OverflowMenu, OverflowMenuPane, OverflowMenuCustomPane, DialogDirective, OverflowMenuDirective, OverflowMenuOption],
      exports: [Dialog, OverflowMenu, OverflowMenuPane, OverflowMenuCustomPane, DialogDirective, OverflowMenuDirective, OverflowMenuOption],
      providers: [DialogService],
      imports: [CommonModule, I18nModule, PlaceholderModule, ExperimentalModule, UtilsModule, IconModule, ButtonModule, TooltipModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-breadcrumb.mjs
var _c07 = ["*"];
function BreadcrumbItemComponent_a_0_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function BreadcrumbItemComponent_a_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 2);
    ɵɵlistener("click", function BreadcrumbItemComponent_a_0_Template_a_click_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.navigate($event));
    });
    ɵɵtemplate(1, BreadcrumbItemComponent_a_0_ng_container_1_Template, 1, 0, "ng-container", 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const content_r3 = ɵɵreference(2);
    ɵɵproperty("href", ctx_r1.skeleton ? "/#" : ctx_r1.href, ɵɵsanitizeUrl);
    ɵɵattribute("aria-current", ctx_r1.current ? ctx_r1.ariaCurrent : null);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", content_r3);
  }
}
function BreadcrumbItemComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
var _c16 = (a0, a1) => ({
  "cds--skeleton": a0,
  "cds--breadcrumb--no-trailing-slash": a1
});
var _c24 = (a0) => ({
  $implicit: a0
});
function Breadcrumb_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
function Breadcrumb_ng_template_3_cds_breadcrumb_item_0_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r3 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(item_r3.content);
  }
}
function Breadcrumb_ng_template_3_cds_breadcrumb_item_0_2_ng_template_0_Template(rf, ctx) {
}
function Breadcrumb_ng_template_3_cds_breadcrumb_item_0_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, Breadcrumb_ng_template_3_cds_breadcrumb_item_0_2_ng_template_0_Template, 0, 0, "ng-template", 7);
  }
  if (rf & 2) {
    const item_r3 = ɵɵnextContext().$implicit;
    ɵɵproperty("ngTemplateOutlet", item_r3.template)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c24, item_r3));
  }
}
function Breadcrumb_ng_template_3_cds_breadcrumb_item_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "cds-breadcrumb-item", 5);
    ɵɵlistener("navigation", function Breadcrumb_ng_template_3_cds_breadcrumb_item_0_Template_cds_breadcrumb_item_navigation_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.navigation.emit($event));
    });
    ɵɵtemplate(1, Breadcrumb_ng_template_3_cds_breadcrumb_item_0_ng_container_1_Template, 2, 1, "ng-container", 6)(2, Breadcrumb_ng_template_3_cds_breadcrumb_item_0_2_Template, 1, 4, null, 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r3 = ctx.$implicit;
    ɵɵproperty("href", item_r3.href)("route", item_r3.route)("routeExtras", item_r3.routeExtras)("current", item_r3.current)("ariaCurrent", item_r3.ariaCurrent);
    ɵɵadvance();
    ɵɵproperty("ngIf", !item_r3.template);
    ɵɵadvance();
    ɵɵproperty("ngIf", item_r3.template);
  }
}
function Breadcrumb_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, Breadcrumb_ng_template_3_cds_breadcrumb_item_0_Template, 3, 7, "cds-breadcrumb-item", 4);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngForOf", ctx_r1.items);
  }
}
function Breadcrumb_ng_template_4_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.first == null ? null : ctx_r1.first.content);
  }
}
function Breadcrumb_ng_template_4_2_ng_template_0_Template(rf, ctx) {
}
function Breadcrumb_ng_template_4_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, Breadcrumb_ng_template_4_2_ng_template_0_Template, 0, 0, "ng-template", 7);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.first == null ? null : ctx_r1.first.template)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c24, ctx_r1.first));
  }
}
function Breadcrumb_ng_template_4_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 10);
  }
}
function Breadcrumb_ng_template_4_li_7_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r6 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(item_r6 == null ? null : item_r6.content);
  }
}
function Breadcrumb_ng_template_4_li_7_3_ng_template_0_Template(rf, ctx) {
}
function Breadcrumb_ng_template_4_li_7_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, Breadcrumb_ng_template_4_li_7_3_ng_template_0_Template, 0, 0, "ng-template", 7);
  }
  if (rf & 2) {
    const item_r6 = ɵɵnextContext().$implicit;
    ɵɵproperty("ngTemplateOutlet", item_r6 == null ? null : item_r6.template)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c24, item_r6));
  }
}
function Breadcrumb_ng_template_4_li_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "li", 11)(1, "a", 12);
    ɵɵlistener("click", function Breadcrumb_ng_template_4_li_7_Template_a_click_1_listener($event) {
      const item_r6 = ɵɵrestoreView(_r5).$implicit;
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.navigate($event, item_r6));
    });
    ɵɵtemplate(2, Breadcrumb_ng_template_4_li_7_ng_container_2_Template, 2, 1, "ng-container", 6)(3, Breadcrumb_ng_template_4_li_7_3_Template, 1, 4, null, 6);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const item_r6 = ctx.$implicit;
    ɵɵadvance();
    ɵɵpropertyInterpolate("href", item_r6 == null ? null : item_r6.href, ɵɵsanitizeUrl);
    ɵɵadvance();
    ɵɵproperty("ngIf", !(item_r6 == null ? null : item_r6.template));
    ɵɵadvance();
    ɵɵproperty("ngIf", item_r6 == null ? null : item_r6.template);
  }
}
function Breadcrumb_ng_template_4_ng_container_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.secondLast == null ? null : ctx_r1.secondLast.content);
  }
}
function Breadcrumb_ng_template_4_10_ng_template_0_Template(rf, ctx) {
}
function Breadcrumb_ng_template_4_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, Breadcrumb_ng_template_4_10_ng_template_0_Template, 0, 0, "ng-template", 7);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.secondLast == null ? null : ctx_r1.secondLast.template)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c24, ctx_r1.secondLast));
  }
}
function Breadcrumb_ng_template_4_ng_container_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.last == null ? null : ctx_r1.last.content);
  }
}
function Breadcrumb_ng_template_4_13_ng_template_0_Template(rf, ctx) {
}
function Breadcrumb_ng_template_4_13_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, Breadcrumb_ng_template_4_13_ng_template_0_Template, 0, 0, "ng-template", 7);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.last == null ? null : ctx_r1.last.template)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c24, ctx_r1.last));
  }
}
function Breadcrumb_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "cds-breadcrumb-item", 5);
    ɵɵlistener("navigation", function Breadcrumb_ng_template_4_Template_cds_breadcrumb_item_navigation_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.navigation.emit($event));
    });
    ɵɵtemplate(1, Breadcrumb_ng_template_4_ng_container_1_Template, 2, 1, "ng-container", 6)(2, Breadcrumb_ng_template_4_2_Template, 1, 4, null, 6);
    ɵɵelementEnd();
    ɵɵelementStart(3, "cds-breadcrumb-item");
    ɵɵtemplate(4, Breadcrumb_ng_template_4_ng_template_4_Template, 1, 0, "ng-template", null, 1, ɵɵtemplateRefExtractor);
    ɵɵelementStart(6, "cds-overflow-menu", 8);
    ɵɵtemplate(7, Breadcrumb_ng_template_4_li_7_Template, 4, 3, "li", 9);
    ɵɵelementEnd()();
    ɵɵelementStart(8, "cds-breadcrumb-item", 5);
    ɵɵlistener("navigation", function Breadcrumb_ng_template_4_Template_cds_breadcrumb_item_navigation_8_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.navigation.emit($event));
    });
    ɵɵtemplate(9, Breadcrumb_ng_template_4_ng_container_9_Template, 2, 1, "ng-container", 6)(10, Breadcrumb_ng_template_4_10_Template, 1, 4, null, 6);
    ɵɵelementEnd();
    ɵɵelementStart(11, "cds-breadcrumb-item", 5);
    ɵɵlistener("navigation", function Breadcrumb_ng_template_4_Template_cds_breadcrumb_item_navigation_11_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.navigation.emit($event));
    });
    ɵɵtemplate(12, Breadcrumb_ng_template_4_ng_container_12_Template, 2, 1, "ng-container", 6)(13, Breadcrumb_ng_template_4_13_Template, 1, 4, null, 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const overflowMenuTrigger_r7 = ɵɵreference(5);
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("href", ctx_r1.first == null ? null : ctx_r1.first.href)("route", ctx_r1.first == null ? null : ctx_r1.first.route)("routeExtras", ctx_r1.first == null ? null : ctx_r1.first.routeExtras)("current", ctx_r1.first == null ? null : ctx_r1.first.current)("ariaCurrent", ctx_r1.first == null ? null : ctx_r1.first.ariaCurrent);
    ɵɵadvance();
    ɵɵproperty("ngIf", !(ctx_r1.first == null ? null : ctx_r1.first.template));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.first == null ? null : ctx_r1.first.template);
    ɵɵadvance(4);
    ɵɵproperty("customTrigger", overflowMenuTrigger_r7)("description", ctx_r1.description)("autoAlign", ctx_r1.autoAlign);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1.overflowItems);
    ɵɵadvance();
    ɵɵproperty("href", ctx_r1.secondLast == null ? null : ctx_r1.secondLast.href)("route", ctx_r1.secondLast == null ? null : ctx_r1.secondLast.route)("routeExtras", ctx_r1.secondLast == null ? null : ctx_r1.secondLast.routeExtras)("current", ctx_r1.secondLast == null ? null : ctx_r1.secondLast.current)("ariaCurrent", ctx_r1.secondLast == null ? null : ctx_r1.secondLast.ariaCurrent);
    ɵɵadvance();
    ɵɵproperty("ngIf", !(ctx_r1.secondLast == null ? null : ctx_r1.secondLast.template));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.secondLast == null ? null : ctx_r1.secondLast.template);
    ɵɵadvance();
    ɵɵproperty("href", ctx_r1.last == null ? null : ctx_r1.last.href)("route", ctx_r1.last == null ? null : ctx_r1.last.route)("routeExtras", ctx_r1.last == null ? null : ctx_r1.last.routeExtras)("current", ctx_r1.last == null ? null : ctx_r1.last.current)("ariaCurrent", ctx_r1.last == null ? null : ctx_r1.last.ariaCurrent);
    ɵɵadvance();
    ɵɵproperty("ngIf", !(ctx_r1.last == null ? null : ctx_r1.last.template));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.last == null ? null : ctx_r1.last.template);
  }
}
var BreadcrumbItemComponent = class {
  constructor(domSanitizer, router) {
    this.domSanitizer = domSanitizer;
    this.router = router;
    this.navigation = new EventEmitter();
    this.skeleton = false;
    this.ariaCurrent = "page";
    this.current = false;
    this.itemClass = true;
  }
  set href(v) {
    this._href = v;
  }
  get href() {
    return this.domSanitizer.bypassSecurityTrustUrl(this._href);
  }
  useTemplate() {
    return this.skeleton || this._href || this.route;
  }
  navigate(event) {
    if (this.router && this.route) {
      event.preventDefault();
      const status = this.router.navigate(this.route, this.routeExtras);
      this.navigation.emit(status);
    }
  }
};
BreadcrumbItemComponent.ɵfac = function BreadcrumbItemComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || BreadcrumbItemComponent)(ɵɵdirectiveInject(DomSanitizer), ɵɵdirectiveInject(Router, 8));
};
BreadcrumbItemComponent.ɵcmp = ɵɵdefineComponent({
  type: BreadcrumbItemComponent,
  selectors: [["cds-breadcrumb-item"], ["ibm-breadcrumb-item"]],
  hostVars: 4,
  hostBindings: function BreadcrumbItemComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--breadcrumb-item--current", ctx.current)("cds--breadcrumb-item", ctx.itemClass);
    }
  },
  inputs: {
    href: "href",
    route: "route",
    routeExtras: "routeExtras",
    skeleton: "skeleton",
    ariaCurrent: "ariaCurrent",
    current: "current"
  },
  outputs: {
    navigation: "navigation"
  },
  standalone: false,
  ngContentSelectors: _c07,
  decls: 3,
  vars: 2,
  consts: [["content", ""], ["class", "cds--link", 3, "href", "click", 4, "ngIf", "ngIfElse"], [1, "cds--link", 3, "click", "href"], [4, "ngTemplateOutlet"]],
  template: function BreadcrumbItemComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, BreadcrumbItemComponent_a_0_Template, 2, 3, "a", 1)(1, BreadcrumbItemComponent_ng_template_1_Template, 1, 0, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      const content_r3 = ɵɵreference(2);
      ɵɵproperty("ngIf", ctx.useTemplate())("ngIfElse", content_r3);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BreadcrumbItemComponent, [{
    type: Component,
    args: [{
      selector: "cds-breadcrumb-item, ibm-breadcrumb-item",
      template: `
	<a
		class="cds--link"
		[href]="(skeleton ? '/#' : href)"
		(click)="navigate($event)"
		[attr.aria-current]="(current ? ariaCurrent : null)"
		*ngIf="useTemplate(); else content">
		<ng-container *ngTemplateOutlet="content"></ng-container>
	</a>
	<ng-template #content>
		<ng-content></ng-content>
	</ng-template>`
    }]
  }], function() {
    return [{
      type: DomSanitizer
    }, {
      type: Router,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    href: [{
      type: Input
    }],
    route: [{
      type: Input
    }],
    routeExtras: [{
      type: Input
    }],
    navigation: [{
      type: Output
    }],
    skeleton: [{
      type: Input
    }],
    ariaCurrent: [{
      type: Input
    }],
    current: [{
      type: HostBinding,
      args: ["class.cds--breadcrumb-item--current"]
    }, {
      type: Input
    }],
    itemClass: [{
      type: HostBinding,
      args: ["class.cds--breadcrumb-item"]
    }]
  });
})();
var MINIMUM_OVERFLOW_THRESHOLD = 4;
var Breadcrumb = class {
  constructor(i18n, router) {
    this.i18n = i18n;
    this.router = router;
    this.noTrailingSlash = false;
    this.ariaLabel = this.i18n.get().BREADCRUMB.LABEL;
    this.autoAlign = false;
    this.description = this.i18n.get().BREADCRUMB.OVERFLOW_MENU_DESCRIPTION;
    this.navigation = new EventEmitter();
    this._skeleton = false;
  }
  set skeleton(value) {
    this._skeleton = value;
    this.updateChildren();
  }
  get skeleton() {
    return this._skeleton;
  }
  set threshold(threshold) {
    this._threshold = threshold;
    if (isNaN(threshold) || threshold < MINIMUM_OVERFLOW_THRESHOLD) {
      this._threshold = MINIMUM_OVERFLOW_THRESHOLD;
    }
  }
  get threshold() {
    return this._threshold;
  }
  get shouldShowContent() {
    return !this.items;
  }
  get shouldShowOverflow() {
    if (!this.items) {
      return false;
    }
    return this.items.length > this.threshold;
  }
  get first() {
    return this.shouldShowOverflow ? this.items[0] : null;
  }
  get overflowItems() {
    return this.shouldShowOverflow ? this.items.slice(1, this.items.length - 2) : [];
  }
  get secondLast() {
    return this.shouldShowOverflow ? this.items[this.items.length - 2] : null;
  }
  get last() {
    return this.shouldShowOverflow ? this.items[this.items.length - 1] : null;
  }
  ngAfterContentInit() {
    this.updateChildren();
  }
  navigate(event, item) {
    if (this.router && item.route) {
      event.preventDefault();
      const status = this.router.navigate(item.route, item.routeExtras);
      this.navigation.emit(status);
    }
  }
  updateChildren() {
    if (this.children) {
      this.children.toArray().forEach((child) => child.skeleton = this.skeleton);
    }
  }
};
Breadcrumb.ɵfac = function Breadcrumb_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Breadcrumb)(ɵɵdirectiveInject(I18n), ɵɵdirectiveInject(Router, 8));
};
Breadcrumb.ɵcmp = ɵɵdefineComponent({
  type: Breadcrumb,
  selectors: [["cds-breadcrumb"], ["ibm-breadcrumb"]],
  contentQueries: function Breadcrumb_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, BreadcrumbItemComponent, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  inputs: {
    items: "items",
    noTrailingSlash: "noTrailingSlash",
    ariaLabel: "ariaLabel",
    skeleton: "skeleton",
    threshold: "threshold",
    autoAlign: "autoAlign",
    description: "description"
  },
  outputs: {
    navigation: "navigation"
  },
  standalone: false,
  ngContentSelectors: _c07,
  decls: 5,
  vars: 8,
  consts: [["nav", ""], ["overflowMenuTrigger", ""], [1, "cds--breadcrumb", 3, "ngClass"], [3, "ngIf"], [3, "href", "route", "routeExtras", "current", "ariaCurrent", "navigation", 4, "ngFor", "ngForOf"], [3, "navigation", "href", "route", "routeExtras", "current", "ariaCurrent"], [4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["triggerClass", "cds--btn--icon-only", 3, "customTrigger", "description", "autoAlign"], ["class", "cds--overflow-menu-options__option", 4, "ngFor", "ngForOf"], ["cdsIcon", "overflow-menu--horizontal", "size", "16", 1, "cds--overflow-menu__icon"], [1, "cds--overflow-menu-options__option"], [1, "cds--overflow-menu-options__btn", 2, "text-decoration", "none", 3, "click", "href"]],
  template: function Breadcrumb_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "nav", 2, 0);
      ɵɵtemplate(2, Breadcrumb_ng_template_2_Template, 1, 0, "ng-template", 3)(3, Breadcrumb_ng_template_3_Template, 1, 1, "ng-template", 3)(4, Breadcrumb_ng_template_4_Template, 14, 25, "ng-template", 3);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngClass", ɵɵpureFunction2(5, _c16, ctx.skeleton, ctx.noTrailingSlash));
      ɵɵattribute("aria-label", ctx.ariaLabel);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.shouldShowContent);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.shouldShowOverflow);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.shouldShowOverflow);
    }
  },
  dependencies: [NgClass, NgForOf, NgIf, NgTemplateOutlet, OverflowMenu, IconDirective, BreadcrumbItemComponent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Breadcrumb, [{
    type: Component,
    args: [{
      selector: "cds-breadcrumb, ibm-breadcrumb",
      template: `
	<nav #nav class="cds--breadcrumb"
		[ngClass]="{
			'cds--skeleton' : skeleton,
			'cds--breadcrumb--no-trailing-slash' : noTrailingSlash
		}"
		[attr.aria-label]="ariaLabel">
		<ng-template [ngIf]="shouldShowContent">
			<ng-content></ng-content>
		</ng-template>
		<ng-template [ngIf]="!shouldShowOverflow">
			<cds-breadcrumb-item
				*ngFor="let item of items"
				[href]="item.href"
				[route]="item.route"
				[routeExtras]="item.routeExtras"
				[current]="item.current"
				[ariaCurrent]="item.ariaCurrent"
				(navigation)="navigation.emit($event)">
				<ng-container *ngIf="!item.template">{{item.content}}</ng-container>
				<ng-template
					*ngIf="item.template"
					[ngTemplateOutlet]="item.template"
					[ngTemplateOutletContext]="{ $implicit: item }">
				</ng-template>
			</cds-breadcrumb-item>
		</ng-template>
		<ng-template [ngIf]="shouldShowOverflow">
			<cds-breadcrumb-item
				[href]="first?.href"
				[route]="first?.route"
				[routeExtras]="first?.routeExtras"
				[current]="first?.current"
				[ariaCurrent]="first?.ariaCurrent"
				(navigation)="navigation.emit($event)">
				<ng-container *ngIf="!first?.template">{{first?.content}}</ng-container>
				<ng-template
					*ngIf="first?.template"
					[ngTemplateOutlet]="first?.template"
					[ngTemplateOutletContext]="{ $implicit: first }">
				</ng-template>
			</cds-breadcrumb-item>
			<cds-breadcrumb-item>
				<ng-template #overflowMenuTrigger>
					<svg class="cds--overflow-menu__icon" cdsIcon="overflow-menu--horizontal" size="16"></svg>
				</ng-template>
				<cds-overflow-menu
					[customTrigger]="overflowMenuTrigger"
					triggerClass="cds--btn--icon-only"
					[description]="description"
					[autoAlign]="autoAlign">
					<li class="cds--overflow-menu-options__option"
						*ngFor="let item of overflowItems">
						<a class="cds--overflow-menu-options__btn"
							href="{{item?.href}}"
							(click)="navigate($event, item)"
							style="text-decoration: none;">
							<ng-container *ngIf="!item?.template">{{item?.content}}</ng-container>
							<ng-template
								*ngIf="item?.template"
								[ngTemplateOutlet]="item?.template"
								[ngTemplateOutletContext]="{ $implicit: item }">
							</ng-template>
						</a>
					</li>
				</cds-overflow-menu>
			</cds-breadcrumb-item>
			<cds-breadcrumb-item
				[href]="secondLast?.href"
				[route]="secondLast?.route"
				[routeExtras]="secondLast?.routeExtras"
				[current]="secondLast?.current"
				[ariaCurrent]="secondLast?.ariaCurrent"
				(navigation)="navigation.emit($event)">
				<ng-container *ngIf="!secondLast?.template">{{secondLast?.content}}</ng-container>
				<ng-template
					*ngIf="secondLast?.template"
					[ngTemplateOutlet]="secondLast?.template"
					[ngTemplateOutletContext]="{ $implicit: secondLast }">
				</ng-template>
			</cds-breadcrumb-item>
			<cds-breadcrumb-item
				[href]="last?.href"
				[route]="last?.route"
				[routeExtras]="last?.routeExtras"
				[current]="last?.current"
				[ariaCurrent]="last?.ariaCurrent"
				(navigation)="navigation.emit($event)">
				<ng-container *ngIf="!last?.template">{{last?.content}}</ng-container>
				<ng-template
					*ngIf="last?.template"
					[ngTemplateOutlet]="last?.template"
					[ngTemplateOutletContext]="{ $implicit: last }">
				</ng-template>
			</cds-breadcrumb-item>
		</ng-template>
	</nav>`
    }]
  }], function() {
    return [{
      type: I18n
    }, {
      type: Router,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    children: [{
      type: ContentChildren,
      args: [BreadcrumbItemComponent]
    }],
    items: [{
      type: Input
    }],
    noTrailingSlash: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    skeleton: [{
      type: Input
    }],
    threshold: [{
      type: Input
    }],
    autoAlign: [{
      type: Input
    }],
    description: [{
      type: Input
    }],
    navigation: [{
      type: Output
    }]
  });
})();
var BreadcrumbModule = class {
};
BreadcrumbModule.ɵfac = function BreadcrumbModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || BreadcrumbModule)();
};
BreadcrumbModule.ɵmod = ɵɵdefineNgModule({
  type: BreadcrumbModule,
  declarations: [Breadcrumb, BreadcrumbItemComponent],
  imports: [CommonModule, ButtonModule, DialogModule, I18nModule, IconModule],
  exports: [Breadcrumb, BreadcrumbItemComponent]
});
BreadcrumbModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ButtonModule, DialogModule, I18nModule, IconModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BreadcrumbModule, [{
    type: NgModule,
    args: [{
      declarations: [Breadcrumb, BreadcrumbItemComponent],
      exports: [Breadcrumb, BreadcrumbItemComponent],
      imports: [CommonModule, ButtonModule, DialogModule, I18nModule, IconModule]
    }]
  }], null, null);
})();

// node_modules/@angular/forms/fesm2022/forms.mjs
var BaseControlValueAccessor = class _BaseControlValueAccessor {
  _renderer;
  _elementRef;
  /**
   * The registered callback function called when a change or input event occurs on the input
   * element.
   * @nodoc
   */
  onChange = (_) => {
  };
  /**
   * The registered callback function called when a blur event occurs on the input element.
   * @nodoc
   */
  onTouched = () => {
  };
  constructor(_renderer, _elementRef) {
    this._renderer = _renderer;
    this._elementRef = _elementRef;
  }
  /**
   * Helper method that sets a property on a target element using the current Renderer
   * implementation.
   * @nodoc
   */
  setProperty(key, value) {
    this._renderer.setProperty(this._elementRef.nativeElement, key, value);
  }
  /**
   * Registers a function called when the control is touched.
   * @nodoc
   */
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  /**
   * Registers a function called when the control value changes.
   * @nodoc
   */
  registerOnChange(fn) {
    this.onChange = fn;
  }
  /**
   * Sets the "disabled" property on the range input element.
   * @nodoc
   */
  setDisabledState(isDisabled) {
    this.setProperty("disabled", isDisabled);
  }
  static ɵfac = function BaseControlValueAccessor_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BaseControlValueAccessor)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _BaseControlValueAccessor
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseControlValueAccessor, [{
    type: Directive
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }], null);
})();
var BuiltInControlValueAccessor = class _BuiltInControlValueAccessor extends BaseControlValueAccessor {
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵBuiltInControlValueAccessor_BaseFactory;
    return function BuiltInControlValueAccessor_Factory(__ngFactoryType__) {
      return (ɵBuiltInControlValueAccessor_BaseFactory || (ɵBuiltInControlValueAccessor_BaseFactory = ɵɵgetInheritedFactory(_BuiltInControlValueAccessor)))(__ngFactoryType__ || _BuiltInControlValueAccessor);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _BuiltInControlValueAccessor,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BuiltInControlValueAccessor, [{
    type: Directive
  }], null, null);
})();
var NG_VALUE_ACCESSOR = new InjectionToken(ngDevMode ? "NgValueAccessor" : "");
var CHECKBOX_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => CheckboxControlValueAccessor),
  multi: true
};
var CheckboxControlValueAccessor = class _CheckboxControlValueAccessor extends BuiltInControlValueAccessor {
  /**
   * Sets the "checked" property on the input element.
   * @nodoc
   */
  writeValue(value) {
    this.setProperty("checked", value);
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵCheckboxControlValueAccessor_BaseFactory;
    return function CheckboxControlValueAccessor_Factory(__ngFactoryType__) {
      return (ɵCheckboxControlValueAccessor_BaseFactory || (ɵCheckboxControlValueAccessor_BaseFactory = ɵɵgetInheritedFactory(_CheckboxControlValueAccessor)))(__ngFactoryType__ || _CheckboxControlValueAccessor);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _CheckboxControlValueAccessor,
    selectors: [["input", "type", "checkbox", "formControlName", ""], ["input", "type", "checkbox", "formControl", ""], ["input", "type", "checkbox", "ngModel", ""]],
    hostBindings: function CheckboxControlValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("change", function CheckboxControlValueAccessor_change_HostBindingHandler($event) {
          return ctx.onChange($event.target.checked);
        })("blur", function CheckboxControlValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    standalone: false,
    features: [ɵɵProvidersFeature([CHECKBOX_VALUE_ACCESSOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckboxControlValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]",
      host: {
        "(change)": "onChange($event.target.checked)",
        "(blur)": "onTouched()"
      },
      providers: [CHECKBOX_VALUE_ACCESSOR],
      standalone: false
    }]
  }], null, null);
})();
var DEFAULT_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => DefaultValueAccessor),
  multi: true
};
function _isAndroid() {
  const userAgent = getDOM() ? getDOM().getUserAgent() : "";
  return /android (\d+)/.test(userAgent.toLowerCase());
}
var COMPOSITION_BUFFER_MODE = new InjectionToken(ngDevMode ? "CompositionEventMode" : "");
var DefaultValueAccessor = class _DefaultValueAccessor extends BaseControlValueAccessor {
  _compositionMode;
  /** Whether the user is creating a composition string (IME events). */
  _composing = false;
  constructor(renderer, elementRef, _compositionMode) {
    super(renderer, elementRef);
    this._compositionMode = _compositionMode;
    if (this._compositionMode == null) {
      this._compositionMode = !_isAndroid();
    }
  }
  /**
   * Sets the "value" property on the input element.
   * @nodoc
   */
  writeValue(value) {
    const normalizedValue = value == null ? "" : value;
    this.setProperty("value", normalizedValue);
  }
  /** @internal */
  _handleInput(value) {
    if (!this._compositionMode || this._compositionMode && !this._composing) {
      this.onChange(value);
    }
  }
  /** @internal */
  _compositionStart() {
    this._composing = true;
  }
  /** @internal */
  _compositionEnd(value) {
    this._composing = false;
    this._compositionMode && this.onChange(value);
  }
  static ɵfac = function DefaultValueAccessor_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DefaultValueAccessor)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(COMPOSITION_BUFFER_MODE, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DefaultValueAccessor,
    selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]],
    hostBindings: function DefaultValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("input", function DefaultValueAccessor_input_HostBindingHandler($event) {
          return ctx._handleInput($event.target.value);
        })("blur", function DefaultValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        })("compositionstart", function DefaultValueAccessor_compositionstart_HostBindingHandler() {
          return ctx._compositionStart();
        })("compositionend", function DefaultValueAccessor_compositionend_HostBindingHandler($event) {
          return ctx._compositionEnd($event.target.value);
        });
      }
    },
    standalone: false,
    features: [ɵɵProvidersFeature([DEFAULT_VALUE_ACCESSOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DefaultValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]",
      // TODO: vsavkin replace the above selector with the one below it once
      // https://github.com/angular/angular/issues/3011 is implemented
      // selector: '[ngModel],[formControl],[formControlName]',
      host: {
        "(input)": "$any(this)._handleInput($event.target.value)",
        "(blur)": "onTouched()",
        "(compositionstart)": "$any(this)._compositionStart()",
        "(compositionend)": "$any(this)._compositionEnd($event.target.value)"
      },
      providers: [DEFAULT_VALUE_ACCESSOR],
      standalone: false
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [COMPOSITION_BUFFER_MODE]
    }]
  }], null);
})();
function isEmptyInputValue(value) {
  return value == null || lengthOrSize(value) === 0;
}
function lengthOrSize(value) {
  if (value == null) {
    return null;
  } else if (Array.isArray(value) || typeof value === "string") {
    return value.length;
  } else if (value instanceof Set) {
    return value.size;
  }
  return null;
}
var NG_VALIDATORS = new InjectionToken(ngDevMode ? "NgValidators" : "");
var NG_ASYNC_VALIDATORS = new InjectionToken(ngDevMode ? "NgAsyncValidators" : "");
var EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
function minValidator(min2) {
  return (control) => {
    if (control.value == null || min2 == null) {
      return null;
    }
    const value = parseFloat(control.value);
    return !isNaN(value) && value < min2 ? {
      "min": {
        "min": min2,
        "actual": control.value
      }
    } : null;
  };
}
function maxValidator(max2) {
  return (control) => {
    if (control.value == null || max2 == null) {
      return null;
    }
    const value = parseFloat(control.value);
    return !isNaN(value) && value > max2 ? {
      "max": {
        "max": max2,
        "actual": control.value
      }
    } : null;
  };
}
function requiredValidator(control) {
  return isEmptyInputValue(control.value) ? {
    "required": true
  } : null;
}
function requiredTrueValidator(control) {
  return control.value === true ? null : {
    "required": true
  };
}
function emailValidator(control) {
  if (isEmptyInputValue(control.value)) {
    return null;
  }
  return EMAIL_REGEXP.test(control.value) ? null : {
    "email": true
  };
}
function minLengthValidator(minLength) {
  return (control) => {
    const length = control.value?.length ?? lengthOrSize(control.value);
    if (length === null || length === 0) {
      return null;
    }
    return length < minLength ? {
      "minlength": {
        "requiredLength": minLength,
        "actualLength": length
      }
    } : null;
  };
}
function maxLengthValidator(maxLength) {
  return (control) => {
    const length = control.value?.length ?? lengthOrSize(control.value);
    if (length !== null && length > maxLength) {
      return {
        "maxlength": {
          "requiredLength": maxLength,
          "actualLength": length
        }
      };
    }
    return null;
  };
}
function patternValidator(pattern) {
  if (!pattern) return nullValidator;
  let regex;
  let regexStr;
  if (typeof pattern === "string") {
    regexStr = "";
    if (pattern.charAt(0) !== "^") regexStr += "^";
    regexStr += pattern;
    if (pattern.charAt(pattern.length - 1) !== "$") regexStr += "$";
    regex = new RegExp(regexStr);
  } else {
    regexStr = pattern.toString();
    regex = pattern;
  }
  return (control) => {
    if (isEmptyInputValue(control.value)) {
      return null;
    }
    const value = control.value;
    return regex.test(value) ? null : {
      "pattern": {
        "requiredPattern": regexStr,
        "actualValue": value
      }
    };
  };
}
function nullValidator(control) {
  return null;
}
function isPresent(o) {
  return o != null;
}
function toObservable(value) {
  const obs = isPromise(value) ? from(value) : value;
  if ((typeof ngDevMode === "undefined" || ngDevMode) && !isSubscribable(obs)) {
    let errorMessage = `Expected async validator to return Promise or Observable.`;
    if (typeof value === "object") {
      errorMessage += " Are you using a synchronous validator where an async validator is expected?";
    }
    throw new RuntimeError(-1101, errorMessage);
  }
  return obs;
}
function mergeErrors(arrayOfErrors) {
  let res = {};
  arrayOfErrors.forEach((errors) => {
    res = errors != null ? __spreadValues(__spreadValues({}, res), errors) : res;
  });
  return Object.keys(res).length === 0 ? null : res;
}
function executeValidators(control, validators) {
  return validators.map((validator) => validator(control));
}
function isValidatorFn(validator) {
  return !validator.validate;
}
function normalizeValidators(validators) {
  return validators.map((validator) => {
    return isValidatorFn(validator) ? validator : (c) => validator.validate(c);
  });
}
function compose(validators) {
  if (!validators) return null;
  const presentValidators = validators.filter(isPresent);
  if (presentValidators.length == 0) return null;
  return function(control) {
    return mergeErrors(executeValidators(control, presentValidators));
  };
}
function composeValidators(validators) {
  return validators != null ? compose(normalizeValidators(validators)) : null;
}
function composeAsync(validators) {
  if (!validators) return null;
  const presentValidators = validators.filter(isPresent);
  if (presentValidators.length == 0) return null;
  return function(control) {
    const observables = executeValidators(control, presentValidators).map(toObservable);
    return forkJoin(observables).pipe(map(mergeErrors));
  };
}
function composeAsyncValidators(validators) {
  return validators != null ? composeAsync(normalizeValidators(validators)) : null;
}
function mergeValidators(controlValidators, dirValidator) {
  if (controlValidators === null) return [dirValidator];
  return Array.isArray(controlValidators) ? [...controlValidators, dirValidator] : [controlValidators, dirValidator];
}
function getControlValidators(control) {
  return control._rawValidators;
}
function getControlAsyncValidators(control) {
  return control._rawAsyncValidators;
}
function makeValidatorsArray(validators) {
  if (!validators) return [];
  return Array.isArray(validators) ? validators : [validators];
}
function hasValidator(validators, validator) {
  return Array.isArray(validators) ? validators.includes(validator) : validators === validator;
}
function addValidators(validators, currentValidators) {
  const current = makeValidatorsArray(currentValidators);
  const validatorsToAdd = makeValidatorsArray(validators);
  validatorsToAdd.forEach((v) => {
    if (!hasValidator(current, v)) {
      current.push(v);
    }
  });
  return current;
}
function removeValidators(validators, currentValidators) {
  return makeValidatorsArray(currentValidators).filter((v) => !hasValidator(validators, v));
}
var AbstractControlDirective = class {
  /**
   * @description
   * Reports the value of the control if it is present, otherwise null.
   */
  get value() {
    return this.control ? this.control.value : null;
  }
  /**
   * @description
   * Reports whether the control is valid. A control is considered valid if no
   * validation errors exist with the current value.
   * If the control is not present, null is returned.
   */
  get valid() {
    return this.control ? this.control.valid : null;
  }
  /**
   * @description
   * Reports whether the control is invalid, meaning that an error exists in the input value.
   * If the control is not present, null is returned.
   */
  get invalid() {
    return this.control ? this.control.invalid : null;
  }
  /**
   * @description
   * Reports whether a control is pending, meaning that async validation is occurring and
   * errors are not yet available for the input value. If the control is not present, null is
   * returned.
   */
  get pending() {
    return this.control ? this.control.pending : null;
  }
  /**
   * @description
   * Reports whether the control is disabled, meaning that the control is disabled
   * in the UI and is exempt from validation checks and excluded from aggregate
   * values of ancestor controls. If the control is not present, null is returned.
   */
  get disabled() {
    return this.control ? this.control.disabled : null;
  }
  /**
   * @description
   * Reports whether the control is enabled, meaning that the control is included in ancestor
   * calculations of validity or value. If the control is not present, null is returned.
   */
  get enabled() {
    return this.control ? this.control.enabled : null;
  }
  /**
   * @description
   * Reports the control's validation errors. If the control is not present, null is returned.
   */
  get errors() {
    return this.control ? this.control.errors : null;
  }
  /**
   * @description
   * Reports whether the control is pristine, meaning that the user has not yet changed
   * the value in the UI. If the control is not present, null is returned.
   */
  get pristine() {
    return this.control ? this.control.pristine : null;
  }
  /**
   * @description
   * Reports whether the control is dirty, meaning that the user has changed
   * the value in the UI. If the control is not present, null is returned.
   */
  get dirty() {
    return this.control ? this.control.dirty : null;
  }
  /**
   * @description
   * Reports whether the control is touched, meaning that the user has triggered
   * a `blur` event on it. If the control is not present, null is returned.
   */
  get touched() {
    return this.control ? this.control.touched : null;
  }
  /**
   * @description
   * Reports the validation status of the control. Possible values include:
   * 'VALID', 'INVALID', 'DISABLED', and 'PENDING'.
   * If the control is not present, null is returned.
   */
  get status() {
    return this.control ? this.control.status : null;
  }
  /**
   * @description
   * Reports whether the control is untouched, meaning that the user has not yet triggered
   * a `blur` event on it. If the control is not present, null is returned.
   */
  get untouched() {
    return this.control ? this.control.untouched : null;
  }
  /**
   * @description
   * Returns a multicasting observable that emits a validation status whenever it is
   * calculated for the control. If the control is not present, null is returned.
   */
  get statusChanges() {
    return this.control ? this.control.statusChanges : null;
  }
  /**
   * @description
   * Returns a multicasting observable of value changes for the control that emits every time the
   * value of the control changes in the UI or programmatically.
   * If the control is not present, null is returned.
   */
  get valueChanges() {
    return this.control ? this.control.valueChanges : null;
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return null;
  }
  /**
   * Contains the result of merging synchronous validators into a single validator function
   * (combined using `Validators.compose`).
   */
  _composedValidatorFn;
  /**
   * Contains the result of merging asynchronous validators into a single validator function
   * (combined using `Validators.composeAsync`).
   */
  _composedAsyncValidatorFn;
  /**
   * Set of synchronous validators as they were provided while calling `setValidators` function.
   * @internal
   */
  _rawValidators = [];
  /**
   * Set of asynchronous validators as they were provided while calling `setAsyncValidators`
   * function.
   * @internal
   */
  _rawAsyncValidators = [];
  /**
   * Sets synchronous validators for this directive.
   * @internal
   */
  _setValidators(validators) {
    this._rawValidators = validators || [];
    this._composedValidatorFn = composeValidators(this._rawValidators);
  }
  /**
   * Sets asynchronous validators for this directive.
   * @internal
   */
  _setAsyncValidators(validators) {
    this._rawAsyncValidators = validators || [];
    this._composedAsyncValidatorFn = composeAsyncValidators(this._rawAsyncValidators);
  }
  /**
   * @description
   * Synchronous validator function composed of all the synchronous validators registered with this
   * directive.
   */
  get validator() {
    return this._composedValidatorFn || null;
  }
  /**
   * @description
   * Asynchronous validator function composed of all the asynchronous validators registered with
   * this directive.
   */
  get asyncValidator() {
    return this._composedAsyncValidatorFn || null;
  }
  /*
   * The set of callbacks to be invoked when directive instance is being destroyed.
   */
  _onDestroyCallbacks = [];
  /**
   * Internal function to register callbacks that should be invoked
   * when directive instance is being destroyed.
   * @internal
   */
  _registerOnDestroy(fn) {
    this._onDestroyCallbacks.push(fn);
  }
  /**
   * Internal function to invoke all registered "on destroy" callbacks.
   * Note: calling this function also clears the list of callbacks.
   * @internal
   */
  _invokeOnDestroyCallbacks() {
    this._onDestroyCallbacks.forEach((fn) => fn());
    this._onDestroyCallbacks = [];
  }
  /**
   * @description
   * Resets the control with the provided value if the control is present.
   */
  reset(value = void 0) {
    if (this.control) this.control.reset(value);
  }
  /**
   * @description
   * Reports whether the control with the given path has the error specified.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   * @usageNotes
   * For example, for the following `FormGroup`:
   *
   * ```ts
   * form = new FormGroup({
   *   address: new FormGroup({ street: new FormControl() })
   * });
   * ```
   *
   * The path to the 'street' control from the root form would be 'address' -> 'street'.
   *
   * It can be provided to this method in one of two formats:
   *
   * 1. An array of string control names, e.g. `['address', 'street']`
   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
   *
   * If no path is given, this method checks for the error on the current control.
   *
   * @returns whether the given error is present in the control at the given path.
   *
   * If the control is not present, false is returned.
   */
  hasError(errorCode, path) {
    return this.control ? this.control.hasError(errorCode, path) : false;
  }
  /**
   * @description
   * Reports error data for the control with the given path.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   * @usageNotes
   * For example, for the following `FormGroup`:
   *
   * ```ts
   * form = new FormGroup({
   *   address: new FormGroup({ street: new FormControl() })
   * });
   * ```
   *
   * The path to the 'street' control from the root form would be 'address' -> 'street'.
   *
   * It can be provided to this method in one of two formats:
   *
   * 1. An array of string control names, e.g. `['address', 'street']`
   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
   *
   * @returns error data for that particular error. If the control or error is not present,
   * null is returned.
   */
  getError(errorCode, path) {
    return this.control ? this.control.getError(errorCode, path) : null;
  }
};
var ControlContainer = class extends AbstractControlDirective {
  /**
   * @description
   * The name for the control
   */
  // TODO(issue/24571): remove '!'.
  name;
  /**
   * @description
   * The top-level form directive for the control.
   */
  get formDirective() {
    return null;
  }
  /**
   * @description
   * The path to this group.
   */
  get path() {
    return null;
  }
};
var NgControl = class extends AbstractControlDirective {
  /**
   * @description
   * The parent form for the control.
   *
   * @internal
   */
  _parent = null;
  /**
   * @description
   * The name for the control
   */
  name = null;
  /**
   * @description
   * The value accessor for the control
   */
  valueAccessor = null;
};
var AbstractControlStatus = class {
  _cd;
  constructor(cd) {
    this._cd = cd;
  }
  get isTouched() {
    this._cd?.control?._touched?.();
    return !!this._cd?.control?.touched;
  }
  get isUntouched() {
    return !!this._cd?.control?.untouched;
  }
  get isPristine() {
    this._cd?.control?._pristine?.();
    return !!this._cd?.control?.pristine;
  }
  get isDirty() {
    return !!this._cd?.control?.dirty;
  }
  get isValid() {
    this._cd?.control?._status?.();
    return !!this._cd?.control?.valid;
  }
  get isInvalid() {
    return !!this._cd?.control?.invalid;
  }
  get isPending() {
    return !!this._cd?.control?.pending;
  }
  get isSubmitted() {
    this._cd?._submitted?.();
    return !!this._cd?.submitted;
  }
};
var ngControlStatusHost = {
  "[class.ng-untouched]": "isUntouched",
  "[class.ng-touched]": "isTouched",
  "[class.ng-pristine]": "isPristine",
  "[class.ng-dirty]": "isDirty",
  "[class.ng-valid]": "isValid",
  "[class.ng-invalid]": "isInvalid",
  "[class.ng-pending]": "isPending"
};
var ngGroupStatusHost = __spreadProps(__spreadValues({}, ngControlStatusHost), {
  "[class.ng-submitted]": "isSubmitted"
});
var NgControlStatus = class _NgControlStatus extends AbstractControlStatus {
  constructor(cd) {
    super(cd);
  }
  static ɵfac = function NgControlStatus_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgControlStatus)(ɵɵdirectiveInject(NgControl, 2));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _NgControlStatus,
    selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]],
    hostVars: 14,
    hostBindings: function NgControlStatus_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("ng-untouched", ctx.isUntouched)("ng-touched", ctx.isTouched)("ng-pristine", ctx.isPristine)("ng-dirty", ctx.isDirty)("ng-valid", ctx.isValid)("ng-invalid", ctx.isInvalid)("ng-pending", ctx.isPending);
      }
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgControlStatus, [{
    type: Directive,
    args: [{
      selector: "[formControlName],[ngModel],[formControl]",
      host: ngControlStatusHost,
      standalone: false
    }]
  }], () => [{
    type: NgControl,
    decorators: [{
      type: Self
    }]
  }], null);
})();
var NgControlStatusGroup = class _NgControlStatusGroup extends AbstractControlStatus {
  constructor(cd) {
    super(cd);
  }
  static ɵfac = function NgControlStatusGroup_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgControlStatusGroup)(ɵɵdirectiveInject(ControlContainer, 10));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _NgControlStatusGroup,
    selectors: [["", "formGroupName", ""], ["", "formArrayName", ""], ["", "ngModelGroup", ""], ["", "formGroup", ""], ["form", 3, "ngNoForm", ""], ["", "ngForm", ""]],
    hostVars: 16,
    hostBindings: function NgControlStatusGroup_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("ng-untouched", ctx.isUntouched)("ng-touched", ctx.isTouched)("ng-pristine", ctx.isPristine)("ng-dirty", ctx.isDirty)("ng-valid", ctx.isValid)("ng-invalid", ctx.isInvalid)("ng-pending", ctx.isPending)("ng-submitted", ctx.isSubmitted);
      }
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgControlStatusGroup, [{
    type: Directive,
    args: [{
      selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]",
      host: ngGroupStatusHost,
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }]
  }], null);
})();
var formControlNameExample = `
  <div [formGroup]="myGroup">
    <input formControlName="firstName">
  </div>

  In your class:

  this.myGroup = new FormGroup({
      firstName: new FormControl()
  });`;
var formGroupNameExample = `
  <div [formGroup]="myGroup">
      <div formGroupName="person">
        <input formControlName="firstName">
      </div>
  </div>

  In your class:

  this.myGroup = new FormGroup({
      person: new FormGroup({ firstName: new FormControl() })
  });`;
var formArrayNameExample = `
  <div [formGroup]="myGroup">
    <div formArrayName="cities">
      <div *ngFor="let city of cityArray.controls; index as i">
        <input [formControlName]="i">
      </div>
    </div>
  </div>

  In your class:

  this.cityArray = new FormArray([new FormControl('SF')]);
  this.myGroup = new FormGroup({
    cities: this.cityArray
  });`;
var ngModelGroupExample = `
  <form>
      <div ngModelGroup="person">
        <input [(ngModel)]="person.name" name="firstName">
      </div>
  </form>`;
var ngModelWithFormGroupExample = `
  <div [formGroup]="myGroup">
      <input formControlName="firstName">
      <input [(ngModel)]="showMoreControls" [ngModelOptions]="{standalone: true}">
  </div>
`;
function controlParentException(nameOrIndex) {
  return new RuntimeError(1050, `formControlName must be used with a parent formGroup directive. You'll want to add a formGroup
      directive and pass it an existing FormGroup instance (you can create one in your class).

      ${describeFormControl(nameOrIndex)}

    Example:

    ${formControlNameExample}`);
}
function describeFormControl(nameOrIndex) {
  if (nameOrIndex == null || nameOrIndex === "") {
    return "";
  }
  const valueType = typeof nameOrIndex === "string" ? "name" : "index";
  return `Affected Form Control ${valueType}: "${nameOrIndex}"`;
}
function ngModelGroupException() {
  return new RuntimeError(1051, `formControlName cannot be used with an ngModelGroup parent. It is only compatible with parents
      that also have a "form" prefix: formGroupName, formArrayName, or formGroup.

      Option 1:  Update the parent to be formGroupName (reactive form strategy)

      ${formGroupNameExample}

      Option 2: Use ngModel instead of formControlName (template-driven strategy)

      ${ngModelGroupExample}`);
}
function missingFormException() {
  return new RuntimeError(1052, `formGroup expects a FormGroup instance. Please pass one in.

      Example:

      ${formControlNameExample}`);
}
function groupParentException() {
  return new RuntimeError(1053, `formGroupName must be used with a parent formGroup directive.  You'll want to add a formGroup
    directive and pass it an existing FormGroup instance (you can create one in your class).

    Example:

    ${formGroupNameExample}`);
}
function arrayParentException() {
  return new RuntimeError(1054, `formArrayName must be used with a parent formGroup directive.  You'll want to add a formGroup
      directive and pass it an existing FormGroup instance (you can create one in your class).

      Example:

      ${formArrayNameExample}`);
}
var disabledAttrWarning = `
  It looks like you're using the disabled attribute with a reactive form directive. If you set disabled to true
  when you set up this control in your component class, the disabled attribute will actually be set in the DOM for
  you. We recommend using this approach to avoid 'changed after checked' errors.

  Example:
  // Specify the \`disabled\` property at control creation time:
  form = new FormGroup({
    first: new FormControl({value: 'Nancy', disabled: true}, Validators.required),
    last: new FormControl('Drew', Validators.required)
  });

  // Controls can also be enabled/disabled after creation:
  form.get('first')?.enable();
  form.get('last')?.disable();
`;
var asyncValidatorsDroppedWithOptsWarning = `
  It looks like you're constructing using a FormControl with both an options argument and an
  async validators argument. Mixing these arguments will cause your async validators to be dropped.
  You should either put all your validators in the options object, or in separate validators
  arguments. For example:

  // Using validators arguments
  fc = new FormControl(42, Validators.required, myAsyncValidator);

  // Using AbstractControlOptions
  fc = new FormControl(42, {validators: Validators.required, asyncValidators: myAV});

  // Do NOT mix them: async validators will be dropped!
  fc = new FormControl(42, {validators: Validators.required}, /* Oops! */ myAsyncValidator);
`;
function ngModelWarning(directiveName) {
  return `
  It looks like you're using ngModel on the same form field as ${directiveName}.
  Support for using the ngModel input property and ngModelChange event with
  reactive form directives has been deprecated in Angular v6 and will be removed
  in a future version of Angular.

  For more information on this, see our API docs here:
  https://angular.io/api/forms/${directiveName === "formControl" ? "FormControlDirective" : "FormControlName"}#use-with-ngmodel
  `;
}
function describeKey(isFormGroup, key) {
  return isFormGroup ? `with name: '${key}'` : `at index: ${key}`;
}
function noControlsError(isFormGroup) {
  return `
    There are no form controls registered with this ${isFormGroup ? "group" : "array"} yet. If you're using ngModel,
    you may want to check next tick (e.g. use setTimeout).
  `;
}
function missingControlError(isFormGroup, key) {
  return `Cannot find form control ${describeKey(isFormGroup, key)}`;
}
function missingControlValueError(isFormGroup, key) {
  return `Must supply a value for form control ${describeKey(isFormGroup, key)}`;
}
var VALID = "VALID";
var INVALID = "INVALID";
var PENDING = "PENDING";
var DISABLED = "DISABLED";
var ControlEvent = class {
};
var ValueChangeEvent = class extends ControlEvent {
  value;
  source;
  constructor(value, source) {
    super();
    this.value = value;
    this.source = source;
  }
};
var PristineChangeEvent = class extends ControlEvent {
  pristine;
  source;
  constructor(pristine, source) {
    super();
    this.pristine = pristine;
    this.source = source;
  }
};
var TouchedChangeEvent = class extends ControlEvent {
  touched;
  source;
  constructor(touched, source) {
    super();
    this.touched = touched;
    this.source = source;
  }
};
var StatusChangeEvent = class extends ControlEvent {
  status;
  source;
  constructor(status, source) {
    super();
    this.status = status;
    this.source = source;
  }
};
var FormSubmittedEvent = class extends ControlEvent {
  source;
  constructor(source) {
    super();
    this.source = source;
  }
};
var FormResetEvent = class extends ControlEvent {
  source;
  constructor(source) {
    super();
    this.source = source;
  }
};
function pickValidators(validatorOrOpts) {
  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.validators : validatorOrOpts) || null;
}
function coerceToValidator(validator) {
  return Array.isArray(validator) ? composeValidators(validator) : validator || null;
}
function pickAsyncValidators(asyncValidator, validatorOrOpts) {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (isOptionsObj(validatorOrOpts) && asyncValidator) {
      console.warn(asyncValidatorsDroppedWithOptsWarning);
    }
  }
  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.asyncValidators : asyncValidator) || null;
}
function coerceToAsyncValidator(asyncValidator) {
  return Array.isArray(asyncValidator) ? composeAsyncValidators(asyncValidator) : asyncValidator || null;
}
function isOptionsObj(validatorOrOpts) {
  return validatorOrOpts != null && !Array.isArray(validatorOrOpts) && typeof validatorOrOpts === "object";
}
function assertControlPresent(parent, isGroup, key) {
  const controls = parent.controls;
  const collection = isGroup ? Object.keys(controls) : controls;
  if (!collection.length) {
    throw new RuntimeError(1e3, typeof ngDevMode === "undefined" || ngDevMode ? noControlsError(isGroup) : "");
  }
  if (!controls[key]) {
    throw new RuntimeError(1001, typeof ngDevMode === "undefined" || ngDevMode ? missingControlError(isGroup, key) : "");
  }
}
function assertAllValuesPresent(control, isGroup, value) {
  control._forEachChild((_, key) => {
    if (value[key] === void 0) {
      throw new RuntimeError(1002, typeof ngDevMode === "undefined" || ngDevMode ? missingControlValueError(isGroup, key) : "");
    }
  });
}
var AbstractControl = class {
  /** @internal */
  _pendingDirty = false;
  /**
   * Indicates that a control has its own pending asynchronous validation in progress.
   * It also stores if the control should emit events when the validation status changes.
   *
   * @internal
   */
  _hasOwnPendingAsyncValidator = null;
  /** @internal */
  _pendingTouched = false;
  /** @internal */
  _onCollectionChange = () => {
  };
  /** @internal */
  _updateOn;
  _parent = null;
  _asyncValidationSubscription;
  /**
   * Contains the result of merging synchronous validators into a single validator function
   * (combined using `Validators.compose`).
   *
   * @internal
   */
  _composedValidatorFn;
  /**
   * Contains the result of merging asynchronous validators into a single validator function
   * (combined using `Validators.composeAsync`).
   *
   * @internal
   */
  _composedAsyncValidatorFn;
  /**
   * Synchronous validators as they were provided:
   *  - in `AbstractControl` constructor
   *  - as an argument while calling `setValidators` function
   *  - while calling the setter on the `validator` field (e.g. `control.validator = validatorFn`)
   *
   * @internal
   */
  _rawValidators;
  /**
   * Asynchronous validators as they were provided:
   *  - in `AbstractControl` constructor
   *  - as an argument while calling `setAsyncValidators` function
   *  - while calling the setter on the `asyncValidator` field (e.g. `control.asyncValidator =
   * asyncValidatorFn`)
   *
   * @internal
   */
  _rawAsyncValidators;
  /**
   * The current value of the control.
   *
   * * For a `FormControl`, the current value.
   * * For an enabled `FormGroup`, the values of enabled controls as an object
   * with a key-value pair for each member of the group.
   * * For a disabled `FormGroup`, the values of all controls as an object
   * with a key-value pair for each member of the group.
   * * For a `FormArray`, the values of enabled controls as an array.
   *
   */
  value;
  /**
   * Initialize the AbstractControl instance.
   *
   * @param validators The function or array of functions that is used to determine the validity of
   *     this control synchronously.
   * @param asyncValidators The function or array of functions that is used to determine validity of
   *     this control asynchronously.
   */
  constructor(validators, asyncValidators) {
    this._assignValidators(validators);
    this._assignAsyncValidators(asyncValidators);
  }
  /**
   * Returns the function that is used to determine the validity of this control synchronously.
   * If multiple validators have been added, this will be a single composed function.
   * See `Validators.compose()` for additional information.
   */
  get validator() {
    return this._composedValidatorFn;
  }
  set validator(validatorFn) {
    this._rawValidators = this._composedValidatorFn = validatorFn;
  }
  /**
   * Returns the function that is used to determine the validity of this control asynchronously.
   * If multiple validators have been added, this will be a single composed function.
   * See `Validators.compose()` for additional information.
   */
  get asyncValidator() {
    return this._composedAsyncValidatorFn;
  }
  set asyncValidator(asyncValidatorFn) {
    this._rawAsyncValidators = this._composedAsyncValidatorFn = asyncValidatorFn;
  }
  /**
   * The parent control.
   */
  get parent() {
    return this._parent;
  }
  /**
   * The validation status of the control.
   *
   * @see {@link FormControlStatus}
   *
   * These status values are mutually exclusive, so a control cannot be
   * both valid AND invalid or invalid AND disabled.
   */
  get status() {
    return untracked(this.statusReactive);
  }
  set status(v) {
    untracked(() => this.statusReactive.set(v));
  }
  /** @internal */
  _status = computed(() => this.statusReactive());
  statusReactive = signal(void 0);
  /**
   * A control is `valid` when its `status` is `VALID`.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if the control has passed all of its validation tests,
   * false otherwise.
   */
  get valid() {
    return this.status === VALID;
  }
  /**
   * A control is `invalid` when its `status` is `INVALID`.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if this control has failed one or more of its validation checks,
   * false otherwise.
   */
  get invalid() {
    return this.status === INVALID;
  }
  /**
   * A control is `pending` when its `status` is `PENDING`.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if this control is in the process of conducting a validation check,
   * false otherwise.
   */
  get pending() {
    return this.status == PENDING;
  }
  /**
   * A control is `disabled` when its `status` is `DISABLED`.
   *
   * Disabled controls are exempt from validation checks and
   * are not included in the aggregate value of their ancestor
   * controls.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if the control is disabled, false otherwise.
   */
  get disabled() {
    return this.status === DISABLED;
  }
  /**
   * A control is `enabled` as long as its `status` is not `DISABLED`.
   *
   * @returns True if the control has any status other than 'DISABLED',
   * false if the status is 'DISABLED'.
   *
   * @see {@link AbstractControl.status}
   *
   */
  get enabled() {
    return this.status !== DISABLED;
  }
  /**
   * An object containing any errors generated by failing validation,
   * or null if there are no errors.
   */
  errors;
  /**
   * A control is `pristine` if the user has not yet changed
   * the value in the UI.
   *
   * @returns True if the user has not yet changed the value in the UI; compare `dirty`.
   * Programmatic changes to a control's value do not mark it dirty.
   */
  get pristine() {
    return untracked(this.pristineReactive);
  }
  set pristine(v) {
    untracked(() => this.pristineReactive.set(v));
  }
  /** @internal */
  _pristine = computed(() => this.pristineReactive());
  pristineReactive = signal(true);
  /**
   * A control is `dirty` if the user has changed the value
   * in the UI.
   *
   * @returns True if the user has changed the value of this control in the UI; compare `pristine`.
   * Programmatic changes to a control's value do not mark it dirty.
   */
  get dirty() {
    return !this.pristine;
  }
  /**
   * True if the control is marked as `touched`.
   *
   * A control is marked `touched` once the user has triggered
   * a `blur` event on it.
   */
  get touched() {
    return untracked(this.touchedReactive);
  }
  set touched(v) {
    untracked(() => this.touchedReactive.set(v));
  }
  /** @internal */
  _touched = computed(() => this.touchedReactive());
  touchedReactive = signal(false);
  /**
   * True if the control has not been marked as touched
   *
   * A control is `untouched` if the user has not yet triggered
   * a `blur` event on it.
   */
  get untouched() {
    return !this.touched;
  }
  /**
   * Exposed as observable, see below.
   *
   * @internal
   */
  _events = new Subject();
  /**
   * A multicasting observable that emits an event every time the state of the control changes.
   * It emits for value, status, pristine or touched changes.
   *
   * **Note**: On value change, the emit happens right after a value of this control is updated. The
   * value of a parent control (for example if this FormControl is a part of a FormGroup) is updated
   * later, so accessing a value of a parent control (using the `value` property) from the callback
   * of this event might result in getting a value that has not been updated yet. Subscribe to the
   * `events` of the parent control instead.
   * For other event types, the events are emitted after the parent control has been updated.
   *
   */
  events = this._events.asObservable();
  /**
   * A multicasting observable that emits an event every time the value of the control changes, in
   * the UI or programmatically. It also emits an event each time you call enable() or disable()
   * without passing along {emitEvent: false} as a function argument.
   *
   * **Note**: the emit happens right after a value of this control is updated. The value of a
   * parent control (for example if this FormControl is a part of a FormGroup) is updated later, so
   * accessing a value of a parent control (using the `value` property) from the callback of this
   * event might result in getting a value that has not been updated yet. Subscribe to the
   * `valueChanges` event of the parent control instead.
   */
  valueChanges;
  /**
   * A multicasting observable that emits an event every time the validation `status` of the control
   * recalculates.
   *
   * @see {@link FormControlStatus}
   * @see {@link AbstractControl.status}
   */
  statusChanges;
  /**
   * Reports the update strategy of the `AbstractControl` (meaning
   * the event on which the control updates itself).
   * Possible values: `'change'` | `'blur'` | `'submit'`
   * Default value: `'change'`
   */
  get updateOn() {
    return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change";
  }
  /**
   * Sets the synchronous validators that are active on this control.  Calling
   * this overwrites any existing synchronous validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * If you want to add a new validator without affecting existing ones, consider
   * using `addValidators()` method instead.
   */
  setValidators(validators) {
    this._assignValidators(validators);
  }
  /**
   * Sets the asynchronous validators that are active on this control. Calling this
   * overwrites any existing asynchronous validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * If you want to add a new validator without affecting existing ones, consider
   * using `addAsyncValidators()` method instead.
   */
  setAsyncValidators(validators) {
    this._assignAsyncValidators(validators);
  }
  /**
   * Add a synchronous validator or validators to this control, without affecting other validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * Adding a validator that already exists will have no effect. If duplicate validator functions
   * are present in the `validators` array, only the first instance would be added to a form
   * control.
   *
   * @param validators The new validator function or functions to add to this control.
   */
  addValidators(validators) {
    this.setValidators(addValidators(validators, this._rawValidators));
  }
  /**
   * Add an asynchronous validator or validators to this control, without affecting other
   * validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * Adding a validator that already exists will have no effect.
   *
   * @param validators The new asynchronous validator function or functions to add to this control.
   */
  addAsyncValidators(validators) {
    this.setAsyncValidators(addValidators(validators, this._rawAsyncValidators));
  }
  /**
   * Remove a synchronous validator from this control, without affecting other validators.
   * Validators are compared by function reference; you must pass a reference to the exact same
   * validator function as the one that was originally set. If a provided validator is not found,
   * it is ignored.
   *
   * @usageNotes
   *
   * ### Reference to a ValidatorFn
   *
   * ```
   * // Reference to the RequiredValidator
   * const ctrl = new FormControl<string | null>('', Validators.required);
   * ctrl.removeValidators(Validators.required);
   *
   * // Reference to anonymous function inside MinValidator
   * const minValidator = Validators.min(3);
   * const ctrl = new FormControl<string | null>('', minValidator);
   * expect(ctrl.hasValidator(minValidator)).toEqual(true)
   * expect(ctrl.hasValidator(Validators.min(3))).toEqual(false)
   *
   * ctrl.removeValidators(minValidator);
   * ```
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * @param validators The validator or validators to remove.
   */
  removeValidators(validators) {
    this.setValidators(removeValidators(validators, this._rawValidators));
  }
  /**
   * Remove an asynchronous validator from this control, without affecting other validators.
   * Validators are compared by function reference; you must pass a reference to the exact same
   * validator function as the one that was originally set. If a provided validator is not found, it
   * is ignored.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * @param validators The asynchronous validator or validators to remove.
   */
  removeAsyncValidators(validators) {
    this.setAsyncValidators(removeValidators(validators, this._rawAsyncValidators));
  }
  /**
   * Check whether a synchronous validator function is present on this control. The provided
   * validator must be a reference to the exact same function that was provided.
   *
   * @usageNotes
   *
   * ### Reference to a ValidatorFn
   *
   * ```
   * // Reference to the RequiredValidator
   * const ctrl = new FormControl<number | null>(0, Validators.required);
   * expect(ctrl.hasValidator(Validators.required)).toEqual(true)
   *
   * // Reference to anonymous function inside MinValidator
   * const minValidator = Validators.min(3);
   * const ctrl = new FormControl<number | null>(0, minValidator);
   * expect(ctrl.hasValidator(minValidator)).toEqual(true)
   * expect(ctrl.hasValidator(Validators.min(3))).toEqual(false)
   * ```
   *
   * @param validator The validator to check for presence. Compared by function reference.
   * @returns Whether the provided validator was found on this control.
   */
  hasValidator(validator) {
    return hasValidator(this._rawValidators, validator);
  }
  /**
   * Check whether an asynchronous validator function is present on this control. The provided
   * validator must be a reference to the exact same function that was provided.
   *
   * @param validator The asynchronous validator to check for presence. Compared by function
   *     reference.
   * @returns Whether the provided asynchronous validator was found on this control.
   */
  hasAsyncValidator(validator) {
    return hasValidator(this._rawAsyncValidators, validator);
  }
  /**
   * Empties out the synchronous validator list.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   */
  clearValidators() {
    this.validator = null;
  }
  /**
   * Empties out the async validator list.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   */
  clearAsyncValidators() {
    this.asyncValidator = null;
  }
  markAsTouched(opts = {}) {
    const changed = this.touched === false;
    this.touched = true;
    const sourceControl = opts.sourceControl ?? this;
    if (this._parent && !opts.onlySelf) {
      this._parent.markAsTouched(__spreadProps(__spreadValues({}, opts), {
        sourceControl
      }));
    }
    if (changed && opts.emitEvent !== false) {
      this._events.next(new TouchedChangeEvent(true, sourceControl));
    }
  }
  /**
   * Marks the control and all its descendant controls as `touched`.
   * @see {@link markAsTouched()}
   *
   * @param opts Configuration options that determine how the control propagates changes
   * and emits events after marking is applied.
   * * `emitEvent`: When true or not supplied (the default), the `events`
   * observable emits a `TouchedChangeEvent` with the `touched` property being `true`.
   * When false, no events are emitted.
   */
  markAllAsTouched(opts = {}) {
    this.markAsTouched({
      onlySelf: true,
      emitEvent: opts.emitEvent,
      sourceControl: this
    });
    this._forEachChild((control) => control.markAllAsTouched(opts));
  }
  markAsUntouched(opts = {}) {
    const changed = this.touched === true;
    this.touched = false;
    this._pendingTouched = false;
    const sourceControl = opts.sourceControl ?? this;
    this._forEachChild((control) => {
      control.markAsUntouched({
        onlySelf: true,
        emitEvent: opts.emitEvent,
        sourceControl
      });
    });
    if (this._parent && !opts.onlySelf) {
      this._parent._updateTouched(opts, sourceControl);
    }
    if (changed && opts.emitEvent !== false) {
      this._events.next(new TouchedChangeEvent(false, sourceControl));
    }
  }
  markAsDirty(opts = {}) {
    const changed = this.pristine === true;
    this.pristine = false;
    const sourceControl = opts.sourceControl ?? this;
    if (this._parent && !opts.onlySelf) {
      this._parent.markAsDirty(__spreadProps(__spreadValues({}, opts), {
        sourceControl
      }));
    }
    if (changed && opts.emitEvent !== false) {
      this._events.next(new PristineChangeEvent(false, sourceControl));
    }
  }
  markAsPristine(opts = {}) {
    const changed = this.pristine === false;
    this.pristine = true;
    this._pendingDirty = false;
    const sourceControl = opts.sourceControl ?? this;
    this._forEachChild((control) => {
      control.markAsPristine({
        onlySelf: true,
        emitEvent: opts.emitEvent
      });
    });
    if (this._parent && !opts.onlySelf) {
      this._parent._updatePristine(opts, sourceControl);
    }
    if (changed && opts.emitEvent !== false) {
      this._events.next(new PristineChangeEvent(true, sourceControl));
    }
  }
  markAsPending(opts = {}) {
    this.status = PENDING;
    const sourceControl = opts.sourceControl ?? this;
    if (opts.emitEvent !== false) {
      this._events.next(new StatusChangeEvent(this.status, sourceControl));
      this.statusChanges.emit(this.status);
    }
    if (this._parent && !opts.onlySelf) {
      this._parent.markAsPending(__spreadProps(__spreadValues({}, opts), {
        sourceControl
      }));
    }
  }
  disable(opts = {}) {
    const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);
    this.status = DISABLED;
    this.errors = null;
    this._forEachChild((control) => {
      control.disable(__spreadProps(__spreadValues({}, opts), {
        onlySelf: true
      }));
    });
    this._updateValue();
    const sourceControl = opts.sourceControl ?? this;
    if (opts.emitEvent !== false) {
      this._events.next(new ValueChangeEvent(this.value, sourceControl));
      this._events.next(new StatusChangeEvent(this.status, sourceControl));
      this.valueChanges.emit(this.value);
      this.statusChanges.emit(this.status);
    }
    this._updateAncestors(__spreadProps(__spreadValues({}, opts), {
      skipPristineCheck
    }), this);
    this._onDisabledChange.forEach((changeFn) => changeFn(true));
  }
  /**
   * Enables the control. This means the control is included in validation checks and
   * the aggregate value of its parent. Its status recalculates based on its value and
   * its validators.
   *
   * By default, if the control has children, all children are enabled.
   *
   * @see {@link AbstractControl.status}
   *
   * @param opts Configure options that control how the control propagates changes and
   * emits events when marked as untouched
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   * * `emitEvent`: When true or not supplied (the default), the `statusChanges`,
   * `valueChanges` and `events`
   * observables emit events with the latest status and value when the control is enabled.
   * When false, no events are emitted.
   */
  enable(opts = {}) {
    const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);
    this.status = VALID;
    this._forEachChild((control) => {
      control.enable(__spreadProps(__spreadValues({}, opts), {
        onlySelf: true
      }));
    });
    this.updateValueAndValidity({
      onlySelf: true,
      emitEvent: opts.emitEvent
    });
    this._updateAncestors(__spreadProps(__spreadValues({}, opts), {
      skipPristineCheck
    }), this);
    this._onDisabledChange.forEach((changeFn) => changeFn(false));
  }
  _updateAncestors(opts, sourceControl) {
    if (this._parent && !opts.onlySelf) {
      this._parent.updateValueAndValidity(opts);
      if (!opts.skipPristineCheck) {
        this._parent._updatePristine({}, sourceControl);
      }
      this._parent._updateTouched({}, sourceControl);
    }
  }
  /**
   * Sets the parent of the control
   *
   * @param parent The new parent.
   */
  setParent(parent) {
    this._parent = parent;
  }
  /**
   * The raw value of this control. For most control implementations, the raw value will include
   * disabled children.
   */
  getRawValue() {
    return this.value;
  }
  updateValueAndValidity(opts = {}) {
    this._setInitialStatus();
    this._updateValue();
    if (this.enabled) {
      const shouldHaveEmitted = this._cancelExistingSubscription();
      this.errors = this._runValidator();
      this.status = this._calculateStatus();
      if (this.status === VALID || this.status === PENDING) {
        this._runAsyncValidator(shouldHaveEmitted, opts.emitEvent);
      }
    }
    const sourceControl = opts.sourceControl ?? this;
    if (opts.emitEvent !== false) {
      this._events.next(new ValueChangeEvent(this.value, sourceControl));
      this._events.next(new StatusChangeEvent(this.status, sourceControl));
      this.valueChanges.emit(this.value);
      this.statusChanges.emit(this.status);
    }
    if (this._parent && !opts.onlySelf) {
      this._parent.updateValueAndValidity(__spreadProps(__spreadValues({}, opts), {
        sourceControl
      }));
    }
  }
  /** @internal */
  _updateTreeValidity(opts = {
    emitEvent: true
  }) {
    this._forEachChild((ctrl) => ctrl._updateTreeValidity(opts));
    this.updateValueAndValidity({
      onlySelf: true,
      emitEvent: opts.emitEvent
    });
  }
  _setInitialStatus() {
    this.status = this._allControlsDisabled() ? DISABLED : VALID;
  }
  _runValidator() {
    return this.validator ? this.validator(this) : null;
  }
  _runAsyncValidator(shouldHaveEmitted, emitEvent) {
    if (this.asyncValidator) {
      this.status = PENDING;
      this._hasOwnPendingAsyncValidator = {
        emitEvent: emitEvent !== false
      };
      const obs = toObservable(this.asyncValidator(this));
      this._asyncValidationSubscription = obs.subscribe((errors) => {
        this._hasOwnPendingAsyncValidator = null;
        this.setErrors(errors, {
          emitEvent,
          shouldHaveEmitted
        });
      });
    }
  }
  _cancelExistingSubscription() {
    if (this._asyncValidationSubscription) {
      this._asyncValidationSubscription.unsubscribe();
      const shouldHaveEmitted = this._hasOwnPendingAsyncValidator?.emitEvent ?? false;
      this._hasOwnPendingAsyncValidator = null;
      return shouldHaveEmitted;
    }
    return false;
  }
  setErrors(errors, opts = {}) {
    this.errors = errors;
    this._updateControlsErrors(opts.emitEvent !== false, this, opts.shouldHaveEmitted);
  }
  /**
   * Retrieves a child control given the control's name or path.
   *
   * @param path A dot-delimited string or array of string/number values that define the path to the
   * control. If a string is provided, passing it as a string literal will result in improved type
   * information. Likewise, if an array is provided, passing it `as const` will cause improved type
   * information to be available.
   *
   * @usageNotes
   * ### Retrieve a nested control
   *
   * For example, to get a `name` control nested within a `person` sub-group:
   *
   * * `this.form.get('person.name');`
   *
   * -OR-
   *
   * * `this.form.get(['person', 'name'] as const);` // `as const` gives improved typings
   *
   * ### Retrieve a control in a FormArray
   *
   * When accessing an element inside a FormArray, you can use an element index.
   * For example, to get a `price` control from the first element in an `items` array you can use:
   *
   * * `this.form.get('items.0.price');`
   *
   * -OR-
   *
   * * `this.form.get(['items', 0, 'price']);`
   */
  get(path) {
    let currPath = path;
    if (currPath == null) return null;
    if (!Array.isArray(currPath)) currPath = currPath.split(".");
    if (currPath.length === 0) return null;
    return currPath.reduce((control, name) => control && control._find(name), this);
  }
  /**
   * @description
   * Reports error data for the control with the given path.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   * @usageNotes
   * For example, for the following `FormGroup`:
   *
   * ```ts
   * form = new FormGroup({
   *   address: new FormGroup({ street: new FormControl() })
   * });
   * ```
   *
   * The path to the 'street' control from the root form would be 'address' -> 'street'.
   *
   * It can be provided to this method in one of two formats:
   *
   * 1. An array of string control names, e.g. `['address', 'street']`
   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
   *
   * @returns error data for that particular error. If the control or error is not present,
   * null is returned.
   */
  getError(errorCode, path) {
    const control = path ? this.get(path) : this;
    return control && control.errors ? control.errors[errorCode] : null;
  }
  /**
   * @description
   * Reports whether the control with the given path has the error specified.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   * @usageNotes
   * For example, for the following `FormGroup`:
   *
   * ```ts
   * form = new FormGroup({
   *   address: new FormGroup({ street: new FormControl() })
   * });
   * ```
   *
   * The path to the 'street' control from the root form would be 'address' -> 'street'.
   *
   * It can be provided to this method in one of two formats:
   *
   * 1. An array of string control names, e.g. `['address', 'street']`
   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
   *
   * If no path is given, this method checks for the error on the current control.
   *
   * @returns whether the given error is present in the control at the given path.
   *
   * If the control is not present, false is returned.
   */
  hasError(errorCode, path) {
    return !!this.getError(errorCode, path);
  }
  /**
   * Retrieves the top-level ancestor of this control.
   */
  get root() {
    let x = this;
    while (x._parent) {
      x = x._parent;
    }
    return x;
  }
  /** @internal */
  _updateControlsErrors(emitEvent, changedControl, shouldHaveEmitted) {
    this.status = this._calculateStatus();
    if (emitEvent) {
      this.statusChanges.emit(this.status);
    }
    if (emitEvent || shouldHaveEmitted) {
      this._events.next(new StatusChangeEvent(this.status, changedControl));
    }
    if (this._parent) {
      this._parent._updateControlsErrors(emitEvent, changedControl, shouldHaveEmitted);
    }
  }
  /** @internal */
  _initObservables() {
    this.valueChanges = new EventEmitter();
    this.statusChanges = new EventEmitter();
  }
  _calculateStatus() {
    if (this._allControlsDisabled()) return DISABLED;
    if (this.errors) return INVALID;
    if (this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(PENDING)) return PENDING;
    if (this._anyControlsHaveStatus(INVALID)) return INVALID;
    return VALID;
  }
  /** @internal */
  _anyControlsHaveStatus(status) {
    return this._anyControls((control) => control.status === status);
  }
  /** @internal */
  _anyControlsDirty() {
    return this._anyControls((control) => control.dirty);
  }
  /** @internal */
  _anyControlsTouched() {
    return this._anyControls((control) => control.touched);
  }
  /** @internal */
  _updatePristine(opts, changedControl) {
    const newPristine = !this._anyControlsDirty();
    const changed = this.pristine !== newPristine;
    this.pristine = newPristine;
    if (this._parent && !opts.onlySelf) {
      this._parent._updatePristine(opts, changedControl);
    }
    if (changed) {
      this._events.next(new PristineChangeEvent(this.pristine, changedControl));
    }
  }
  /** @internal */
  _updateTouched(opts = {}, changedControl) {
    this.touched = this._anyControlsTouched();
    this._events.next(new TouchedChangeEvent(this.touched, changedControl));
    if (this._parent && !opts.onlySelf) {
      this._parent._updateTouched(opts, changedControl);
    }
  }
  /** @internal */
  _onDisabledChange = [];
  /** @internal */
  _registerOnCollectionChange(fn) {
    this._onCollectionChange = fn;
  }
  /** @internal */
  _setUpdateStrategy(opts) {
    if (isOptionsObj(opts) && opts.updateOn != null) {
      this._updateOn = opts.updateOn;
    }
  }
  /**
   * Check to see if parent has been marked artificially dirty.
   *
   * @internal
   */
  _parentMarkedDirty(onlySelf) {
    const parentDirty = this._parent && this._parent.dirty;
    return !onlySelf && !!parentDirty && !this._parent._anyControlsDirty();
  }
  /** @internal */
  _find(name) {
    return null;
  }
  /**
   * Internal implementation of the `setValidators` method. Needs to be separated out into a
   * different method, because it is called in the constructor and it can break cases where
   * a control is extended.
   */
  _assignValidators(validators) {
    this._rawValidators = Array.isArray(validators) ? validators.slice() : validators;
    this._composedValidatorFn = coerceToValidator(this._rawValidators);
  }
  /**
   * Internal implementation of the `setAsyncValidators` method. Needs to be separated out into a
   * different method, because it is called in the constructor and it can break cases where
   * a control is extended.
   */
  _assignAsyncValidators(validators) {
    this._rawAsyncValidators = Array.isArray(validators) ? validators.slice() : validators;
    this._composedAsyncValidatorFn = coerceToAsyncValidator(this._rawAsyncValidators);
  }
};
var FormGroup = class extends AbstractControl {
  /**
   * Creates a new `FormGroup` instance.
   *
   * @param controls A collection of child controls. The key for each child is the name
   * under which it is registered.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of
   * such functions, or an `AbstractControlOptions` object that contains validation functions
   * and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator functions
   *
   */
  constructor(controls, validatorOrOpts, asyncValidator) {
    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
    (typeof ngDevMode === "undefined" || ngDevMode) && validateFormGroupControls(controls);
    this.controls = controls;
    this._initObservables();
    this._setUpdateStrategy(validatorOrOpts);
    this._setUpControls();
    this.updateValueAndValidity({
      onlySelf: true,
      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
      // `VALID` or `INVALID`. The status should be broadcasted via the `statusChanges` observable,
      // so we set `emitEvent` to `true` to allow that during the control creation process.
      emitEvent: !!this.asyncValidator
    });
  }
  controls;
  registerControl(name, control) {
    if (this.controls[name]) return this.controls[name];
    this.controls[name] = control;
    control.setParent(this);
    control._registerOnCollectionChange(this._onCollectionChange);
    return control;
  }
  addControl(name, control, options = {}) {
    this.registerControl(name, control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  /**
   * Remove a control from this group. In a strongly-typed group, required controls cannot be
   * removed.
   *
   * This method also updates the value and validity of the control.
   *
   * @param name The control name to remove from the collection
   * @param options Specifies whether this FormGroup instance should emit events after a
   *     control is removed.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * removed. When false, no events are emitted.
   */
  removeControl(name, options = {}) {
    if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {
    });
    delete this.controls[name];
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  setControl(name, control, options = {}) {
    if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {
    });
    delete this.controls[name];
    if (control) this.registerControl(name, control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  contains(controlName) {
    return this.controls.hasOwnProperty(controlName) && this.controls[controlName].enabled;
  }
  /**
   * Sets the value of the `FormGroup`. It accepts an object that matches
   * the structure of the group, with control names as keys.
   *
   * @usageNotes
   * ### Set the complete value for the form group
   *
   * ```ts
   * const form = new FormGroup({
   *   first: new FormControl(),
   *   last: new FormControl()
   * });
   *
   * console.log(form.value);   // {first: null, last: null}
   *
   * form.setValue({first: 'Nancy', last: 'Drew'});
   * console.log(form.value);   // {first: 'Nancy', last: 'Drew'}
   * ```
   *
   * @throws When strict checks fail, such as setting the value of a control
   * that doesn't exist or if you exclude a value of a control that does exist.
   *
   * @param value The new value for the control that matches the structure of the group.
   * @param options Configuration options that determine how the control propagates changes
   * and emits events after the value changes.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is
   * false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control value is updated.
   * When false, no events are emitted.
   */
  setValue(value, options = {}) {
    assertAllValuesPresent(this, true, value);
    Object.keys(value).forEach((name) => {
      assertControlPresent(this, true, name);
      this.controls[name].setValue(value[name], {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Patches the value of the `FormGroup`. It accepts an object with control
   * names as keys, and does its best to match the values to the correct controls
   * in the group.
   *
   * It accepts both super-sets and sub-sets of the group without throwing an error.
   *
   * @usageNotes
   * ### Patch the value for a form group
   *
   * ```ts
   * const form = new FormGroup({
   *    first: new FormControl(),
   *    last: new FormControl()
   * });
   * console.log(form.value);   // {first: null, last: null}
   *
   * form.patchValue({first: 'Nancy'});
   * console.log(form.value);   // {first: 'Nancy', last: null}
   * ```
   *
   * @param value The object that matches the structure of the group.
   * @param options Configuration options that determine how the control propagates changes and
   * emits events after the value is patched.
   * * `onlySelf`: When true, each change only affects this control and not its parent. Default is
   * true.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control value
   * is updated. When false, no events are emitted. The configuration options are passed to
   * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.
   */
  patchValue(value, options = {}) {
    if (value == null) return;
    Object.keys(value).forEach((name) => {
      const control = this.controls[name];
      if (control) {
        control.patchValue(
          /* Guaranteed to be present, due to the outer forEach. */
          value[name],
          {
            onlySelf: true,
            emitEvent: options.emitEvent
          }
        );
      }
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Resets the `FormGroup`, marks all descendants `pristine` and `untouched` and sets
   * the value of all descendants to their default values, or null if no defaults were provided.
   *
   * You reset to a specific form state by passing in a map of states
   * that matches the structure of your form, with control names as keys. The state
   * is a standalone value or a form state object with both a value and a disabled
   * status.
   *
   * @param value Resets the control with an initial value,
   * or an object that defines the initial value and disabled state.
   *
   * @param options Configuration options that determine how the control propagates changes
   * and emits events when the group is reset.
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is
   * false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control is reset.
   * When false, no events are emitted.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   *
   * @usageNotes
   *
   * ### Reset the form group values
   *
   * ```ts
   * const form = new FormGroup({
   *   first: new FormControl('first name'),
   *   last: new FormControl('last name')
   * });
   *
   * console.log(form.value);  // {first: 'first name', last: 'last name'}
   *
   * form.reset({ first: 'name', last: 'last name' });
   *
   * console.log(form.value);  // {first: 'name', last: 'last name'}
   * ```
   *
   * ### Reset the form group values and disabled status
   *
   * ```ts
   * const form = new FormGroup({
   *   first: new FormControl('first name'),
   *   last: new FormControl('last name')
   * });
   *
   * form.reset({
   *   first: {value: 'name', disabled: true},
   *   last: 'last'
   * });
   *
   * console.log(form.value);  // {last: 'last'}
   * console.log(form.get('first').status);  // 'DISABLED'
   * ```
   */
  reset(value = {}, options = {}) {
    this._forEachChild((control, name) => {
      control.reset(value ? value[name] : null, {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this._updatePristine(options, this);
    this._updateTouched(options, this);
    this.updateValueAndValidity(options);
  }
  /**
   * The aggregate value of the `FormGroup`, including any disabled controls.
   *
   * Retrieves all values regardless of disabled status.
   */
  getRawValue() {
    return this._reduceChildren({}, (acc, control, name) => {
      acc[name] = control.getRawValue();
      return acc;
    });
  }
  /** @internal */
  _syncPendingControls() {
    let subtreeUpdated = this._reduceChildren(false, (updated, child) => {
      return child._syncPendingControls() ? true : updated;
    });
    if (subtreeUpdated) this.updateValueAndValidity({
      onlySelf: true
    });
    return subtreeUpdated;
  }
  /** @internal */
  _forEachChild(cb) {
    Object.keys(this.controls).forEach((key) => {
      const control = this.controls[key];
      control && cb(control, key);
    });
  }
  /** @internal */
  _setUpControls() {
    this._forEachChild((control) => {
      control.setParent(this);
      control._registerOnCollectionChange(this._onCollectionChange);
    });
  }
  /** @internal */
  _updateValue() {
    this.value = this._reduceValue();
  }
  /** @internal */
  _anyControls(condition) {
    for (const [controlName, control] of Object.entries(this.controls)) {
      if (this.contains(controlName) && condition(control)) {
        return true;
      }
    }
    return false;
  }
  /** @internal */
  _reduceValue() {
    let acc = {};
    return this._reduceChildren(acc, (acc2, control, name) => {
      if (control.enabled || this.disabled) {
        acc2[name] = control.value;
      }
      return acc2;
    });
  }
  /** @internal */
  _reduceChildren(initValue, fn) {
    let res = initValue;
    this._forEachChild((control, name) => {
      res = fn(res, control, name);
    });
    return res;
  }
  /** @internal */
  _allControlsDisabled() {
    for (const controlName of Object.keys(this.controls)) {
      if (this.controls[controlName].enabled) {
        return false;
      }
    }
    return Object.keys(this.controls).length > 0 || this.disabled;
  }
  /** @internal */
  _find(name) {
    return this.controls.hasOwnProperty(name) ? this.controls[name] : null;
  }
};
function validateFormGroupControls(controls) {
  const invalidKeys = Object.keys(controls).filter((key) => key.includes("."));
  if (invalidKeys.length > 0) {
    console.warn(`FormGroup keys cannot include \`.\`, please replace the keys for: ${invalidKeys.join(",")}.`);
  }
}
var FormRecord = class extends FormGroup {
};
var CALL_SET_DISABLED_STATE = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "CallSetDisabledState" : "", {
  providedIn: "root",
  factory: () => setDisabledStateDefault
});
var setDisabledStateDefault = "always";
function controlPath(name, parent) {
  return [...parent.path, name];
}
function setUpControl(control, dir, callSetDisabledState = setDisabledStateDefault) {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (!control) _throwError(dir, "Cannot find control with");
    if (!dir.valueAccessor) _throwMissingValueAccessorError(dir);
  }
  setUpValidators(control, dir);
  dir.valueAccessor.writeValue(control.value);
  if (control.disabled || callSetDisabledState === "always") {
    dir.valueAccessor.setDisabledState?.(control.disabled);
  }
  setUpViewChangePipeline(control, dir);
  setUpModelChangePipeline(control, dir);
  setUpBlurPipeline(control, dir);
  setUpDisabledChangeHandler(control, dir);
}
function cleanUpControl(control, dir, validateControlPresenceOnChange = true) {
  const noop2 = () => {
    if (validateControlPresenceOnChange && (typeof ngDevMode === "undefined" || ngDevMode)) {
      _noControlError(dir);
    }
  };
  if (dir.valueAccessor) {
    dir.valueAccessor.registerOnChange(noop2);
    dir.valueAccessor.registerOnTouched(noop2);
  }
  cleanUpValidators(control, dir);
  if (control) {
    dir._invokeOnDestroyCallbacks();
    control._registerOnCollectionChange(() => {
    });
  }
}
function registerOnValidatorChange(validators, onChange) {
  validators.forEach((validator) => {
    if (validator.registerOnValidatorChange) validator.registerOnValidatorChange(onChange);
  });
}
function setUpDisabledChangeHandler(control, dir) {
  if (dir.valueAccessor.setDisabledState) {
    const onDisabledChange = (isDisabled) => {
      dir.valueAccessor.setDisabledState(isDisabled);
    };
    control.registerOnDisabledChange(onDisabledChange);
    dir._registerOnDestroy(() => {
      control._unregisterOnDisabledChange(onDisabledChange);
    });
  }
}
function setUpValidators(control, dir) {
  const validators = getControlValidators(control);
  if (dir.validator !== null) {
    control.setValidators(mergeValidators(validators, dir.validator));
  } else if (typeof validators === "function") {
    control.setValidators([validators]);
  }
  const asyncValidators = getControlAsyncValidators(control);
  if (dir.asyncValidator !== null) {
    control.setAsyncValidators(mergeValidators(asyncValidators, dir.asyncValidator));
  } else if (typeof asyncValidators === "function") {
    control.setAsyncValidators([asyncValidators]);
  }
  const onValidatorChange = () => control.updateValueAndValidity();
  registerOnValidatorChange(dir._rawValidators, onValidatorChange);
  registerOnValidatorChange(dir._rawAsyncValidators, onValidatorChange);
}
function cleanUpValidators(control, dir) {
  let isControlUpdated = false;
  if (control !== null) {
    if (dir.validator !== null) {
      const validators = getControlValidators(control);
      if (Array.isArray(validators) && validators.length > 0) {
        const updatedValidators = validators.filter((validator) => validator !== dir.validator);
        if (updatedValidators.length !== validators.length) {
          isControlUpdated = true;
          control.setValidators(updatedValidators);
        }
      }
    }
    if (dir.asyncValidator !== null) {
      const asyncValidators = getControlAsyncValidators(control);
      if (Array.isArray(asyncValidators) && asyncValidators.length > 0) {
        const updatedAsyncValidators = asyncValidators.filter((asyncValidator) => asyncValidator !== dir.asyncValidator);
        if (updatedAsyncValidators.length !== asyncValidators.length) {
          isControlUpdated = true;
          control.setAsyncValidators(updatedAsyncValidators);
        }
      }
    }
  }
  const noop2 = () => {
  };
  registerOnValidatorChange(dir._rawValidators, noop2);
  registerOnValidatorChange(dir._rawAsyncValidators, noop2);
  return isControlUpdated;
}
function setUpViewChangePipeline(control, dir) {
  dir.valueAccessor.registerOnChange((newValue) => {
    control._pendingValue = newValue;
    control._pendingChange = true;
    control._pendingDirty = true;
    if (control.updateOn === "change") updateControl(control, dir);
  });
}
function setUpBlurPipeline(control, dir) {
  dir.valueAccessor.registerOnTouched(() => {
    control._pendingTouched = true;
    if (control.updateOn === "blur" && control._pendingChange) updateControl(control, dir);
    if (control.updateOn !== "submit") control.markAsTouched();
  });
}
function updateControl(control, dir) {
  if (control._pendingDirty) control.markAsDirty();
  control.setValue(control._pendingValue, {
    emitModelToViewChange: false
  });
  dir.viewToModelUpdate(control._pendingValue);
  control._pendingChange = false;
}
function setUpModelChangePipeline(control, dir) {
  const onChange = (newValue, emitModelEvent) => {
    dir.valueAccessor.writeValue(newValue);
    if (emitModelEvent) dir.viewToModelUpdate(newValue);
  };
  control.registerOnChange(onChange);
  dir._registerOnDestroy(() => {
    control._unregisterOnChange(onChange);
  });
}
function setUpFormContainer(control, dir) {
  if (control == null && (typeof ngDevMode === "undefined" || ngDevMode)) _throwError(dir, "Cannot find control with");
  setUpValidators(control, dir);
}
function cleanUpFormContainer(control, dir) {
  return cleanUpValidators(control, dir);
}
function _noControlError(dir) {
  return _throwError(dir, "There is no FormControl instance attached to form control element with");
}
function _throwError(dir, message) {
  const messageEnd = _describeControlLocation(dir);
  throw new Error(`${message} ${messageEnd}`);
}
function _describeControlLocation(dir) {
  const path = dir.path;
  if (path && path.length > 1) return `path: '${path.join(" -> ")}'`;
  if (path?.[0]) return `name: '${path}'`;
  return "unspecified name attribute";
}
function _throwMissingValueAccessorError(dir) {
  const loc = _describeControlLocation(dir);
  throw new RuntimeError(-1203, `No value accessor for form control ${loc}.`);
}
function _throwInvalidValueAccessorError(dir) {
  const loc = _describeControlLocation(dir);
  throw new RuntimeError(1200, `Value accessor was not provided as an array for form control with ${loc}. Check that the \`NG_VALUE_ACCESSOR\` token is configured as a \`multi: true\` provider.`);
}
function isPropertyUpdated(changes, viewModel) {
  if (!changes.hasOwnProperty("model")) return false;
  const change = changes["model"];
  if (change.isFirstChange()) return true;
  return !Object.is(viewModel, change.currentValue);
}
function isBuiltInAccessor(valueAccessor) {
  return Object.getPrototypeOf(valueAccessor.constructor) === BuiltInControlValueAccessor;
}
function syncPendingControls(form, directives) {
  form._syncPendingControls();
  directives.forEach((dir) => {
    const control = dir.control;
    if (control.updateOn === "submit" && control._pendingChange) {
      dir.viewToModelUpdate(control._pendingValue);
      control._pendingChange = false;
    }
  });
}
function selectValueAccessor(dir, valueAccessors) {
  if (!valueAccessors) return null;
  if (!Array.isArray(valueAccessors) && (typeof ngDevMode === "undefined" || ngDevMode)) _throwInvalidValueAccessorError(dir);
  let defaultAccessor = void 0;
  let builtinAccessor = void 0;
  let customAccessor = void 0;
  valueAccessors.forEach((v) => {
    if (v.constructor === DefaultValueAccessor) {
      defaultAccessor = v;
    } else if (isBuiltInAccessor(v)) {
      if (builtinAccessor && (typeof ngDevMode === "undefined" || ngDevMode)) _throwError(dir, "More than one built-in value accessor matches form control with");
      builtinAccessor = v;
    } else {
      if (customAccessor && (typeof ngDevMode === "undefined" || ngDevMode)) _throwError(dir, "More than one custom value accessor matches form control with");
      customAccessor = v;
    }
  });
  if (customAccessor) return customAccessor;
  if (builtinAccessor) return builtinAccessor;
  if (defaultAccessor) return defaultAccessor;
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    _throwError(dir, "No valid value accessor for form control with");
  }
  return null;
}
function removeListItem$1(list, el) {
  const index = list.indexOf(el);
  if (index > -1) list.splice(index, 1);
}
function _ngModelWarning(name, type, instance, warningConfig) {
  if (warningConfig === "never") return;
  if ((warningConfig === null || warningConfig === "once") && !type._ngModelWarningSentOnce || warningConfig === "always" && !instance._ngModelWarningSent) {
    console.warn(ngModelWarning(name));
    type._ngModelWarningSentOnce = true;
    instance._ngModelWarningSent = true;
  }
}
var formDirectiveProvider$1 = {
  provide: ControlContainer,
  useExisting: forwardRef(() => NgForm)
};
var resolvedPromise$1 = (() => Promise.resolve())();
var NgForm = class _NgForm extends ControlContainer {
  callSetDisabledState;
  /**
   * @description
   * Returns whether the form submission has been triggered.
   */
  get submitted() {
    return untracked(this.submittedReactive);
  }
  /** @internal */
  _submitted = computed(() => this.submittedReactive());
  submittedReactive = signal(false);
  _directives = /* @__PURE__ */ new Set();
  /**
   * @description
   * The `FormGroup` instance created for this form.
   */
  form;
  /**
   * @description
   * Event emitter for the "ngSubmit" event
   */
  ngSubmit = new EventEmitter();
  /**
   * @description
   * Tracks options for the `NgForm` instance.
   *
   * **updateOn**: Sets the default `updateOn` value for all child `NgModels` below it
   * unless explicitly set by a child `NgModel` using `ngModelOptions`). Defaults to 'change'.
   * Possible values: `'change'` | `'blur'` | `'submit'`.
   *
   */
  // TODO(issue/24571): remove '!'.
  options;
  constructor(validators, asyncValidators, callSetDisabledState) {
    super();
    this.callSetDisabledState = callSetDisabledState;
    this.form = new FormGroup({}, composeValidators(validators), composeAsyncValidators(asyncValidators));
  }
  /** @nodoc */
  ngAfterViewInit() {
    this._setUpdateStrategy();
  }
  /**
   * @description
   * The directive instance.
   */
  get formDirective() {
    return this;
  }
  /**
   * @description
   * The internal `FormGroup` instance.
   */
  get control() {
    return this.form;
  }
  /**
   * @description
   * Returns an array representing the path to this group. Because this directive
   * always lives at the top level of a form, it is always an empty array.
   */
  get path() {
    return [];
  }
  /**
   * @description
   * Returns a map of the controls in this group.
   */
  get controls() {
    return this.form.controls;
  }
  /**
   * @description
   * Method that sets up the control directive in this group, re-calculates its value
   * and validity, and adds the instance to the internal list of directives.
   *
   * @param dir The `NgModel` directive instance.
   */
  addControl(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      dir.control = container.registerControl(dir.name, dir.control);
      setUpControl(dir.control, dir, this.callSetDisabledState);
      dir.control.updateValueAndValidity({
        emitEvent: false
      });
      this._directives.add(dir);
    });
  }
  /**
   * @description
   * Retrieves the `FormControl` instance from the provided `NgModel` directive.
   *
   * @param dir The `NgModel` directive instance.
   */
  getControl(dir) {
    return this.form.get(dir.path);
  }
  /**
   * @description
   * Removes the `NgModel` instance from the internal list of directives
   *
   * @param dir The `NgModel` directive instance.
   */
  removeControl(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      if (container) {
        container.removeControl(dir.name);
      }
      this._directives.delete(dir);
    });
  }
  /**
   * @description
   * Adds a new `NgModelGroup` directive instance to the form.
   *
   * @param dir The `NgModelGroup` directive instance.
   */
  addFormGroup(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      const group = new FormGroup({});
      setUpFormContainer(group, dir);
      container.registerControl(dir.name, group);
      group.updateValueAndValidity({
        emitEvent: false
      });
    });
  }
  /**
   * @description
   * Removes the `NgModelGroup` directive instance from the form.
   *
   * @param dir The `NgModelGroup` directive instance.
   */
  removeFormGroup(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      if (container) {
        container.removeControl(dir.name);
      }
    });
  }
  /**
   * @description
   * Retrieves the `FormGroup` for a provided `NgModelGroup` directive instance
   *
   * @param dir The `NgModelGroup` directive instance.
   */
  getFormGroup(dir) {
    return this.form.get(dir.path);
  }
  /**
   * Sets the new value for the provided `NgControl` directive.
   *
   * @param dir The `NgControl` directive instance.
   * @param value The new value for the directive's control.
   */
  updateModel(dir, value) {
    resolvedPromise$1.then(() => {
      const ctrl = this.form.get(dir.path);
      ctrl.setValue(value);
    });
  }
  /**
   * @description
   * Sets the value for this `FormGroup`.
   *
   * @param value The new value
   */
  setValue(value) {
    this.control.setValue(value);
  }
  /**
   * @description
   * Method called when the "submit" event is triggered on the form.
   * Triggers the `ngSubmit` emitter to emit the "submit" event as its payload.
   *
   * @param $event The "submit" event object
   */
  onSubmit($event) {
    this.submittedReactive.set(true);
    syncPendingControls(this.form, this._directives);
    this.ngSubmit.emit($event);
    return $event?.target?.method === "dialog";
  }
  /**
   * @description
   * Method called when the "reset" event is triggered on the form.
   */
  onReset() {
    this.resetForm();
  }
  /**
   * @description
   * Resets the form to an initial value and resets its submitted status.
   *
   * @param value The new value for the form.
   */
  resetForm(value = void 0) {
    this.form.reset(value);
    this.submittedReactive.set(false);
  }
  _setUpdateStrategy() {
    if (this.options && this.options.updateOn != null) {
      this.form._updateOn = this.options.updateOn;
    }
  }
  _findContainer(path) {
    path.pop();
    return path.length ? this.form.get(path) : this.form;
  }
  static ɵfac = function NgForm_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgForm)(ɵɵdirectiveInject(NG_VALIDATORS, 10), ɵɵdirectiveInject(NG_ASYNC_VALIDATORS, 10), ɵɵdirectiveInject(CALL_SET_DISABLED_STATE, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _NgForm,
    selectors: [["form", 3, "ngNoForm", "", 3, "formGroup", ""], ["ng-form"], ["", "ngForm", ""]],
    hostBindings: function NgForm_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("submit", function NgForm_submit_HostBindingHandler($event) {
          return ctx.onSubmit($event);
        })("reset", function NgForm_reset_HostBindingHandler() {
          return ctx.onReset();
        });
      }
    },
    inputs: {
      options: [0, "ngFormOptions", "options"]
    },
    outputs: {
      ngSubmit: "ngSubmit"
    },
    exportAs: ["ngForm"],
    standalone: false,
    features: [ɵɵProvidersFeature([formDirectiveProvider$1]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgForm, [{
    type: Directive,
    args: [{
      selector: "form:not([ngNoForm]):not([formGroup]),ng-form,[ngForm]",
      providers: [formDirectiveProvider$1],
      host: {
        "(submit)": "onSubmit($event)",
        "(reset)": "onReset()"
      },
      outputs: ["ngSubmit"],
      exportAs: "ngForm",
      standalone: false
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    options: [{
      type: Input,
      args: ["ngFormOptions"]
    }]
  });
})();
function removeListItem(list, el) {
  const index = list.indexOf(el);
  if (index > -1) list.splice(index, 1);
}
function isFormControlState(formState) {
  return typeof formState === "object" && formState !== null && Object.keys(formState).length === 2 && "value" in formState && "disabled" in formState;
}
var FormControl = class FormControl2 extends AbstractControl {
  /** @publicApi */
  defaultValue = null;
  /** @internal */
  _onChange = [];
  /** @internal */
  _pendingValue;
  /** @internal */
  _pendingChange = false;
  constructor(formState = null, validatorOrOpts, asyncValidator) {
    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
    this._applyFormState(formState);
    this._setUpdateStrategy(validatorOrOpts);
    this._initObservables();
    this.updateValueAndValidity({
      onlySelf: true,
      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
      // `VALID` or `INVALID`.
      // The status should be broadcasted via the `statusChanges` observable, so we set
      // `emitEvent` to `true` to allow that during the control creation process.
      emitEvent: !!this.asyncValidator
    });
    if (isOptionsObj(validatorOrOpts) && (validatorOrOpts.nonNullable || validatorOrOpts.initialValueIsDefault)) {
      if (isFormControlState(formState)) {
        this.defaultValue = formState.value;
      } else {
        this.defaultValue = formState;
      }
    }
  }
  setValue(value, options = {}) {
    this.value = this._pendingValue = value;
    if (this._onChange.length && options.emitModelToViewChange !== false) {
      this._onChange.forEach((changeFn) => changeFn(this.value, options.emitViewToModelChange !== false));
    }
    this.updateValueAndValidity(options);
  }
  patchValue(value, options = {}) {
    this.setValue(value, options);
  }
  reset(formState = this.defaultValue, options = {}) {
    this._applyFormState(formState);
    this.markAsPristine(options);
    this.markAsUntouched(options);
    this.setValue(this.value, options);
    this._pendingChange = false;
  }
  /**  @internal */
  _updateValue() {
  }
  /**  @internal */
  _anyControls(condition) {
    return false;
  }
  /**  @internal */
  _allControlsDisabled() {
    return this.disabled;
  }
  registerOnChange(fn) {
    this._onChange.push(fn);
  }
  /** @internal */
  _unregisterOnChange(fn) {
    removeListItem(this._onChange, fn);
  }
  registerOnDisabledChange(fn) {
    this._onDisabledChange.push(fn);
  }
  /** @internal */
  _unregisterOnDisabledChange(fn) {
    removeListItem(this._onDisabledChange, fn);
  }
  /** @internal */
  _forEachChild(cb) {
  }
  /** @internal */
  _syncPendingControls() {
    if (this.updateOn === "submit") {
      if (this._pendingDirty) this.markAsDirty();
      if (this._pendingTouched) this.markAsTouched();
      if (this._pendingChange) {
        this.setValue(this._pendingValue, {
          onlySelf: true,
          emitModelToViewChange: false
        });
        return true;
      }
    }
    return false;
  }
  _applyFormState(formState) {
    if (isFormControlState(formState)) {
      this.value = this._pendingValue = formState.value;
      formState.disabled ? this.disable({
        onlySelf: true,
        emitEvent: false
      }) : this.enable({
        onlySelf: true,
        emitEvent: false
      });
    } else {
      this.value = this._pendingValue = formState;
    }
  }
};
var isFormControl = (control) => control instanceof FormControl;
var AbstractFormGroupDirective = class _AbstractFormGroupDirective extends ControlContainer {
  /**
   * @description
   * The parent control for the group
   *
   * @internal
   */
  // TODO(issue/24571): remove '!'.
  _parent;
  /** @nodoc */
  ngOnInit() {
    this._checkParentType();
    this.formDirective.addFormGroup(this);
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this.formDirective) {
      this.formDirective.removeFormGroup(this);
    }
  }
  /**
   * @description
   * The `FormGroup` bound to this directive.
   */
  get control() {
    return this.formDirective.getFormGroup(this);
  }
  /**
   * @description
   * The path to this group from the top-level directive.
   */
  get path() {
    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
  }
  /**
   * @description
   * The top-level directive for this group if present, otherwise null.
   */
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  /** @internal */
  _checkParentType() {
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵAbstractFormGroupDirective_BaseFactory;
    return function AbstractFormGroupDirective_Factory(__ngFactoryType__) {
      return (ɵAbstractFormGroupDirective_BaseFactory || (ɵAbstractFormGroupDirective_BaseFactory = ɵɵgetInheritedFactory(_AbstractFormGroupDirective)))(__ngFactoryType__ || _AbstractFormGroupDirective);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _AbstractFormGroupDirective,
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AbstractFormGroupDirective, [{
    type: Directive,
    args: [{
      standalone: false
    }]
  }], null, null);
})();
function modelParentException() {
  return new RuntimeError(1350, `
    ngModel cannot be used to register form controls with a parent formGroup directive.  Try using
    formGroup's partner directive "formControlName" instead.  Example:

    ${formControlNameExample}

    Or, if you'd like to avoid registering this form control, indicate that it's standalone in ngModelOptions:

    Example:

    ${ngModelWithFormGroupExample}`);
}
function formGroupNameException() {
  return new RuntimeError(1351, `
    ngModel cannot be used to register form controls with a parent formGroupName or formArrayName directive.

    Option 1: Use formControlName instead of ngModel (reactive strategy):

    ${formGroupNameExample}

    Option 2:  Update ngModel's parent be ngModelGroup (template-driven strategy):

    ${ngModelGroupExample}`);
}
function missingNameException() {
  return new RuntimeError(1352, `If ngModel is used within a form tag, either the name attribute must be set or the form
    control must be defined as 'standalone' in ngModelOptions.

    Example 1: <input [(ngModel)]="person.firstName" name="first">
    Example 2: <input [(ngModel)]="person.firstName" [ngModelOptions]="{standalone: true}">`);
}
function modelGroupParentException() {
  return new RuntimeError(1353, `
    ngModelGroup cannot be used with a parent formGroup directive.

    Option 1: Use formGroupName instead of ngModelGroup (reactive strategy):

    ${formGroupNameExample}

    Option 2:  Use a regular form tag instead of the formGroup directive (template-driven strategy):

    ${ngModelGroupExample}`);
}
var modelGroupProvider = {
  provide: ControlContainer,
  useExisting: forwardRef(() => NgModelGroup)
};
var NgModelGroup = class _NgModelGroup extends AbstractFormGroupDirective {
  /**
   * @description
   * Tracks the name of the `NgModelGroup` bound to the directive. The name corresponds
   * to a key in the parent `NgForm`.
   */
  name = "";
  constructor(parent, validators, asyncValidators) {
    super();
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  /** @internal */
  _checkParentType() {
    if (!(this._parent instanceof _NgModelGroup) && !(this._parent instanceof NgForm) && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw modelGroupParentException();
    }
  }
  static ɵfac = function NgModelGroup_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgModelGroup)(ɵɵdirectiveInject(ControlContainer, 5), ɵɵdirectiveInject(NG_VALIDATORS, 10), ɵɵdirectiveInject(NG_ASYNC_VALIDATORS, 10));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _NgModelGroup,
    selectors: [["", "ngModelGroup", ""]],
    inputs: {
      name: [0, "ngModelGroup", "name"]
    },
    exportAs: ["ngModelGroup"],
    standalone: false,
    features: [ɵɵProvidersFeature([modelGroupProvider]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgModelGroup, [{
    type: Directive,
    args: [{
      selector: "[ngModelGroup]",
      providers: [modelGroupProvider],
      exportAs: "ngModelGroup",
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Host
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }], {
    name: [{
      type: Input,
      args: ["ngModelGroup"]
    }]
  });
})();
var formControlBinding$1 = {
  provide: NgControl,
  useExisting: forwardRef(() => NgModel)
};
var resolvedPromise = (() => Promise.resolve())();
var NgModel = class _NgModel extends NgControl {
  _changeDetectorRef;
  callSetDisabledState;
  control = new FormControl();
  // At runtime we coerce arbitrary values assigned to the "disabled" input to a "boolean".
  // This is not reflected in the type of the property because outside of templates, consumers
  // should only deal with booleans. In templates, a string is allowed for convenience and to
  // match the native "disabled attribute" semantics which can be observed on input elements.
  // This static member tells the compiler that values of type "string" can also be assigned
  // to the input in a template.
  /** @nodoc */
  static ngAcceptInputType_isDisabled;
  /** @internal */
  _registered = false;
  /**
   * Internal reference to the view model value.
   * @nodoc
   */
  viewModel;
  /**
   * @description
   * Tracks the name bound to the directive. If a parent form exists, it
   * uses this name as a key to retrieve this control's value.
   */
  name = "";
  /**
   * @description
   * Tracks whether the control is disabled.
   */
  // TODO(issue/24571): remove '!'.
  isDisabled;
  /**
   * @description
   * Tracks the value bound to this directive.
   */
  model;
  /**
   * @description
   * Tracks the configuration options for this `ngModel` instance.
   *
   * **name**: An alternative to setting the name attribute on the form control element. See
   * the [example](api/forms/NgModel#using-ngmodel-on-a-standalone-control) for using `NgModel`
   * as a standalone control.
   *
   * **standalone**: When set to true, the `ngModel` will not register itself with its parent form,
   * and acts as if it's not in the form. Defaults to false. If no parent form exists, this option
   * has no effect.
   *
   * **updateOn**: Defines the event upon which the form control value and validity update.
   * Defaults to 'change'. Possible values: `'change'` | `'blur'` | `'submit'`.
   *
   */
  // TODO(issue/24571): remove '!'.
  options;
  /**
   * @description
   * Event emitter for producing the `ngModelChange` event after
   * the view model updates.
   */
  update = new EventEmitter();
  constructor(parent, validators, asyncValidators, valueAccessors, _changeDetectorRef, callSetDisabledState) {
    super();
    this._changeDetectorRef = _changeDetectorRef;
    this.callSetDisabledState = callSetDisabledState;
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
    this.valueAccessor = selectValueAccessor(this, valueAccessors);
  }
  /** @nodoc */
  ngOnChanges(changes) {
    this._checkForErrors();
    if (!this._registered || "name" in changes) {
      if (this._registered) {
        this._checkName();
        if (this.formDirective) {
          const oldName = changes["name"].previousValue;
          this.formDirective.removeControl({
            name: oldName,
            path: this._getPath(oldName)
          });
        }
      }
      this._setUpControl();
    }
    if ("isDisabled" in changes) {
      this._updateDisabled(changes);
    }
    if (isPropertyUpdated(changes, this.viewModel)) {
      this._updateValue(this.model);
      this.viewModel = this.model;
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    this.formDirective && this.formDirective.removeControl(this);
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return this._getPath(this.name);
  }
  /**
   * @description
   * The top-level directive for this control if present, otherwise null.
   */
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  /**
   * @description
   * Sets the new value for the view model and emits an `ngModelChange` event.
   *
   * @param newValue The new value emitted by `ngModelChange`.
   */
  viewToModelUpdate(newValue) {
    this.viewModel = newValue;
    this.update.emit(newValue);
  }
  _setUpControl() {
    this._setUpdateStrategy();
    this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this);
    this._registered = true;
  }
  _setUpdateStrategy() {
    if (this.options && this.options.updateOn != null) {
      this.control._updateOn = this.options.updateOn;
    }
  }
  _isStandalone() {
    return !this._parent || !!(this.options && this.options.standalone);
  }
  _setUpStandalone() {
    setUpControl(this.control, this, this.callSetDisabledState);
    this.control.updateValueAndValidity({
      emitEvent: false
    });
  }
  _checkForErrors() {
    if ((typeof ngDevMode === "undefined" || ngDevMode) && !this._isStandalone()) {
      checkParentType$1(this._parent);
    }
    this._checkName();
  }
  _checkName() {
    if (this.options && this.options.name) this.name = this.options.name;
    if (!this._isStandalone() && !this.name && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw missingNameException();
    }
  }
  _updateValue(value) {
    resolvedPromise.then(() => {
      this.control.setValue(value, {
        emitViewToModelChange: false
      });
      this._changeDetectorRef?.markForCheck();
    });
  }
  _updateDisabled(changes) {
    const disabledValue = changes["isDisabled"].currentValue;
    const isDisabled = disabledValue !== 0 && booleanAttribute(disabledValue);
    resolvedPromise.then(() => {
      if (isDisabled && !this.control.disabled) {
        this.control.disable();
      } else if (!isDisabled && this.control.disabled) {
        this.control.enable();
      }
      this._changeDetectorRef?.markForCheck();
    });
  }
  _getPath(controlName) {
    return this._parent ? controlPath(controlName, this._parent) : [controlName];
  }
  static ɵfac = function NgModel_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgModel)(ɵɵdirectiveInject(ControlContainer, 9), ɵɵdirectiveInject(NG_VALIDATORS, 10), ɵɵdirectiveInject(NG_ASYNC_VALIDATORS, 10), ɵɵdirectiveInject(NG_VALUE_ACCESSOR, 10), ɵɵdirectiveInject(ChangeDetectorRef, 8), ɵɵdirectiveInject(CALL_SET_DISABLED_STATE, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _NgModel,
    selectors: [["", "ngModel", "", 3, "formControlName", "", 3, "formControl", ""]],
    inputs: {
      name: "name",
      isDisabled: [0, "disabled", "isDisabled"],
      model: [0, "ngModel", "model"],
      options: [0, "ngModelOptions", "options"]
    },
    outputs: {
      update: "ngModelChange"
    },
    exportAs: ["ngModel"],
    standalone: false,
    features: [ɵɵProvidersFeature([formControlBinding$1]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgModel, [{
    type: Directive,
    args: [{
      selector: "[ngModel]:not([formControlName]):not([formControl])",
      providers: [formControlBinding$1],
      exportAs: "ngModel",
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALUE_ACCESSOR]
    }]
  }, {
    type: ChangeDetectorRef,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [ChangeDetectorRef]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    name: [{
      type: Input
    }],
    isDisabled: [{
      type: Input,
      args: ["disabled"]
    }],
    model: [{
      type: Input,
      args: ["ngModel"]
    }],
    options: [{
      type: Input,
      args: ["ngModelOptions"]
    }],
    update: [{
      type: Output,
      args: ["ngModelChange"]
    }]
  });
})();
function checkParentType$1(parent) {
  if (!(parent instanceof NgModelGroup) && parent instanceof AbstractFormGroupDirective) {
    throw formGroupNameException();
  } else if (!(parent instanceof NgModelGroup) && !(parent instanceof NgForm)) {
    throw modelParentException();
  }
}
var ɵNgNoValidate = class _ɵNgNoValidate {
  static ɵfac = function ɵNgNoValidate_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ɵNgNoValidate)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ɵNgNoValidate,
    selectors: [["form", 3, "ngNoForm", "", 3, "ngNativeValidate", ""]],
    hostAttrs: ["novalidate", ""],
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ɵNgNoValidate, [{
    type: Directive,
    args: [{
      selector: "form:not([ngNoForm]):not([ngNativeValidate])",
      host: {
        "novalidate": ""
      },
      standalone: false
    }]
  }], null, null);
})();
var NUMBER_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => NumberValueAccessor),
  multi: true
};
var NumberValueAccessor = class _NumberValueAccessor extends BuiltInControlValueAccessor {
  /**
   * Sets the "value" property on the input element.
   * @nodoc
   */
  writeValue(value) {
    const normalizedValue = value == null ? "" : value;
    this.setProperty("value", normalizedValue);
  }
  /**
   * Registers a function called when the control value changes.
   * @nodoc
   */
  registerOnChange(fn) {
    this.onChange = (value) => {
      fn(value == "" ? null : parseFloat(value));
    };
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵNumberValueAccessor_BaseFactory;
    return function NumberValueAccessor_Factory(__ngFactoryType__) {
      return (ɵNumberValueAccessor_BaseFactory || (ɵNumberValueAccessor_BaseFactory = ɵɵgetInheritedFactory(_NumberValueAccessor)))(__ngFactoryType__ || _NumberValueAccessor);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _NumberValueAccessor,
    selectors: [["input", "type", "number", "formControlName", ""], ["input", "type", "number", "formControl", ""], ["input", "type", "number", "ngModel", ""]],
    hostBindings: function NumberValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("input", function NumberValueAccessor_input_HostBindingHandler($event) {
          return ctx.onChange($event.target.value);
        })("blur", function NumberValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    standalone: false,
    features: [ɵɵProvidersFeature([NUMBER_VALUE_ACCESSOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumberValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]",
      host: {
        "(input)": "onChange($event.target.value)",
        "(blur)": "onTouched()"
      },
      providers: [NUMBER_VALUE_ACCESSOR],
      standalone: false
    }]
  }], null, null);
})();
var RADIO_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => RadioControlValueAccessor),
  multi: true
};
function throwNameError() {
  throw new RuntimeError(1202, `
      If you define both a name and a formControlName attribute on your radio button, their values
      must match. Ex: <input type="radio" formControlName="food" name="food">
    `);
}
var RadioControlRegistry = class _RadioControlRegistry {
  _accessors = [];
  /**
   * @description
   * Adds a control to the internal registry. For internal use only.
   */
  add(control, accessor) {
    this._accessors.push([control, accessor]);
  }
  /**
   * @description
   * Removes a control from the internal registry. For internal use only.
   */
  remove(accessor) {
    for (let i = this._accessors.length - 1; i >= 0; --i) {
      if (this._accessors[i][1] === accessor) {
        this._accessors.splice(i, 1);
        return;
      }
    }
  }
  /**
   * @description
   * Selects a radio button. For internal use only.
   */
  select(accessor) {
    this._accessors.forEach((c) => {
      if (this._isSameGroup(c, accessor) && c[1] !== accessor) {
        c[1].fireUncheck(accessor.value);
      }
    });
  }
  _isSameGroup(controlPair, accessor) {
    if (!controlPair[0].control) return false;
    return controlPair[0]._parent === accessor._control._parent && controlPair[1].name === accessor.name;
  }
  static ɵfac = function RadioControlRegistry_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RadioControlRegistry)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _RadioControlRegistry,
    factory: _RadioControlRegistry.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioControlRegistry, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var RadioControlValueAccessor = class _RadioControlValueAccessor extends BuiltInControlValueAccessor {
  _registry;
  _injector;
  /** @internal */
  // TODO(issue/24571): remove '!'.
  _state;
  /** @internal */
  // TODO(issue/24571): remove '!'.
  _control;
  /** @internal */
  // TODO(issue/24571): remove '!'.
  _fn;
  setDisabledStateFired = false;
  /**
   * The registered callback function called when a change event occurs on the input element.
   * Note: we declare `onChange` here (also used as host listener) as a function with no arguments
   * to override the `onChange` function (which expects 1 argument) in the parent
   * `BaseControlValueAccessor` class.
   * @nodoc
   */
  onChange = () => {
  };
  /**
   * @description
   * Tracks the name of the radio input element.
   */
  // TODO(issue/24571): remove '!'.
  name;
  /**
   * @description
   * Tracks the name of the `FormControl` bound to the directive. The name corresponds
   * to a key in the parent `FormGroup` or `FormArray`.
   */
  // TODO(issue/24571): remove '!'.
  formControlName;
  /**
   * @description
   * Tracks the value of the radio input element
   */
  value;
  callSetDisabledState = inject(CALL_SET_DISABLED_STATE, {
    optional: true
  }) ?? setDisabledStateDefault;
  constructor(renderer, elementRef, _registry, _injector) {
    super(renderer, elementRef);
    this._registry = _registry;
    this._injector = _injector;
  }
  /** @nodoc */
  ngOnInit() {
    this._control = this._injector.get(NgControl);
    this._checkName();
    this._registry.add(this._control, this);
  }
  /** @nodoc */
  ngOnDestroy() {
    this._registry.remove(this);
  }
  /**
   * Sets the "checked" property value on the radio input element.
   * @nodoc
   */
  writeValue(value) {
    this._state = value === this.value;
    this.setProperty("checked", this._state);
  }
  /**
   * Registers a function called when the control value changes.
   * @nodoc
   */
  registerOnChange(fn) {
    this._fn = fn;
    this.onChange = () => {
      fn(this.value);
      this._registry.select(this);
    };
  }
  /** @nodoc */
  setDisabledState(isDisabled) {
    if (this.setDisabledStateFired || isDisabled || this.callSetDisabledState === "whenDisabledForLegacyCode") {
      this.setProperty("disabled", isDisabled);
    }
    this.setDisabledStateFired = true;
  }
  /**
   * Sets the "value" on the radio input element and unchecks it.
   *
   * @param value
   */
  fireUncheck(value) {
    this.writeValue(value);
  }
  _checkName() {
    if (this.name && this.formControlName && this.name !== this.formControlName && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throwNameError();
    }
    if (!this.name && this.formControlName) this.name = this.formControlName;
  }
  static ɵfac = function RadioControlValueAccessor_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RadioControlValueAccessor)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(RadioControlRegistry), ɵɵdirectiveInject(Injector));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _RadioControlValueAccessor,
    selectors: [["input", "type", "radio", "formControlName", ""], ["input", "type", "radio", "formControl", ""], ["input", "type", "radio", "ngModel", ""]],
    hostBindings: function RadioControlValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("change", function RadioControlValueAccessor_change_HostBindingHandler() {
          return ctx.onChange();
        })("blur", function RadioControlValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    inputs: {
      name: "name",
      formControlName: "formControlName",
      value: "value"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([RADIO_VALUE_ACCESSOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioControlValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]",
      host: {
        "(change)": "onChange()",
        "(blur)": "onTouched()"
      },
      providers: [RADIO_VALUE_ACCESSOR],
      standalone: false
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: RadioControlRegistry
  }, {
    type: Injector
  }], {
    name: [{
      type: Input
    }],
    formControlName: [{
      type: Input
    }],
    value: [{
      type: Input
    }]
  });
})();
var RANGE_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => RangeValueAccessor),
  multi: true
};
var RangeValueAccessor = class _RangeValueAccessor extends BuiltInControlValueAccessor {
  /**
   * Sets the "value" property on the input element.
   * @nodoc
   */
  writeValue(value) {
    this.setProperty("value", parseFloat(value));
  }
  /**
   * Registers a function called when the control value changes.
   * @nodoc
   */
  registerOnChange(fn) {
    this.onChange = (value) => {
      fn(value == "" ? null : parseFloat(value));
    };
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵRangeValueAccessor_BaseFactory;
    return function RangeValueAccessor_Factory(__ngFactoryType__) {
      return (ɵRangeValueAccessor_BaseFactory || (ɵRangeValueAccessor_BaseFactory = ɵɵgetInheritedFactory(_RangeValueAccessor)))(__ngFactoryType__ || _RangeValueAccessor);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _RangeValueAccessor,
    selectors: [["input", "type", "range", "formControlName", ""], ["input", "type", "range", "formControl", ""], ["input", "type", "range", "ngModel", ""]],
    hostBindings: function RangeValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("change", function RangeValueAccessor_change_HostBindingHandler($event) {
          return ctx.onChange($event.target.value);
        })("input", function RangeValueAccessor_input_HostBindingHandler($event) {
          return ctx.onChange($event.target.value);
        })("blur", function RangeValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    standalone: false,
    features: [ɵɵProvidersFeature([RANGE_VALUE_ACCESSOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RangeValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input[type=range][formControlName],input[type=range][formControl],input[type=range][ngModel]",
      host: {
        "(change)": "onChange($event.target.value)",
        "(input)": "onChange($event.target.value)",
        "(blur)": "onTouched()"
      },
      providers: [RANGE_VALUE_ACCESSOR],
      standalone: false
    }]
  }], null, null);
})();
var NG_MODEL_WITH_FORM_CONTROL_WARNING = new InjectionToken(ngDevMode ? "NgModelWithFormControlWarning" : "");
var formControlBinding = {
  provide: NgControl,
  useExisting: forwardRef(() => FormControlDirective)
};
var FormControlDirective = class _FormControlDirective extends NgControl {
  _ngModelWarningConfig;
  callSetDisabledState;
  /**
   * Internal reference to the view model value.
   * @nodoc
   */
  viewModel;
  /**
   * @description
   * Tracks the `FormControl` instance bound to the directive.
   */
  // TODO(issue/24571): remove '!'.
  form;
  /**
   * @description
   * Triggers a warning in dev mode that this input should not be used with reactive forms.
   */
  set isDisabled(isDisabled) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      console.warn(disabledAttrWarning);
    }
  }
  // TODO(kara): remove next 4 properties once deprecation period is over
  /** @deprecated as of v6 */
  model;
  /** @deprecated as of v6 */
  update = new EventEmitter();
  /**
   * @description
   * Static property used to track whether any ngModel warnings have been sent across
   * all instances of FormControlDirective. Used to support warning config of "once".
   *
   * @internal
   */
  static _ngModelWarningSentOnce = false;
  /**
   * @description
   * Instance property used to track whether an ngModel warning has been sent out for this
   * particular `FormControlDirective` instance. Used to support warning config of "always".
   *
   * @internal
   */
  _ngModelWarningSent = false;
  constructor(validators, asyncValidators, valueAccessors, _ngModelWarningConfig, callSetDisabledState) {
    super();
    this._ngModelWarningConfig = _ngModelWarningConfig;
    this.callSetDisabledState = callSetDisabledState;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
    this.valueAccessor = selectValueAccessor(this, valueAccessors);
  }
  /** @nodoc */
  ngOnChanges(changes) {
    if (this._isControlChanged(changes)) {
      const previousForm = changes["form"].previousValue;
      if (previousForm) {
        cleanUpControl(
          previousForm,
          this,
          /* validateControlPresenceOnChange */
          false
        );
      }
      setUpControl(this.form, this, this.callSetDisabledState);
      this.form.updateValueAndValidity({
        emitEvent: false
      });
    }
    if (isPropertyUpdated(changes, this.viewModel)) {
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        _ngModelWarning("formControl", _FormControlDirective, this, this._ngModelWarningConfig);
      }
      this.form.setValue(this.model);
      this.viewModel = this.model;
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this.form) {
      cleanUpControl(
        this.form,
        this,
        /* validateControlPresenceOnChange */
        false
      );
    }
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return [];
  }
  /**
   * @description
   * The `FormControl` bound to this directive.
   */
  get control() {
    return this.form;
  }
  /**
   * @description
   * Sets the new value for the view model and emits an `ngModelChange` event.
   *
   * @param newValue The new value for the view model.
   */
  viewToModelUpdate(newValue) {
    this.viewModel = newValue;
    this.update.emit(newValue);
  }
  _isControlChanged(changes) {
    return changes.hasOwnProperty("form");
  }
  static ɵfac = function FormControlDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormControlDirective)(ɵɵdirectiveInject(NG_VALIDATORS, 10), ɵɵdirectiveInject(NG_ASYNC_VALIDATORS, 10), ɵɵdirectiveInject(NG_VALUE_ACCESSOR, 10), ɵɵdirectiveInject(NG_MODEL_WITH_FORM_CONTROL_WARNING, 8), ɵɵdirectiveInject(CALL_SET_DISABLED_STATE, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FormControlDirective,
    selectors: [["", "formControl", ""]],
    inputs: {
      form: [0, "formControl", "form"],
      isDisabled: [0, "disabled", "isDisabled"],
      model: [0, "ngModel", "model"]
    },
    outputs: {
      update: "ngModelChange"
    },
    exportAs: ["ngForm"],
    standalone: false,
    features: [ɵɵProvidersFeature([formControlBinding]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormControlDirective, [{
    type: Directive,
    args: [{
      selector: "[formControl]",
      providers: [formControlBinding],
      exportAs: "ngForm",
      standalone: false
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALUE_ACCESSOR]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NG_MODEL_WITH_FORM_CONTROL_WARNING]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    form: [{
      type: Input,
      args: ["formControl"]
    }],
    isDisabled: [{
      type: Input,
      args: ["disabled"]
    }],
    model: [{
      type: Input,
      args: ["ngModel"]
    }],
    update: [{
      type: Output,
      args: ["ngModelChange"]
    }]
  });
})();
var formDirectiveProvider = {
  provide: ControlContainer,
  useExisting: forwardRef(() => FormGroupDirective)
};
var FormGroupDirective = class _FormGroupDirective extends ControlContainer {
  callSetDisabledState;
  /**
   * @description
   * Reports whether the form submission has been triggered.
   */
  get submitted() {
    return untracked(this._submittedReactive);
  }
  // TODO(atscott): Remove once invalid API usage is cleaned up internally
  set submitted(value) {
    this._submittedReactive.set(value);
  }
  /** @internal */
  _submitted = computed(() => this._submittedReactive());
  _submittedReactive = signal(false);
  /**
   * Reference to an old form group input value, which is needed to cleanup
   * old instance in case it was replaced with a new one.
   */
  _oldForm;
  /**
   * Callback that should be invoked when controls in FormGroup or FormArray collection change
   * (added or removed). This callback triggers corresponding DOM updates.
   */
  _onCollectionChange = () => this._updateDomValue();
  /**
   * @description
   * Tracks the list of added `FormControlName` instances
   */
  directives = [];
  /**
   * @description
   * Tracks the `FormGroup` bound to this directive.
   */
  form = null;
  /**
   * @description
   * Emits an event when the form submission has been triggered.
   */
  ngSubmit = new EventEmitter();
  constructor(validators, asyncValidators, callSetDisabledState) {
    super();
    this.callSetDisabledState = callSetDisabledState;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  /** @nodoc */
  ngOnChanges(changes) {
    if ((typeof ngDevMode === "undefined" || ngDevMode) && !this.form) {
      throw missingFormException();
    }
    if (changes.hasOwnProperty("form")) {
      this._updateValidators();
      this._updateDomValue();
      this._updateRegistrations();
      this._oldForm = this.form;
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this.form) {
      cleanUpValidators(this.form, this);
      if (this.form._onCollectionChange === this._onCollectionChange) {
        this.form._registerOnCollectionChange(() => {
        });
      }
    }
  }
  /**
   * @description
   * Returns this directive's instance.
   */
  get formDirective() {
    return this;
  }
  /**
   * @description
   * Returns the `FormGroup` bound to this directive.
   */
  get control() {
    return this.form;
  }
  /**
   * @description
   * Returns an array representing the path to this group. Because this directive
   * always lives at the top level of a form, it always an empty array.
   */
  get path() {
    return [];
  }
  /**
   * @description
   * Method that sets up the control directive in this group, re-calculates its value
   * and validity, and adds the instance to the internal list of directives.
   *
   * @param dir The `FormControlName` directive instance.
   */
  addControl(dir) {
    const ctrl = this.form.get(dir.path);
    setUpControl(ctrl, dir, this.callSetDisabledState);
    ctrl.updateValueAndValidity({
      emitEvent: false
    });
    this.directives.push(dir);
    return ctrl;
  }
  /**
   * @description
   * Retrieves the `FormControl` instance from the provided `FormControlName` directive
   *
   * @param dir The `FormControlName` directive instance.
   */
  getControl(dir) {
    return this.form.get(dir.path);
  }
  /**
   * @description
   * Removes the `FormControlName` instance from the internal list of directives
   *
   * @param dir The `FormControlName` directive instance.
   */
  removeControl(dir) {
    cleanUpControl(
      dir.control || null,
      dir,
      /* validateControlPresenceOnChange */
      false
    );
    removeListItem$1(this.directives, dir);
  }
  /**
   * Adds a new `FormGroupName` directive instance to the form.
   *
   * @param dir The `FormGroupName` directive instance.
   */
  addFormGroup(dir) {
    this._setUpFormContainer(dir);
  }
  /**
   * Performs the necessary cleanup when a `FormGroupName` directive instance is removed from the
   * view.
   *
   * @param dir The `FormGroupName` directive instance.
   */
  removeFormGroup(dir) {
    this._cleanUpFormContainer(dir);
  }
  /**
   * @description
   * Retrieves the `FormGroup` for a provided `FormGroupName` directive instance
   *
   * @param dir The `FormGroupName` directive instance.
   */
  getFormGroup(dir) {
    return this.form.get(dir.path);
  }
  /**
   * Performs the necessary setup when a `FormArrayName` directive instance is added to the view.
   *
   * @param dir The `FormArrayName` directive instance.
   */
  addFormArray(dir) {
    this._setUpFormContainer(dir);
  }
  /**
   * Performs the necessary cleanup when a `FormArrayName` directive instance is removed from the
   * view.
   *
   * @param dir The `FormArrayName` directive instance.
   */
  removeFormArray(dir) {
    this._cleanUpFormContainer(dir);
  }
  /**
   * @description
   * Retrieves the `FormArray` for a provided `FormArrayName` directive instance.
   *
   * @param dir The `FormArrayName` directive instance.
   */
  getFormArray(dir) {
    return this.form.get(dir.path);
  }
  /**
   * Sets the new value for the provided `FormControlName` directive.
   *
   * @param dir The `FormControlName` directive instance.
   * @param value The new value for the directive's control.
   */
  updateModel(dir, value) {
    const ctrl = this.form.get(dir.path);
    ctrl.setValue(value);
  }
  /**
   * @description
   * Method called with the "submit" event is triggered on the form.
   * Triggers the `ngSubmit` emitter to emit the "submit" event as its payload.
   *
   * @param $event The "submit" event object
   */
  onSubmit($event) {
    this._submittedReactive.set(true);
    syncPendingControls(this.form, this.directives);
    this.ngSubmit.emit($event);
    this.form._events.next(new FormSubmittedEvent(this.control));
    return $event?.target?.method === "dialog";
  }
  /**
   * @description
   * Method called when the "reset" event is triggered on the form.
   */
  onReset() {
    this.resetForm();
  }
  /**
   * @description
   * Resets the form to an initial value and resets its submitted status.
   *
   * @param value The new value for the form.
   */
  resetForm(value = void 0) {
    this.form.reset(value);
    this._submittedReactive.set(false);
    this.form._events.next(new FormResetEvent(this.form));
  }
  /** @internal */
  _updateDomValue() {
    this.directives.forEach((dir) => {
      const oldCtrl = dir.control;
      const newCtrl = this.form.get(dir.path);
      if (oldCtrl !== newCtrl) {
        cleanUpControl(oldCtrl || null, dir);
        if (isFormControl(newCtrl)) {
          setUpControl(newCtrl, dir, this.callSetDisabledState);
          dir.control = newCtrl;
        }
      }
    });
    this.form._updateTreeValidity({
      emitEvent: false
    });
  }
  _setUpFormContainer(dir) {
    const ctrl = this.form.get(dir.path);
    setUpFormContainer(ctrl, dir);
    ctrl.updateValueAndValidity({
      emitEvent: false
    });
  }
  _cleanUpFormContainer(dir) {
    if (this.form) {
      const ctrl = this.form.get(dir.path);
      if (ctrl) {
        const isControlUpdated = cleanUpFormContainer(ctrl, dir);
        if (isControlUpdated) {
          ctrl.updateValueAndValidity({
            emitEvent: false
          });
        }
      }
    }
  }
  _updateRegistrations() {
    this.form._registerOnCollectionChange(this._onCollectionChange);
    if (this._oldForm) {
      this._oldForm._registerOnCollectionChange(() => {
      });
    }
  }
  _updateValidators() {
    setUpValidators(this.form, this);
    if (this._oldForm) {
      cleanUpValidators(this._oldForm, this);
    }
  }
  static ɵfac = function FormGroupDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormGroupDirective)(ɵɵdirectiveInject(NG_VALIDATORS, 10), ɵɵdirectiveInject(NG_ASYNC_VALIDATORS, 10), ɵɵdirectiveInject(CALL_SET_DISABLED_STATE, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FormGroupDirective,
    selectors: [["", "formGroup", ""]],
    hostBindings: function FormGroupDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("submit", function FormGroupDirective_submit_HostBindingHandler($event) {
          return ctx.onSubmit($event);
        })("reset", function FormGroupDirective_reset_HostBindingHandler() {
          return ctx.onReset();
        });
      }
    },
    inputs: {
      form: [0, "formGroup", "form"]
    },
    outputs: {
      ngSubmit: "ngSubmit"
    },
    exportAs: ["ngForm"],
    standalone: false,
    features: [ɵɵProvidersFeature([formDirectiveProvider]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormGroupDirective, [{
    type: Directive,
    args: [{
      selector: "[formGroup]",
      providers: [formDirectiveProvider],
      host: {
        "(submit)": "onSubmit($event)",
        "(reset)": "onReset()"
      },
      exportAs: "ngForm",
      standalone: false
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    form: [{
      type: Input,
      args: ["formGroup"]
    }],
    ngSubmit: [{
      type: Output
    }]
  });
})();
var formGroupNameProvider = {
  provide: ControlContainer,
  useExisting: forwardRef(() => FormGroupName)
};
var FormGroupName = class _FormGroupName extends AbstractFormGroupDirective {
  /**
   * @description
   * Tracks the name of the `FormGroup` bound to the directive. The name corresponds
   * to a key in the parent `FormGroup` or `FormArray`.
   * Accepts a name as a string or a number.
   * The name in the form of a string is useful for individual forms,
   * while the numerical form allows for form groups to be bound
   * to indices when iterating over groups in a `FormArray`.
   */
  name = null;
  constructor(parent, validators, asyncValidators) {
    super();
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  /** @internal */
  _checkParentType() {
    if (hasInvalidParent(this._parent) && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw groupParentException();
    }
  }
  static ɵfac = function FormGroupName_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormGroupName)(ɵɵdirectiveInject(ControlContainer, 13), ɵɵdirectiveInject(NG_VALIDATORS, 10), ɵɵdirectiveInject(NG_ASYNC_VALIDATORS, 10));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FormGroupName,
    selectors: [["", "formGroupName", ""]],
    inputs: {
      name: [0, "formGroupName", "name"]
    },
    standalone: false,
    features: [ɵɵProvidersFeature([formGroupNameProvider]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormGroupName, [{
    type: Directive,
    args: [{
      selector: "[formGroupName]",
      providers: [formGroupNameProvider],
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }], {
    name: [{
      type: Input,
      args: ["formGroupName"]
    }]
  });
})();
var formArrayNameProvider = {
  provide: ControlContainer,
  useExisting: forwardRef(() => FormArrayName)
};
var FormArrayName = class _FormArrayName extends ControlContainer {
  /** @internal */
  _parent;
  /**
   * @description
   * Tracks the name of the `FormArray` bound to the directive. The name corresponds
   * to a key in the parent `FormGroup` or `FormArray`.
   * Accepts a name as a string or a number.
   * The name in the form of a string is useful for individual forms,
   * while the numerical form allows for form arrays to be bound
   * to indices when iterating over arrays in a `FormArray`.
   */
  name = null;
  constructor(parent, validators, asyncValidators) {
    super();
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  /**
   * A lifecycle method called when the directive's inputs are initialized. For internal use only.
   * @throws If the directive does not have a valid parent.
   * @nodoc
   */
  ngOnInit() {
    if (hasInvalidParent(this._parent) && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw arrayParentException();
    }
    this.formDirective.addFormArray(this);
  }
  /**
   * A lifecycle method called before the directive's instance is destroyed. For internal use only.
   * @nodoc
   */
  ngOnDestroy() {
    this.formDirective?.removeFormArray(this);
  }
  /**
   * @description
   * The `FormArray` bound to this directive.
   */
  get control() {
    return this.formDirective.getFormArray(this);
  }
  /**
   * @description
   * The top-level directive for this group if present, otherwise null.
   */
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
  }
  static ɵfac = function FormArrayName_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormArrayName)(ɵɵdirectiveInject(ControlContainer, 13), ɵɵdirectiveInject(NG_VALIDATORS, 10), ɵɵdirectiveInject(NG_ASYNC_VALIDATORS, 10));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FormArrayName,
    selectors: [["", "formArrayName", ""]],
    inputs: {
      name: [0, "formArrayName", "name"]
    },
    standalone: false,
    features: [ɵɵProvidersFeature([formArrayNameProvider]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormArrayName, [{
    type: Directive,
    args: [{
      selector: "[formArrayName]",
      providers: [formArrayNameProvider],
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }], {
    name: [{
      type: Input,
      args: ["formArrayName"]
    }]
  });
})();
function hasInvalidParent(parent) {
  return !(parent instanceof FormGroupName) && !(parent instanceof FormGroupDirective) && !(parent instanceof FormArrayName);
}
var controlNameBinding = {
  provide: NgControl,
  useExisting: forwardRef(() => FormControlName)
};
var FormControlName = class _FormControlName extends NgControl {
  _ngModelWarningConfig;
  _added = false;
  /**
   * Internal reference to the view model value.
   * @internal
   */
  viewModel;
  /**
   * @description
   * Tracks the `FormControl` instance bound to the directive.
   */
  // TODO(issue/24571): remove '!'.
  control;
  /**
   * @description
   * Tracks the name of the `FormControl` bound to the directive. The name corresponds
   * to a key in the parent `FormGroup` or `FormArray`.
   * Accepts a name as a string or a number.
   * The name in the form of a string is useful for individual forms,
   * while the numerical form allows for form controls to be bound
   * to indices when iterating over controls in a `FormArray`.
   */
  name = null;
  /**
   * @description
   * Triggers a warning in dev mode that this input should not be used with reactive forms.
   */
  set isDisabled(isDisabled) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      console.warn(disabledAttrWarning);
    }
  }
  // TODO(kara): remove next 4 properties once deprecation period is over
  /** @deprecated as of v6 */
  model;
  /** @deprecated as of v6 */
  update = new EventEmitter();
  /**
   * @description
   * Static property used to track whether any ngModel warnings have been sent across
   * all instances of FormControlName. Used to support warning config of "once".
   *
   * @internal
   */
  static _ngModelWarningSentOnce = false;
  /**
   * @description
   * Instance property used to track whether an ngModel warning has been sent out for this
   * particular FormControlName instance. Used to support warning config of "always".
   *
   * @internal
   */
  _ngModelWarningSent = false;
  constructor(parent, validators, asyncValidators, valueAccessors, _ngModelWarningConfig) {
    super();
    this._ngModelWarningConfig = _ngModelWarningConfig;
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
    this.valueAccessor = selectValueAccessor(this, valueAccessors);
  }
  /** @nodoc */
  ngOnChanges(changes) {
    if (!this._added) this._setUpControl();
    if (isPropertyUpdated(changes, this.viewModel)) {
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        _ngModelWarning("formControlName", _FormControlName, this, this._ngModelWarningConfig);
      }
      this.viewModel = this.model;
      this.formDirective.updateModel(this, this.model);
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this.formDirective) {
      this.formDirective.removeControl(this);
    }
  }
  /**
   * @description
   * Sets the new value for the view model and emits an `ngModelChange` event.
   *
   * @param newValue The new value for the view model.
   */
  viewToModelUpdate(newValue) {
    this.viewModel = newValue;
    this.update.emit(newValue);
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
  }
  /**
   * @description
   * The top-level directive for this group if present, otherwise null.
   */
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  _setUpControl() {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      checkParentType(this._parent, this.name);
    }
    this.control = this.formDirective.addControl(this);
    this._added = true;
  }
  static ɵfac = function FormControlName_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormControlName)(ɵɵdirectiveInject(ControlContainer, 13), ɵɵdirectiveInject(NG_VALIDATORS, 10), ɵɵdirectiveInject(NG_ASYNC_VALIDATORS, 10), ɵɵdirectiveInject(NG_VALUE_ACCESSOR, 10), ɵɵdirectiveInject(NG_MODEL_WITH_FORM_CONTROL_WARNING, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FormControlName,
    selectors: [["", "formControlName", ""]],
    inputs: {
      name: [0, "formControlName", "name"],
      isDisabled: [0, "disabled", "isDisabled"],
      model: [0, "ngModel", "model"]
    },
    outputs: {
      update: "ngModelChange"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([controlNameBinding]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormControlName, [{
    type: Directive,
    args: [{
      selector: "[formControlName]",
      providers: [controlNameBinding],
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALUE_ACCESSOR]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NG_MODEL_WITH_FORM_CONTROL_WARNING]
    }]
  }], {
    name: [{
      type: Input,
      args: ["formControlName"]
    }],
    isDisabled: [{
      type: Input,
      args: ["disabled"]
    }],
    model: [{
      type: Input,
      args: ["ngModel"]
    }],
    update: [{
      type: Output,
      args: ["ngModelChange"]
    }]
  });
})();
function checkParentType(parent, name) {
  if (!(parent instanceof FormGroupName) && parent instanceof AbstractFormGroupDirective) {
    throw ngModelGroupException();
  } else if (!(parent instanceof FormGroupName) && !(parent instanceof FormGroupDirective) && !(parent instanceof FormArrayName)) {
    throw controlParentException(name);
  }
}
var SELECT_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => SelectControlValueAccessor),
  multi: true
};
function _buildValueString$1(id, value) {
  if (id == null) return `${value}`;
  if (value && typeof value === "object") value = "Object";
  return `${id}: ${value}`.slice(0, 50);
}
function _extractId$1(valueString) {
  return valueString.split(":")[0];
}
var SelectControlValueAccessor = class _SelectControlValueAccessor extends BuiltInControlValueAccessor {
  /** @nodoc */
  value;
  /** @internal */
  _optionMap = /* @__PURE__ */ new Map();
  /** @internal */
  _idCounter = 0;
  /**
   * @description
   * Tracks the option comparison algorithm for tracking identities when
   * checking for changes.
   */
  set compareWith(fn) {
    if (typeof fn !== "function" && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw new RuntimeError(1201, `compareWith must be a function, but received ${JSON.stringify(fn)}`);
    }
    this._compareWith = fn;
  }
  _compareWith = Object.is;
  /**
   * Sets the "value" property on the select element.
   * @nodoc
   */
  writeValue(value) {
    this.value = value;
    const id = this._getOptionId(value);
    const valueString = _buildValueString$1(id, value);
    this.setProperty("value", valueString);
  }
  /**
   * Registers a function called when the control value changes.
   * @nodoc
   */
  registerOnChange(fn) {
    this.onChange = (valueString) => {
      this.value = this._getOptionValue(valueString);
      fn(this.value);
    };
  }
  /** @internal */
  _registerOption() {
    return (this._idCounter++).toString();
  }
  /** @internal */
  _getOptionId(value) {
    for (const id of this._optionMap.keys()) {
      if (this._compareWith(this._optionMap.get(id), value)) return id;
    }
    return null;
  }
  /** @internal */
  _getOptionValue(valueString) {
    const id = _extractId$1(valueString);
    return this._optionMap.has(id) ? this._optionMap.get(id) : valueString;
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵSelectControlValueAccessor_BaseFactory;
    return function SelectControlValueAccessor_Factory(__ngFactoryType__) {
      return (ɵSelectControlValueAccessor_BaseFactory || (ɵSelectControlValueAccessor_BaseFactory = ɵɵgetInheritedFactory(_SelectControlValueAccessor)))(__ngFactoryType__ || _SelectControlValueAccessor);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _SelectControlValueAccessor,
    selectors: [["select", "formControlName", "", 3, "multiple", ""], ["select", "formControl", "", 3, "multiple", ""], ["select", "ngModel", "", 3, "multiple", ""]],
    hostBindings: function SelectControlValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("change", function SelectControlValueAccessor_change_HostBindingHandler($event) {
          return ctx.onChange($event.target.value);
        })("blur", function SelectControlValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    inputs: {
      compareWith: "compareWith"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([SELECT_VALUE_ACCESSOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectControlValueAccessor, [{
    type: Directive,
    args: [{
      selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]",
      host: {
        "(change)": "onChange($event.target.value)",
        "(blur)": "onTouched()"
      },
      providers: [SELECT_VALUE_ACCESSOR],
      standalone: false
    }]
  }], null, {
    compareWith: [{
      type: Input
    }]
  });
})();
var NgSelectOption = class _NgSelectOption {
  _element;
  _renderer;
  _select;
  /**
   * @description
   * ID of the option element
   */
  // TODO(issue/24571): remove '!'.
  id;
  constructor(_element, _renderer, _select) {
    this._element = _element;
    this._renderer = _renderer;
    this._select = _select;
    if (this._select) this.id = this._select._registerOption();
  }
  /**
   * @description
   * Tracks the value bound to the option element. Unlike the value binding,
   * ngValue supports binding to objects.
   */
  set ngValue(value) {
    if (this._select == null) return;
    this._select._optionMap.set(this.id, value);
    this._setElementValue(_buildValueString$1(this.id, value));
    this._select.writeValue(this._select.value);
  }
  /**
   * @description
   * Tracks simple string values bound to the option element.
   * For objects, use the `ngValue` input binding.
   */
  set value(value) {
    this._setElementValue(value);
    if (this._select) this._select.writeValue(this._select.value);
  }
  /** @internal */
  _setElementValue(value) {
    this._renderer.setProperty(this._element.nativeElement, "value", value);
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this._select) {
      this._select._optionMap.delete(this.id);
      this._select.writeValue(this._select.value);
    }
  }
  static ɵfac = function NgSelectOption_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgSelectOption)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(SelectControlValueAccessor, 9));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _NgSelectOption,
    selectors: [["option"]],
    inputs: {
      ngValue: "ngValue",
      value: "value"
    },
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgSelectOption, [{
    type: Directive,
    args: [{
      selector: "option",
      standalone: false
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: SelectControlValueAccessor,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }], {
    ngValue: [{
      type: Input,
      args: ["ngValue"]
    }],
    value: [{
      type: Input,
      args: ["value"]
    }]
  });
})();
var SELECT_MULTIPLE_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => SelectMultipleControlValueAccessor),
  multi: true
};
function _buildValueString(id, value) {
  if (id == null) return `${value}`;
  if (typeof value === "string") value = `'${value}'`;
  if (value && typeof value === "object") value = "Object";
  return `${id}: ${value}`.slice(0, 50);
}
function _extractId(valueString) {
  return valueString.split(":")[0];
}
var SelectMultipleControlValueAccessor = class _SelectMultipleControlValueAccessor extends BuiltInControlValueAccessor {
  /**
   * The current value.
   * @nodoc
   */
  value;
  /** @internal */
  _optionMap = /* @__PURE__ */ new Map();
  /** @internal */
  _idCounter = 0;
  /**
   * @description
   * Tracks the option comparison algorithm for tracking identities when
   * checking for changes.
   */
  set compareWith(fn) {
    if (typeof fn !== "function" && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw new RuntimeError(1201, `compareWith must be a function, but received ${JSON.stringify(fn)}`);
    }
    this._compareWith = fn;
  }
  _compareWith = Object.is;
  /**
   * Sets the "value" property on one or of more of the select's options.
   * @nodoc
   */
  writeValue(value) {
    this.value = value;
    let optionSelectedStateSetter;
    if (Array.isArray(value)) {
      const ids = value.map((v) => this._getOptionId(v));
      optionSelectedStateSetter = (opt, o) => {
        opt._setSelected(ids.indexOf(o.toString()) > -1);
      };
    } else {
      optionSelectedStateSetter = (opt, o) => {
        opt._setSelected(false);
      };
    }
    this._optionMap.forEach(optionSelectedStateSetter);
  }
  /**
   * Registers a function called when the control value changes
   * and writes an array of the selected options.
   * @nodoc
   */
  registerOnChange(fn) {
    this.onChange = (element) => {
      const selected = [];
      const selectedOptions = element.selectedOptions;
      if (selectedOptions !== void 0) {
        const options = selectedOptions;
        for (let i = 0; i < options.length; i++) {
          const opt = options[i];
          const val = this._getOptionValue(opt.value);
          selected.push(val);
        }
      } else {
        const options = element.options;
        for (let i = 0; i < options.length; i++) {
          const opt = options[i];
          if (opt.selected) {
            const val = this._getOptionValue(opt.value);
            selected.push(val);
          }
        }
      }
      this.value = selected;
      fn(selected);
    };
  }
  /** @internal */
  _registerOption(value) {
    const id = (this._idCounter++).toString();
    this._optionMap.set(id, value);
    return id;
  }
  /** @internal */
  _getOptionId(value) {
    for (const id of this._optionMap.keys()) {
      if (this._compareWith(this._optionMap.get(id)._value, value)) return id;
    }
    return null;
  }
  /** @internal */
  _getOptionValue(valueString) {
    const id = _extractId(valueString);
    return this._optionMap.has(id) ? this._optionMap.get(id)._value : valueString;
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵSelectMultipleControlValueAccessor_BaseFactory;
    return function SelectMultipleControlValueAccessor_Factory(__ngFactoryType__) {
      return (ɵSelectMultipleControlValueAccessor_BaseFactory || (ɵSelectMultipleControlValueAccessor_BaseFactory = ɵɵgetInheritedFactory(_SelectMultipleControlValueAccessor)))(__ngFactoryType__ || _SelectMultipleControlValueAccessor);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _SelectMultipleControlValueAccessor,
    selectors: [["select", "multiple", "", "formControlName", ""], ["select", "multiple", "", "formControl", ""], ["select", "multiple", "", "ngModel", ""]],
    hostBindings: function SelectMultipleControlValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("change", function SelectMultipleControlValueAccessor_change_HostBindingHandler($event) {
          return ctx.onChange($event.target);
        })("blur", function SelectMultipleControlValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    inputs: {
      compareWith: "compareWith"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([SELECT_MULTIPLE_VALUE_ACCESSOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectMultipleControlValueAccessor, [{
    type: Directive,
    args: [{
      selector: "select[multiple][formControlName],select[multiple][formControl],select[multiple][ngModel]",
      host: {
        "(change)": "onChange($event.target)",
        "(blur)": "onTouched()"
      },
      providers: [SELECT_MULTIPLE_VALUE_ACCESSOR],
      standalone: false
    }]
  }], null, {
    compareWith: [{
      type: Input
    }]
  });
})();
var ɵNgSelectMultipleOption = class _ɵNgSelectMultipleOption {
  _element;
  _renderer;
  _select;
  // TODO(issue/24571): remove '!'.
  id;
  /** @internal */
  _value;
  constructor(_element, _renderer, _select) {
    this._element = _element;
    this._renderer = _renderer;
    this._select = _select;
    if (this._select) {
      this.id = this._select._registerOption(this);
    }
  }
  /**
   * @description
   * Tracks the value bound to the option element. Unlike the value binding,
   * ngValue supports binding to objects.
   */
  set ngValue(value) {
    if (this._select == null) return;
    this._value = value;
    this._setElementValue(_buildValueString(this.id, value));
    this._select.writeValue(this._select.value);
  }
  /**
   * @description
   * Tracks simple string values bound to the option element.
   * For objects, use the `ngValue` input binding.
   */
  set value(value) {
    if (this._select) {
      this._value = value;
      this._setElementValue(_buildValueString(this.id, value));
      this._select.writeValue(this._select.value);
    } else {
      this._setElementValue(value);
    }
  }
  /** @internal */
  _setElementValue(value) {
    this._renderer.setProperty(this._element.nativeElement, "value", value);
  }
  /** @internal */
  _setSelected(selected) {
    this._renderer.setProperty(this._element.nativeElement, "selected", selected);
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this._select) {
      this._select._optionMap.delete(this.id);
      this._select.writeValue(this._select.value);
    }
  }
  static ɵfac = function ɵNgSelectMultipleOption_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ɵNgSelectMultipleOption)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(SelectMultipleControlValueAccessor, 9));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ɵNgSelectMultipleOption,
    selectors: [["option"]],
    inputs: {
      ngValue: "ngValue",
      value: "value"
    },
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ɵNgSelectMultipleOption, [{
    type: Directive,
    args: [{
      selector: "option",
      standalone: false
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: SelectMultipleControlValueAccessor,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }], {
    ngValue: [{
      type: Input,
      args: ["ngValue"]
    }],
    value: [{
      type: Input,
      args: ["value"]
    }]
  });
})();
function toInteger(value) {
  return typeof value === "number" ? value : parseInt(value, 10);
}
function toFloat(value) {
  return typeof value === "number" ? value : parseFloat(value);
}
var AbstractValidatorDirective = class _AbstractValidatorDirective {
  _validator = nullValidator;
  _onChange;
  /**
   * A flag that tracks whether this validator is enabled.
   *
   * Marking it `internal` (vs `protected`), so that this flag can be used in host bindings of
   * directive classes that extend this base class.
   * @internal
   */
  _enabled;
  /** @nodoc */
  ngOnChanges(changes) {
    if (this.inputName in changes) {
      const input = this.normalizeInput(changes[this.inputName].currentValue);
      this._enabled = this.enabled(input);
      this._validator = this._enabled ? this.createValidator(input) : nullValidator;
      if (this._onChange) {
        this._onChange();
      }
    }
  }
  /** @nodoc */
  validate(control) {
    return this._validator(control);
  }
  /** @nodoc */
  registerOnValidatorChange(fn) {
    this._onChange = fn;
  }
  /**
   * @description
   * Determines whether this validator should be active or not based on an input.
   * Base class implementation checks whether an input is defined (if the value is different from
   * `null` and `undefined`). Validator classes that extend this base class can override this
   * function with the logic specific to a particular validator directive.
   */
  enabled(input) {
    return input != null;
  }
  static ɵfac = function AbstractValidatorDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AbstractValidatorDirective)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _AbstractValidatorDirective,
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AbstractValidatorDirective, [{
    type: Directive
  }], null, null);
})();
var MAX_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MaxValidator),
  multi: true
};
var MaxValidator = class _MaxValidator extends AbstractValidatorDirective {
  /**
   * @description
   * Tracks changes to the max bound to this directive.
   */
  max;
  /** @internal */
  inputName = "max";
  /** @internal */
  normalizeInput = (input) => toFloat(input);
  /** @internal */
  createValidator = (max2) => maxValidator(max2);
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵMaxValidator_BaseFactory;
    return function MaxValidator_Factory(__ngFactoryType__) {
      return (ɵMaxValidator_BaseFactory || (ɵMaxValidator_BaseFactory = ɵɵgetInheritedFactory(_MaxValidator)))(__ngFactoryType__ || _MaxValidator);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _MaxValidator,
    selectors: [["input", "type", "number", "max", "", "formControlName", ""], ["input", "type", "number", "max", "", "formControl", ""], ["input", "type", "number", "max", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function MaxValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("max", ctx._enabled ? ctx.max : null);
      }
    },
    inputs: {
      max: "max"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([MAX_VALIDATOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MaxValidator, [{
    type: Directive,
    args: [{
      selector: "input[type=number][max][formControlName],input[type=number][max][formControl],input[type=number][max][ngModel]",
      providers: [MAX_VALIDATOR],
      host: {
        "[attr.max]": "_enabled ? max : null"
      },
      standalone: false
    }]
  }], null, {
    max: [{
      type: Input
    }]
  });
})();
var MIN_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MinValidator),
  multi: true
};
var MinValidator = class _MinValidator extends AbstractValidatorDirective {
  /**
   * @description
   * Tracks changes to the min bound to this directive.
   */
  min;
  /** @internal */
  inputName = "min";
  /** @internal */
  normalizeInput = (input) => toFloat(input);
  /** @internal */
  createValidator = (min2) => minValidator(min2);
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵMinValidator_BaseFactory;
    return function MinValidator_Factory(__ngFactoryType__) {
      return (ɵMinValidator_BaseFactory || (ɵMinValidator_BaseFactory = ɵɵgetInheritedFactory(_MinValidator)))(__ngFactoryType__ || _MinValidator);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _MinValidator,
    selectors: [["input", "type", "number", "min", "", "formControlName", ""], ["input", "type", "number", "min", "", "formControl", ""], ["input", "type", "number", "min", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function MinValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("min", ctx._enabled ? ctx.min : null);
      }
    },
    inputs: {
      min: "min"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([MIN_VALIDATOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MinValidator, [{
    type: Directive,
    args: [{
      selector: "input[type=number][min][formControlName],input[type=number][min][formControl],input[type=number][min][ngModel]",
      providers: [MIN_VALIDATOR],
      host: {
        "[attr.min]": "_enabled ? min : null"
      },
      standalone: false
    }]
  }], null, {
    min: [{
      type: Input
    }]
  });
})();
var REQUIRED_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => RequiredValidator),
  multi: true
};
var CHECKBOX_REQUIRED_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => CheckboxRequiredValidator),
  multi: true
};
var RequiredValidator = class _RequiredValidator extends AbstractValidatorDirective {
  /**
   * @description
   * Tracks changes to the required attribute bound to this directive.
   */
  required;
  /** @internal */
  inputName = "required";
  /** @internal */
  normalizeInput = booleanAttribute;
  /** @internal */
  createValidator = (input) => requiredValidator;
  /** @nodoc */
  enabled(input) {
    return input;
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵRequiredValidator_BaseFactory;
    return function RequiredValidator_Factory(__ngFactoryType__) {
      return (ɵRequiredValidator_BaseFactory || (ɵRequiredValidator_BaseFactory = ɵɵgetInheritedFactory(_RequiredValidator)))(__ngFactoryType__ || _RequiredValidator);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _RequiredValidator,
    selectors: [["", "required", "", "formControlName", "", 3, "type", "checkbox"], ["", "required", "", "formControl", "", 3, "type", "checkbox"], ["", "required", "", "ngModel", "", 3, "type", "checkbox"]],
    hostVars: 1,
    hostBindings: function RequiredValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("required", ctx._enabled ? "" : null);
      }
    },
    inputs: {
      required: "required"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([REQUIRED_VALIDATOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RequiredValidator, [{
    type: Directive,
    args: [{
      selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]",
      providers: [REQUIRED_VALIDATOR],
      host: {
        "[attr.required]": '_enabled ? "" : null'
      },
      standalone: false
    }]
  }], null, {
    required: [{
      type: Input
    }]
  });
})();
var CheckboxRequiredValidator = class _CheckboxRequiredValidator extends RequiredValidator {
  /** @internal */
  createValidator = (input) => requiredTrueValidator;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵCheckboxRequiredValidator_BaseFactory;
    return function CheckboxRequiredValidator_Factory(__ngFactoryType__) {
      return (ɵCheckboxRequiredValidator_BaseFactory || (ɵCheckboxRequiredValidator_BaseFactory = ɵɵgetInheritedFactory(_CheckboxRequiredValidator)))(__ngFactoryType__ || _CheckboxRequiredValidator);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _CheckboxRequiredValidator,
    selectors: [["input", "type", "checkbox", "required", "", "formControlName", ""], ["input", "type", "checkbox", "required", "", "formControl", ""], ["input", "type", "checkbox", "required", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function CheckboxRequiredValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("required", ctx._enabled ? "" : null);
      }
    },
    standalone: false,
    features: [ɵɵProvidersFeature([CHECKBOX_REQUIRED_VALIDATOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckboxRequiredValidator, [{
    type: Directive,
    args: [{
      selector: "input[type=checkbox][required][formControlName],input[type=checkbox][required][formControl],input[type=checkbox][required][ngModel]",
      providers: [CHECKBOX_REQUIRED_VALIDATOR],
      host: {
        "[attr.required]": '_enabled ? "" : null'
      },
      standalone: false
    }]
  }], null, null);
})();
var EMAIL_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => EmailValidator),
  multi: true
};
var EmailValidator = class _EmailValidator extends AbstractValidatorDirective {
  /**
   * @description
   * Tracks changes to the email attribute bound to this directive.
   */
  email;
  /** @internal */
  inputName = "email";
  /** @internal */
  normalizeInput = booleanAttribute;
  /** @internal */
  createValidator = (input) => emailValidator;
  /** @nodoc */
  enabled(input) {
    return input;
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵEmailValidator_BaseFactory;
    return function EmailValidator_Factory(__ngFactoryType__) {
      return (ɵEmailValidator_BaseFactory || (ɵEmailValidator_BaseFactory = ɵɵgetInheritedFactory(_EmailValidator)))(__ngFactoryType__ || _EmailValidator);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _EmailValidator,
    selectors: [["", "email", "", "formControlName", ""], ["", "email", "", "formControl", ""], ["", "email", "", "ngModel", ""]],
    inputs: {
      email: "email"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([EMAIL_VALIDATOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EmailValidator, [{
    type: Directive,
    args: [{
      selector: "[email][formControlName],[email][formControl],[email][ngModel]",
      providers: [EMAIL_VALIDATOR],
      standalone: false
    }]
  }], null, {
    email: [{
      type: Input
    }]
  });
})();
var MIN_LENGTH_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MinLengthValidator),
  multi: true
};
var MinLengthValidator = class _MinLengthValidator extends AbstractValidatorDirective {
  /**
   * @description
   * Tracks changes to the minimum length bound to this directive.
   */
  minlength;
  /** @internal */
  inputName = "minlength";
  /** @internal */
  normalizeInput = (input) => toInteger(input);
  /** @internal */
  createValidator = (minlength) => minLengthValidator(minlength);
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵMinLengthValidator_BaseFactory;
    return function MinLengthValidator_Factory(__ngFactoryType__) {
      return (ɵMinLengthValidator_BaseFactory || (ɵMinLengthValidator_BaseFactory = ɵɵgetInheritedFactory(_MinLengthValidator)))(__ngFactoryType__ || _MinLengthValidator);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _MinLengthValidator,
    selectors: [["", "minlength", "", "formControlName", ""], ["", "minlength", "", "formControl", ""], ["", "minlength", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function MinLengthValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("minlength", ctx._enabled ? ctx.minlength : null);
      }
    },
    inputs: {
      minlength: "minlength"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([MIN_LENGTH_VALIDATOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MinLengthValidator, [{
    type: Directive,
    args: [{
      selector: "[minlength][formControlName],[minlength][formControl],[minlength][ngModel]",
      providers: [MIN_LENGTH_VALIDATOR],
      host: {
        "[attr.minlength]": "_enabled ? minlength : null"
      },
      standalone: false
    }]
  }], null, {
    minlength: [{
      type: Input
    }]
  });
})();
var MAX_LENGTH_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MaxLengthValidator),
  multi: true
};
var MaxLengthValidator = class _MaxLengthValidator extends AbstractValidatorDirective {
  /**
   * @description
   * Tracks changes to the maximum length bound to this directive.
   */
  maxlength;
  /** @internal */
  inputName = "maxlength";
  /** @internal */
  normalizeInput = (input) => toInteger(input);
  /** @internal */
  createValidator = (maxlength) => maxLengthValidator(maxlength);
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵMaxLengthValidator_BaseFactory;
    return function MaxLengthValidator_Factory(__ngFactoryType__) {
      return (ɵMaxLengthValidator_BaseFactory || (ɵMaxLengthValidator_BaseFactory = ɵɵgetInheritedFactory(_MaxLengthValidator)))(__ngFactoryType__ || _MaxLengthValidator);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _MaxLengthValidator,
    selectors: [["", "maxlength", "", "formControlName", ""], ["", "maxlength", "", "formControl", ""], ["", "maxlength", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function MaxLengthValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("maxlength", ctx._enabled ? ctx.maxlength : null);
      }
    },
    inputs: {
      maxlength: "maxlength"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([MAX_LENGTH_VALIDATOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MaxLengthValidator, [{
    type: Directive,
    args: [{
      selector: "[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]",
      providers: [MAX_LENGTH_VALIDATOR],
      host: {
        "[attr.maxlength]": "_enabled ? maxlength : null"
      },
      standalone: false
    }]
  }], null, {
    maxlength: [{
      type: Input
    }]
  });
})();
var PATTERN_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => PatternValidator),
  multi: true
};
var PatternValidator = class _PatternValidator extends AbstractValidatorDirective {
  /**
   * @description
   * Tracks changes to the pattern bound to this directive.
   */
  pattern;
  // This input is always defined, since the name matches selector.
  /** @internal */
  inputName = "pattern";
  /** @internal */
  normalizeInput = (input) => input;
  /** @internal */
  createValidator = (input) => patternValidator(input);
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPatternValidator_BaseFactory;
    return function PatternValidator_Factory(__ngFactoryType__) {
      return (ɵPatternValidator_BaseFactory || (ɵPatternValidator_BaseFactory = ɵɵgetInheritedFactory(_PatternValidator)))(__ngFactoryType__ || _PatternValidator);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _PatternValidator,
    selectors: [["", "pattern", "", "formControlName", ""], ["", "pattern", "", "formControl", ""], ["", "pattern", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function PatternValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("pattern", ctx._enabled ? ctx.pattern : null);
      }
    },
    inputs: {
      pattern: "pattern"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([PATTERN_VALIDATOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PatternValidator, [{
    type: Directive,
    args: [{
      selector: "[pattern][formControlName],[pattern][formControl],[pattern][ngModel]",
      providers: [PATTERN_VALIDATOR],
      host: {
        "[attr.pattern]": "_enabled ? pattern : null"
      },
      standalone: false
    }]
  }], null, {
    pattern: [{
      type: Input
    }]
  });
})();
var SHARED_FORM_DIRECTIVES = [ɵNgNoValidate, NgSelectOption, ɵNgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, CheckboxRequiredValidator, EmailValidator, MinValidator, MaxValidator];
var TEMPLATE_DRIVEN_DIRECTIVES = [NgModel, NgModelGroup, NgForm];
var REACTIVE_DRIVEN_DIRECTIVES = [FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName];
var ɵInternalFormsSharedModule = class _ɵInternalFormsSharedModule {
  static ɵfac = function ɵInternalFormsSharedModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ɵInternalFormsSharedModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _ɵInternalFormsSharedModule,
    declarations: [ɵNgNoValidate, NgSelectOption, ɵNgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, CheckboxRequiredValidator, EmailValidator, MinValidator, MaxValidator],
    exports: [ɵNgNoValidate, NgSelectOption, ɵNgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, CheckboxRequiredValidator, EmailValidator, MinValidator, MaxValidator]
  });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ɵInternalFormsSharedModule, [{
    type: NgModule,
    args: [{
      declarations: SHARED_FORM_DIRECTIVES,
      exports: SHARED_FORM_DIRECTIVES
    }]
  }], null, null);
})();
var FormArray = class extends AbstractControl {
  /**
   * Creates a new `FormArray` instance.
   *
   * @param controls An array of child controls. Each child control is given an index
   * where it is registered.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of
   * such functions, or an `AbstractControlOptions` object that contains validation functions
   * and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator functions
   *
   */
  constructor(controls, validatorOrOpts, asyncValidator) {
    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
    this.controls = controls;
    this._initObservables();
    this._setUpdateStrategy(validatorOrOpts);
    this._setUpControls();
    this.updateValueAndValidity({
      onlySelf: true,
      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
      // `VALID` or `INVALID`.
      // The status should be broadcasted via the `statusChanges` observable, so we set `emitEvent`
      // to `true` to allow that during the control creation process.
      emitEvent: !!this.asyncValidator
    });
  }
  controls;
  /**
   * Get the `AbstractControl` at the given `index` in the array.
   *
   * @param index Index in the array to retrieve the control. If `index` is negative, it will wrap
   *     around from the back, and if index is greatly negative (less than `-length`), the result is
   * undefined. This behavior is the same as `Array.at(index)`.
   */
  at(index) {
    return this.controls[this._adjustIndex(index)];
  }
  /**
   * Insert a new `AbstractControl` at the end of the array.
   *
   * @param control Form control to be inserted
   * @param options Specifies whether this FormArray instance should emit events after a new
   *     control is added.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * inserted. When false, no events are emitted.
   */
  push(control, options = {}) {
    this.controls.push(control);
    this._registerControl(control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  /**
   * Insert a new `AbstractControl` at the given `index` in the array.
   *
   * @param index Index in the array to insert the control. If `index` is negative, wraps around
   *     from the back. If `index` is greatly negative (less than `-length`), prepends to the array.
   * This behavior is the same as `Array.splice(index, 0, control)`.
   * @param control Form control to be inserted
   * @param options Specifies whether this FormArray instance should emit events after a new
   *     control is inserted.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * inserted. When false, no events are emitted.
   */
  insert(index, control, options = {}) {
    this.controls.splice(index, 0, control);
    this._registerControl(control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
  }
  /**
   * Remove the control at the given `index` in the array.
   *
   * @param index Index in the array to remove the control.  If `index` is negative, wraps around
   *     from the back. If `index` is greatly negative (less than `-length`), removes the first
   *     element. This behavior is the same as `Array.splice(index, 1)`.
   * @param options Specifies whether this FormArray instance should emit events after a
   *     control is removed.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * removed. When false, no events are emitted.
   */
  removeAt(index, options = {}) {
    let adjustedIndex = this._adjustIndex(index);
    if (adjustedIndex < 0) adjustedIndex = 0;
    if (this.controls[adjustedIndex]) this.controls[adjustedIndex]._registerOnCollectionChange(() => {
    });
    this.controls.splice(adjustedIndex, 1);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
  }
  /**
   * Replace an existing control.
   *
   * @param index Index in the array to replace the control. If `index` is negative, wraps around
   *     from the back. If `index` is greatly negative (less than `-length`), replaces the first
   *     element. This behavior is the same as `Array.splice(index, 1, control)`.
   * @param control The `AbstractControl` control to replace the existing control
   * @param options Specifies whether this FormArray instance should emit events after an
   *     existing control is replaced with a new one.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * replaced with a new one. When false, no events are emitted.
   */
  setControl(index, control, options = {}) {
    let adjustedIndex = this._adjustIndex(index);
    if (adjustedIndex < 0) adjustedIndex = 0;
    if (this.controls[adjustedIndex]) this.controls[adjustedIndex]._registerOnCollectionChange(() => {
    });
    this.controls.splice(adjustedIndex, 1);
    if (control) {
      this.controls.splice(adjustedIndex, 0, control);
      this._registerControl(control);
    }
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  /**
   * Length of the control array.
   */
  get length() {
    return this.controls.length;
  }
  /**
   * Sets the value of the `FormArray`. It accepts an array that matches
   * the structure of the control.
   *
   * This method performs strict checks, and throws an error if you try
   * to set the value of a control that doesn't exist or if you exclude the
   * value of a control.
   *
   * @usageNotes
   * ### Set the values for the controls in the form array
   *
   * ```ts
   * const arr = new FormArray([
   *   new FormControl(),
   *   new FormControl()
   * ]);
   * console.log(arr.value);   // [null, null]
   *
   * arr.setValue(['Nancy', 'Drew']);
   * console.log(arr.value);   // ['Nancy', 'Drew']
   * ```
   *
   * @param value Array of values for the controls
   * @param options Configure options that determine how the control propagates changes and
   * emits events after the value changes
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
   * is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control value is updated.
   * When false, no events are emitted.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   */
  setValue(value, options = {}) {
    assertAllValuesPresent(this, false, value);
    value.forEach((newValue, index) => {
      assertControlPresent(this, false, index);
      this.at(index).setValue(newValue, {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Patches the value of the `FormArray`. It accepts an array that matches the
   * structure of the control, and does its best to match the values to the correct
   * controls in the group.
   *
   * It accepts both super-sets and sub-sets of the array without throwing an error.
   *
   * @usageNotes
   * ### Patch the values for controls in a form array
   *
   * ```ts
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   * console.log(arr.value);   // [null, null]
   *
   * arr.patchValue(['Nancy']);
   * console.log(arr.value);   // ['Nancy', null]
   * ```
   *
   * @param value Array of latest values for the controls
   * @param options Configure options that determine how the control propagates changes and
   * emits events after the value changes
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
   * is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control
   * value is updated. When false, no events are emitted. The configuration options are passed to
   * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.
   */
  patchValue(value, options = {}) {
    if (value == null) return;
    value.forEach((newValue, index) => {
      if (this.at(index)) {
        this.at(index).patchValue(newValue, {
          onlySelf: true,
          emitEvent: options.emitEvent
        });
      }
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Resets the `FormArray` and all descendants are marked `pristine` and `untouched`, and the
   * value of all descendants to null or null maps.
   *
   * You reset to a specific form state by passing in an array of states
   * that matches the structure of the control. The state is a standalone value
   * or a form state object with both a value and a disabled status.
   *
   * @usageNotes
   * ### Reset the values in a form array
   *
   * ```ts
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   * arr.reset(['name', 'last name']);
   *
   * console.log(arr.value);  // ['name', 'last name']
   * ```
   *
   * ### Reset the values in a form array and the disabled status for the first control
   *
   * ```ts
   * arr.reset([
   *   {value: 'name', disabled: true},
   *   'last'
   * ]);
   *
   * console.log(arr.value);  // ['last']
   * console.log(arr.at(0).status);  // 'DISABLED'
   * ```
   *
   * @param value Array of values for the controls
   * @param options Configure options that determine how the control propagates changes and
   * emits events after the value changes
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
   * is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control is reset.
   * When false, no events are emitted.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   */
  reset(value = [], options = {}) {
    this._forEachChild((control, index) => {
      control.reset(value[index], {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this._updatePristine(options, this);
    this._updateTouched(options, this);
    this.updateValueAndValidity(options);
  }
  /**
   * The aggregate value of the array, including any disabled controls.
   *
   * Reports all values regardless of disabled status.
   */
  getRawValue() {
    return this.controls.map((control) => control.getRawValue());
  }
  /**
   * Remove all controls in the `FormArray`.
   *
   * @param options Specifies whether this FormArray instance should emit events after all
   *     controls are removed.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when all controls
   * in this FormArray instance are removed. When false, no events are emitted.
   *
   * @usageNotes
   * ### Remove all elements from a FormArray
   *
   * ```ts
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   * console.log(arr.length);  // 2
   *
   * arr.clear();
   * console.log(arr.length);  // 0
   * ```
   *
   * It's a simpler and more efficient alternative to removing all elements one by one:
   *
   * ```ts
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   *
   * while (arr.length) {
   *    arr.removeAt(0);
   * }
   * ```
   */
  clear(options = {}) {
    if (this.controls.length < 1) return;
    this._forEachChild((control) => control._registerOnCollectionChange(() => {
    }));
    this.controls.splice(0);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
  }
  /**
   * Adjusts a negative index by summing it with the length of the array. For very negative
   * indices, the result may remain negative.
   * @internal
   */
  _adjustIndex(index) {
    return index < 0 ? index + this.length : index;
  }
  /** @internal */
  _syncPendingControls() {
    let subtreeUpdated = this.controls.reduce((updated, child) => {
      return child._syncPendingControls() ? true : updated;
    }, false);
    if (subtreeUpdated) this.updateValueAndValidity({
      onlySelf: true
    });
    return subtreeUpdated;
  }
  /** @internal */
  _forEachChild(cb) {
    this.controls.forEach((control, index) => {
      cb(control, index);
    });
  }
  /** @internal */
  _updateValue() {
    this.value = this.controls.filter((control) => control.enabled || this.disabled).map((control) => control.value);
  }
  /** @internal */
  _anyControls(condition) {
    return this.controls.some((control) => control.enabled && condition(control));
  }
  /** @internal */
  _setUpControls() {
    this._forEachChild((control) => this._registerControl(control));
  }
  /** @internal */
  _allControlsDisabled() {
    for (const control of this.controls) {
      if (control.enabled) return false;
    }
    return this.controls.length > 0 || this.disabled;
  }
  _registerControl(control) {
    control.setParent(this);
    control._registerOnCollectionChange(this._onCollectionChange);
  }
  /** @internal */
  _find(name) {
    return this.at(name) ?? null;
  }
};
function isAbstractControlOptions(options) {
  return !!options && (options.asyncValidators !== void 0 || options.validators !== void 0 || options.updateOn !== void 0);
}
var FormBuilder = class _FormBuilder {
  useNonNullable = false;
  /**
   * @description
   * Returns a FormBuilder in which automatically constructed `FormControl` elements
   * have `{nonNullable: true}` and are non-nullable.
   *
   * **Constructing non-nullable controls**
   *
   * When constructing a control, it will be non-nullable, and will reset to its initial value.
   *
   * ```ts
   * let nnfb = new FormBuilder().nonNullable;
   * let name = nnfb.control('Alex'); // FormControl<string>
   * name.reset();
   * console.log(name); // 'Alex'
   * ```
   *
   * **Constructing non-nullable groups or arrays**
   *
   * When constructing a group or array, all automatically created inner controls will be
   * non-nullable, and will reset to their initial values.
   *
   * ```ts
   * let nnfb = new FormBuilder().nonNullable;
   * let name = nnfb.group({who: 'Alex'}); // FormGroup<{who: FormControl<string>}>
   * name.reset();
   * console.log(name); // {who: 'Alex'}
   * ```
   * **Constructing *nullable* fields on groups or arrays**
   *
   * It is still possible to have a nullable field. In particular, any `FormControl` which is
   * *already* constructed will not be altered. For example:
   *
   * ```ts
   * let nnfb = new FormBuilder().nonNullable;
   * // FormGroup<{who: FormControl<string|null>}>
   * let name = nnfb.group({who: new FormControl('Alex')});
   * name.reset(); console.log(name); // {who: null}
   * ```
   *
   * Because the inner control is constructed explicitly by the caller, the builder has
   * no control over how it is created, and cannot exclude the `null`.
   */
  get nonNullable() {
    const nnfb = new _FormBuilder();
    nnfb.useNonNullable = true;
    return nnfb;
  }
  group(controls, options = null) {
    const reducedControls = this._reduceControls(controls);
    let newOptions = {};
    if (isAbstractControlOptions(options)) {
      newOptions = options;
    } else if (options !== null) {
      newOptions.validators = options.validator;
      newOptions.asyncValidators = options.asyncValidator;
    }
    return new FormGroup(reducedControls, newOptions);
  }
  /**
   * @description
   * Constructs a new `FormRecord` instance. Accepts a single generic argument, which is an object
   * containing all the keys and corresponding inner control types.
   *
   * @param controls A collection of child controls. The key for each child is the name
   * under which it is registered.
   *
   * @param options Configuration options object for the `FormRecord`. The object should have the
   * `AbstractControlOptions` type and might contain the following fields:
   * * `validators`: A synchronous validator function, or an array of validator functions.
   * * `asyncValidators`: A single async validator or array of async validator functions.
   * * `updateOn`: The event upon which the control should be updated (options: 'change' | 'blur'
   * | submit').
   */
  record(controls, options = null) {
    const reducedControls = this._reduceControls(controls);
    return new FormRecord(reducedControls, options);
  }
  /**
   * @description
   * Constructs a new `FormControl` with the given state, validators and options. Sets
   * `{nonNullable: true}` in the options to get a non-nullable control. Otherwise, the
   * control will be nullable. Accepts a single generic argument, which is the type  of the
   * control's value.
   *
   * @param formState Initializes the control with an initial state value, or
   * with an object that contains both a value and a disabled status.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of
   * such functions, or a `FormControlOptions` object that contains
   * validation functions and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator
   * functions.
   *
   * @usageNotes
   *
   * ### Initialize a control as disabled
   *
   * The following example returns a control with an initial value in a disabled state.
   *
   * {@example forms/ts/formBuilder/form_builder_example.ts region='disabled-control'}
   */
  control(formState, validatorOrOpts, asyncValidator) {
    let newOptions = {};
    if (!this.useNonNullable) {
      return new FormControl(formState, validatorOrOpts, asyncValidator);
    }
    if (isAbstractControlOptions(validatorOrOpts)) {
      newOptions = validatorOrOpts;
    } else {
      newOptions.validators = validatorOrOpts;
      newOptions.asyncValidators = asyncValidator;
    }
    return new FormControl(formState, __spreadProps(__spreadValues({}, newOptions), {
      nonNullable: true
    }));
  }
  /**
   * Constructs a new `FormArray` from the given array of configurations,
   * validators and options. Accepts a single generic argument, which is the type of each control
   * inside the array.
   *
   * @param controls An array of child controls or control configs. Each child control is given an
   *     index when it is registered.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of such functions, or an
   *     `AbstractControlOptions` object that contains
   * validation functions and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator functions.
   */
  array(controls, validatorOrOpts, asyncValidator) {
    const createdControls = controls.map((c) => this._createControl(c));
    return new FormArray(createdControls, validatorOrOpts, asyncValidator);
  }
  /** @internal */
  _reduceControls(controls) {
    const createdControls = {};
    Object.keys(controls).forEach((controlName) => {
      createdControls[controlName] = this._createControl(controls[controlName]);
    });
    return createdControls;
  }
  /** @internal */
  _createControl(controls) {
    if (controls instanceof FormControl) {
      return controls;
    } else if (controls instanceof AbstractControl) {
      return controls;
    } else if (Array.isArray(controls)) {
      const value = controls[0];
      const validator = controls.length > 1 ? controls[1] : null;
      const asyncValidator = controls.length > 2 ? controls[2] : null;
      return this.control(value, validator, asyncValidator);
    } else {
      return this.control(controls);
    }
  }
  static ɵfac = function FormBuilder_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormBuilder)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _FormBuilder,
    factory: _FormBuilder.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var NonNullableFormBuilder = class _NonNullableFormBuilder {
  static ɵfac = function NonNullableFormBuilder_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NonNullableFormBuilder)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _NonNullableFormBuilder,
    factory: () => (() => inject(FormBuilder).nonNullable)(),
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NonNullableFormBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: () => inject(FormBuilder).nonNullable
    }]
  }], null, null);
})();
var UntypedFormBuilder = class _UntypedFormBuilder extends FormBuilder {
  group(controlsConfig, options = null) {
    return super.group(controlsConfig, options);
  }
  /**
   * Like `FormBuilder#control`, except the resulting control is untyped.
   */
  control(formState, validatorOrOpts, asyncValidator) {
    return super.control(formState, validatorOrOpts, asyncValidator);
  }
  /**
   * Like `FormBuilder#array`, except the resulting array is untyped.
   */
  array(controlsConfig, validatorOrOpts, asyncValidator) {
    return super.array(controlsConfig, validatorOrOpts, asyncValidator);
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵUntypedFormBuilder_BaseFactory;
    return function UntypedFormBuilder_Factory(__ngFactoryType__) {
      return (ɵUntypedFormBuilder_BaseFactory || (ɵUntypedFormBuilder_BaseFactory = ɵɵgetInheritedFactory(_UntypedFormBuilder)))(__ngFactoryType__ || _UntypedFormBuilder);
    };
  })();
  static ɵprov = ɵɵdefineInjectable({
    token: _UntypedFormBuilder,
    factory: _UntypedFormBuilder.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UntypedFormBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var VERSION = new Version("19.2.3");
var FormsModule = class _FormsModule {
  /**
   * @description
   * Provides options for configuring the forms module.
   *
   * @param opts An object of configuration options
   * * `callSetDisabledState` Configures whether to `always` call `setDisabledState`, which is more
   * correct, or to only call it `whenDisabled`, which is the legacy behavior.
   */
  static withConfig(opts) {
    return {
      ngModule: _FormsModule,
      providers: [{
        provide: CALL_SET_DISABLED_STATE,
        useValue: opts.callSetDisabledState ?? setDisabledStateDefault
      }]
    };
  }
  static ɵfac = function FormsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormsModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _FormsModule,
    declarations: [NgModel, NgModelGroup, NgForm],
    exports: [ɵInternalFormsSharedModule, NgModel, NgModelGroup, NgForm]
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [ɵInternalFormsSharedModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormsModule, [{
    type: NgModule,
    args: [{
      declarations: TEMPLATE_DRIVEN_DIRECTIVES,
      exports: [ɵInternalFormsSharedModule, TEMPLATE_DRIVEN_DIRECTIVES]
    }]
  }], null, null);
})();
var ReactiveFormsModule = class _ReactiveFormsModule {
  /**
   * @description
   * Provides options for configuring the reactive forms module.
   *
   * @param opts An object of configuration options
   * * `warnOnNgModelWithFormControl` Configures when to emit a warning when an `ngModel`
   * binding is used with reactive form directives.
   * * `callSetDisabledState` Configures whether to `always` call `setDisabledState`, which is more
   * correct, or to only call it `whenDisabled`, which is the legacy behavior.
   */
  static withConfig(opts) {
    return {
      ngModule: _ReactiveFormsModule,
      providers: [{
        provide: NG_MODEL_WITH_FORM_CONTROL_WARNING,
        useValue: opts.warnOnNgModelWithFormControl ?? "always"
      }, {
        provide: CALL_SET_DISABLED_STATE,
        useValue: opts.callSetDisabledState ?? setDisabledStateDefault
      }]
    };
  }
  static ɵfac = function ReactiveFormsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ReactiveFormsModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _ReactiveFormsModule,
    declarations: [FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName],
    exports: [ɵInternalFormsSharedModule, FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName]
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [ɵInternalFormsSharedModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ReactiveFormsModule, [{
    type: NgModule,
    args: [{
      declarations: [REACTIVE_DRIVEN_DIRECTIVES],
      exports: [ɵInternalFormsSharedModule, REACTIVE_DRIVEN_DIRECTIVES]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-checkbox.mjs
var _c08 = ["inputCheckbox"];
var _c17 = ["*"];
var _c25 = (a0) => ({
  "cds--skeleton": a0
});
var _c32 = (a0) => ({
  "cds--visually-hidden": a0
});
var CheckboxState;
(function(CheckboxState2) {
  CheckboxState2[CheckboxState2["Init"] = 0] = "Init";
  CheckboxState2[CheckboxState2["Indeterminate"] = 1] = "Indeterminate";
  CheckboxState2[CheckboxState2["Checked"] = 2] = "Checked";
  CheckboxState2[CheckboxState2["Unchecked"] = 3] = "Unchecked";
})(CheckboxState || (CheckboxState = {}));
var Checkbox = class _Checkbox {
  /**
   * Creates an instance of `Checkbox`.
   */
  constructor(changeDetectorRef) {
    this.changeDetectorRef = changeDetectorRef;
    this.disabled = false;
    this.skeleton = false;
    this.hideLabel = false;
    this.id = `checkbox-${_Checkbox.checkboxCount}`;
    this.click = new EventEmitter();
    this.checkedChange = new EventEmitter();
    this.indeterminateChange = new EventEmitter();
    this._checked = false;
    this._indeterminate = false;
    this.currentCheckboxState = CheckboxState.Init;
    this.onTouched = () => {
    };
    this.propagateChange = (_) => {
    };
    _Checkbox.checkboxCount++;
  }
  /**
   * Set the checkbox's indeterminate state to match the parameter and transition the view to reflect the change.
   *
   * Allows double binding with the `indeterminateChange` Output.
   */
  set indeterminate(indeterminate) {
    if (indeterminate === this._indeterminate) {
      return;
    }
    this._indeterminate = indeterminate;
    if (this._indeterminate) {
      this.transitionCheckboxState(CheckboxState.Indeterminate);
    } else {
      this.transitionCheckboxState(this.checked ? CheckboxState.Checked : CheckboxState.Unchecked);
    }
    if (this.inputCheckbox && this.inputCheckbox.nativeElement) {
      this.inputCheckbox.nativeElement.indeterminate = indeterminate;
    }
    this.changeDetectorRef.markForCheck();
    this.indeterminateChange.emit(this._indeterminate);
  }
  /**
   * Reflects whether the checkbox state is indeterminate.
   */
  get indeterminate() {
    return this._indeterminate;
  }
  /**
   * Sets the `checked` state. `true` for checked, `false` for unchecked
   *
   * Allows double binding with the `checkedChange` Output.
   */
  set checked(checked) {
    this.setChecked(checked, false);
  }
  /**
   * Returns value `true` if state is selected for the checkbox.
   */
  get checked() {
    return this._checked;
  }
  /**
   * Toggle the selected state of the checkbox.
   */
  toggle() {
    this.setChecked(!this.checked, true);
  }
  /**
   * Writes a value from `ngModel` to the component.
   *
   * In this case the value is the `checked` property.
   *
   * @param value boolean, corresponds to the `checked` property.
   */
  writeValue(value) {
    this.setChecked(!!value, true);
  }
  /**
   * Sets a method in order to propagate changes back to the form.
   */
  registerOnChange(fn) {
    this.propagateChange = fn;
  }
  /**
   * Registers a callback to be triggered when the control has been touched.
   * @param fn Callback to be triggered when the checkbox is touched.
   */
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  /**
   * `ControlValueAccessor` method to programmatically disable the checkbox.
   *
   * ex: `this.formGroup.get("myCheckbox").disable();`
   *
   * @param isDisabled `true` to disable the checkbox
   */
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
    this.changeDetectorRef.markForCheck();
  }
  focusOut() {
    this.onTouched();
  }
  /**
   * Executes on the event of a change within `Checkbox` to block propagation.
   */
  onChange(event) {
    event.stopPropagation();
  }
  /**
   * Handles click events on the `Checkbox` and emits changes to other classes.
   */
  onClick(event) {
    if (this.click.observers.length) {
      event.preventDefault();
      this.click.emit();
      return;
    }
    if (!this.disabled) {
      this.toggle();
      this.transitionCheckboxState(this._checked ? CheckboxState.Checked : CheckboxState.Unchecked);
      this.emitChangeEvent();
    }
  }
  /**
   * Handles changes between checkbox states.
   */
  transitionCheckboxState(newState) {
    this.currentCheckboxState = newState;
  }
  /**
   * Creates instance of `CheckboxChange` used to propagate the change event.
   */
  emitChangeEvent() {
    this.checkedChange.emit(this.checked);
    this.propagateChange(this.checked);
  }
  /**
   * Updates the checkbox if it is in the indeterminate state.
   */
  ngAfterViewInit() {
    if (this.indeterminate && this.inputCheckbox && this.inputCheckbox.nativeElement) {
      this.inputCheckbox.nativeElement.indeterminate = true;
    }
  }
  /**
   * Sets checked state and optionally resets indeterminate state.
   */
  setChecked(checked, resetIndeterminate) {
    if (checked === this._checked) {
      return;
    }
    this._checked = checked;
    if (resetIndeterminate && this._indeterminate) {
      this._indeterminate = false;
      Promise.resolve().then(() => {
        this.indeterminateChange.emit(this._indeterminate);
      });
    }
    this.changeDetectorRef.markForCheck();
  }
};
Checkbox.checkboxCount = 0;
Checkbox.ɵfac = function Checkbox_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Checkbox)(ɵɵdirectiveInject(ChangeDetectorRef));
};
Checkbox.ɵcmp = ɵɵdefineComponent({
  type: Checkbox,
  selectors: [["cds-checkbox"], ["ibm-checkbox"]],
  viewQuery: function Checkbox_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c08, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inputCheckbox = _t.first);
    }
  },
  hostBindings: function Checkbox_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("focusout", function Checkbox_focusout_HostBindingHandler() {
        return ctx.focusOut();
      });
    }
  },
  inputs: {
    disabled: "disabled",
    skeleton: "skeleton",
    hideLabel: "hideLabel",
    name: "name",
    id: "id",
    required: "required",
    value: "value",
    ariaLabel: "ariaLabel",
    ariaLabelledby: "ariaLabelledby",
    indeterminate: "indeterminate",
    checked: "checked"
  },
  outputs: {
    click: "click",
    checkedChange: "checkedChange",
    indeterminateChange: "indeterminateChange"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: Checkbox,
    multi: true
  }])],
  ngContentSelectors: _c17,
  decls: 6,
  vars: 15,
  consts: [["inputCheckbox", ""], [1, "cds--form-item", "cds--checkbox-wrapper"], ["type", "checkbox", 1, "cds--checkbox", 3, "change", "click", "id", "value", "name", "required", "checked", "disabled"], [1, "cds--checkbox-label", 3, "for", "ngClass"], [1, "cds--checkbox-label-text", 3, "ngClass"]],
  template: function Checkbox_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 1)(1, "input", 2, 0);
      ɵɵlistener("change", function Checkbox_Template_input_change_1_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onChange($event));
      })("click", function Checkbox_Template_input_click_1_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onClick($event));
      });
      ɵɵelementEnd();
      ɵɵelementStart(3, "label", 3)(4, "span", 4);
      ɵɵprojection(5);
      ɵɵelementEnd()()();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("id", ctx.id + "_input")("value", ctx.value)("name", ctx.name)("required", ctx.required)("checked", ctx.checked)("disabled", ctx.disabled);
      ɵɵattribute("aria-labelledby", ctx.ariaLabelledby);
      ɵɵadvance(2);
      ɵɵproperty("for", ctx.id + "_input")("ngClass", ɵɵpureFunction1(11, _c25, ctx.skeleton));
      ɵɵattribute("aria-label", ctx.ariaLabel);
      ɵɵadvance();
      ɵɵproperty("ngClass", ɵɵpureFunction1(13, _c32, ctx.hideLabel));
    }
  },
  dependencies: [NgClass],
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Checkbox, [{
    type: Component,
    args: [{
      selector: "cds-checkbox, ibm-checkbox",
      template: `
		<div class="cds--form-item cds--checkbox-wrapper">
			<input
				#inputCheckbox
				class="cds--checkbox"
				type="checkbox"
				[id]="id + '_input'"
				[value]="value"
				[name]="name"
				[required]="required"
				[checked]="checked"
				[disabled]="disabled"
				[attr.aria-labelledby]="ariaLabelledby"
				(change)="onChange($event)"
				(click)="onClick($event)">
			<label
				[for]="id + '_input'"
				[attr.aria-label]="ariaLabel"
				class="cds--checkbox-label"
				[ngClass]="{
					'cds--skeleton' : skeleton
				}">
				<span [ngClass]="{'cds--visually-hidden' : hideLabel}" class="cds--checkbox-label-text">
					<ng-content></ng-content>
				</span>
			</label>
		</div>
	`,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: Checkbox,
        multi: true
      }],
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }];
  }, {
    disabled: [{
      type: Input
    }],
    skeleton: [{
      type: Input
    }],
    hideLabel: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    required: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    ariaLabelledby: [{
      type: Input
    }],
    indeterminate: [{
      type: Input
    }],
    checked: [{
      type: Input
    }],
    click: [{
      type: Output
    }],
    checkedChange: [{
      type: Output
    }],
    indeterminateChange: [{
      type: Output
    }],
    inputCheckbox: [{
      type: ViewChild,
      args: ["inputCheckbox"]
    }],
    focusOut: [{
      type: HostListener,
      args: ["focusout"]
    }]
  });
})();
var CheckboxModule = class {
};
CheckboxModule.ɵfac = function CheckboxModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || CheckboxModule)();
};
CheckboxModule.ɵmod = ɵɵdefineNgModule({
  type: CheckboxModule,
  declarations: [Checkbox],
  imports: [CommonModule, FormsModule],
  exports: [Checkbox]
});
CheckboxModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, FormsModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckboxModule, [{
    type: NgModule,
    args: [{
      declarations: [Checkbox],
      exports: [Checkbox],
      imports: [CommonModule, FormsModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-code-snippet.mjs
var _c09 = ["code"];
var _c18 = ["codeContent"];
var _c26 = ["codeContainer"];
var _c33 = ["*"];
var _c42 = (a0) => ({
  "cds--snippet--light": a0
});
var _c5 = (a0, a1, a2, a3, a4, a5, a6) => ({
  "cds--snippet--light": a0,
  "cds--snippet--inline": a1,
  "cds--btn--icon-only": a2,
  "cds--copy-btn": a3,
  "cds--copy-btn--animating": a4,
  "cds--copy-btn--fade-in": a5,
  "cds--copy-btn--fade-out": a6,
  "cds--snippet cds--copy": true
});
var _c6 = (a0) => ({
  "aria-label": a0,
  "aria-live": "polite",
  "tabindex": "0"
});
function CodeSnippet_ng_container_0_ng_container_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function CodeSnippet_ng_container_0_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, CodeSnippet_ng_container_0_ng_container_1_ng_container_1_Template, 1, 0, "ng-container", 9);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const buttonTemplate_r1 = ɵɵreference(4);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", buttonTemplate_r1);
  }
}
function CodeSnippet_ng_container_0_ng_template_2_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function CodeSnippet_ng_container_0_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 10)(1, "code", null, 4);
    ɵɵtemplate(3, CodeSnippet_ng_container_0_ng_template_2_ng_container_3_Template, 1, 0, "ng-container", 9);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    const codeTemplate_r3 = ɵɵreference(6);
    ɵɵproperty("ngClass", ɵɵpureFunction1(2, _c42, ctx_r1.theme === "light"));
    ɵɵadvance(3);
    ɵɵproperty("ngTemplateOutlet", codeTemplate_r3);
  }
}
function CodeSnippet_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, CodeSnippet_ng_container_0_ng_container_1_Template, 2, 1, "ng-container", 8)(2, CodeSnippet_ng_container_0_ng_template_2_Template, 4, 4, "ng-template", null, 3, ɵɵtemplateRefExtractor);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const noBtnInline_r4 = ɵɵreference(3);
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.hideCopyButton)("ngIfElse", noBtnInline_r4);
  }
}
function CodeSnippet_ng_template_1_ng_container_2_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span");
  }
}
function CodeSnippet_ng_template_1_ng_container_2_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span")(1, "span")(2, "span");
  }
}
function CodeSnippet_ng_template_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, CodeSnippet_ng_template_1_ng_container_2_span_1_Template, 1, 0, "span", 8)(2, CodeSnippet_ng_template_1_ng_container_2_ng_template_2_Template, 3, 0, "ng-template", null, 6, ɵɵtemplateRefExtractor);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const multiSkeleton_r6 = ɵɵreference(3);
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.display === "single")("ngIfElse", multiSkeleton_r6);
  }
}
function CodeSnippet_ng_template_1_pre_3_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function CodeSnippet_ng_template_1_pre_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "pre", 17, 7);
    ɵɵlistener("scroll", function CodeSnippet_ng_template_1_pre_3_Template_pre_scroll_0_listener() {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.display === "multi" ? ctx_r1.handleScroll() : null);
    });
    ɵɵelementStart(2, "code", null, 4);
    ɵɵtemplate(4, CodeSnippet_ng_template_1_pre_3_ng_container_4_Template, 1, 0, "ng-container", 9);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const codeTemplate_r3 = ɵɵreference(6);
    ɵɵadvance(4);
    ɵɵproperty("ngTemplateOutlet", codeTemplate_r3);
  }
}
function CodeSnippet_ng_template_1_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 18);
  }
}
function CodeSnippet_ng_template_1_div_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 19);
  }
}
function CodeSnippet_ng_template_1_ng_container_6_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function CodeSnippet_ng_template_1_ng_container_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, CodeSnippet_ng_template_1_ng_container_6_ng_container_1_Template, 1, 0, "ng-container", 9);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const buttonTemplate_r1 = ɵɵreference(4);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", buttonTemplate_r1);
  }
}
function CodeSnippet_ng_template_1_button_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 20);
    ɵɵlistener("click", function CodeSnippet_ng_template_1_button_7_Template_button_click_0_listener() {
      ɵɵrestoreView(_r8);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.toggleSnippetExpansion());
    });
    ɵɵelementStart(1, "span", 21);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵnamespaceSVG();
    ɵɵelement(3, "svg", 22);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r1.expanded ? ctx_r1.translations.SHOW_LESS : ctx_r1.translations.SHOW_MORE);
    ɵɵadvance();
    ɵɵattribute("aria-label", ctx_r1.translations.SHOW_MORE_ICON);
  }
}
function CodeSnippet_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 11, 5);
    ɵɵlistener("scroll", function CodeSnippet_ng_template_1_Template_div_scroll_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.display === "single" ? ctx_r1.handleScroll() : null);
    });
    ɵɵtemplate(2, CodeSnippet_ng_template_1_ng_container_2_Template, 4, 2, "ng-container", 12)(3, CodeSnippet_ng_template_1_pre_3_Template, 5, 1, "pre", 13);
    ɵɵelementEnd();
    ɵɵtemplate(4, CodeSnippet_ng_template_1_div_4_Template, 1, 0, "div", 14)(5, CodeSnippet_ng_template_1_div_5_Template, 1, 0, "div", 15)(6, CodeSnippet_ng_template_1_ng_container_6_Template, 2, 1, "ng-container", 12)(7, CodeSnippet_ng_template_1_button_7_Template, 4, 2, "button", 16);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngStyle", ctx_r1.styles);
    ɵɵattribute("aria-label", ctx_r1.translations.CODE_SNIPPET_TEXT)("tabindex", ctx_r1.display === "single" && !ctx_r1.disabled ? "0" : null)("role", ctx_r1.display === "single" ? "textarea" : null);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r1.skeleton);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.skeleton);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.hasLeft);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.hasRight);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.hideCopyButton);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.isExpandable);
  }
}
function CodeSnippet_ng_template_3_cds_icon_button_0_ng_container_1_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function CodeSnippet_ng_template_3_cds_icon_button_0_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "code", null, 4);
    ɵɵtemplate(3, CodeSnippet_ng_template_3_cds_icon_button_0_ng_container_1_ng_container_3_Template, 1, 0, "ng-container", 9);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    ɵɵnextContext(3);
    const codeTemplate_r3 = ɵɵreference(6);
    ɵɵadvance(3);
    ɵɵproperty("ngTemplateOutlet", codeTemplate_r3);
  }
}
function CodeSnippet_ng_template_3_cds_icon_button_0_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵnamespaceSVG();
    ɵɵelement(1, "svg", 25);
    ɵɵelementContainerEnd();
  }
}
function CodeSnippet_ng_template_3_cds_icon_button_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "cds-icon-button", 24);
    ɵɵlistener("click", function CodeSnippet_ng_template_3_cds_icon_button_0_Template_cds_icon_button_click_0_listener($event) {
      ɵɵrestoreView(_r9);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onCopyButtonClicked($event));
    });
    ɵɵtemplate(1, CodeSnippet_ng_template_3_cds_icon_button_0_ng_container_1_Template, 4, 1, "ng-container", 12)(2, CodeSnippet_ng_template_3_cds_icon_button_0_ng_container_2_Template, 2, 0, "ng-container", 12);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("description", ctx_r1.showFeedback ? ctx_r1.feedbackText : ctx_r1.copyButtonDescription)("align", ctx_r1.align)("autoAlign", ctx_r1.autoAlign)("dropShadow", ctx_r1.dropShadow)("caret", ctx_r1.caret)("highContrast", ctx_r1.highContrast)("isOpen", ctx_r1.isOpen)("enterDelayMs", ctx_r1.enterDelayMs)("leaveDelayMs", ctx_r1.leaveDelayMs)("buttonNgClass", ɵɵpureFunction7(13, _c5, ctx_r1.theme === "light", ctx_r1.display === "inline", ctx_r1.display !== "inline", ctx_r1.display !== "inline", ctx_r1.animating, ctx_r1.showFeedback, !ctx_r1.showFeedback && ctx_r1.animating))("buttonAttributes", ɵɵpureFunction1(21, _c6, ctx_r1.translations.COPY_CODE));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.display === "inline");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.display !== "inline");
  }
}
function CodeSnippet_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, CodeSnippet_ng_template_3_cds_icon_button_0_Template, 3, 23, "cds-icon-button", 23);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngIf", !ctx_r1.skeleton);
  }
}
function CodeSnippet_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
var SnippetType;
(function(SnippetType2) {
  SnippetType2["single"] = "single";
  SnippetType2["multi"] = "multi";
  SnippetType2["inline"] = "inline";
})(SnippetType || (SnippetType = {}));
var CodeSnippet = class extends BaseIconButton {
  /**
   * Creates an instance of CodeSnippet.
   */
  constructor(i18n, eventService) {
    super();
    this.i18n = i18n;
    this.eventService = eventService;
    this.rowHeightInPixel = 16;
    this.display = SnippetType.single;
    this.translations = this.i18n.get().CODE_SNIPPET;
    this.hideCopyButton = false;
    this.disabled = false;
    this.maxCollapsedNumberOfRows = 15;
    this.minCollapsedNumberOfRows = 3;
    this.maxExpandedNumberOfRows = 0;
    this.minExpandedNumberOfRows = 16;
    this.wrapText = false;
    this.theme = "dark";
    this.feedbackText = this.translations.COPIED;
    this.feedbackTimeout = 2e3;
    this.expanded = false;
    this.skeleton = false;
    this.styles = {};
    this.showFeedback = false;
    this.animating = false;
    this.hasExpandButton = null;
    this.isExpandable = false;
    this.hasRightOverflow = false;
    this.hasRight = false;
    this.hasLeft = false;
    this.dropShadow = false;
  }
  get snippetClass() {
    return this.display !== SnippetType.inline;
  }
  get snippetSingleClass() {
    return this.display === SnippetType.single;
  }
  get snippetMultiClass() {
    return this.display === SnippetType.multi;
  }
  get snippetDisabledClass() {
    return this.display !== "inline" && this.disabled;
  }
  get snippetInlineLightClass() {
    return this.theme === "light";
  }
  handleScroll() {
    if (this.skeleton) {
      return;
    }
    let ref;
    switch (this.display) {
      case "multi":
        ref = this.codeContent.nativeElement;
        break;
      case "single":
        ref = this.codeContainer.nativeElement;
        break;
      default:
        return;
    }
    if (ref) {
      const {
        scrollWidth,
        clientWidth,
        scrollLeft
      } = ref;
      const horizontalOverflow = scrollWidth > clientWidth;
      this.hasLeft = horizontalOverflow && !!scrollLeft;
      this.hasRight = horizontalOverflow && scrollLeft + clientWidth !== scrollWidth;
    }
  }
  toggleSnippetExpansion() {
    this.expanded = !this.expanded;
    this.calculateContainerHeight();
  }
  onCopyButtonClicked() {
    if (!this.disabled) {
      window.navigator.clipboard.writeText(this.code.nativeElement.innerText || this.code.nativeElement.textContent).then(() => {
        this.showFeedback = true;
        this.animating = true;
        setTimeout(() => {
          this.showFeedback = false;
          this.animating = false;
        }, this.feedbackTimeout);
      });
    }
  }
  ngOnInit() {
    this.calculateContainerHeight();
  }
  ngAfterViewInit() {
    this.canExpand();
    this.handleScroll();
    if (window) {
      this.eventService.on(window, "resize", () => {
        this.canExpand();
        this.handleScroll();
      });
    }
  }
  calculateContainerHeight() {
    if (this.display === "multi" && !this.skeleton) {
      this.styles = {};
      if (this.expanded) {
        if (this.maxExpandedNumberOfRows > 0) {
          this.styles["max-height"] = `${this.maxExpandedNumberOfRows * this.rowHeightInPixel}px`;
        }
        if (this.minExpandedNumberOfRows > 0) {
          this.styles["min-height"] = `${this.minExpandedNumberOfRows * this.rowHeightInPixel}px`;
        }
      } else {
        if (this.maxCollapsedNumberOfRows > 0) {
          this.styles["max-height"] = `${this.maxCollapsedNumberOfRows * this.rowHeightInPixel}px`;
        }
        if (this.minCollapsedNumberOfRows > 0) {
          this.styles["min-height"] = `${this.minCollapsedNumberOfRows * this.rowHeightInPixel}px`;
        }
      }
    }
  }
  canExpand() {
    if (this.display === "multi" && !this.skeleton) {
      const height = this.codeContent.nativeElement.getBoundingClientRect().height;
      if (this.maxCollapsedNumberOfRows > 0 && (this.maxExpandedNumberOfRows <= 0 || this.maxExpandedNumberOfRows > this.maxCollapsedNumberOfRows) && height > this.maxCollapsedNumberOfRows * this.rowHeightInPixel) {
        this.isExpandable = true;
      } else {
        this.isExpandable = false;
      }
      if (this.expanded && this.minExpandedNumberOfRows > 0 && height <= this.minExpandedNumberOfRows * this.rowHeightInPixel) {
        this.isExpandable = false;
      }
    }
  }
};
CodeSnippet.ɵfac = function CodeSnippet_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || CodeSnippet)(ɵɵdirectiveInject(I18n), ɵɵdirectiveInject(EventService));
};
CodeSnippet.ɵcmp = ɵɵdefineComponent({
  type: CodeSnippet,
  selectors: [["cds-code-snippet"], ["ibm-code-snippet"]],
  viewQuery: function CodeSnippet_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c09, 5);
      ɵɵviewQuery(_c18, 5);
      ɵɵviewQuery(_c26, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.code = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.codeContent = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.codeContainer = _t.first);
    }
  },
  hostVars: 16,
  hostBindings: function CodeSnippet_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--snippet", ctx.snippetClass)("cds--snippet--single", ctx.snippetSingleClass)("cds--snippet--multi", ctx.snippetMultiClass)("cds--snippet--disabled", ctx.snippetDisabledClass)("cds--snippet--light", ctx.snippetInlineLightClass)("cds--snippet--wraptext", ctx.wrapText)("cds--snippet--expand", ctx.expanded)("cds--skeleton", ctx.skeleton);
    }
  },
  inputs: {
    display: "display",
    translations: "translations",
    copyButtonDescription: "copyButtonDescription",
    hideCopyButton: "hideCopyButton",
    disabled: "disabled",
    maxCollapsedNumberOfRows: "maxCollapsedNumberOfRows",
    minCollapsedNumberOfRows: "minCollapsedNumberOfRows",
    maxExpandedNumberOfRows: "maxExpandedNumberOfRows",
    minExpandedNumberOfRows: "minExpandedNumberOfRows",
    wrapText: "wrapText",
    theme: "theme",
    feedbackText: "feedbackText",
    feedbackTimeout: "feedbackTimeout",
    expanded: "expanded",
    skeleton: "skeleton"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c33,
  decls: 7,
  vars: 2,
  consts: [["notInline", ""], ["buttonTemplate", ""], ["codeTemplate", ""], ["noBtnInline", ""], ["code", ""], ["codeContainer", ""], ["multiSkeleton", ""], ["codeContent", ""], [4, "ngIf", "ngIfElse"], [4, "ngTemplateOutlet"], [1, "cds--snippet", "cds--snippet--inline", "cds--snippet--no-copy", 3, "ngClass"], [1, "cds--snippet-container", 3, "scroll", "ngStyle"], [4, "ngIf"], [3, "scroll", 4, "ngIf"], ["class", "cds--snippet__overflow-indicator--left", 4, "ngIf"], ["class", "cds--snippet__overflow-indicator--right", 4, "ngIf"], ["class", "cds--btn cds--btn--ghost cds--btn--sm cds--snippet-btn--expand", "type", "button", 3, "click", 4, "ngIf"], [3, "scroll"], [1, "cds--snippet__overflow-indicator--left"], [1, "cds--snippet__overflow-indicator--right"], ["type", "button", 1, "cds--btn", "cds--btn--ghost", "cds--btn--sm", "cds--snippet-btn--expand", 3, "click"], [1, "cds--snippet-btn--text"], ["cdsIcon", "chevron--down", "size", "16", 1, "cds--icon-chevron--down"], ["type", "button", "kind", "primary", "size", "md", 3, "description", "align", "autoAlign", "dropShadow", "caret", "highContrast", "isOpen", "enterDelayMs", "leaveDelayMs", "buttonNgClass", "buttonAttributes", "click", 4, "ngIf"], ["type", "button", "kind", "primary", "size", "md", 3, "click", "description", "align", "autoAlign", "dropShadow", "caret", "highContrast", "isOpen", "enterDelayMs", "leaveDelayMs", "buttonNgClass", "buttonAttributes"], ["cdsIcon", "copy", "size", "16", 1, "cds--snippet__icon"]],
  template: function CodeSnippet_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, CodeSnippet_ng_container_0_Template, 4, 2, "ng-container", 8)(1, CodeSnippet_ng_template_1_Template, 8, 10, "ng-template", null, 0, ɵɵtemplateRefExtractor)(3, CodeSnippet_ng_template_3_Template, 1, 1, "ng-template", null, 1, ɵɵtemplateRefExtractor)(5, CodeSnippet_ng_template_5_Template, 1, 0, "ng-template", null, 2, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      const notInline_r10 = ɵɵreference(2);
      ɵɵproperty("ngIf", ctx.display === "inline")("ngIfElse", notInline_r10);
    }
  },
  dependencies: [NgClass, NgIf, NgTemplateOutlet, NgStyle, IconButton, IconDirective],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CodeSnippet, [{
    type: Component,
    args: [{
      selector: "cds-code-snippet, ibm-code-snippet",
      template: `
		<ng-container *ngIf="display === 'inline'; else notInline">
			<ng-container *ngIf="!hideCopyButton; else noBtnInline">
				<ng-container *ngTemplateOutlet="buttonTemplate"></ng-container>
			</ng-container>
			<ng-template #noBtnInline>
				<span
					class="cds--snippet cds--snippet--inline cds--snippet--no-copy"
					[ngClass]="{
						'cds--snippet--light': theme === 'light'
					}">
					<code #code>
						<ng-container *ngTemplateOutlet="codeTemplate"></ng-container>
					</code>
				</span>
			</ng-template>
		</ng-container>

		<ng-template #notInline>
			<div
				#codeContainer
				class="cds--snippet-container"
				[attr.aria-label]="translations.CODE_SNIPPET_TEXT"
				[attr.tabindex]="display === 'single' && !disabled ? '0' : null"
				[attr.role]="display==='single' ? 'textarea' : null"
				[ngStyle]="styles"
				(scroll)="(display === 'single' ? handleScroll() : null)">
				<ng-container *ngIf="skeleton">
					<span *ngIf="display === 'single'; else multiSkeleton"></span>
					<ng-template #multiSkeleton>
						<span></span>
						<span></span>
						<span></span>
					</ng-template>
				</ng-container>
				<pre
					#codeContent
					*ngIf="!skeleton"
					(scroll)="(display === 'multi' ? handleScroll() : null)"><code #code><ng-container *ngTemplateOutlet="codeTemplate"></ng-container></code></pre>
			</div>
			<div *ngIf="hasLeft" class="cds--snippet__overflow-indicator--left"></div>
			<div *ngIf="hasRight" class="cds--snippet__overflow-indicator--right"></div>
			<ng-container *ngIf="!hideCopyButton;">
				<ng-container *ngTemplateOutlet="buttonTemplate"></ng-container>
			</ng-container>
			<button
				*ngIf="isExpandable"
				class="cds--btn cds--btn--ghost cds--btn--sm cds--snippet-btn--expand"
				(click)="toggleSnippetExpansion()"
				type="button">
				<span class="cds--snippet-btn--text">{{expanded ? translations.SHOW_LESS : translations.SHOW_MORE}}</span>
				<svg cdsIcon="chevron--down" size="16" class="cds--icon-chevron--down" [attr.aria-label]="translations.SHOW_MORE_ICON"></svg>
			</button>
		</ng-template>

		<ng-template #buttonTemplate>
			<cds-icon-button
				*ngIf="!skeleton"
				[description]="showFeedback ? feedbackText : copyButtonDescription"
				[align]="align"
				[autoAlign]="autoAlign"
				[dropShadow]="dropShadow"
				[caret]="caret"
				[highContrast]="highContrast"
				[isOpen]="isOpen"
				[enterDelayMs]="enterDelayMs"
				[leaveDelayMs]="leaveDelayMs"
				type="button"
				kind="primary"
				size="md"
				(click)="onCopyButtonClicked($event)"
				[buttonNgClass]="{
					'cds--snippet--light': theme === 'light',
					'cds--snippet--inline': display === 'inline',
					'cds--btn--icon-only': display !== 'inline',
					'cds--copy-btn': display !== 'inline',
					'cds--copy-btn--animating': animating,
					'cds--copy-btn--fade-in': showFeedback,
					'cds--copy-btn--fade-out': !showFeedback && animating,
					'cds--snippet cds--copy': true
				}"
				[buttonAttributes]="{
					'aria-label': translations.COPY_CODE,
					'aria-live': 'polite',
					'tabindex': '0'
				}">
				<ng-container *ngIf="display === 'inline'">
					<code #code>
						<ng-container *ngTemplateOutlet="codeTemplate"></ng-container>
					</code>
				</ng-container>
				<ng-container *ngIf="display !== 'inline'">
					<svg cdsIcon="copy" size="16" class="cds--snippet__icon"></svg>
				</ng-container>
			</cds-icon-button>
		</ng-template>

		<ng-template #codeTemplate>
			<ng-content></ng-content>
		</ng-template>
	`
    }]
  }], function() {
    return [{
      type: I18n
    }, {
      type: EventService
    }];
  }, {
    snippetClass: [{
      type: HostBinding,
      args: ["class.cds--snippet"]
    }],
    snippetSingleClass: [{
      type: HostBinding,
      args: ["class.cds--snippet--single"]
    }],
    snippetMultiClass: [{
      type: HostBinding,
      args: ["class.cds--snippet--multi"]
    }],
    snippetDisabledClass: [{
      type: HostBinding,
      args: ["class.cds--snippet--disabled"]
    }],
    snippetInlineLightClass: [{
      type: HostBinding,
      args: ["class.cds--snippet--light"]
    }],
    display: [{
      type: Input
    }],
    translations: [{
      type: Input
    }],
    copyButtonDescription: [{
      type: Input
    }],
    hideCopyButton: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    maxCollapsedNumberOfRows: [{
      type: Input
    }],
    minCollapsedNumberOfRows: [{
      type: Input
    }],
    maxExpandedNumberOfRows: [{
      type: Input
    }],
    minExpandedNumberOfRows: [{
      type: Input
    }],
    wrapText: [{
      type: HostBinding,
      args: ["class.cds--snippet--wraptext"]
    }, {
      type: Input
    }],
    theme: [{
      type: Input
    }],
    feedbackText: [{
      type: Input
    }],
    feedbackTimeout: [{
      type: Input
    }],
    expanded: [{
      type: HostBinding,
      args: ["class.cds--snippet--expand"]
    }, {
      type: Input
    }],
    skeleton: [{
      type: HostBinding,
      args: ["class.cds--skeleton"]
    }, {
      type: Input
    }],
    code: [{
      type: ViewChild,
      args: ["code"]
    }],
    codeContent: [{
      type: ViewChild,
      args: ["codeContent"]
    }],
    codeContainer: [{
      type: ViewChild,
      args: ["codeContainer"]
    }]
  });
})();
var CodeSnippetModule = class {
};
CodeSnippetModule.ɵfac = function CodeSnippetModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || CodeSnippetModule)();
};
CodeSnippetModule.ɵmod = ɵɵdefineNgModule({
  type: CodeSnippetModule,
  declarations: [CodeSnippet],
  imports: [CommonModule, ButtonModule, I18nModule, UtilsModule, IconModule],
  exports: [CodeSnippet]
});
CodeSnippetModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ButtonModule, I18nModule, UtilsModule, IconModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CodeSnippetModule, [{
    type: NgModule,
    args: [{
      declarations: [CodeSnippet],
      exports: [CodeSnippet],
      imports: [CommonModule, ButtonModule, I18nModule, UtilsModule, IconModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-dropdown.mjs
var _c010 = ["dropdownButton"];
var _c19 = ["dropdownMenu"];
var _c27 = ["*"];
var _c34 = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) => ({
  "cds--dropdown": a0,
  "cds--multiselect": a1,
  "cds--multi-select--selected": a2,
  "cds--dropdown--light": a3,
  "cds--list-box--light": a4,
  "cds--list-box--inline": a5,
  "cds--skeleton": a6,
  "cds--dropdown--disabled cds--list-box--disabled": a7,
  "cds--dropdown--readonly": a8,
  "cds--dropdown--invalid": a9,
  "cds--dropdown--warning cds--list-box--warning": a10,
  "cds--dropdown--sm cds--list-box--sm": a11,
  "cds--dropdown--md cds--list-box--md": a12,
  "cds--dropdown--lg cds--list-box--lg": a13,
  "cds--list-box--expanded": a14,
  "cds--list-box--invalid": a15
});
var _c43 = (a0) => ({
  "a": a0
});
var _c52 = (a0) => ({
  "cds--list-box--up": a0
});
var _c62 = (a0, a1) => ({
  "cds--label--disabled": a0,
  "cds--visually-hidden": a1
});
var _c7 = (a0) => ({
  "cds--list-box__menu-icon--open": a0
});
var _c8 = (a0) => ({
  "cds--form__helper-text--disabled": a0
});
function Dropdown_label_0_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.label);
  }
}
function Dropdown_label_0_2_ng_template_0_Template(rf, ctx) {
}
function Dropdown_label_0_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, Dropdown_label_0_2_ng_template_0_Template, 0, 0, "ng-template", 17);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.label);
  }
}
function Dropdown_label_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "label", 16);
    ɵɵtemplate(1, Dropdown_label_0_ng_container_1_Template, 2, 1, "ng-container", 7)(2, Dropdown_label_0_2_Template, 1, 1, null, 7);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("for", ctx_r1.id)("ngClass", ɵɵpureFunction2(4, _c62, ctx_r1.disabled, ctx_r1.hideLabel));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.isTemplate(ctx_r1.label));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.isTemplate(ctx_r1.label));
  }
}
function Dropdown_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 18);
  }
}
function Dropdown_div_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 19);
    ɵɵlistener("click", function Dropdown_div_5_Template_div_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clearSelected());
    })("keydown.enter", function Dropdown_div_5_Template_div_keydown_enter_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clearSelected());
    });
    ɵɵtext(1);
    ɵɵnamespaceSVG();
    ɵɵelementStart(2, "svg", 20);
    ɵɵelement(3, "path", 21);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("title", ctx_r1.clearText);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.getSelectedCount(), " ");
  }
}
function Dropdown_span_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 18);
    ɵɵtext(1);
    ɵɵpipe(2, "async");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ɵɵpipeBind1(2, 1, ctx_r1.getDisplayStringValue()));
  }
}
function Dropdown_7_ng_template_0_Template(rf, ctx) {
}
function Dropdown_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, Dropdown_7_ng_template_0_Template, 0, 0, "ng-template", 22);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutletContext", ctx_r1.getRenderTemplateContext())("ngTemplateOutlet", ctx_r1.displayValue);
  }
}
function Dropdown__svg_svg_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 23);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngClass", ɵɵpureFunction1(2, _c7, !ctx_r1.menuIsClosed));
    ɵɵattribute("aria-label", ctx_r1.menuButtonLabel);
  }
}
function Dropdown__svg_svg_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 24);
  }
}
function Dropdown__svg_svg_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 25);
  }
}
function Dropdown_ng_content_14_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 0, ["*ngIf", "!menuIsClosed"]);
  }
}
function Dropdown_hr_15_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "hr", 26);
  }
}
function Dropdown_div_16_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.helperText);
  }
}
function Dropdown_div_16_2_ng_template_0_Template(rf, ctx) {
}
function Dropdown_div_16_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, Dropdown_div_16_2_ng_template_0_Template, 0, 0, "ng-template", 17);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.helperText);
  }
}
function Dropdown_div_16_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 27);
    ɵɵtemplate(1, Dropdown_div_16_ng_container_1_Template, 2, 1, "ng-container", 7)(2, Dropdown_div_16_2_Template, 1, 1, null, 7);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngClass", ɵɵpureFunction1(3, _c8, ctx_r1.disabled));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.isTemplate(ctx_r1.helperText));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.isTemplate(ctx_r1.helperText));
  }
}
function Dropdown_div_17_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.invalidText);
  }
}
function Dropdown_div_17_2_ng_template_0_Template(rf, ctx) {
}
function Dropdown_div_17_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, Dropdown_div_17_2_ng_template_0_Template, 0, 0, "ng-template", 17);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.invalidText);
  }
}
function Dropdown_div_17_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 28);
    ɵɵtemplate(1, Dropdown_div_17_ng_container_1_Template, 2, 1, "ng-container", 7)(2, Dropdown_div_17_2_Template, 1, 1, null, 7);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.isTemplate(ctx_r1.invalidText));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.isTemplate(ctx_r1.invalidText));
  }
}
function Dropdown_div_18_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.warnText);
  }
}
function Dropdown_div_18_2_ng_template_0_Template(rf, ctx) {
}
function Dropdown_div_18_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, Dropdown_div_18_2_ng_template_0_Template, 0, 0, "ng-template", 17);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.warnText);
  }
}
function Dropdown_div_18_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 28);
    ɵɵtemplate(1, Dropdown_div_18_ng_container_1_Template, 2, 1, "ng-container", 7)(2, Dropdown_div_18_2_Template, 1, 1, null, 7);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.isTemplate(ctx_r1.warnText));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.isTemplate(ctx_r1.warnText));
  }
}
var _c9 = ["list"];
var _c10 = ["listItem"];
var _c11 = (a0, a1) => ({
  "cds--list-box__menu-item--active": a0,
  "cds--list-box__menu-item--highlighted": a1
});
var _c122 = (a0) => ({
  item: a0
});
function DropdownList_li_2_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 9)(1, "label", 10);
    ɵɵelement(2, "input", 11)(3, "span", 12);
    ɵɵelementStart(4, "span", 13);
    ɵɵtext(5);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const item_r3 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵattribute("data-contained-checkbox-state", item_r3.selected);
    ɵɵadvance();
    ɵɵproperty("checked", item_r3.selected)("disabled", item_r3.disabled);
    ɵɵadvance(3);
    ɵɵtextInterpolate(item_r3.content);
  }
}
function DropdownList_li_2_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r3 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(item_r3.content);
  }
}
function DropdownList_li_2__svg_svg_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 14);
  }
}
function DropdownList_li_2_6_ng_template_0_Template(rf, ctx) {
}
function DropdownList_li_2_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, DropdownList_li_2_6_ng_template_0_Template, 0, 0, "ng-template", 15);
  }
  if (rf & 2) {
    const item_r3 = ɵɵnextContext().$implicit;
    const ctx_r3 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutletContext", ɵɵpureFunction1(2, _c122, item_r3))("ngTemplateOutlet", ctx_r3.listTpl);
  }
}
function DropdownList_li_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "li", 4);
    ɵɵlistener("click", function DropdownList_li_2_Template_li_click_0_listener($event) {
      const item_r3 = ɵɵrestoreView(_r2).$implicit;
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.doClick($event, item_r3));
    });
    ɵɵelementStart(1, "div", 5, 1);
    ɵɵtemplate(3, DropdownList_li_2_div_3_Template, 6, 4, "div", 6)(4, DropdownList_li_2_ng_container_4_Template, 2, 1, "ng-container", 7)(5, DropdownList_li_2__svg_svg_5_Template, 1, 0, "svg", 8)(6, DropdownList_li_2_6_Template, 1, 4, null, 7);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const item_r3 = ctx.$implicit;
    const i_r5 = ctx.index;
    const ctx_r3 = ɵɵnextContext();
    ɵɵproperty("id", ctx_r3.getItemId(i_r5))("ngClass", ɵɵpureFunction2(9, _c11, item_r3.selected, ctx_r3.highlightedItem === ctx_r3.getItemId(i_r5)));
    ɵɵattribute("aria-selected", item_r3.selected)("title", ctx_r3.showTitles ? item_r3.content : null)("disabled", item_r3.disabled ? true : null);
    ɵɵadvance(3);
    ɵɵproperty("ngIf", !ctx_r3.listTpl && ctx_r3.type === "multi");
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r3.listTpl && ctx_r3.type === "single");
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r3.listTpl && ctx_r3.type === "single");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r3.listTpl);
  }
}
var AbstractDropdownView = class {
  constructor() {
    this.type = "single";
    this.size = "md";
  }
  /**
   * The items to be displayed in the list within the `AbstractDropDownView`.
   */
  set items(value) {
  }
  get items() {
    return;
  }
  /**
   * Returns the `ListItem` that is subsequent to the selected item in the `DropdownList`.
   */
  getNextItem() {
    return;
  }
  /**
   * Returns a boolean if the currently selected item is preceded by another
   */
  hasNextElement() {
    return;
  }
  /**
   * Returns the `HTMLElement` for the item that is subsequent to the selected item.
   */
  getNextElement() {
    return;
  }
  /**
   * Returns the `ListItem` that precedes the selected item within `DropdownList`.
   */
  getPrevItem() {
    return;
  }
  /**
   * Returns a boolean if the currently selected item is followed by another
   */
  hasPrevElement() {
    return;
  }
  /**
   * Returns the `HTMLElement` for the item that precedes the selected item.
   */
  getPrevElement() {
    return;
  }
  /**
   * Returns the selected leaf level item(s) within the `DropdownList`.
   */
  getSelected() {
    return;
  }
  /**
   * Returns the `ListItem` that is selected within `DropdownList`.
   */
  getCurrentItem() {
    return;
  }
  /**
   * Returns the `HTMLElement` for the item that is selected within the `DropdownList`.
   */
  getCurrentElement() {
    return;
  }
  /**
   * Guaranteed to return the current items as an Array.
   */
  getListItems() {
    return;
  }
  /**
   * Transforms array input list of items to the correct state by updating the selected item(s).
   */
  propagateSelected(value) {
  }
  /**
   *
   * @param value value to filter the list by
   */
  filterBy(value) {
  }
  /**
   * Initializes focus in the list
   * In most cases this just calls `getCurrentElement().focus()`
   */
  initFocus() {
  }
  /**
   * Subscribe the function passed to an internal observable that will resolve once the items are ready
   */
  onItemsReady(subcription) {
  }
  /**
   * Reorder selected items bringing them to the top of the list
   */
  reorderSelected(moveFocus) {
  }
};
AbstractDropdownView.ɵfac = function AbstractDropdownView_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || AbstractDropdownView)();
};
AbstractDropdownView.ɵdir = ɵɵdefineDirective({
  type: AbstractDropdownView,
  selectors: [["", "cdsAbstractDropdownView", ""], ["", "ibmAbstractDropdownView", ""]],
  inputs: {
    items: "items"
  },
  outputs: {
    select: "select",
    blurIntent: "blurIntent"
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AbstractDropdownView, [{
    type: Directive,
    args: [{
      selector: "[cdsAbstractDropdownView], [ibmAbstractDropdownView]"
    }]
  }], null, {
    items: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    blurIntent: [{
      type: Output
    }]
  });
})();
var defaultOffset = {
  top: 0,
  left: 0
};
var DropdownService = class {
  constructor(placeholderService, animationFrameService) {
    this.placeholderService = placeholderService;
    this.animationFrameService = animationFrameService;
    this.animationFrameSubscription = new Subscription();
    this._offset = defaultOffset;
  }
  set offset(value) {
    this._offset = Object.assign({}, defaultOffset, value);
  }
  get offset() {
    return this._offset;
  }
  /**
   * Appends the menu to the body, or a `cds-placeholder` (if defined)
   *
   * @param parentRef container to position relative to
   * @param menuRef menu to be appended to body
   * @param classList any extra classes we should wrap the container with
   */
  appendToBody(parentRef, menuRef, classList) {
    menuRef.style.display = "block";
    const dropdownWrapper = document.createElement("div");
    dropdownWrapper.className = `dropdown ${classList}`;
    dropdownWrapper.style.width = parentRef.offsetWidth + "px";
    dropdownWrapper.style.position = "absolute";
    dropdownWrapper.appendChild(menuRef);
    if (this.placeholderService.hasPlaceholderRef()) {
      this.placeholderService.appendElement(dropdownWrapper);
    } else {
      document.body.appendChild(dropdownWrapper);
    }
    this.menuInstance = dropdownWrapper;
    this.animationFrameSubscription = this.animationFrameService.tick.subscribe(() => {
      this.positionDropdown(parentRef, dropdownWrapper);
    });
    this.positionDropdown(parentRef, dropdownWrapper);
    return dropdownWrapper;
  }
  /**
   * Reattach the dropdown menu to the parent container
   * @param hostRef container to append to
   */
  appendToDropdown(hostRef) {
    if (!this.menuInstance) {
      return;
    }
    const instance = this.menuInstance;
    const menu = instance.firstElementChild;
    this.menuInstance = null;
    menu.style.display = "none";
    hostRef.appendChild(menu);
    this.animationFrameSubscription.unsubscribe();
    if (this.placeholderService.hasPlaceholderRef() && this.placeholderService.hasElement(instance)) {
      this.placeholderService.removeElement(instance);
    } else if (document.body.contains(instance)) {
      document.body.removeChild(instance);
    }
    return instance;
  }
  /**
   * position an open dropdown relative to the given parentRef
   */
  updatePosition(parentRef) {
    this.positionDropdown(parentRef, this.menuInstance);
  }
  ngOnDestroy() {
    this.animationFrameSubscription.unsubscribe();
  }
  positionDropdown(parentRef, menuRef) {
    if (!menuRef) {
      return;
    }
    let leftOffset = 0;
    const boxMenu = menuRef.querySelector(".cds--list-box__menu");
    if (boxMenu) {
      if (parentRef.getBoundingClientRect().left !== boxMenu.getBoundingClientRect().left) {
        const testBoxMenuRightEdgePos = parentRef.getBoundingClientRect().left - boxMenu.getBoundingClientRect().left + boxMenu.getBoundingClientRect().right;
        if (testBoxMenuRightEdgePos > (window.innerWidth || document.documentElement.clientWidth)) {
          leftOffset = parentRef.offsetWidth - boxMenu.offsetWidth;
        }
      } else if (boxMenu.getBoundingClientRect().right > (window.innerWidth || document.documentElement.clientWidth)) {
        leftOffset = parentRef.offsetWidth - boxMenu.offsetWidth;
      }
    }
    const closestMenuWithPos = closestAttr("position", ["relative", "fixed", "absolute"], menuRef.parentElement);
    const topPos = closestMenuWithPos ? closestMenuWithPos.getBoundingClientRect().top * -1 : this.offset.top;
    const leftPos = closestMenuWithPos ? closestMenuWithPos.getBoundingClientRect().left * -1 : this.offset.left + leftOffset;
    let pos = position.findAbsolute(parentRef, menuRef, "bottom");
    pos = position.addOffset(pos, topPos, leftPos);
    position.setElement(menuRef, pos);
  }
};
DropdownService.ɵfac = function DropdownService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || DropdownService)(ɵɵinject(PlaceholderService), ɵɵinject(AnimationFrameService));
};
DropdownService.ɵprov = ɵɵdefineInjectable({
  token: DropdownService,
  factory: DropdownService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropdownService, [{
    type: Injectable
  }], function() {
    return [{
      type: PlaceholderService
    }, {
      type: AnimationFrameService
    }];
  }, null);
})();
var Dropdown = class _Dropdown {
  /**
   * Creates an instance of Dropdown.
   */
  constructor(elementRef, i18n, dropdownService, elementService) {
    this.elementRef = elementRef;
    this.i18n = i18n;
    this.dropdownService = dropdownService;
    this.elementService = elementService;
    this.id = `dropdown-${_Dropdown.dropdownCount++}`;
    this.hideLabel = false;
    this.placeholder = "";
    this.displayValue = "";
    this.clearText = this.i18n.get().DROPDOWN.CLEAR;
    this.size = "md";
    this.type = "single";
    this.theme = "dark";
    this.disabled = false;
    this.readonly = false;
    this.skeleton = false;
    this.inline = false;
    this.disableArrowKeys = false;
    this.invalid = false;
    this.warn = false;
    this.appendInline = null;
    this.selectionFeedback = "top-after-reopen";
    this.menuButtonLabel = this.i18n.get().DROPDOWN.OPEN;
    this.selectedLabel = this.i18n.get().DROPDOWN.SELECTED;
    this.selected = new EventEmitter();
    this.onClose = new EventEmitter();
    this.close = new EventEmitter();
    this.hostClass = true;
    this.hostWrapperClass = true;
    this.fluid = false;
    this.menuIsClosed = true;
    this._dropUp = false;
    this.noop = this._noop.bind(this);
    this.outsideClick = this._outsideClick.bind(this);
    this.outsideKey = this._outsideKey.bind(this);
    this.keyboardNav = this._keyboardNav.bind(this);
    this.visibilitySubscription = new Subscription();
    this.onTouchedCallback = this._noop;
    this._isFocused = false;
    this._writtenValue = [];
    this.propagateChange = (_) => {
    };
  }
  get fluidInvalidClass() {
    return this.invalid && this.fluid;
  }
  get fluidFocusClass() {
    return this.fluid && this._isFocused && this.menuIsClosed;
  }
  get writtenValue() {
    return this._writtenValue;
  }
  set writtenValue(val) {
    if (val && val.length === 0) {
      this.clearSelected();
    }
    this._writtenValue = val;
  }
  /**
   * Updates the `type` property in the `@ContentChild`.
   * The `type` property specifies whether the `Dropdown` allows single selection or multi selection.
   */
  ngOnInit() {
    if (this.view) {
      this.view.type = this.type;
    }
  }
  /**
   * Initializes classes and subscribes to events for single or multi selection.
   */
  ngAfterContentInit() {
    if (!this.view) {
      return;
    }
    if (this.writtenValue && this.writtenValue.length || typeof this.writtenValue === "number") {
      this.writeValue(this.writtenValue);
    }
    this.view.type = this.type;
    this.view.size = this.size;
    const isUpdate = (event) => event && event.isUpdate;
    this.view.select.subscribe((event) => {
      if (this.type === "single" && !isUpdate(event) && !Array.isArray(event)) {
        this.closeMenu();
        if (event.item && event.item.selected) {
          if (this.itemValueKey) {
            this.propagateChange(event.item[this.itemValueKey]);
          } else {
            this.propagateChange(event.item);
          }
        } else {
          this.propagateChange(null);
        }
      }
      if (this.type === "multi" && !isUpdate(event)) {
        if (this.itemValueKey && this.view.getSelected()) {
          const values = this.view.getSelected().map((item) => item[this.itemValueKey]);
          this.propagateChange(values);
        } else {
          this.propagateChange(this.view.getSelected());
        }
      }
      if (!isUpdate(event)) {
        this.checkForReorder();
        this.selected.emit(event);
      }
    });
  }
  ngAfterViewInit() {
    if (this.appendInline === null && hasScrollableParents(this.elementRef.nativeElement)) {
      this.appendInline = false;
    } else if (this.appendInline === null) {
      this.appendInline = true;
    }
    this.checkForReorder();
  }
  /**
   * Removing the `Dropdown` from the body if it is appended to the body.
   */
  ngOnDestroy() {
    if (!this.appendInline) {
      this._appendToDropdown();
    }
  }
  /**
   * Propagates the injected `value`.
   */
  writeValue(value) {
    this.writtenValue = value;
    this.view.onItemsReady(() => {
      if (!value) {
        this.view.propagateSelected([value]);
      } else if (this.type === "single") {
        if (this.itemValueKey) {
          const newValue = Object.assign({}, this.view.getListItems().find((item) => item[this.itemValueKey] === value));
          newValue.selected = true;
          this.view.propagateSelected([newValue]);
        } else {
          this.view.propagateSelected([value]);
        }
      } else {
        if (this.itemValueKey) {
          let newValues = [];
          for (const v of value) {
            for (const item of this.view.getListItems()) {
              if (item[this.itemValueKey] === v) {
                newValues.push(Object.assign({}, item, {
                  selected: true
                }));
              }
            }
          }
          this.view.propagateSelected(newValues);
        } else {
          this.view.propagateSelected(value);
        }
      }
      this.checkForReorder();
    });
  }
  onBlur() {
    this.onTouchedCallback();
  }
  registerOnChange(fn) {
    this.propagateChange = fn;
  }
  /**
   * Registering the function injected to control the touch use of the `Dropdown`.
   */
  registerOnTouched(fn) {
    this.onTouchedCallback = fn;
  }
  /**
   * `ControlValueAccessor` method to programmatically disable the dropdown.
   *
   * ex: `this.formGroup.get("myDropdown").disable();`
   *
   * @param isDisabled `true` to disable the input
   */
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  /**
   * Adds keyboard functionality for navigation, selection and closing of the `Dropdown`.
   */
  onKeyDown(event) {
    if (this.readonly) {
      return;
    }
    if (event.key === "Escape" && !this.menuIsClosed) {
      event.stopImmediatePropagation();
    }
    if (event.key === "Escape") {
      event.preventDefault();
      this.closeMenu();
      this.dropdownButton.nativeElement.focus();
    } else if (this.menuIsClosed && (event.key === " " || event.key === "ArrowDown" || event.key === "ArrowUp")) {
      if (this.disableArrowKeys && (event.key === "ArrowDown" || event.key === "ArrowUp")) {
        return;
      }
      event.preventDefault();
      this.openMenu();
    }
    if (!this.menuIsClosed && event.key === "Tab" && this.dropdownMenu.nativeElement.contains(event.target)) {
      this.closeMenu();
    }
    if (!this.menuIsClosed && event.key === "Tab" && event.shiftKey) {
      this.closeMenu();
    }
    if (this.type === "multi") {
      return;
    }
    if (this.menuIsClosed) {
      this.closedDropdownNavigation(event);
    }
  }
  closedDropdownNavigation(event) {
    if (event.key === "ArrowDown") {
      event.preventDefault();
      this.view.getCurrentItem().selected = false;
      let item = this.view.getNextItem();
      if (item) {
        item.selected = true;
      }
    } else if (event.key === "ArrowUp") {
      event.preventDefault();
      this.view.getCurrentItem().selected = false;
      let item = this.view.getPrevItem();
      if (item) {
        item.selected = true;
      }
    }
  }
  /**
   * Returns the display value if there is a selection and displayValue is set,
   * if there is just a selection the ListItem content property will be returned,
   * otherwise the placeholder will be returned.
   */
  getDisplayStringValue() {
    if (!this.view || this.skeleton) {
      return;
    }
    let selected = this.view.getSelected();
    if (selected.length && (!this.displayValue || !this.isRenderString())) {
      if (this.type === "multi") {
        return of(this.placeholder);
      } else {
        return of(selected[0].content);
      }
    } else if (selected.length && this.isRenderString()) {
      return of(this.displayValue);
    }
    return of(this.placeholder);
  }
  isRenderString() {
    return typeof this.displayValue === "string";
  }
  getRenderTemplateContext() {
    if (!this.view) {
      return;
    }
    let selected = this.view.getSelected();
    if (this.type === "multi") {
      return {
        items: selected
      };
    } else if (selected && selected.length > 0) {
      return {
        item: selected[0]
      };
    } else {
      return {};
    }
  }
  getSelectedCount() {
    if (this.view.getSelected()) {
      return this.view.getSelected().length;
    }
  }
  clearSelected() {
    if (this.disabled || this.getSelectedCount() === 0) {
      return;
    }
    for (const item of this.view.getListItems()) {
      item.selected = false;
    }
    this.selected.emit([]);
    this.propagateChange([]);
  }
  /**
   * Returns `true` if there is a value selected.
   */
  valueSelected() {
    if (this.view.getSelected()) {
      return true;
    }
    return false;
  }
  _noop() {
  }
  /**
   * Handles clicks outside of the `Dropdown`.
   */
  _outsideClick(event) {
    if (!this.elementRef.nativeElement.contains(event.target) && // if we're appendToBody the list isn't within the _elementRef,
    // so we've got to check if our target is possibly in there too.
    !this.dropdownMenu.nativeElement.contains(event.target)) {
      this.closeMenu();
    }
  }
  _outsideKey(event) {
    if (!this.menuIsClosed && event.key === "Tab" && this.dropdownMenu.nativeElement.contains(event.target)) {
      this.closeMenu();
    }
  }
  /**
   * Handles keyboard events so users are controlling the `Dropdown` instead of unintentionally controlling outside elements.
   */
  _keyboardNav(event) {
    if (event.key === "Escape" && !this.menuIsClosed) {
      event.stopImmediatePropagation();
    }
    if (event.key === "Escape") {
      event.preventDefault();
      this.closeMenu();
      this.dropdownButton.nativeElement.focus();
    } else if (!this.menuIsClosed && event.key === "Tab") {
      this.dropdownButton.nativeElement.focus();
      this.dropdownButton.nativeElement.dispatchEvent(new KeyboardEvent("keydown", {
        bubbles: true,
        cancelable: true,
        key: "Tab"
      }));
      this.closeMenu();
    }
  }
  /**
   * Creates the `Dropdown` list appending it to the dropdown parent object instead of the body.
   */
  _appendToDropdown() {
    this.dropdownService.appendToDropdown(this.elementRef.nativeElement);
    this.dropdownMenu.nativeElement.removeEventListener("keydown", this.keyboardNav, true);
  }
  /**
   * Creates the `Dropdown` list as an element that is appended to the DOM body.
   */
  _appendToBody() {
    const lightClass = this.theme === "light" ? " cds--list-box--light" : "";
    const expandedClass = !this.menuIsClosed ? " cds--list-box--expanded" : "";
    this.dropdownService.appendToBody(this.dropdownButton.nativeElement, this.dropdownMenu.nativeElement, `${this.elementRef.nativeElement.className}${lightClass}${expandedClass}`);
    this.dropdownMenu.nativeElement.addEventListener("keydown", this.keyboardNav, true);
  }
  /**
   * Detects whether or not the `Dropdown` list is visible within all scrollable parents.
   * This can be overridden by passing in a value to the `dropUp` input.
   */
  _shouldDropUp() {
    const menu = this.dropdownMenu && this.dropdownMenu.nativeElement.querySelector(".cds--list-box__menu");
    const menuRect = menu && menu.getBoundingClientRect();
    if (menu && menuRect) {
      const scrollableParents = getScrollableParents(menu);
      return scrollableParents.reduce((shouldDropUp, parent) => {
        const parentRect = parent.getBoundingClientRect();
        const isBelowParent = !(menuRect.bottom <= parentRect.bottom);
        return shouldDropUp || isBelowParent;
      }, false);
    }
    return false;
  }
  /**
   * Expands the dropdown menu in the view.
   */
  openMenu() {
    if (this.view.getListItems().length === 0) {
      return;
    }
    this._dropUp = false;
    this.menuIsClosed = false;
    if (!this.appendInline) {
      const target = this.dropdownButton.nativeElement;
      const parent = this.elementRef.nativeElement;
      this.visibilitySubscription = this.elementService.visibility(target, parent).subscribe((value) => {
        if (!value.visible) {
          this.closeMenu();
        }
      });
      this._appendToBody();
    }
    setTimeout(() => {
      if (this.dropUp === null || this.dropUp === void 0) {
        this._dropUp = this._shouldDropUp();
      }
    }, 0);
    document.body.firstElementChild.addEventListener("click", this.noop, true);
    document.body.firstElementChild.addEventListener("keydown", this.noop, true);
    document.addEventListener("click", this.outsideClick, true);
    document.addEventListener("keydown", this.outsideKey, true);
    setTimeout(() => this.view.initFocus(), 0);
  }
  /**
   * Collapsing the dropdown menu and removing unnecessary `EventListeners`.
   */
  closeMenu() {
    if (this.menuIsClosed) {
      return;
    }
    this.menuIsClosed = true;
    this.checkForReorder();
    this.onClose.emit();
    this.close.emit();
    this.dropdownButton.nativeElement.focus();
    if (this.view["disableScroll"]) {
      this.view["disableScroll"]();
    }
    if (!this.appendInline) {
      this.visibilitySubscription.unsubscribe();
      this._appendToDropdown();
    }
    document.body.firstElementChild.removeEventListener("click", this.noop, true);
    document.body.firstElementChild.removeEventListener("keydown", this.noop, true);
    document.removeEventListener("click", this.outsideClick, true);
    document.removeEventListener("keydown", this.outsideKey, true);
  }
  /**
   * Controls toggling menu states between open/expanded and closed/collapsed.
   */
  toggleMenu() {
    if (this.menuIsClosed) {
      this.openMenu();
    } else {
      this.closeMenu();
    }
  }
  isTemplate(value) {
    return value instanceof TemplateRef;
  }
  handleFocus(event) {
    this._isFocused = event.type === "focus";
    if (event.type === "blur") {
      this.onBlur();
    }
  }
  /**
   * Controls when it's needed to apply the selection feedback
   */
  checkForReorder() {
    const topAfterReopen = this.menuIsClosed && this.selectionFeedback === "top-after-reopen";
    if (this.type === "multi" && (topAfterReopen || this.selectionFeedback === "top")) {
      this.view.reorderSelected();
    }
  }
};
Dropdown.dropdownCount = 0;
Dropdown.ɵfac = function Dropdown_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Dropdown)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(I18n), ɵɵdirectiveInject(DropdownService), ɵɵdirectiveInject(ElementService));
};
Dropdown.ɵcmp = ɵɵdefineComponent({
  type: Dropdown,
  selectors: [["cds-dropdown"], ["ibm-dropdown"]],
  contentQueries: function Dropdown_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, AbstractDropdownView, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.view = _t.first);
    }
  },
  viewQuery: function Dropdown_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c010, 7);
      ɵɵviewQuery(_c19, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dropdownButton = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dropdownMenu = _t.first);
    }
  },
  hostVars: 10,
  hostBindings: function Dropdown_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("keydown", function Dropdown_keydown_HostBindingHandler($event) {
        return ctx.onKeyDown($event);
      });
    }
    if (rf & 2) {
      ɵɵclassProp("cds--list-box__wrapper--fluid--invalid", ctx.fluidInvalidClass)("cds--list-box__wrapper--fluid--focus", ctx.fluidFocusClass)("cds--dropdown__wrapper", ctx.hostClass)("cds--list-box__wrapper", ctx.hostWrapperClass)("cds--list-box__wrapper--fluid", ctx.fluid);
    }
  },
  inputs: {
    id: "id",
    label: "label",
    hideLabel: "hideLabel",
    helperText: "helperText",
    placeholder: "placeholder",
    displayValue: "displayValue",
    clearText: "clearText",
    size: "size",
    type: "type",
    theme: "theme",
    disabled: "disabled",
    readonly: "readonly",
    skeleton: "skeleton",
    inline: "inline",
    disableArrowKeys: "disableArrowKeys",
    invalid: "invalid",
    invalidText: "invalidText",
    warn: "warn",
    warnText: "warnText",
    appendInline: "appendInline",
    scrollableContainer: "scrollableContainer",
    itemValueKey: "itemValueKey",
    selectionFeedback: "selectionFeedback",
    menuButtonLabel: "menuButtonLabel",
    selectedLabel: "selectedLabel",
    dropUp: "dropUp",
    fluid: "fluid"
  },
  outputs: {
    selected: "selected",
    onClose: "onClose",
    close: "close"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: Dropdown,
    multi: true
  }])],
  ngContentSelectors: _c27,
  decls: 19,
  vars: 42,
  consts: [["dropdownButton", ""], ["dropdownMenu", ""], ["class", "cds--label", 3, "for", "ngClass", 4, "ngIf"], [1, "cds--list-box", 3, "ngClass"], ["class", "cds--list-box__label", 4, "ngIf"], ["type", "button", "aria-haspopup", "listbox", 1, "cds--list-box__field", 3, "click", "focus", "blur", "id", "ngClass"], ["class", "cds--list-box__selection cds--tag--filter cds--list-box__selection--multi", "tabindex", "0", 3, "title", "click", "keydown.enter", 4, "ngIf"], [4, "ngIf"], [1, "cds--list-box__menu-icon"], ["cdsIcon", "chevron--down", "size", "16", 3, "ngClass", 4, "ngIf"], ["class", "cds--list-box__invalid-icon", "cdsIcon", "warning--filled", "size", "16", 4, "ngIf"], ["cdsIcon", "warning--alt--filled", "size", "16", "class", "cds--list-box__invalid-icon cds--list-box__invalid-icon--warning", 4, "ngIf"], [3, "ngClass"], ["class", "cds--list-box__divider", 4, "ngIf"], ["class", "cds--form__helper-text", 3, "ngClass", 4, "ngIf"], ["class", "cds--form-requirement", 4, "ngIf"], [1, "cds--label", 3, "for", "ngClass"], [3, "ngTemplateOutlet"], [1, "cds--list-box__label"], ["tabindex", "0", 1, "cds--list-box__selection", "cds--tag--filter", "cds--list-box__selection--multi", 3, "click", "keydown.enter", "title"], ["focusable", "false", "preserveAspectRatio", "xMidYMid meet", "role", "img", "xmlns", "http://www.w3.org/2000/svg", "width", "16", "height", "16", "viewBox", "0 0 16 16", "aria-hidden", "true", 2, "will-change", "transform"], ["d", "M12 4.7l-.7-.7L8 7.3 4.7 4l-.7.7L7.3 8 4 11.3l.7.7L8 8.7l3.3 3.3.7-.7L8.7 8z"], [3, "ngTemplateOutletContext", "ngTemplateOutlet"], ["cdsIcon", "chevron--down", "size", "16", 3, "ngClass"], ["cdsIcon", "warning--filled", "size", "16", 1, "cds--list-box__invalid-icon"], ["cdsIcon", "warning--alt--filled", "size", "16", 1, "cds--list-box__invalid-icon", "cds--list-box__invalid-icon--warning"], [1, "cds--list-box__divider"], [1, "cds--form__helper-text", 3, "ngClass"], [1, "cds--form-requirement"]],
  template: function Dropdown_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵprojectionDef();
      ɵɵtemplate(0, Dropdown_label_0_Template, 3, 7, "label", 2);
      ɵɵelementStart(1, "div", 3);
      ɵɵtemplate(2, Dropdown_div_2_Template, 1, 0, "div", 4);
      ɵɵelementStart(3, "button", 5, 0);
      ɵɵlistener("click", function Dropdown_Template_button_click_3_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.disabled || ctx.readonly ? $event.stopPropagation() : ctx.toggleMenu());
      })("focus", function Dropdown_Template_button_focus_3_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.fluid ? ctx.handleFocus($event) : null);
      })("blur", function Dropdown_Template_button_blur_3_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.fluid ? ctx.handleFocus($event) : ctx.onBlur());
      });
      ɵɵtemplate(5, Dropdown_div_5_Template, 4, 2, "div", 6)(6, Dropdown_span_6_Template, 3, 3, "span", 4)(7, Dropdown_7_Template, 1, 2, null, 7);
      ɵɵelementStart(8, "span", 8);
      ɵɵtemplate(9, Dropdown__svg_svg_9_Template, 1, 4, "svg", 9);
      ɵɵelementEnd()();
      ɵɵtemplate(10, Dropdown__svg_svg_10_Template, 1, 0, "svg", 10)(11, Dropdown__svg_svg_11_Template, 1, 0, "svg", 11);
      ɵɵelementStart(12, "div", 12, 1);
      ɵɵtemplate(14, Dropdown_ng_content_14_Template, 1, 0, "ng-content", 7);
      ɵɵelementEnd()();
      ɵɵtemplate(15, Dropdown_hr_15_Template, 1, 0, "hr", 13)(16, Dropdown_div_16_Template, 3, 5, "div", 14)(17, Dropdown_div_17_Template, 3, 2, "div", 15)(18, Dropdown_div_18_Template, 3, 2, "div", 15);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.label && !ctx.skeleton);
      ɵɵadvance();
      ɵɵproperty("ngClass", ɵɵpureFunctionV(21, _c34, [ctx.type !== "multi" && !(ctx.skeleton && ctx.fluid), ctx.type === "multi", ctx.type === "multi" && ctx.getSelectedCount() > 0, ctx.theme === "light", ctx.theme === "light", ctx.inline, ctx.skeleton, ctx.disabled, ctx.readonly, ctx.invalid, ctx.warn, ctx.size === "sm", ctx.size === "md", ctx.size === "lg", !ctx.menuIsClosed, ctx.invalid]));
      ɵɵattribute("data-invalid", ctx.invalid ? true : null);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.skeleton && ctx.fluid);
      ɵɵadvance();
      ɵɵproperty("id", ctx.id)("ngClass", ɵɵpureFunction1(38, _c43, !ctx.menuIsClosed));
      ɵɵattribute("aria-expanded", !ctx.menuIsClosed)("aria-disabled", ctx.disabled)("disabled", ctx.disabled ? true : null);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.type === "multi" && ctx.getSelectedCount() > 0);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.isRenderString());
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.isRenderString());
      ɵɵadvance(2);
      ɵɵproperty("ngIf", !ctx.skeleton);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.invalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.invalid && ctx.warn);
      ɵɵadvance();
      ɵɵproperty("ngClass", ɵɵpureFunction1(40, _c52, ctx.dropUp !== null && ctx.dropUp !== void 0 ? ctx.dropUp : ctx._dropUp));
      ɵɵadvance(2);
      ɵɵproperty("ngIf", !ctx.menuIsClosed);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.fluid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.helperText && !ctx.invalid && !ctx.warn && !ctx.skeleton && !ctx.fluid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.invalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.invalid && ctx.warn);
    }
  },
  dependencies: [NgClass, NgIf, NgTemplateOutlet, IconDirective, AsyncPipe],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Dropdown, [{
    type: Component,
    args: [{
      selector: "cds-dropdown, ibm-dropdown",
      template: `
	<label
		*ngIf="label && !skeleton"
		[for]="id"
		class="cds--label"
		[ngClass]="{
			'cds--label--disabled': disabled,
			'cds--visually-hidden': hideLabel
		}">
		<ng-container *ngIf="!isTemplate(label)">{{label}}</ng-container>
		<ng-template *ngIf="isTemplate(label)" [ngTemplateOutlet]="label"></ng-template>
	</label>
	<div
		class="cds--list-box"
		[ngClass]="{
			'cds--dropdown': type !== 'multi' && !(skeleton && fluid),
			'cds--multiselect': type === 'multi',
			'cds--multi-select--selected': type === 'multi' && getSelectedCount() > 0,
			'cds--dropdown--light': theme === 'light',
			'cds--list-box--light': theme === 'light',
			'cds--list-box--inline': inline,
			'cds--skeleton': skeleton,
			'cds--dropdown--disabled cds--list-box--disabled': disabled,
			'cds--dropdown--readonly': readonly,
			'cds--dropdown--invalid': invalid,
			'cds--dropdown--warning cds--list-box--warning': warn,
			'cds--dropdown--sm cds--list-box--sm': size === 'sm',
			'cds--dropdown--md cds--list-box--md': size === 'md',
			'cds--dropdown--lg cds--list-box--lg': size === 'lg',
			'cds--list-box--expanded': !menuIsClosed,
			'cds--list-box--invalid': invalid
		}"
		[attr.data-invalid]="invalid ? true : null">
		<div *ngIf="skeleton && fluid" class="cds--list-box__label"></div>
		<button
			#dropdownButton
			[id]="id"
			type="button"
			class="cds--list-box__field"
			[ngClass]="{'a': !menuIsClosed}"
			[attr.aria-expanded]="!menuIsClosed"
			[attr.aria-disabled]="disabled"
			aria-haspopup="listbox"
			(click)="disabled || readonly ? $event.stopPropagation() : toggleMenu()"
			(focus)="fluid ? handleFocus($event) : null"
			(blur)="fluid ? handleFocus($event) : onBlur()"
			[attr.disabled]="disabled ? true : null">
			<div
				(click)="clearSelected()"
				(keydown.enter)="clearSelected()"
				*ngIf="type === 'multi' && getSelectedCount() > 0"
				class="cds--list-box__selection cds--tag--filter cds--list-box__selection--multi"
				tabindex="0"
				[title]="clearText">
				{{getSelectedCount()}}
				<svg
					focusable="false"
					preserveAspectRatio="xMidYMid meet"
					style="will-change: transform;"
					role="img"
					xmlns="http://www.w3.org/2000/svg"
					width="16"
					height="16"
					viewBox="0 0 16 16"
					aria-hidden="true">
					<path d="M12 4.7l-.7-.7L8 7.3 4.7 4l-.7.7L7.3 8 4 11.3l.7.7L8 8.7l3.3 3.3.7-.7L8.7 8z"></path>
				</svg>
			</div>
			<span *ngIf="isRenderString()" class="cds--list-box__label">{{getDisplayStringValue() | async}}</span>
			<ng-template
				*ngIf="!isRenderString()"
				[ngTemplateOutletContext]="getRenderTemplateContext()"
				[ngTemplateOutlet]="displayValue">
			</ng-template>
			<span class="cds--list-box__menu-icon">
				<svg
					*ngIf="!skeleton"
					cdsIcon="chevron--down"
					size="16"
					[attr.aria-label]="menuButtonLabel"
					[ngClass]="{'cds--list-box__menu-icon--open': !menuIsClosed }">
				</svg>
			</span>
		</button>
		<svg
			*ngIf="invalid"
			class="cds--list-box__invalid-icon"
			cdsIcon="warning--filled"
			size="16">
		</svg>
		<svg
			*ngIf="!invalid && warn"
			cdsIcon="warning--alt--filled"
			size="16"
			class="cds--list-box__invalid-icon cds--list-box__invalid-icon--warning">
		</svg>
		<div
			#dropdownMenu
			[ngClass]="{
				'cds--list-box--up': this.dropUp !== null && this.dropUp !== undefined ? dropUp : _dropUp
			}">
			<ng-content *ngIf="!menuIsClosed"></ng-content>
		</div>
	</div>
	<hr *ngIf="fluid" class="cds--list-box__divider" />
	<div
		*ngIf="helperText && !invalid && !warn && !skeleton && !fluid"
		class="cds--form__helper-text"
		[ngClass]="{
			'cds--form__helper-text--disabled': disabled
		}">
		<ng-container *ngIf="!isTemplate(helperText)">{{helperText}}</ng-container>
		<ng-template *ngIf="isTemplate(helperText)" [ngTemplateOutlet]="helperText"></ng-template>
	</div>
	<div *ngIf="invalid" class="cds--form-requirement">
		<ng-container *ngIf="!isTemplate(invalidText)">{{ invalidText }}</ng-container>
		<ng-template *ngIf="isTemplate(invalidText)" [ngTemplateOutlet]="invalidText"></ng-template>
	</div>
	<div *ngIf="!invalid && warn" class="cds--form-requirement">
		<ng-container *ngIf="!isTemplate(warnText)">{{warnText}}</ng-container>
		<ng-template *ngIf="isTemplate(warnText)" [ngTemplateOutlet]="warnText"></ng-template>
	</div>
	`,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: Dropdown,
        multi: true
      }]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: I18n
    }, {
      type: DropdownService
    }, {
      type: ElementService
    }];
  }, {
    fluidInvalidClass: [{
      type: HostBinding,
      args: ["class.cds--list-box__wrapper--fluid--invalid"]
    }],
    fluidFocusClass: [{
      type: HostBinding,
      args: ["class.cds--list-box__wrapper--fluid--focus"]
    }],
    id: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    hideLabel: [{
      type: Input
    }],
    helperText: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    displayValue: [{
      type: Input
    }],
    clearText: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    theme: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }],
    skeleton: [{
      type: Input
    }],
    inline: [{
      type: Input
    }],
    disableArrowKeys: [{
      type: Input
    }],
    invalid: [{
      type: Input
    }],
    invalidText: [{
      type: Input
    }],
    warn: [{
      type: Input
    }],
    warnText: [{
      type: Input
    }],
    appendInline: [{
      type: Input
    }],
    scrollableContainer: [{
      type: Input
    }],
    itemValueKey: [{
      type: Input
    }],
    selectionFeedback: [{
      type: Input
    }],
    menuButtonLabel: [{
      type: Input
    }],
    selectedLabel: [{
      type: Input
    }],
    dropUp: [{
      type: Input
    }],
    selected: [{
      type: Output
    }],
    onClose: [{
      type: Output
    }],
    close: [{
      type: Output
    }],
    view: [{
      type: ContentChild,
      args: [AbstractDropdownView, {
        static: true
      }]
    }],
    dropdownButton: [{
      type: ViewChild,
      args: ["dropdownButton", {
        static: true
      }]
    }],
    dropdownMenu: [{
      type: ViewChild,
      args: ["dropdownMenu", {
        static: true
      }]
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.cds--dropdown__wrapper"]
    }],
    hostWrapperClass: [{
      type: HostBinding,
      args: ["class.cds--list-box__wrapper"]
    }],
    fluid: [{
      type: HostBinding,
      args: ["class.cds--list-box__wrapper--fluid"]
    }, {
      type: Input
    }],
    onKeyDown: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }]
  });
})();
function watchFocusJump(target, elements) {
  return fromEvent(target, "keydown").pipe(debounceTime(150), map((ev) => {
    let el = elements.find((itemEl) => itemEl.textContent.trim().toLowerCase().startsWith(ev.key));
    if (el) {
      return el;
    }
  }), filter((el) => !!el));
}
var DropdownList = class _DropdownList {
  /**
   * Creates an instance of `DropdownList`.
   */
  constructor(elementRef, i18n, appRef) {
    this.elementRef = elementRef;
    this.i18n = i18n;
    this.appRef = appRef;
    this.ariaLabel = this.i18n.get().DROPDOWN_LIST.LABEL;
    this.listTpl = null;
    this.select = new EventEmitter();
    this.scroll = new EventEmitter();
    this.blurIntent = new EventEmitter();
    this.type = "single";
    this.showTitles = true;
    this.size = "md";
    this.listId = `listbox-${_DropdownList.listCount++}`;
    this.highlightedItem = null;
    this.displayItems = [];
    this.index = -1;
    this._items = [];
  }
  /**
   * The list items belonging to the `DropdownList`.
   */
  set items(value) {
    if (isObservable(value)) {
      if (this._itemsSubscription) {
        this._itemsSubscription.unsubscribe();
      }
      this._itemsReady = new Observable((observer) => {
        this._itemsSubscription = value.subscribe((v) => {
          this.updateList(v);
          observer.next(true);
          observer.complete();
        });
      });
      this.onItemsReady(null);
    } else {
      this.updateList(value);
    }
    this._originalItems = value;
  }
  get items() {
    return this._originalItems;
  }
  /**
   * Retrieves array of list items and index of the selected item after view has rendered.
   * Additionally, any Observables for the `DropdownList` are initialized.
   */
  ngAfterViewInit() {
    this.index = this.getListItems().findIndex((item) => item.selected);
    this.setupFocusObservable();
    setTimeout(() => {
      this.doEmitSelect(true);
    });
  }
  /**
   * Removes any Observables on destruction of the component.
   */
  ngOnDestroy() {
    if (this.focusJump) {
      this.focusJump.unsubscribe();
    }
    if (this._itemsSubscription) {
      this._itemsSubscription.unsubscribe();
    }
  }
  doEmitSelect(isUpdate = true) {
    if (this.type === "single") {
      this.select.emit({
        item: this._items.find((item) => item.selected),
        isUpdate
      });
    } else {
      const selected = this.getSelected() || [];
      selected["isUpdate"] = isUpdate;
      this.select.emit(selected);
    }
  }
  getItemId(index) {
    return `${this.listId}-${index}`;
  }
  /**
   * Updates the displayed list of items and then retrieves the most current properties for the `DropdownList` from the DOM.
   */
  updateList(items) {
    this._items = items.map((item) => Object.assign({}, item));
    this.displayItems = this._items;
    this.updateIndex();
    this.setupFocusObservable();
    this.doEmitSelect();
  }
  /**
   * Filters the items being displayed in the DOM list.
   */
  filterBy(query = "") {
    if (query) {
      this.displayItems = this.getListItems().filter((item) => item.content.toLowerCase().includes(query.toLowerCase()));
      if (this.displayItems) {
        this.index = 0;
      }
    } else {
      this.displayItems = this.getListItems();
    }
    this.updateIndex();
  }
  /**
   * Initializes (or re-initializes) the Observable that handles switching focus to an element based on
   * key input matching the first letter of the item in the list.
   */
  setupFocusObservable() {
    if (!this.list) {
      return;
    }
    if (this.focusJump) {
      this.focusJump.unsubscribe();
    }
    let elList = Array.from(this.list.nativeElement.querySelectorAll("li"));
    this.focusJump = watchFocusJump(this.list.nativeElement, elList).subscribe((el) => {
      el.focus();
    });
  }
  /**
   * Returns the `ListItem` that is subsequent to the selected item in the `DropdownList`.
   */
  getNextItem() {
    if (this.index < this.displayItems.length - 1) {
      this.index++;
    }
    return this.displayItems[this.index];
  }
  /**
   * Returns `true` if the selected item is not the last item in the `DropdownList`.
   */
  hasNextElement() {
    return this.index < this.displayItems.length - 1 && (!(this.index === this.displayItems.length - 2) || !this.displayItems[this.index + 1].disabled);
  }
  /**
   * Returns the `HTMLElement` for the item that is subsequent to the selected item.
   */
  getNextElement() {
    const elemList = this.listElementList ? this.listElementList.toArray() : [];
    if (!elemList.length) {
      return null;
    }
    for (let i = this.index + 1; i < elemList.length; i++) {
      if (!this.displayItems[i].disabled) {
        this.index = i;
        return elemList[i].nativeElement;
      }
    }
    return elemList[this.index]?.nativeElement;
  }
  /**
   * Returns the `ListItem` that precedes the selected item within `DropdownList`.
   */
  getPrevItem() {
    if (this.index > 0) {
      this.index--;
    }
    return this.displayItems[this.index];
  }
  /**
   * Returns `true` if the selected item is not the first in the list.
   */
  hasPrevElement() {
    return this.index > 0 && (!(this.index === 1) || !this.displayItems[0].disabled);
  }
  /**
   * Returns the `HTMLElement` for the item that precedes the selected item.
   */
  getPrevElement() {
    const elemList = this.listElementList ? this.listElementList.toArray() : [];
    if (!elemList.length) {
      return null;
    }
    for (let i = this.index - 1; i < this.index && i >= 0; i--) {
      if (!this.displayItems[i].disabled) {
        this.index = i;
        return elemList[i].nativeElement;
      }
    }
    return elemList[this.index].nativeElement;
  }
  /**
   * Returns the `ListItem` that is selected within `DropdownList`.
   */
  getCurrentItem() {
    if (this.index < 0) {
      return this.displayItems[0];
    }
    return this.displayItems[this.index];
  }
  /**
   * Returns the `HTMLElement` for the item that is selected within the `DropdownList`.
   */
  getCurrentElement() {
    if (this.index < 0) {
      return this.listElementList.first.nativeElement;
    }
    return this.listElementList.toArray()[this.index].nativeElement;
  }
  /**
   * Returns the items as an Array
   */
  getListItems() {
    return this._items;
  }
  /**
   * Returns a list containing the selected item(s) in the `DropdownList`.
   */
  getSelected() {
    let selected = this.getListItems().filter((item) => item.selected);
    if (selected.length === 0) {
      return [];
    }
    return selected;
  }
  /**
   * Transforms array input list of items to the correct state by updating the selected item(s).
   */
  propagateSelected(value) {
    if (!Array.isArray(value)) {
      console.error(`${this.constructor.name}.propagateSelected expects an Array<ListItem>, got ${JSON.stringify(value)}`);
    }
    this.onItemsReady(() => {
      const selectedNewItems = [];
      for (let newItem of value) {
        if (newItem && newItem.selected) {
          let tempNewItem = Object.assign({}, newItem);
          delete tempNewItem.selected;
          tempNewItem = JSON.stringify(tempNewItem);
          selectedNewItems.push(tempNewItem);
        }
      }
      for (let oldItem of this.getListItems()) {
        if (selectedNewItems.length === 0) {
          oldItem.selected = false;
          continue;
        }
        let tempOldItem = Object.assign({}, oldItem);
        delete tempOldItem.selected;
        tempOldItem = JSON.stringify(tempOldItem);
        for (let selectedNewItem of selectedNewItems) {
          if (tempOldItem.includes(selectedNewItem)) {
            oldItem.selected = true;
            break;
          } else {
            oldItem.selected = false;
          }
        }
      }
    });
  }
  /**
   * Initializes focus in the list, effectively a wrapper for `getCurrentElement().focus()`
   */
  initFocus() {
    if (this.index < 0) {
      this.updateIndex();
    }
    this.list.nativeElement.focus();
    setTimeout(() => {
      this.highlightedItem = this.getItemId(this.index);
    });
  }
  updateIndex() {
    const selected = this.getSelected();
    if (selected.length) {
      this.index = this.displayItems.indexOf(selected[0]);
    } else if (this.hasNextElement()) {
      this.getNextElement();
    }
  }
  /**
   * Manages the keyboard accessibility for navigation and selection within a `DropdownList`.
   */
  navigateList(event) {
    if (event.key === "Enter" || event.key === " ") {
      if (this.listElementList.some((option) => option.nativeElement === event.target)) {
        event.preventDefault();
      }
      if (event.key === "Enter") {
        this.doClick(event, this.getCurrentItem());
      }
    } else if (event.key === "ArrowDown" || event.key === "ArrowUp") {
      event.preventDefault();
      if (event.key === "ArrowDown") {
        if (this.hasNextElement()) {
          this.getNextElement()?.scrollIntoView({
            block: "end"
          });
        } else {
          this.blurIntent.emit("bottom");
        }
      } else if (event.key === "ArrowUp") {
        if (this.hasPrevElement()) {
          this.getPrevElement().scrollIntoView({
            block: "nearest"
          });
        } else {
          this.blurIntent.emit("top");
        }
      }
      setTimeout(() => {
        this.highlightedItem = this.getItemId(this.index);
      });
    }
  }
  /**
   * Emits the selected item or items after a mouse click event has occurred.
   */
  doClick(event, item) {
    event.preventDefault();
    if (item && !item.disabled) {
      this.list.nativeElement.focus();
      if (this.type === "single") {
        item.selected = true;
        for (let otherItem of this.getListItems()) {
          if (item !== otherItem) {
            otherItem.selected = false;
          }
        }
      } else {
        item.selected = !item.selected;
      }
      this.index = this.displayItems.indexOf(item);
      this.highlightedItem = this.getItemId(this.index);
      this.doEmitSelect(false);
      this.appRef.tick();
    }
  }
  onItemFocus(index) {
    const element = this.listElementList.toArray()[index].nativeElement;
    element.classList.add("cds--list-box__menu-item--highlighted");
    element.tabIndex = 0;
  }
  onItemBlur(index) {
    const element = this.listElementList.toArray()[index].nativeElement;
    element.classList.remove("cds--list-box__menu-item--highlighted");
    element.tabIndex = -1;
  }
  /**
   * Emits the scroll event of the options list
   */
  emitScroll(event) {
    const atTop = event.srcElement.scrollTop === 0;
    const atBottom = event.srcElement.scrollHeight - event.srcElement.scrollTop === event.srcElement.clientHeight;
    const customScrollEvent = {
      atTop,
      atBottom,
      event
    };
    this.scroll.emit(customScrollEvent);
  }
  /**
   * Subscribe the function passed to an internal observable that will resolve once the items are ready
   */
  onItemsReady(subcription) {
    (this._itemsReady || of(true)).pipe(first()).subscribe(subcription);
  }
  reorderSelected(moveFocus = true) {
    this.displayItems = [...this.getSelected(), ...this.getListItems().filter((item) => !item.selected)];
    if (moveFocus) {
      setTimeout(() => {
        this.updateIndex();
        this.highlightedItem = this.getItemId(this.index);
      });
    }
  }
};
DropdownList.listCount = 0;
DropdownList.ɵfac = function DropdownList_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || DropdownList)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(I18n), ɵɵdirectiveInject(ApplicationRef));
};
DropdownList.ɵcmp = ɵɵdefineComponent({
  type: DropdownList,
  selectors: [["cds-dropdown-list"], ["ibm-dropdown-list"]],
  viewQuery: function DropdownList_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c9, 7);
      ɵɵviewQuery(_c10, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.list = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.listElementList = _t);
    }
  },
  inputs: {
    ariaLabel: "ariaLabel",
    items: "items",
    listTpl: "listTpl",
    type: "type",
    showTitles: "showTitles"
  },
  outputs: {
    select: "select",
    scroll: "scroll",
    blurIntent: "blurIntent"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([{
    provide: AbstractDropdownView,
    useExisting: DropdownList
  }])],
  decls: 3,
  vars: 4,
  consts: [["list", ""], ["listItem", ""], ["role", "listbox", "tabindex", "-1", 1, "cds--list-box__menu", "cds--multi-select", 3, "scroll", "keydown", "id"], ["role", "option", "class", "cds--list-box__menu-item", 3, "id", "ngClass", "click", 4, "ngFor", "ngForOf"], ["role", "option", 1, "cds--list-box__menu-item", 3, "click", "id", "ngClass"], ["tabindex", "-1", 1, "cds--list-box__menu-item__option"], ["class", "cds--form-item cds--checkbox-wrapper", 4, "ngIf"], [4, "ngIf"], ["cdsIcon", "checkmark", "size", "16", "class", "cds--list-box__menu-item__selected-icon", 4, "ngIf"], [1, "cds--form-item", "cds--checkbox-wrapper"], [1, "cds--checkbox-label"], ["type", "checkbox", "tabindex", "-1", 1, "cds--checkbox", 3, "checked", "disabled"], [1, "cds--checkbox-appearance"], [1, "cds--checkbox-label-text"], ["cdsIcon", "checkmark", "size", "16", 1, "cds--list-box__menu-item__selected-icon"], [3, "ngTemplateOutletContext", "ngTemplateOutlet"]],
  template: function DropdownList_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵelementStart(0, "ul", 2, 0);
      ɵɵlistener("scroll", function DropdownList_Template_ul_scroll_0_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.emitScroll($event));
      })("keydown", function DropdownList_Template_ul_keydown_0_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.navigateList($event));
      });
      ɵɵtemplate(2, DropdownList_li_2_Template, 7, 12, "li", 3);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("id", ctx.listId);
      ɵɵattribute("aria-label", ctx.ariaLabel)("aria-activedescendant", ctx.highlightedItem);
      ɵɵadvance(2);
      ɵɵproperty("ngForOf", ctx.displayItems);
    }
  },
  dependencies: [NgClass, NgForOf, NgIf, NgTemplateOutlet, IconDirective],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropdownList, [{
    type: Component,
    args: [{
      selector: "cds-dropdown-list, ibm-dropdown-list",
      template: `
		<ul
			#list
			[id]="listId"
			role="listbox"
			class="cds--list-box__menu cds--multi-select"
			(scroll)="emitScroll($event)"
			(keydown)="navigateList($event)"
			tabindex="-1"
			[attr.aria-label]="ariaLabel"
			[attr.aria-activedescendant]="highlightedItem">
			<li
				role="option"
				*ngFor="let item of displayItems; let i = index"
				(click)="doClick($event, item)"
				class="cds--list-box__menu-item"
				[attr.aria-selected]="item.selected"
				[id]="getItemId(i)"
				[attr.title]=" showTitles ? item.content : null"
				[attr.disabled]="item.disabled ? true : null"
				[ngClass]="{
					'cds--list-box__menu-item--active': item.selected,
					'cds--list-box__menu-item--highlighted': highlightedItem === getItemId(i)
				}">
				<div
					#listItem
					tabindex="-1"
					class="cds--list-box__menu-item__option">
					<div
						*ngIf="!listTpl && type === 'multi'"
						class="cds--form-item cds--checkbox-wrapper">
						<label
							[attr.data-contained-checkbox-state]="item.selected"
							class="cds--checkbox-label">
							<input
								class="cds--checkbox"
								type="checkbox"
								[checked]="item.selected"
								[disabled]="item.disabled"
								tabindex="-1">
							<span class="cds--checkbox-appearance"></span>
							<span class="cds--checkbox-label-text">{{item.content}}</span>
						</label>
					</div>
					<ng-container *ngIf="!listTpl && type === 'single'">{{item.content}}</ng-container>
					<svg
						*ngIf="!listTpl && type === 'single'"
						cdsIcon="checkmark"
						size="16"
						class="cds--list-box__menu-item__selected-icon">
					</svg>
					<ng-template
						*ngIf="listTpl"
						[ngTemplateOutletContext]="{item: item}"
						[ngTemplateOutlet]="listTpl">
					</ng-template>
				</div>
			</li>
		</ul>`,
      providers: [{
        provide: AbstractDropdownView,
        useExisting: DropdownList
      }]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: I18n
    }, {
      type: ApplicationRef
    }];
  }, {
    ariaLabel: [{
      type: Input
    }],
    items: [{
      type: Input
    }],
    listTpl: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    scroll: [{
      type: Output
    }],
    blurIntent: [{
      type: Output
    }],
    list: [{
      type: ViewChild,
      args: ["list", {
        static: true
      }]
    }],
    type: [{
      type: Input
    }],
    showTitles: [{
      type: Input
    }],
    listElementList: [{
      type: ViewChildren,
      args: ["listItem"]
    }]
  });
})();
var ScrollableList = class {
  constructor(elementRef) {
    this.elementRef = elementRef;
    this.nScrollableList = null;
    this.scrollEnabled = true;
    this.scrollBy = 10;
    this.canScrollUp = false;
    this.canScrollDown = false;
    this.list = this.elementRef.nativeElement;
  }
  ngOnChanges(changes) {
    if (changes.scrollEnabled) {
      if (changes.scrollEnabled.currentValue) {
        this.list.style.overflow = "hidden";
        this.scrollUpTarget.style.display = "flex";
        this.scrollDownTarget.style.display = "flex";
        this.canScrollUp = true;
        this.canScrollDown = true;
        this.updateScrollHeight();
        this.checkScrollArrows();
        setTimeout(() => {
          this.checkScrollArrows();
        });
      } else {
        this.scrollUpTarget.style.display = "none";
        this.scrollDownTarget.style.display = "none";
        this.canScrollUp = false;
        this.canScrollDown = false;
        this.list.style.height = null;
        this.list.style.overflow = null;
        clearInterval(this.hoverScrollInterval);
      }
    }
  }
  ngAfterViewInit() {
    if (this.nScrollableList) {
      this.list = this.elementRef.nativeElement.querySelector(this.nScrollableList);
    }
    this.scrollUpTarget.addEventListener("mouseover", () => this.onHoverUp(true));
    this.scrollUpTarget.addEventListener("mouseout", () => this.onHoverUp(false));
    this.scrollDownTarget.addEventListener("mouseover", () => this.onHoverDown(true));
    this.scrollDownTarget.addEventListener("mouseout", () => this.onHoverDown(false));
  }
  updateScrollHeight() {
    if (this.scrollEnabled) {
      const container = this.elementRef.nativeElement.parentElement;
      const containerRect = container.getBoundingClientRect();
      const innerHeightDiff = this.list.getBoundingClientRect().top - containerRect.top;
      const outerHeightDiff = containerRect.height - (containerRect.bottom - window.innerHeight);
      const height = outerHeightDiff - innerHeightDiff - 40;
      this.list.style.height = `${height}px`;
    }
  }
  checkScrollArrows() {
    const scrollUpHeight = this.scrollUpTarget.offsetHeight;
    const scrollDownHeight = this.scrollDownTarget.offsetHeight;
    if (this.list.scrollTop === 0) {
      if (this.canScrollUp) {
        this.list.style.height = `${parseInt(this.list.style.height, 10) + scrollUpHeight}px`;
      }
      this.scrollUpTarget.style.display = "none";
      this.canScrollUp = false;
    } else if (this.list.scrollTop === this.list.scrollTopMax) {
      if (this.canScrollDown) {
        this.list.style.height = `${parseInt(this.list.style.height, 10) + scrollDownHeight}px`;
      }
      this.scrollDownTarget.style.display = "none";
      this.canScrollDown = false;
    } else {
      if (!this.canScrollUp) {
        this.list.style.height = `${parseInt(this.list.style.height, 10) - scrollUpHeight}px`;
      }
      if (!this.canScrollDown) {
        this.list.style.height = `${parseInt(this.list.style.height, 10) - scrollDownHeight}px`;
      }
      this.scrollUpTarget.style.display = "flex";
      this.scrollDownTarget.style.display = "flex";
      this.canScrollUp = true;
      this.canScrollDown = true;
    }
  }
  onWheel(event) {
    if (event.deltaY < 0) {
      this.list.scrollTop -= this.scrollBy;
    } else {
      this.list.scrollTop += this.scrollBy;
    }
    if (!(this.list.scrollTop === this.list.scrollTopMax || this.list.scrollTop === 0)) {
      event.preventDefault();
      event.stopPropagation();
    }
    this.checkScrollArrows();
  }
  onTouchStart(event) {
    if (event.touches[0]) {
      this.lastTouch = event.touches[0].clientY;
    }
  }
  onTouchMove(event) {
    event.preventDefault();
    event.stopPropagation();
    if (event.touches[0]) {
      const touch = event.touches[0];
      this.list.scrollTop += this.lastTouch - touch.clientY;
      this.lastTouch = touch.clientY;
      this.checkScrollArrows();
    }
  }
  hoverScrollBy(hovering, amount) {
    if (hovering) {
      this.hoverScrollInterval = setInterval(() => {
        this.list.scrollTop += amount;
        this.checkScrollArrows();
      }, 1);
    } else {
      clearInterval(this.hoverScrollInterval);
    }
  }
  onHoverUp(hovering) {
    this.hoverScrollBy(hovering, -3);
  }
  onHoverDown(hovering) {
    this.hoverScrollBy(hovering, 3);
  }
  onKeyDown(event) {
    if (event.key === "ArrowDown" || event.key === "ArrowUp") {
      this.checkScrollArrows();
    }
  }
};
ScrollableList.ɵfac = function ScrollableList_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ScrollableList)(ɵɵdirectiveInject(ElementRef));
};
ScrollableList.ɵdir = ɵɵdefineDirective({
  type: ScrollableList,
  selectors: [["", "cdsScrollableList", ""], ["", "ibmScrollableList", ""]],
  hostBindings: function ScrollableList_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("wheel", function ScrollableList_wheel_HostBindingHandler($event) {
        return ctx.onWheel($event);
      })("touchstart", function ScrollableList_touchstart_HostBindingHandler($event) {
        return ctx.onTouchStart($event);
      })("touchmove", function ScrollableList_touchmove_HostBindingHandler($event) {
        return ctx.onTouchMove($event);
      })("keydown", function ScrollableList_keydown_HostBindingHandler($event) {
        return ctx.onKeyDown($event);
      });
    }
  },
  inputs: {
    nScrollableList: "nScrollableList",
    scrollEnabled: "scrollEnabled",
    scrollUpTarget: "scrollUpTarget",
    scrollDownTarget: "scrollDownTarget",
    scrollBy: "scrollBy"
  },
  exportAs: ["scrollable-list"],
  standalone: false,
  features: [ɵɵNgOnChangesFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollableList, [{
    type: Directive,
    args: [{
      selector: "[cdsScrollableList], [ibmScrollableList]",
      exportAs: "scrollable-list"
    }]
  }], function() {
    return [{
      type: ElementRef
    }];
  }, {
    nScrollableList: [{
      type: Input
    }],
    scrollEnabled: [{
      type: Input
    }],
    scrollUpTarget: [{
      type: Input
    }],
    scrollDownTarget: [{
      type: Input
    }],
    scrollBy: [{
      type: Input
    }],
    onWheel: [{
      type: HostListener,
      args: ["wheel", ["$event"]]
    }],
    onTouchStart: [{
      type: HostListener,
      args: ["touchstart", ["$event"]]
    }],
    onTouchMove: [{
      type: HostListener,
      args: ["touchmove", ["$event"]]
    }],
    onKeyDown: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }]
  });
})();
var DropdownModule = class {
};
DropdownModule.ɵfac = function DropdownModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || DropdownModule)();
};
DropdownModule.ɵmod = ɵɵdefineNgModule({
  type: DropdownModule,
  declarations: [Dropdown, DropdownList, ScrollableList, AbstractDropdownView],
  imports: [CommonModule, FormsModule, I18nModule, PlaceholderModule, UtilsModule, IconModule],
  exports: [Dropdown, DropdownList, ScrollableList, AbstractDropdownView]
});
DropdownModule.ɵinj = ɵɵdefineInjector({
  providers: [DropdownService],
  imports: [CommonModule, FormsModule, I18nModule, PlaceholderModule, UtilsModule, IconModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropdownModule, [{
    type: NgModule,
    args: [{
      declarations: [Dropdown, DropdownList, ScrollableList, AbstractDropdownView],
      exports: [Dropdown, DropdownList, ScrollableList, AbstractDropdownView],
      imports: [CommonModule, FormsModule, I18nModule, PlaceholderModule, UtilsModule, IconModule],
      providers: [DropdownService]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-combobox.mjs
var _c011 = ["dropdownMenu"];
var _c110 = ["input"];
var _c28 = ["listbox"];
var _c35 = ["*"];
var _c44 = (a0, a1, a2) => ({
  "cds--list-box__wrapper--fluid": a0,
  "cds--list-box__wrapper--fluid--invalid": a1,
  "cds--list-box__wrapper--fluid--focus": a2
});
var _c53 = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => ({
  "cds--multi-select cds--multi-select--filterable": a0,
  "cds--list-box--light": a1,
  "cds--list-box--expanded": a2,
  "cds--list-box--sm": a3,
  "cds--list-box--md": a4,
  "cds--list-box--lg": a5,
  "cds--list-box--disabled": a6,
  "cds--combo-box--readonly": a7,
  "cds--combo-box--warning cds--list-box--warning": a8,
  "cds--list-box--invalid": a9
});
var _c63 = (a0) => ({
  "cds--text-input--empty": a0
});
var _c72 = (a0) => ({
  "cds--list-box__menu-icon--open": a0
});
var _c82 = (a0) => ({
  "cds--list-box--up": a0
});
var _c92 = (a0, a1) => ({
  "cds--label--disabled": a0,
  "cds--visually-hidden": a1
});
var _c102 = (a0) => ({
  "cds--tag--disabled": a0
});
var _c112 = (a0) => ({
  "cds--form__helper-text--disabled": a0
});
function ComboBox_label_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.label);
  }
}
function ComboBox_label_1_2_ng_template_0_Template(rf, ctx) {
}
function ComboBox_label_1_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ComboBox_label_1_2_ng_template_0_Template, 0, 0, "ng-template", 20);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.label);
  }
}
function ComboBox_label_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "label", 19);
    ɵɵtemplate(1, ComboBox_label_1_ng_container_1_Template, 2, 1, "ng-container", 15)(2, ComboBox_label_1_2_Template, 1, 1, null, 15);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("for", ctx_r1.id)("id", ctx_r1.labelId)("ngClass", ɵɵpureFunction2(5, _c92, ctx_r1.disabled, ctx_r1.hideLabel));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.isTemplate(ctx_r1.label));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.isTemplate(ctx_r1.label));
  }
}
function ComboBox_div_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 21)(1, "span", 22);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelementStart(3, "button", 23);
    ɵɵlistener("click", function ComboBox_div_5_Template_button_click_3_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clearSelected($event));
    })("blur", function ComboBox_div_5_Template_button_blur_3_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onBlur());
    })("keydown.enter", function ComboBox_div_5_Template_button_keydown_enter_3_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clearSelected($event));
    });
    ɵɵnamespaceSVG();
    ɵɵelementStart(4, "svg", 24);
    ɵɵelement(5, "path", 25);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngClass", ɵɵpureFunction1(5, _c102, ctx_r1.disabled || ctx_r1.readonly));
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r1.pills.length);
    ɵɵadvance();
    ɵɵproperty("title", ctx_r1.clearSelectionsTitle)("disabled", ctx_r1.disabled || ctx_r1.readonly);
    ɵɵattribute("aria-label", ctx_r1.clearSelectionAria);
  }
}
function ComboBox__svg_svg_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 26);
  }
}
function ComboBox__svg_svg_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 27);
  }
}
function ComboBox_div_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 28);
    ɵɵlistener("keyup.enter", function ComboBox_div_10_Template_div_keyup_enter_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clearInput($event));
    })("click", function ComboBox_div_10_Template_div_click_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clearInput($event));
    })("blur", function ComboBox_div_10_Template_div_blur_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onBlur());
    });
    ɵɵnamespaceSVG();
    ɵɵelement(1, "svg", 29);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("title", ctx_r1.clearSelectionTitle);
    ɵɵattribute("aria-label", ctx_r1.clearSelectionAria);
  }
}
function ComboBox_ng_content_15_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 0, ["*ngIf", "open"]);
  }
}
function ComboBox_hr_16_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "hr", 30);
  }
}
function ComboBox_div_17_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.helperText);
  }
}
function ComboBox_div_17_2_ng_template_0_Template(rf, ctx) {
}
function ComboBox_div_17_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ComboBox_div_17_2_ng_template_0_Template, 0, 0, "ng-template", 20);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.helperText);
  }
}
function ComboBox_div_17_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 31);
    ɵɵtemplate(1, ComboBox_div_17_ng_container_1_Template, 2, 1, "ng-container", 15)(2, ComboBox_div_17_2_Template, 1, 1, null, 15);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngClass", ɵɵpureFunction1(3, _c112, ctx_r1.disabled));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.isTemplate(ctx_r1.helperText));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.isTemplate(ctx_r1.helperText));
  }
}
function ComboBox_div_18_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.invalidText);
  }
}
function ComboBox_div_18_2_ng_template_0_Template(rf, ctx) {
}
function ComboBox_div_18_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ComboBox_div_18_2_ng_template_0_Template, 0, 0, "ng-template", 20);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.invalidText);
  }
}
function ComboBox_div_18_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 32);
    ɵɵtemplate(1, ComboBox_div_18_ng_container_1_Template, 2, 1, "ng-container", 15)(2, ComboBox_div_18_2_Template, 1, 1, null, 15);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.isTemplate(ctx_r1.invalidText));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.isTemplate(ctx_r1.invalidText));
  }
}
function ComboBox_div_19_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.warnText);
  }
}
function ComboBox_div_19_2_ng_template_0_Template(rf, ctx) {
}
function ComboBox_div_19_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ComboBox_div_19_2_ng_template_0_Template, 0, 0, "ng-template", 20);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.warnText);
  }
}
function ComboBox_div_19_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 32);
    ɵɵtemplate(1, ComboBox_div_19_ng_container_1_Template, 2, 1, "ng-container", 15)(2, ComboBox_div_19_2_Template, 1, 1, null, 15);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.isTemplate(ctx_r1.warnText));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.isTemplate(ctx_r1.warnText));
  }
}
var ComboBox = class _ComboBox {
  /**
   * Creates an instance of ComboBox.
   */
  constructor(elementRef, dropdownService, i18n) {
    this.elementRef = elementRef;
    this.dropdownService = dropdownService;
    this.i18n = i18n;
    this.id = `combobox-${_ComboBox.comboBoxCount++}`;
    this.labelId = `combobox-label-${_ComboBox.comboBoxCount++}`;
    this.items = [];
    this.type = "single";
    this.size = "md";
    this.hideLabel = false;
    this.appendInline = null;
    this.invalid = false;
    this.warn = false;
    this.maxLength = null;
    this.theme = "dark";
    this.selectionFeedback = "top-after-reopen";
    this.autocomplete = "list";
    this.disabled = false;
    this.readonly = false;
    this.fluid = false;
    this.selected = new EventEmitter();
    this.submit = new EventEmitter();
    this.close = new EventEmitter();
    this.search = new EventEmitter();
    this.clear = new EventEmitter();
    this.hostClass = true;
    this.open = false;
    this.showClearButton = false;
    this.pills = [];
    this.selectedValue = "";
    this.outsideClick = this._outsideClick.bind(this);
    this.keyboardNav = this._keyboardNav.bind(this);
    this._dropUp = false;
    this.noop = this._noop.bind(this);
    this.onTouchedCallback = this._noop;
    this.propagateChangeCallback = this._noop;
    this._placeholder = this.i18n.getOverridable("COMBOBOX.PLACEHOLDER");
    this._closeMenuAria = this.i18n.getOverridable("COMBOBOX.A11Y.CLOSE_MENU");
    this._openMenuAria = this.i18n.getOverridable("COMBOBOX.A11Y.OPEN_MENU");
    this._clearSelectionsTitle = this.i18n.getOverridable("COMBOBOX.CLEAR_SELECTIONS");
    this._clearSelectionsAria = this.i18n.getOverridable("COMBOBOX.A11Y.CLEAR_SELECTIONS");
    this._clearSelectionTitle = this.i18n.getOverridable("COMBOBOX.CLEAR_SELECTED");
    this._clearSelectionAria = this.i18n.getOverridable("COMBOBOX.A11Y.CLEAR_SELECTED");
    this._isFocused = false;
  }
  /**
   * Text to show when nothing is selected.
   */
  set placeholder(value) {
    this._placeholder.override(value);
  }
  get placeholder() {
    return this._placeholder.value;
  }
  /**
   * Value to display for accessibility purposes on the combobox control menu when closed
   */
  set openMenuAria(value) {
    this._openMenuAria.override(value);
  }
  get openMenuAria() {
    return this._openMenuAria.value;
  }
  /**
   * Value to display for accessibility purposes on the combobox control menu when opened
   */
  set closeMenuAria(value) {
    this._closeMenuAria.override(value);
  }
  get closeMenuAria() {
    return this._closeMenuAria.value;
  }
  /**
   * Value to display on the clear selections icon, when multi is selected
   */
  set clearSelectionsTitle(value) {
    this._clearSelectionsTitle.override(value);
  }
  get clearSelectionsTitle() {
    return this._clearSelectionsTitle.value;
  }
  /**
   * Value to display for accessibility purposes to clear selections, when multi is selected
   */
  set clearSelectionsAria(value) {
    this._clearSelectionsAria.override(value);
  }
  get clearSelectionsAria() {
    return this._clearSelectionsAria.value;
  }
  /**
   * Value to display on the clear the selected item icon, when single is selected
   */
  set clearSelectionTitle(value) {
    this._clearSelectionTitle.override(value);
  }
  get clearSelectionTitle() {
    return this._clearSelectionTitle.value;
  }
  /**
   * Value to display for accessibility purposes on the clear the selected item icon, when single is selected
   */
  set clearSelectionAria(value) {
    this._clearSelectionAria.override(value);
  }
  get clearSelectionAria() {
    return this._clearSelectionAria.value;
  }
  /**
   * Lifecycle hook.
   * Updates pills if necessary.
   *
   */
  ngOnChanges(changes) {
    if (changes.items) {
      this.view.items = changes.items.currentValue;
      this.updateSelected();
      if (this.type === "multi" || this.type === "single" && !this.selectedValue) {
        this.onSearch(this.input.nativeElement.value, false);
      }
    }
  }
  /**
   * Sets initial state that depends on child components
   * Subscribes to select events and handles focus/filtering/initial list updates
   */
  ngAfterContentInit() {
    if (this.view) {
      this.view.type = this.type;
      const isUpdate = (event) => event && event.isUpdate;
      this.view.select.subscribe((event) => {
        if (Array.isArray(event)) {
          this.updatePills();
          if (!isUpdate(event)) {
            if (this.itemValueKey && this.view.getSelected()) {
              const values = this.view.getSelected().map((item) => item[this.itemValueKey]);
              this.propagateChangeCallback(values);
            } else {
              this.propagateChangeCallback(this.view.getSelected());
            }
            this.selected.emit(event);
          }
        } else {
          if (event.item && event.item.selected) {
            this.showClearButton = true;
            this.selectedValue = event.item.content;
            if (!isUpdate(event)) {
              if (this.itemValueKey) {
                this.propagateChangeCallback(event.item[this.itemValueKey]);
              } else {
                this.propagateChangeCallback(event.item);
              }
            }
          } else {
            this.selectedValue = "";
            if (!isUpdate(event)) {
              this.propagateChangeCallback(null);
            }
          }
          if (!isUpdate(event)) {
            this.elementRef.nativeElement.querySelector("input").focus();
            this.view.filterBy("");
            this.selected.emit(event.item);
          }
          this.closeDropdown();
        }
      });
      setTimeout(() => {
        this.updateSelected();
      });
      this.view.blurIntent.pipe(filter((v) => v === "top")).subscribe(() => {
        this.elementRef.nativeElement.querySelector(".cds--text-input").focus();
      });
    }
  }
  /**
   * Binds event handlers against the rendered view
   */
  ngAfterViewInit() {
    if (this.appendInline === null && hasScrollableParents(this.elementRef.nativeElement)) {
      this.appendInline = false;
    } else if (this.appendInline === null) {
      this.appendInline = true;
    }
  }
  /**
   * Removing the `Dropdown` from the body if it is appended to the body.
   */
  ngOnDestroy() {
    if (!this.appendInline) {
      this._appendToDropdown();
    }
  }
  /**
   * Handles `Escape/Tab` key closing the dropdown, and arrow up/down focus to/from the dropdown list.
   */
  hostkeys(ev) {
    if (ev.key === "Escape") {
      this.closeDropdown();
    } else if (ev.key === "ArrowDown" && (!this.dropdownMenu || !this.dropdownMenu.nativeElement.contains(ev.target))) {
      ev.preventDefault();
      this.openDropdown();
      setTimeout(() => {
        this.view.initFocus();
      }, 0);
    }
    if (this.open && ev.key === "Tab" && (this.dropdownMenu.nativeElement.contains(ev.target) || ev.target === this.input.nativeElement)) {
      this.closeDropdown();
    }
    if (this.open && ev.key === "Tab" && ev.shiftKey) {
      this.closeDropdown();
    }
  }
  /*
   * no-op method for null event listeners, and other no op calls
   */
  _noop() {
  }
  /*
   * propagates the value provided from ngModel
   */
  writeValue(value) {
    if (this.type === "single") {
      if (this.itemValueKey) {
        const newValue = Object.assign({}, this.view.getListItems().find((item) => item[this.itemValueKey] === value));
        newValue.selected = true;
        this.view.propagateSelected([newValue]);
      } else {
        this.view.propagateSelected([value || ""]);
      }
      this.showClearButton = !!(value && this.view.getSelected().length);
    } else {
      if (this.itemValueKey) {
        let newValues = [];
        for (const v of value ?? []) {
          for (const item of this.view.getListItems()) {
            if (item[this.itemValueKey] === v) {
              newValues.push(Object.assign({}, item, {
                selected: true
              }));
            }
          }
        }
        this.view.propagateSelected(newValues);
      } else {
        this.view.propagateSelected(value ? value : [""]);
      }
    }
    this.updateSelected();
  }
  onBlur() {
    this.onTouchedCallback();
  }
  registerOnChange(fn) {
    this.propagateChangeCallback = fn;
  }
  registerOnTouched(fn) {
    this.onTouchedCallback = fn;
  }
  /**
   * `ControlValueAccessor` method to programmatically disable the combobox.
   *
   * ex: `this.formGroup.get("myCoolCombobox").disable();`
   */
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  /**
   * Called by `n-pill-input` when the selected pills have changed.
   */
  updatePills() {
    this.pills = this.view.getSelected() || [];
    this.checkForReorder();
  }
  clearSelected(event) {
    this.items = this.items.map((item) => {
      if (!item.disabled) {
        item.selected = false;
      }
      return item;
    });
    this.view.items = this.items;
    this.updatePills();
    const selected = this.view.getSelected();
    if (this.itemValueKey && selected) {
      const values = selected.map((item) => item[this.itemValueKey]);
      this.propagateChangeCallback(values);
    } else {
      this.propagateChangeCallback(selected);
    }
    this.selected.emit(selected);
    this.clear.emit(event);
  }
  /**
   * Closes the dropdown and emits the close event.
   */
  closeDropdown() {
    this.open = false;
    this.checkForReorder();
    this.close.emit();
    if (!this.appendInline) {
      this._appendToDropdown();
    }
    document.removeEventListener("click", this.outsideClick, true);
  }
  /**
   * Opens the dropdown.
   */
  openDropdown() {
    if (this.disabled || this.readonly) {
      return;
    }
    this.open = true;
    this._dropUp = false;
    if (!this.appendInline) {
      this._appendToBody();
    }
    document.addEventListener("click", this.outsideClick, true);
    setTimeout(() => {
      if (this.dropUp === null || this.dropUp === void 0) {
        this._dropUp = this._shouldDropUp();
      }
    }, 0);
  }
  /**
   * Toggles the dropdown.
   */
  toggleDropdown() {
    if (this.open) {
      this.closeDropdown();
    } else {
      this.openDropdown();
    }
  }
  /**
   * Sets the list group filter, and manages single select item selection.
   */
  onSearch(searchString, shouldEmitSearch = true) {
    if (shouldEmitSearch) {
      this.search.emit(searchString);
    }
    this.showClearButton = !!searchString;
    this.view.filterBy(searchString);
    if (searchString !== "") {
      if (!this.open) {
        this.openDropdown();
      }
    } else {
      this.selectedValue = "";
      if (this.type === "multi" && (this.selectionFeedback === "top" || this.selectionFeedback === "top-after-reopen")) {
        this.view.reorderSelected();
      }
    }
    if (this.type === "single") {
      const matches = this.view.getListItems().some((item) => item.content.toLowerCase().includes(searchString.toLowerCase()));
      if (!matches) {
        const selected = this.view.getSelected();
        if (!selected || !selected[0]) {
          this.view.filterBy(searchString);
        }
      }
    }
  }
  /**
   * Intended to be used to add items to the list.
   */
  onSubmit(event) {
    this.submit.emit({
      items: this.view.getListItems(),
      index: 0,
      value: {
        content: event.target.value,
        selected: false
      }
    });
  }
  clearInput(event) {
    event.stopPropagation();
    event.preventDefault();
    if (this.disabled || this.readonly) {
      return;
    }
    if (this.type === "single") {
      this.clearSelected(event);
      this.closeDropdown();
    }
    this.selectedValue = "";
    this.input.nativeElement.value = "";
    this.showClearButton = false;
    this.input.nativeElement.focus();
    this.onSearch(this.input.nativeElement.value);
  }
  isTemplate(value) {
    return value instanceof TemplateRef;
  }
  /**
   * Handles keyboard events so users are controlling the `Dropdown` instead of unintentionally controlling outside elements.
   */
  _keyboardNav(event) {
    if (event.key === "Escape" && this.open) {
      event.stopImmediatePropagation();
    }
    if (event.key === "Escape") {
      event.preventDefault();
      this.closeDropdown();
      this.input.nativeElement.focus();
    } else if (this.open && event.key === "Tab") {
      this.input.nativeElement.focus();
      this.input.nativeElement.dispatchEvent(new KeyboardEvent("keydown", {
        bubbles: true,
        cancelable: true,
        key: "Tab"
      }));
      this.closeDropdown();
    }
  }
  /**
   * Creates the `Dropdown` list as an element that is appended to the DOM body.
   */
  _appendToBody() {
    this.dropdownService.appendToBody(this.listbox.nativeElement, this.dropdownMenu.nativeElement, `${this.elementRef.nativeElement.className}${this.open ? " cds--list-box--expanded" : ""}`);
    this.dropdownMenu.nativeElement.addEventListener("keydown", this.keyboardNav, true);
  }
  /**
   * Creates the `Dropdown` list appending it to the dropdown parent object instead of the body.
   */
  _appendToDropdown() {
    this.dropdownService.appendToDropdown(this.elementRef.nativeElement);
    this.dropdownMenu.nativeElement.removeEventListener("keydown", this.keyboardNav, true);
  }
  /**
   * Detects whether or not the `Dropdown` list is visible within all scrollable parents.
   * This can be overridden by passing in a value to the `dropUp` input.
   */
  _shouldDropUp() {
    const menu = this.dropdownMenu && this.dropdownMenu.nativeElement.querySelector(".cds--list-box__menu");
    const menuRect = menu && menu.getBoundingClientRect();
    if (menu && menuRect) {
      const scrollableParents = getScrollableParents(menu);
      return scrollableParents.reduce((shouldDropUp, parent) => {
        const parentRect = parent.getBoundingClientRect();
        const isBelowParent = !(menuRect.bottom <= parentRect.bottom);
        return shouldDropUp || isBelowParent;
      }, false);
    }
    return false;
  }
  /**
   * Handles clicks outside of the `Dropdown` list.
   */
  _outsideClick(event) {
    if (!this.elementRef.nativeElement.contains(event.target) && // if we're appendToBody the list isn't within the _elementRef,
    // so we've got to check if our target is possibly in there too.
    !this.dropdownMenu.nativeElement.contains(event.target)) {
      this.closeDropdown();
    }
  }
  handleFocus(event) {
    this._isFocused = event.type === "focus";
  }
  updateSelected() {
    const selected = this.view.getSelected();
    if (this.type === "multi") {
      this.updatePills();
    } else if (selected) {
      const value = selected[0] ? selected[0].content : "";
      const changeCallbackValue = selected[0] ? selected[0] : "";
      this.selectedValue = value;
      this.showClearButton = !!value;
    }
  }
  checkForReorder() {
    const topAfterReopen = !this.open && this.selectionFeedback === "top-after-reopen";
    if (this.type === "multi" && (topAfterReopen || this.selectionFeedback === "top")) {
      this.view.reorderSelected(true);
    }
  }
};
ComboBox.comboBoxCount = 0;
ComboBox.ɵfac = function ComboBox_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ComboBox)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(DropdownService), ɵɵdirectiveInject(I18n));
};
ComboBox.ɵcmp = ɵɵdefineComponent({
  type: ComboBox,
  selectors: [["cds-combo-box"], ["ibm-combo-box"]],
  contentQueries: function ComboBox_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, AbstractDropdownView, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.view = _t.first);
    }
  },
  viewQuery: function ComboBox_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c011, 5);
      ɵɵviewQuery(_c110, 7);
      ɵɵviewQuery(_c28, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dropdownMenu = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.input = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.listbox = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function ComboBox_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("keydown", function ComboBox_keydown_HostBindingHandler($event) {
        return ctx.hostkeys($event);
      });
    }
    if (rf & 2) {
      ɵɵclassProp("cds--list-box__wrapper", ctx.hostClass);
    }
  },
  inputs: {
    placeholder: "placeholder",
    openMenuAria: "openMenuAria",
    closeMenuAria: "closeMenuAria",
    clearSelectionsTitle: "clearSelectionsTitle",
    clearSelectionsAria: "clearSelectionsAria",
    clearSelectionTitle: "clearSelectionTitle",
    clearSelectionAria: "clearSelectionAria",
    id: "id",
    labelId: "labelId",
    items: "items",
    type: "type",
    size: "size",
    itemValueKey: "itemValueKey",
    label: "label",
    hideLabel: "hideLabel",
    helperText: "helperText",
    appendInline: "appendInline",
    invalid: "invalid",
    invalidText: "invalidText",
    warn: "warn",
    warnText: "warnText",
    maxLength: "maxLength",
    theme: "theme",
    selectionFeedback: "selectionFeedback",
    autocomplete: "autocomplete",
    dropUp: "dropUp",
    disabled: "disabled",
    readonly: "readonly",
    fluid: "fluid"
  },
  outputs: {
    selected: "selected",
    submit: "submit",
    close: "close",
    search: "search",
    clear: "clear"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: ComboBox,
    multi: true
  }]), ɵɵNgOnChangesFeature],
  ngContentSelectors: _c35,
  decls: 20,
  vars: 49,
  consts: [["listbox", ""], ["input", ""], ["dropdownMenu", ""], [1, "cds--list-box__wrapper", 3, "ngClass"], ["class", "cds--label", 3, "for", "id", "ngClass", 4, "ngIf"], [1, "cds--list-box", "cds--combo-box", 3, "ngClass"], [1, "cds--list-box__field", 3, "click", "blur"], ["class", "cds--tag cds--tag--filter cds--tag--high-contrast", 3, "ngClass", 4, "ngIf"], ["type", "text", "autocomplete", "off", "role", "combobox", "tabindex", "0", "aria-haspopup", "listbox", 1, "cds--text-input", 3, "input", "focus", "blur", "keydown.enter", "disabled", "readOnly", "value", "ngClass", "id", "placeholder"], ["cdsIcon", "warning--filled", "size", "16", "class", "cds--list-box__invalid-icon", 4, "ngIf"], ["cdsIcon", "warning--alt--filled", "size", "16", "class", "cds--list-box__invalid-icon cds--list-box__invalid-icon--warning", 4, "ngIf"], ["role", "button", "class", "cds--list-box__selection", "tabindex", "0", 3, "title", "keyup.enter", "click", "blur", 4, "ngIf"], ["type", "button", "role", "button", "tabindex", "-1", 1, "cds--list-box__menu-icon", 3, "title", "ngClass"], ["cdsIcon", "chevron--down", "size", "16"], [3, "ngClass"], [4, "ngIf"], ["class", "cds--list-box__divider", 4, "ngIf"], ["class", "cds--form__helper-text", 3, "ngClass", 4, "ngIf"], ["class", "cds--form-requirement", 4, "ngIf"], [1, "cds--label", 3, "for", "id", "ngClass"], [3, "ngTemplateOutlet"], [1, "cds--tag", "cds--tag--filter", "cds--tag--high-contrast", 3, "ngClass"], [1, "cds--tag__label"], ["type", "button", "tabindex", "0", 1, "cds--tag__close-icon", 3, "click", "blur", "keydown.enter", "title", "disabled"], ["focusable", "false", "preserveAspectRatio", "xMidYMid meet", "role", "img", "xmlns", "http://www.w3.org/2000/svg", "width", "16", "height", "16", "viewBox", "0 0 16 16", "aria-hidden", "true", 2, "will-change", "transform"], ["d", "M12 4.7l-.7-.7L8 7.3 4.7 4l-.7.7L7.3 8 4 11.3l.7.7L8 8.7l3.3 3.3.7-.7L8.7 8z"], ["cdsIcon", "warning--filled", "size", "16", 1, "cds--list-box__invalid-icon"], ["cdsIcon", "warning--alt--filled", "size", "16", 1, "cds--list-box__invalid-icon", "cds--list-box__invalid-icon--warning"], ["role", "button", "tabindex", "0", 1, "cds--list-box__selection", 3, "keyup.enter", "click", "blur", "title"], ["cdsIcon", "close", "size", "16"], [1, "cds--list-box__divider"], [1, "cds--form__helper-text", 3, "ngClass"], [1, "cds--form-requirement"]],
  template: function ComboBox_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 3);
      ɵɵtemplate(1, ComboBox_label_1_Template, 3, 8, "label", 4);
      ɵɵelementStart(2, "div", 5, 0)(4, "div", 6);
      ɵɵlistener("click", function ComboBox_Template_div_click_4_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.toggleDropdown());
      })("blur", function ComboBox_Template_div_blur_4_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onBlur());
      });
      ɵɵtemplate(5, ComboBox_div_5_Template, 6, 7, "div", 7);
      ɵɵelementStart(6, "input", 8, 1);
      ɵɵlistener("input", function ComboBox_Template_input_input_6_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onSearch($event.target.value));
      })("focus", function ComboBox_Template_input_focus_6_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.fluid ? ctx.handleFocus($event) : null);
      })("blur", function ComboBox_Template_input_blur_6_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.fluid ? ctx.handleFocus($event) : ctx.onBlur());
      })("keydown.enter", function ComboBox_Template_input_keydown_enter_6_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onSubmit($event));
      });
      ɵɵelementEnd();
      ɵɵtemplate(8, ComboBox__svg_svg_8_Template, 1, 0, "svg", 9)(9, ComboBox__svg_svg_9_Template, 1, 0, "svg", 10)(10, ComboBox_div_10_Template, 2, 2, "div", 11);
      ɵɵelementStart(11, "button", 12);
      ɵɵnamespaceSVG();
      ɵɵelement(12, "svg", 13);
      ɵɵelementEnd()();
      ɵɵnamespaceHTML();
      ɵɵelementStart(13, "div", 14, 2);
      ɵɵtemplate(15, ComboBox_ng_content_15_Template, 1, 0, "ng-content", 15);
      ɵɵelementEnd()();
      ɵɵtemplate(16, ComboBox_hr_16_Template, 1, 0, "hr", 16)(17, ComboBox_div_17_Template, 3, 5, "div", 17)(18, ComboBox_div_18_Template, 3, 2, "div", 18)(19, ComboBox_div_19_Template, 3, 2, "div", 18);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngClass", ɵɵpureFunction3(28, _c44, ctx.fluid, ctx.fluid && ctx.invalid, ctx.fluid && ctx._isFocused));
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.label);
      ɵɵadvance();
      ɵɵproperty("ngClass", ɵɵpureFunctionV(32, _c53, [ctx.type === "multi", ctx.theme === "light", ctx.open, ctx.size === "sm", ctx.size === "md", ctx.size === "lg", ctx.disabled, ctx.readonly, ctx.warn, ctx.invalid]));
      ɵɵattribute("data-invalid", ctx.invalid ? true : null);
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.type === "multi" && ctx.pills.length > 0);
      ɵɵadvance();
      ɵɵproperty("disabled", ctx.disabled)("readOnly", ctx.readonly)("value", ctx.selectedValue)("ngClass", ɵɵpureFunction1(43, _c63, !ctx.showClearButton))("id", ctx.id)("placeholder", ctx.placeholder);
      ɵɵattribute("aria-labelledby", ctx.labelId)("aria-expanded", ctx.open)("maxlength", ctx.maxLength)("aria-controls", ctx.open ? ctx.view == null ? null : ctx.view.listId : null)("aria-autocomplete", ctx.autocomplete);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.invalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.invalid && ctx.warn);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showClearButton);
      ɵɵadvance();
      ɵɵproperty("title", ctx.open ? ctx.closeMenuAria : ctx.openMenuAria)("ngClass", ɵɵpureFunction1(45, _c72, ctx.open));
      ɵɵattribute("aria-label", ctx.open ? ctx.closeMenuAria : ctx.openMenuAria);
      ɵɵadvance(2);
      ɵɵproperty("ngClass", ɵɵpureFunction1(47, _c82, ctx.dropUp !== null && ctx.dropUp !== void 0 ? ctx.dropUp : ctx._dropUp));
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.open);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.fluid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.helperText && !ctx.invalid && !ctx.warn && !ctx.fluid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.invalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.invalid && ctx.warn);
    }
  },
  dependencies: [NgClass, NgIf, NgTemplateOutlet, IconDirective],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ComboBox, [{
    type: Component,
    args: [{
      selector: "cds-combo-box, ibm-combo-box",
      template: `
		<div
			class="cds--list-box__wrapper"
			[ngClass]="{
				'cds--list-box__wrapper--fluid': fluid,
				'cds--list-box__wrapper--fluid--invalid': fluid && invalid,
				'cds--list-box__wrapper--fluid--focus': fluid && _isFocused
			}">
			<label
				*ngIf="label"
				[for]="id"
				[id]="labelId"
				class="cds--label"
				[ngClass]="{
					'cds--label--disabled': disabled,
					'cds--visually-hidden': hideLabel
				}">
				<ng-container *ngIf="!isTemplate(label)">{{label}}</ng-container>
				<ng-template *ngIf="isTemplate(label)" [ngTemplateOutlet]="label"></ng-template>
			</label>
			<div
				#listbox
				[ngClass]="{
					'cds--multi-select cds--multi-select--filterable': type === 'multi',
					'cds--list-box--light': theme === 'light',
					'cds--list-box--expanded': open,
					'cds--list-box--sm': size === 'sm',
					'cds--list-box--md': size === 'md',
					'cds--list-box--lg': size === 'lg',
					'cds--list-box--disabled': disabled,
					'cds--combo-box--readonly': readonly,
					'cds--combo-box--warning cds--list-box--warning': warn,
					'cds--list-box--invalid': invalid
				}"
				class="cds--list-box cds--combo-box"
				[attr.data-invalid]="(invalid ? true : null)">
				<div
					class="cds--list-box__field"
					(click)="toggleDropdown()"
					(blur)="onBlur()">
					<div
						*ngIf="type === 'multi' && pills.length > 0"
						class="cds--tag cds--tag--filter cds--tag--high-contrast"
						[ngClass]="{'cds--tag--disabled': disabled || readonly}">
						<span class="cds--tag__label">{{ pills.length }}</span>
						<button
							type="button"
							(click)="clearSelected($event)"
							(blur)="onBlur()"
							(keydown.enter)="clearSelected($event)"
							class="cds--tag__close-icon"
							tabindex="0"
							[title]="clearSelectionsTitle"
							[disabled]="disabled || readonly"
							[attr.aria-label]="clearSelectionAria">
							<svg
								focusable="false"
								preserveAspectRatio="xMidYMid meet"
								style="will-change: transform;"
								role="img"
								xmlns="http://www.w3.org/2000/svg"
								width="16"
								height="16"
								viewBox="0 0 16 16"
								aria-hidden="true">
								<path d="M12 4.7l-.7-.7L8 7.3 4.7 4l-.7.7L7.3 8 4 11.3l.7.7L8 8.7l3.3 3.3.7-.7L8.7 8z"></path>
							</svg>
						</button>
					</div>
					<input
						#input
						type="text"
						autocomplete="off"
						role="combobox"
						[disabled]="disabled"
						[readOnly]="readonly"
						(input)="onSearch($event.target.value)"
						(focus)="fluid ? handleFocus($event) : null"
						(blur)="fluid ? handleFocus($event) : onBlur()"
						(keydown.enter)="onSubmit($event)"
						[value]="selectedValue"
						class="cds--text-input"
						[ngClass]="{'cds--text-input--empty': !showClearButton}"
						tabindex="0"
						[id]="id"
						[attr.aria-labelledby]="labelId"
						[attr.aria-expanded]="open"
						aria-haspopup="listbox"
						[attr.maxlength]="maxLength"
						[attr.aria-controls]="open ? view?.listId : null"
						[attr.aria-autocomplete]="autocomplete"
						[placeholder]="placeholder"/>
					<svg
						*ngIf="invalid"
						cdsIcon="warning--filled"
						size="16"
						class="cds--list-box__invalid-icon">
					</svg>
					<svg
						*ngIf="!invalid && warn"
						cdsIcon="warning--alt--filled"
						size="16"
						class="cds--list-box__invalid-icon cds--list-box__invalid-icon--warning">
					</svg>
					<div
						*ngIf="showClearButton"
						role="button"
						class="cds--list-box__selection"
						tabindex="0"
						[attr.aria-label]="clearSelectionAria"
						[title]="clearSelectionTitle"
						(keyup.enter)="clearInput($event)"
						(click)="clearInput($event)"
						(blur)="onBlur()">
						<svg cdsIcon="close" size="16"></svg>
					</div>
					<button
						type="button"
						role="button"
						class="cds--list-box__menu-icon"
						tabindex="-1"
						[title]="open ? closeMenuAria : openMenuAria"
						[attr.aria-label]="open ? closeMenuAria : openMenuAria"
						[ngClass]="{'cds--list-box__menu-icon--open': open}">
						<svg cdsIcon="chevron--down" size="16"></svg>
					</button>
				</div>
				<div
					#dropdownMenu
					[ngClass]="{
						'cds--list-box--up': this.dropUp !== null && this.dropUp !== undefined ? dropUp : _dropUp
					}">
					<ng-content *ngIf="open"></ng-content>
				</div>
			</div>
			<hr *ngIf="fluid" class="cds--list-box__divider" />
			<div
				*ngIf="helperText && !invalid && !warn && !fluid"
				class="cds--form__helper-text"
				[ngClass]="{'cds--form__helper-text--disabled': disabled}">
				<ng-container *ngIf="!isTemplate(helperText)">{{helperText}}</ng-container>
				<ng-template *ngIf="isTemplate(helperText)" [ngTemplateOutlet]="helperText"></ng-template>
			</div>
			<div *ngIf="invalid" class="cds--form-requirement">
				<ng-container *ngIf="!isTemplate(invalidText)">{{ invalidText }}</ng-container>
				<ng-template *ngIf="isTemplate(invalidText)" [ngTemplateOutlet]="invalidText"></ng-template>
			</div>
			<div *ngIf="!invalid && warn" class="cds--form-requirement">
				<ng-container *ngIf="!isTemplate(warnText)">{{warnText}}</ng-container>
				<ng-template *ngIf="isTemplate(warnText)" [ngTemplateOutlet]="warnText"></ng-template>
			</div>
		</div>
	`,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: ComboBox,
        multi: true
      }]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: DropdownService
    }, {
      type: I18n
    }];
  }, {
    placeholder: [{
      type: Input
    }],
    openMenuAria: [{
      type: Input
    }],
    closeMenuAria: [{
      type: Input
    }],
    clearSelectionsTitle: [{
      type: Input
    }],
    clearSelectionsAria: [{
      type: Input
    }],
    clearSelectionTitle: [{
      type: Input
    }],
    clearSelectionAria: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    labelId: [{
      type: Input
    }],
    items: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    itemValueKey: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    hideLabel: [{
      type: Input
    }],
    helperText: [{
      type: Input
    }],
    appendInline: [{
      type: Input
    }],
    invalid: [{
      type: Input
    }],
    invalidText: [{
      type: Input
    }],
    warn: [{
      type: Input
    }],
    warnText: [{
      type: Input
    }],
    maxLength: [{
      type: Input
    }],
    theme: [{
      type: Input
    }],
    selectionFeedback: [{
      type: Input
    }],
    autocomplete: [{
      type: Input
    }],
    dropUp: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }],
    fluid: [{
      type: Input
    }],
    selected: [{
      type: Output
    }],
    submit: [{
      type: Output
    }],
    close: [{
      type: Output
    }],
    search: [{
      type: Output
    }],
    clear: [{
      type: Output
    }],
    view: [{
      type: ContentChild,
      args: [AbstractDropdownView, {
        static: true
      }]
    }],
    dropdownMenu: [{
      type: ViewChild,
      args: ["dropdownMenu"]
    }],
    input: [{
      type: ViewChild,
      args: ["input", {
        static: true
      }]
    }],
    listbox: [{
      type: ViewChild,
      args: ["listbox", {
        static: true
      }]
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.cds--list-box__wrapper"]
    }],
    hostkeys: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }]
  });
})();
var ComboBoxModule = class {
};
ComboBoxModule.ɵfac = function ComboBoxModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ComboBoxModule)();
};
ComboBoxModule.ɵmod = ɵɵdefineNgModule({
  type: ComboBoxModule,
  declarations: [ComboBox],
  imports: [CommonModule, DropdownModule, I18nModule, UtilsModule, IconModule],
  exports: [ComboBox, DropdownModule]
});
ComboBoxModule.ɵinj = ɵɵdefineInjector({
  providers: [DropdownService],
  imports: [CommonModule, DropdownModule, I18nModule, UtilsModule, IconModule, DropdownModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ComboBoxModule, [{
    type: NgModule,
    args: [{
      declarations: [ComboBox],
      exports: [ComboBox, DropdownModule],
      imports: [CommonModule, DropdownModule, I18nModule, UtilsModule, IconModule],
      providers: [DropdownService]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-contained-list.mjs
var _c012 = ["*"];
var _c111 = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) => ({
  "cds--contained-list--inset-rulers": a0,
  "cds--contained-list--on-page": a1,
  "cds--contained-list--disclosed": a2,
  "cds--contained-list--sm": a3,
  "cds--contained-list--md": a4,
  "cds--contained-list--lg": a5,
  "cds--contained-list--xl": a6,
  "cds--layout--size-sm": a7,
  "cds--layout--size-md": a8,
  "cds--layout--size-lg": a9,
  "cds--layout--size-xl": a10
});
var _c29 = (a0) => ({
  $implicit: a0
});
function ContainedList_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.label);
  }
}
function ContainedList_4_ng_template_0_Template(rf, ctx) {
}
function ContainedList_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ContainedList_4_ng_template_0_Template, 0, 0, "ng-template", 6);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.label);
  }
}
function ContainedList_div_5_ng_template_1_Template(rf, ctx) {
}
function ContainedList_div_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 7);
    ɵɵtemplate(1, ContainedList_div_5_ng_template_1_Template, 0, 0, "ng-template", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.action)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c29, ctx_r0.actionData));
  }
}
var _c36 = [[["", "cdsContainedListItemButton", ""], ["", "ibmContainedListItemButton", ""]], "*"];
var _c45 = ["[cdsContainedListItemButton],[ibmContainedListItemButton]", "*"];
function ContainedListItem_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "button", 2);
    ɵɵlistener("click", function ContainedListItem_ng_container_0_Template_button_click_1_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onClick());
    });
    ɵɵprojection(2);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("disabled", ctx_r1.disabled);
  }
}
function ContainedListItem_ng_container_1_div_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵnamespaceSVG();
    ɵɵelement(1, "svg", 6);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ibmIcon", ctx_r1.icon);
  }
}
function ContainedListItem_ng_container_1_div_2_2_ng_template_0_Template(rf, ctx) {
}
function ContainedListItem_ng_container_1_div_2_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ContainedListItem_ng_container_1_div_2_2_ng_template_0_Template, 0, 0, "ng-template", 7);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.icon);
  }
}
function ContainedListItem_ng_container_1_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 5);
    ɵɵtemplate(1, ContainedListItem_ng_container_1_div_2_ng_container_1_Template, 2, 1, "ng-container", 0)(2, ContainedListItem_ng_container_1_div_2_2_Template, 1, 1, null, 0);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.isTemplate(ctx_r1.icon));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.isTemplate(ctx_r1.icon));
  }
}
function ContainedListItem_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 3);
    ɵɵtemplate(2, ContainedListItem_ng_container_1_div_2_Template, 3, 2, "div", 4);
    ɵɵprojection(3, 1);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r1.icon);
  }
}
function ContainedListItem_div_2_ng_template_1_Template(rf, ctx) {
}
function ContainedListItem_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 8);
    ɵɵtemplate(1, ContainedListItem_div_2_ng_template_1_Template, 0, 0, "ng-template", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.action)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c29, ctx_r1.actionData));
  }
}
var ContainedListSize;
(function(ContainedListSize2) {
  ContainedListSize2["Small"] = "sm";
  ContainedListSize2["Medium"] = "md";
  ContainedListSize2["Large"] = "lg";
  ContainedListSize2["ExtraLarge"] = "xl";
})(ContainedListSize || (ContainedListSize = {}));
var ContainedListKind;
(function(ContainedListKind2) {
  ContainedListKind2["OnPage"] = "on-page";
  ContainedListKind2["Disclosed"] = "disclosed";
})(ContainedListKind || (ContainedListKind = {}));
var ContainedList = class _ContainedList {
  constructor() {
    this.isInset = false;
    this.kind = ContainedListKind.OnPage;
    this.size = ContainedListSize.Large;
    this.labelId = `contained-list-${_ContainedList.count++}-header`;
    this.ContainedListSize = ContainedListSize;
    this.ContainedListKind = ContainedListKind;
  }
  isTemplate(value) {
    return value instanceof TemplateRef;
  }
};
ContainedList.count = 0;
ContainedList.ɵfac = function ContainedList_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ContainedList)();
};
ContainedList.ɵcmp = ɵɵdefineComponent({
  type: ContainedList,
  selectors: [["cds-contained-list"], ["ibm-contained-list"]],
  inputs: {
    action: "action",
    actionData: "actionData",
    isInset: "isInset",
    kind: "kind",
    label: "label",
    size: "size",
    labelId: "labelId"
  },
  standalone: false,
  ngContentSelectors: _c012,
  decls: 8,
  vars: 18,
  consts: [[1, "cds--contained-list", 3, "ngClass"], [1, "cds--contained-list__header"], [1, "cds--contained-list__label", 3, "id"], [4, "ngIf"], ["class", "cds--contained-list__action", 4, "ngIf"], ["role", "list"], [3, "ngTemplateOutlet"], [1, "cds--contained-list__action"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
  template: function ContainedList_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 0)(1, "div", 1)(2, "div", 2);
      ɵɵtemplate(3, ContainedList_ng_container_3_Template, 2, 1, "ng-container", 3)(4, ContainedList_4_Template, 1, 1, null, 3);
      ɵɵelementEnd();
      ɵɵtemplate(5, ContainedList_div_5_Template, 2, 4, "div", 4);
      ɵɵelementEnd();
      ɵɵelementStart(6, "div", 5);
      ɵɵprojection(7);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵproperty("ngClass", ɵɵpureFunctionV(6, _c111, [ctx.isInset, ctx.kind === ctx.ContainedListKind.OnPage, ctx.kind === ctx.ContainedListKind.Disclosed, ctx.size === ctx.ContainedListSize.Small, ctx.size === ctx.ContainedListSize.Medium, ctx.size === ctx.ContainedListSize.Large, ctx.size === ctx.ContainedListSize.ExtraLarge, ctx.size === ctx.ContainedListSize.Small, ctx.size === ctx.ContainedListSize.Medium, ctx.size === ctx.ContainedListSize.Large, ctx.size === ctx.ContainedListSize.ExtraLarge]));
      ɵɵadvance(2);
      ɵɵproperty("id", ctx.labelId);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.isTemplate(ctx.label));
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.isTemplate(ctx.label));
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.action);
      ɵɵadvance();
      ɵɵattribute("aria-labelledby", ctx.labelId);
    }
  },
  dependencies: [NgClass, NgIf, NgTemplateOutlet],
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContainedList, [{
    type: Component,
    args: [{
      selector: "cds-contained-list, ibm-contained-list",
      template: `
		<div
			class="cds--contained-list"
			[ngClass]="{
				'cds--contained-list--inset-rulers': isInset,
				'cds--contained-list--on-page': kind === ContainedListKind.OnPage,
				'cds--contained-list--disclosed': kind === ContainedListKind.Disclosed,
				'cds--contained-list--sm': size === ContainedListSize.Small,
				'cds--contained-list--md': size === ContainedListSize.Medium,
				'cds--contained-list--lg': size === ContainedListSize.Large,
				'cds--contained-list--xl': size === ContainedListSize.ExtraLarge,
				'cds--layout--size-sm': size === ContainedListSize.Small,
				'cds--layout--size-md': size === ContainedListSize.Medium,
				'cds--layout--size-lg': size === ContainedListSize.Large,
				'cds--layout--size-xl': size === ContainedListSize.ExtraLarge
			}">
			<div class="cds--contained-list__header">
				<div [id]="labelId" class="cds--contained-list__label">
					<ng-container *ngIf="!isTemplate(label)">{{ label }}</ng-container>
					<ng-template *ngIf="isTemplate(label)" [ngTemplateOutlet]="label"></ng-template>
				</div>

				<div class="cds--contained-list__action" *ngIf="action">
					<ng-template [ngTemplateOutlet]="action" [ngTemplateOutletContext]="{ $implicit: actionData }"></ng-template>
				</div>
			</div>
			<div role="list" [attr.aria-labelledby]="labelId">
				<ng-content></ng-content>
			</div>
		</div>
	`,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    action: [{
      type: Input
    }],
    actionData: [{
      type: Input
    }],
    isInset: [{
      type: Input
    }],
    kind: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    labelId: [{
      type: Input
    }]
  });
})();
var ContainedListItem = class {
  constructor() {
    this.disabled = false;
    this.click = new EventEmitter();
    this.itemClass = true;
    this.role = "listitem";
  }
  /**
   * Host binding clickable item class.
   */
  get itemClickableClass() {
    return this.clickable;
  }
  /**
   * Host binding item with icon class.
   */
  get itemWithIconClass() {
    return !!this.icon;
  }
  onClick() {
    this.click.emit();
  }
  isTemplate(value) {
    return value instanceof TemplateRef;
  }
};
ContainedListItem.ɵfac = function ContainedListItem_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ContainedListItem)();
};
ContainedListItem.ɵcmp = ɵɵdefineComponent({
  type: ContainedListItem,
  selectors: [["cds-contained-list-item"], ["ibm-contained-list-item"]],
  hostVars: 7,
  hostBindings: function ContainedListItem_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", ctx.role);
      ɵɵclassProp("cds--contained-list-item", ctx.itemClass)("cds--contained-list-item--clickable", ctx.itemClickableClass)("cds--contained-list-item--with-icon", ctx.itemWithIconClass);
    }
  },
  inputs: {
    action: "action",
    actionData: "actionData",
    disabled: "disabled",
    clickable: "clickable",
    icon: "icon"
  },
  outputs: {
    click: "click"
  },
  standalone: false,
  ngContentSelectors: _c45,
  decls: 3,
  vars: 3,
  consts: [[4, "ngIf"], ["class", "cds--contained-list-item__action", 4, "ngIf"], ["type", "button", 1, "cds--contained-list-item__content", 3, "click", "disabled"], [1, "cds--contained-list-item__content"], ["class", "cds--contained-list-item__icon", 4, "ngIf"], [1, "cds--contained-list-item__icon"], ["size", "16", 3, "ibmIcon"], [3, "ngTemplateOutlet"], [1, "cds--contained-list-item__action"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
  template: function ContainedListItem_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c36);
      ɵɵtemplate(0, ContainedListItem_ng_container_0_Template, 3, 1, "ng-container", 0)(1, ContainedListItem_ng_container_1_Template, 4, 1, "ng-container", 0)(2, ContainedListItem_div_2_Template, 2, 4, "div", 1);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.clickable);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.clickable);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.action);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet, IconDirective],
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContainedListItem, [{
    type: Component,
    args: [{
      selector: "cds-contained-list-item, ibm-contained-list-item",
      template: `
		<ng-container *ngIf="clickable">
			<button
				class="cds--contained-list-item__content"
				type="button"
				[disabled]="disabled"
				(click)="onClick()">
				<ng-content select="[cdsContainedListItemButton],[ibmContainedListItemButton]"></ng-content>
			</button>
		</ng-container>
		<ng-container *ngIf="!clickable">
			<div class="cds--contained-list-item__content">
				<div *ngIf="icon" class="cds--contained-list-item__icon">
					<ng-container *ngIf="!isTemplate(icon)"><svg [ibmIcon]="icon" size="16"></svg></ng-container>
					<ng-template *ngIf="isTemplate(icon)" [ngTemplateOutlet]="icon"></ng-template>
				</div>
				<ng-content></ng-content>
			</div>
		</ng-container>
		<div class="cds--contained-list-item__action" *ngIf="action">
			<ng-template [ngTemplateOutlet]="action" [ngTemplateOutletContext]="{ $implicit: actionData }"></ng-template>
		</div>
	`,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    action: [{
      type: Input
    }],
    actionData: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    clickable: [{
      type: Input
    }],
    icon: [{
      type: Input
    }],
    click: [{
      type: Output
    }],
    itemClass: [{
      type: HostBinding,
      args: ["class.cds--contained-list-item"]
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    itemClickableClass: [{
      type: HostBinding,
      args: ["class.cds--contained-list-item--clickable"]
    }],
    itemWithIconClass: [{
      type: HostBinding,
      args: ["class.cds--contained-list-item--with-icon"]
    }]
  });
})();
var ContainedListModule = class {
};
ContainedListModule.ɵfac = function ContainedListModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ContainedListModule)();
};
ContainedListModule.ɵmod = ɵɵdefineNgModule({
  type: ContainedListModule,
  declarations: [ContainedList, ContainedListItem],
  imports: [CommonModule, IconModule],
  exports: [ContainedList, ContainedListItem]
});
ContainedListModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, IconModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContainedListModule, [{
    type: NgModule,
    args: [{
      declarations: [ContainedList, ContainedListItem],
      exports: [ContainedList, ContainedListItem],
      imports: [CommonModule, IconModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-content-switcher.mjs
var _c013 = ["*"];
var _c113 = (a0, a1, a2) => ({
  "cds--content-switcher--sm": a0,
  "cds--content-switcher--md": a1,
  "cds--content-switcher--lg": a2
});
var ContentSwitcherOption = class {
  constructor(renderer, hostElement) {
    this.renderer = renderer;
    this.hostElement = hostElement;
    this.name = "option";
    this.selected = new EventEmitter();
    this.onClick = new EventEmitter();
    this.onFocus = new EventEmitter();
    this.switcherClass = "cds--content-switcher-btn";
    this.selectedClass = false;
    this.role = "tab";
    this.ariaSelected = false;
    this.tabindex = "-1";
    this._active = false;
  }
  /**
   * Used to activate the option. Only one option may be `active` at a time
   */
  set active(value) {
    this._active = value;
    this.selectedClass = value;
    this.ariaSelected = value;
    this.tabindex = value ? "0" : "-1";
  }
  get active() {
    return this._active;
  }
  hostClick(event) {
    this.onClick.emit(event);
    if (this.active) {
      return;
    }
    this.active = true;
    this.selected.emit(true);
  }
  doFocus(event) {
    this.onFocus.emit(event);
    if (this.active) {
      return;
    }
    this.active = true;
    this.selected.emit(true);
  }
  /*
  * encapsulating the content in a span with cds--content-switcher__label class
  * to mimic what is done in the react version
  */
  ngOnInit() {
    const hostNativeElement = this.hostElement.nativeElement;
    const spanWrapper = this.renderer.createElement("span");
    this.renderer.addClass(spanWrapper, "cds--content-switcher__label");
    const hostChildren = [];
    hostNativeElement.childNodes.forEach((node) => hostChildren.push(node));
    hostChildren.forEach((node) => {
      this.renderer.removeChild(hostNativeElement, node);
      this.renderer.appendChild(spanWrapper, node);
    });
    this.renderer.appendChild(hostNativeElement, spanWrapper);
  }
};
ContentSwitcherOption.ɵfac = function ContentSwitcherOption_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ContentSwitcherOption)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
};
ContentSwitcherOption.ɵdir = ɵɵdefineDirective({
  type: ContentSwitcherOption,
  selectors: [["", "cdsContentOption", ""], ["", "ibmContentOption", ""]],
  hostVars: 7,
  hostBindings: function ContentSwitcherOption_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function ContentSwitcherOption_click_HostBindingHandler($event) {
        return ctx.hostClick($event);
      })("focus", function ContentSwitcherOption_focus_HostBindingHandler($event) {
        return ctx.doFocus($event);
      });
    }
    if (rf & 2) {
      ɵɵattribute("role", ctx.role)("aria-selected", ctx.ariaSelected)("tabIndex", ctx.tabindex);
      ɵɵclassMap(ctx.switcherClass);
      ɵɵclassProp("cds--content-switcher--selected", ctx.selectedClass);
    }
  },
  inputs: {
    active: "active",
    name: "name"
  },
  outputs: {
    selected: "selected",
    onClick: "onClick",
    onFocus: "onFocus"
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContentSwitcherOption, [{
    type: Directive,
    args: [{
      selector: "[cdsContentOption], [ibmContentOption]"
    }]
  }], function() {
    return [{
      type: Renderer2
    }, {
      type: ElementRef
    }];
  }, {
    active: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    selected: [{
      type: Output
    }],
    onClick: [{
      type: Output
    }],
    onFocus: [{
      type: Output
    }],
    switcherClass: [{
      type: HostBinding,
      args: ["class"]
    }],
    selectedClass: [{
      type: HostBinding,
      args: ["class.cds--content-switcher--selected"]
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    ariaSelected: [{
      type: HostBinding,
      args: ["attr.aria-selected"]
    }],
    tabindex: [{
      type: HostBinding,
      args: ["attr.tabIndex"]
    }],
    hostClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }],
    doFocus: [{
      type: HostListener,
      args: ["focus", ["$event"]]
    }]
  });
})();
var ContentSwitcher = class {
  constructor(elementRef) {
    this.elementRef = elementRef;
    this.ariaLabel = "content switcher";
    this.size = "md";
    this.selected = new EventEmitter();
  }
  ngAfterViewInit() {
    const firstActive = this.options.find((option) => option.active);
    if (!firstActive) {
      setTimeout(() => this.options.first.active = true);
    }
    this.options.forEach((option) => {
      option.selected.subscribe((_) => {
        const active = option;
        this.options.forEach((option2) => {
          if (option2 !== active) {
            option2.active = false;
          }
        });
        this.selected.emit(active);
      });
    });
  }
  hostkeys(event) {
    const buttonList = Array.from(this.elementRef.nativeElement.querySelectorAll("[cdsContentOption], [ibmContentOption]"));
    switch (event.key) {
      case "ArrowRight":
        event.preventDefault();
        if (!isFocusInLastItem(event, buttonList)) {
          const index = buttonList.findIndex((item) => item === event.target);
          buttonList[index + 1].focus();
        } else {
          buttonList[0].focus();
        }
        break;
      case "ArrowLeft":
        event.preventDefault();
        if (!isFocusInFirstItem(event, buttonList)) {
          const index = buttonList.findIndex((item) => item === event.target);
          buttonList[index - 1].focus();
        } else {
          buttonList[buttonList.length - 1].focus();
        }
        break;
      case "Home":
        event.preventDefault();
        buttonList[0].focus();
        break;
      case "End":
        event.preventDefault();
        buttonList[buttonList.length - 1].focus();
        break;
    }
  }
};
ContentSwitcher.ɵfac = function ContentSwitcher_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ContentSwitcher)(ɵɵdirectiveInject(ElementRef));
};
ContentSwitcher.ɵcmp = ɵɵdefineComponent({
  type: ContentSwitcher,
  selectors: [["cds-content-switcher"], ["ibm-content-switcher"]],
  contentQueries: function ContentSwitcher_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ContentSwitcherOption, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.options = _t);
    }
  },
  hostBindings: function ContentSwitcher_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("keydown", function ContentSwitcher_keydown_HostBindingHandler($event) {
        return ctx.hostkeys($event);
      });
    }
  },
  inputs: {
    ariaLabel: "ariaLabel",
    size: "size"
  },
  outputs: {
    selected: "selected"
  },
  standalone: false,
  ngContentSelectors: _c013,
  decls: 2,
  vars: 6,
  consts: [["role", "tablist", 1, "cds--content-switcher", 3, "ngClass"]],
  template: function ContentSwitcher_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 0);
      ɵɵprojection(1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngClass", ɵɵpureFunction3(2, _c113, ctx.size === "sm", ctx.size === "md", ctx.size === "lg"));
      ɵɵattribute("aria-label", ctx.ariaLabel);
    }
  },
  dependencies: [NgClass],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContentSwitcher, [{
    type: Component,
    args: [{
      selector: "cds-content-switcher, ibm-content-switcher",
      template: `
		<div
			[attr.aria-label]="ariaLabel"
			class="cds--content-switcher"
			[ngClass]="{
				'cds--content-switcher--sm': size === 'sm',
				'cds--content-switcher--md': size === 'md',
				'cds--content-switcher--lg': size === 'lg'
			}"
			role="tablist">
			<ng-content></ng-content>
		</div>
	`
    }]
  }], function() {
    return [{
      type: ElementRef
    }];
  }, {
    ariaLabel: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    selected: [{
      type: Output
    }],
    options: [{
      type: ContentChildren,
      args: [ContentSwitcherOption]
    }],
    hostkeys: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }]
  });
})();
var ContentSwitcherModule = class {
};
ContentSwitcherModule.ɵfac = function ContentSwitcherModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ContentSwitcherModule)();
};
ContentSwitcherModule.ɵmod = ɵɵdefineNgModule({
  type: ContentSwitcherModule,
  declarations: [ContentSwitcher, ContentSwitcherOption],
  imports: [CommonModule],
  exports: [ContentSwitcher, ContentSwitcherOption]
});
ContentSwitcherModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContentSwitcherModule, [{
    type: NgModule,
    args: [{
      declarations: [ContentSwitcher, ContentSwitcherOption],
      exports: [ContentSwitcher, ContentSwitcherOption],
      imports: [CommonModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-context-menu.mjs
var _c014 = ["*"];
function ContextMenuItemComponent__svg_svg_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 7);
  }
}
function ContextMenuItemComponent__svg_svg_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 8);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("cdsIcon", ctx_r0.icon);
  }
}
function ContextMenuItemComponent_ng_container_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.info);
  }
}
function ContextMenuItemComponent__svg_svg_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 9);
  }
}
var ContextMenuDividerComponent = class {
  constructor() {
    this.dividerClass = true;
    this.role = "separator";
  }
};
ContextMenuDividerComponent.ɵfac = function ContextMenuDividerComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ContextMenuDividerComponent)();
};
ContextMenuDividerComponent.ɵcmp = ɵɵdefineComponent({
  type: ContextMenuDividerComponent,
  selectors: [["cds-menu-divider"], ["cds-context-menu-divider"], ["ibm-context-menu-divider"]],
  hostVars: 3,
  hostBindings: function ContextMenuDividerComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", ctx.role);
      ɵɵclassProp("cds--menu-item-divider", ctx.dividerClass);
    }
  },
  standalone: false,
  decls: 0,
  vars: 0,
  template: function ContextMenuDividerComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContextMenuDividerComponent, [{
    type: Component,
    args: [{
      selector: "cds-menu-divider, cds-context-menu-divider, ibm-context-menu-divider",
      template: ""
    }]
  }], null, {
    dividerClass: [{
      type: HostBinding,
      args: ["class.cds--menu-item-divider"]
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }]
  });
})();
var ContextMenuSelectionService = class {
  constructor() {
    this.selectionSubject = new ReplaySubject(1);
    this.value = [];
    this.selectionObservable = this.selectionSubject.asObservable();
  }
  selectRadio(value) {
    if (!value) {
      return;
    }
    this.selectionSubject.next(value);
    this.value = [value];
  }
  selectCheckbox(value) {
    if (!value) {
      return;
    }
    if (this.value.includes(value)) {
      this.value = this.value.filter((v) => v !== value);
    } else {
      this.value.push(value);
    }
    this.selectionSubject.next(this.value);
  }
  selectCheckboxes(value) {
    if (!value) {
      return;
    }
    this.value = value;
    this.selectionSubject.next(value);
  }
};
ContextMenuSelectionService.ɵfac = function ContextMenuSelectionService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ContextMenuSelectionService)();
};
ContextMenuSelectionService.ɵprov = ɵɵdefineInjectable({
  token: ContextMenuSelectionService,
  factory: ContextMenuSelectionService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContextMenuSelectionService, [{
    type: Injectable
  }], function() {
    return [];
  }, null);
})();
var ContextMenuGroupComponent = class {
  constructor(contextMenuSelectionService) {
    this.contextMenuSelectionService = contextMenuSelectionService;
    this.role = "group";
    this.label = null;
    this.value = [];
    this.type = null;
    this.valueChange = new EventEmitter();
    this.subscription = new Subscription();
  }
  get radioGroup() {
    return this.type === "radio";
  }
  get group() {
    return this.type === "checkbox";
  }
  ngOnInit() {
    const {
      selectionObservable
    } = this.contextMenuSelectionService;
    const subscription = selectionObservable.subscribe((value) => {
      this.valueChange.emit(value);
    });
    this.subscription.add(subscription);
  }
  ngOnChanges(changes) {
    if (changes.value) {
      if (this.type === "radio") {
        this.contextMenuSelectionService.selectRadio(changes.value.currentValue);
      }
      if (this.type === "checkbox") {
        this.contextMenuSelectionService.selectCheckboxes(changes.value.currentValue);
      }
    }
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
};
ContextMenuGroupComponent.ɵfac = function ContextMenuGroupComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ContextMenuGroupComponent)(ɵɵdirectiveInject(ContextMenuSelectionService));
};
ContextMenuGroupComponent.ɵcmp = ɵɵdefineComponent({
  type: ContextMenuGroupComponent,
  selectors: [["cds-menu-group"], ["cds-context-menu-group"], ["ibm-context-menu-group"]],
  hostVars: 6,
  hostBindings: function ContextMenuGroupComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", ctx.role)("aria-label", ctx.label);
      ɵɵclassProp("cds--menu-item-radio-group", ctx.radioGroup)("cds--menu-item-group", ctx.group);
    }
  },
  inputs: {
    label: "label",
    value: "value",
    type: "type"
  },
  outputs: {
    valueChange: "valueChange"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([ContextMenuSelectionService]), ɵɵNgOnChangesFeature],
  ngContentSelectors: _c014,
  decls: 1,
  vars: 0,
  template: function ContextMenuGroupComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContextMenuGroupComponent, [{
    type: Component,
    args: [{
      selector: "cds-menu-group, cds-context-menu-group, ibm-context-menu-group",
      template: `
		<ng-content></ng-content>
	`,
      providers: [ContextMenuSelectionService]
    }]
  }], function() {
    return [{
      type: ContextMenuSelectionService
    }];
  }, {
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    radioGroup: [{
      type: HostBinding,
      args: ["class.cds--menu-item-radio-group"]
    }],
    group: [{
      type: HostBinding,
      args: ["class.cds--menu-item-group"]
    }],
    label: [{
      type: HostBinding,
      args: ["attr.aria-label"]
    }, {
      type: Input
    }],
    value: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }]
  });
})();
var ContextMenuComponent = class {
  constructor(elementRef) {
    this.elementRef = elementRef;
    this.open = false;
    this.position = {
      left: 0,
      top: 0
    };
    this.size = "lg";
    this.role = "menu";
    this.tabindex = "-1";
    this.iconClass = false;
  }
  get hostClass() {
    const open2 = this.open ? "cds--menu--open cds--menu--shown" : "";
    return `cds--menu cds--autoalign cds--menu--${this.size} ${open2}`;
  }
  get leftPosition() {
    return this.position.left;
  }
  get topPosition() {
    return this.position.top;
  }
  ngOnChanges(changes) {
    if (changes.open && changes.open.currentValue) {
      this.focusMenu();
    }
  }
  ngAfterViewInit() {
    setTimeout(() => {
      const nativeElement = this.elementRef.nativeElement;
      if (nativeElement) {
        this.iconClass = !!nativeElement.querySelector(".cds--menu-item .cds--menu-item__icon svg");
      }
    });
  }
  focusMenu() {
    setTimeout(() => {
      const list = this.elementRef.nativeElement;
      const firstOption = list.querySelector(".cds--menu-item");
      firstOption.focus();
    });
  }
  handleNavigation(event) {
    const list = this.elementRef.nativeElement;
    const subMenus = Array.from(list.querySelectorAll("cds-context-menu[role=menu]"));
    const menuItems = Array.from(list.querySelectorAll(".cds--menu-item")).filter((menuItem) => !subMenus.some((subMenu) => subMenu.contains(menuItem)));
    const currentIndex = menuItems.findIndex((menuItem) => parseInt(menuItem.getAttribute("tabindex"), 10) === 0);
    const currentMenuItem = menuItems[currentIndex];
    switch (event.key) {
      case "ArrowDown": {
        if (document.activeElement === list) {
          menuItems[0].focus();
        } else {
          if (currentIndex !== -1 && currentIndex < menuItems.length - 1) {
            menuItems[currentIndex + 1].focus();
          }
        }
        break;
      }
      case "ArrowUp": {
        if (document.activeElement === list) {
          menuItems[menuItems.length - 1].focus();
        } else {
          if (currentIndex !== -1 && currentIndex > 0) {
            menuItems[currentIndex - 1].focus();
          }
        }
        break;
      }
      case "ArrowRight": {
        if (currentIndex !== -1 && subMenus.some((subMenu) => currentMenuItem.contains(subMenu))) {
          currentMenuItem.click();
        }
        break;
      }
      case "ArrowLeft": {
        const parent = currentMenuItem.parentElement.closest(".cds--menu-item, .cds--menu-item");
        if (parent) {
          parent.focus();
        }
        break;
      }
    }
  }
};
ContextMenuComponent.ɵfac = function ContextMenuComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ContextMenuComponent)(ɵɵdirectiveInject(ElementRef));
};
ContextMenuComponent.ɵcmp = ɵɵdefineComponent({
  type: ContextMenuComponent,
  selectors: [["cds-menu"], ["cds-context-menu"], ["ibm-context-menu"]],
  hostVars: 10,
  hostBindings: function ContextMenuComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("keydown", function ContextMenuComponent_keydown_HostBindingHandler($event) {
        return ctx.handleNavigation($event);
      });
    }
    if (rf & 2) {
      ɵɵattribute("role", ctx.role)("tabindex", ctx.tabindex);
      ɵɵclassMap(ctx.hostClass);
      ɵɵstyleProp("left", ctx.leftPosition, "px")("top", ctx.topPosition, "px");
      ɵɵclassProp("cds--menu--with-icons", ctx.iconClass);
    }
  },
  inputs: {
    open: "open",
    position: "position",
    size: "size"
  },
  standalone: false,
  features: [ɵɵNgOnChangesFeature],
  ngContentSelectors: _c014,
  decls: 1,
  vars: 0,
  template: function ContextMenuComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  styles: ["[_nghost-%COMP%]{display:block}"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContextMenuComponent, [{
    type: Component,
    args: [{
      selector: "cds-menu, cds-context-menu, ibm-context-menu",
      template: `
			<ng-content></ng-content>
	`,
      styles: [":host{display:block}\n"]
    }]
  }], function() {
    return [{
      type: ElementRef
    }];
  }, {
    open: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class"]
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    tabindex: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    leftPosition: [{
      type: HostBinding,
      args: ["style.left.px"]
    }],
    topPosition: [{
      type: HostBinding,
      args: ["style.top.px"]
    }],
    iconClass: [{
      type: HostBinding,
      args: ["class.cds--menu--with-icons"]
    }],
    handleNavigation: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }]
  });
})();
var ContextMenuItemComponent = class {
  constructor(elementRef, contextMenuSelectionService) {
    this.elementRef = elementRef;
    this.contextMenuSelectionService = contextMenuSelectionService;
    this.optionClass = true;
    this.role = "menuitem";
    this.tabindex = -1;
    this.ariaHasPopup = null;
    this.ariaExpanded = null;
    this.disabled = false;
    this.danger = false;
    this.label = "";
    this.info = "";
    this.type = null;
    this.checked = false;
    this.icon = "";
    this.value = "";
    this.checkedChange = new EventEmitter();
    this.itemClick = new EventEmitter();
    this.hasChildren = false;
    this.selectable = false;
    this.subscriptions = new Subscription();
  }
  get ariaChecked() {
    return this.type === "checkbox" ? this.checked ? true : false : null;
  }
  get ariaDisabled() {
    return this.disabled;
  }
  ngOnInit() {
    switch (this.type) {
      case "checkbox": {
        this.role = "menuitemcheckbox";
        this.selectable = true;
        break;
      }
      case "radio": {
        this.role = "menuitemradio";
        this.selectable = true;
        break;
      }
      default: {
        this.role = "menuitem";
      }
    }
    if (this.type && this.contextMenuSelectionService && this.value) {
      const {
        selectionObservable
      } = this.contextMenuSelectionService;
      const subscription = selectionObservable.subscribe((value) => {
        if (this.type === "radio") {
          this.handleSelection(value === this.value);
        }
        if (this.type === "checkbox") {
          this.handleSelection(value.includes(this.value));
        }
      });
      this.subscriptions.add(subscription);
    }
  }
  ngAfterContentInit() {
    if (this.childContextMenu) {
      this.hasChildren = true;
      this.ariaHasPopup = true;
      this.ariaExpanded = false;
    }
  }
  handleClick(event) {
    event.stopPropagation();
    if (this.hasChildren) {
      this.openSubMenu();
      this.childContextMenu.focusMenu();
    }
    if (this.type) {
      this.handleSelection(!this.checked);
    }
    if (this.contextMenuSelectionService) {
      if (this.type === "radio") {
        this.contextMenuSelectionService.selectRadio(this.value);
      }
      if (this.type === "checkbox") {
        this.contextMenuSelectionService.selectCheckbox(this.value);
      }
    }
    if (!this.disabled) {
      this.itemClick.emit({
        event,
        label: this.label,
        info: this.info,
        value: this.value,
        type: this.type
      });
    }
  }
  handleSelection(selected) {
    this.checked = selected;
    this.checkedChange.emit(this.checked);
  }
  openSubMenu() {
    if (this.childContextMenu) {
      this.childContextMenu.open = true;
      this.ariaExpanded = true;
      const dimensions = this.elementRef.nativeElement.getBoundingClientRect();
      this.childContextMenu.position.left = dimensions.left + dimensions.width;
      this.childContextMenu.position.top = dimensions.top - 4;
    }
  }
  closeSubMenu() {
    if (this.childContextMenu) {
      this.childContextMenu.open = false;
      this.ariaExpanded = false;
    }
  }
  handleMouseOver() {
    this.openSubMenu();
  }
  handleMouseOut() {
    this.closeSubMenu();
  }
  handleFocus() {
    this.tabindex = 0;
    if (this.hasChildren && this.ariaExpanded) {
      this.closeSubMenu();
    }
  }
  handleBlur() {
    this.tabindex = -1;
  }
  focusItem() {
    this.elementRef.nativeElement.focus();
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
};
ContextMenuItemComponent.ɵfac = function ContextMenuItemComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ContextMenuItemComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ContextMenuSelectionService, 8));
};
ContextMenuItemComponent.ɵcmp = ɵɵdefineComponent({
  type: ContextMenuItemComponent,
  selectors: [["cds-menu-item"], ["cds-context-menu-item"], ["ibm-context-menu-item"]],
  contentQueries: function ContextMenuItemComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ContextMenuComponent, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.childContextMenu = _t.first);
    }
  },
  hostVars: 12,
  hostBindings: function ContextMenuItemComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("keydown.enter", function ContextMenuItemComponent_keydown_enter_HostBindingHandler($event) {
        return ctx.handleClick($event);
      })("keydown.space", function ContextMenuItemComponent_keydown_space_HostBindingHandler($event) {
        return ctx.handleClick($event);
      })("click", function ContextMenuItemComponent_click_HostBindingHandler($event) {
        return ctx.handleClick($event);
      })("mouseover", function ContextMenuItemComponent_mouseover_HostBindingHandler() {
        return ctx.handleMouseOver();
      })("mouseout", function ContextMenuItemComponent_mouseout_HostBindingHandler() {
        return ctx.handleMouseOut();
      })("focus", function ContextMenuItemComponent_focus_HostBindingHandler() {
        return ctx.handleFocus();
      })("blur", function ContextMenuItemComponent_blur_HostBindingHandler() {
        return ctx.handleBlur();
      });
    }
    if (rf & 2) {
      ɵɵattribute("role", ctx.role)("tabindex", ctx.tabindex)("aria-haspopup", ctx.ariaHasPopup)("aria-expanded", ctx.ariaExpanded)("aria-checked", ctx.ariaChecked)("aria-disabled", ctx.ariaDisabled);
      ɵɵclassProp("cds--menu-item", ctx.optionClass)("cds--menu-item--disabled", ctx.disabled)("cds--menu-item--danger", ctx.danger);
    }
  },
  inputs: {
    disabled: "disabled",
    danger: "danger",
    label: "label",
    info: "info",
    type: "type",
    checked: "checked",
    icon: "icon",
    value: "value"
  },
  outputs: {
    checkedChange: "checkedChange",
    itemClick: "itemClick"
  },
  standalone: false,
  ngContentSelectors: _c014,
  decls: 9,
  vars: 6,
  consts: [[1, "cds--menu-item__icon"], ["cdsIcon", "checkmark", "size", "16", 4, "ngIf"], ["size", "16", 3, "cdsIcon", 4, "ngIf"], [1, "cds--menu-item__label", 3, "title"], [1, "cds--menu-item__shortcut"], [4, "ngIf"], ["cdsIcon", "caret--right", "size", "16", 4, "ngIf"], ["cdsIcon", "checkmark", "size", "16"], ["size", "16", 3, "cdsIcon"], ["cdsIcon", "caret--right", "size", "16"]],
  template: function ContextMenuItemComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 0);
      ɵɵtemplate(1, ContextMenuItemComponent__svg_svg_1_Template, 1, 0, "svg", 1)(2, ContextMenuItemComponent__svg_svg_2_Template, 1, 1, "svg", 2);
      ɵɵelementEnd();
      ɵɵelementStart(3, "div", 3);
      ɵɵtext(4);
      ɵɵelementEnd();
      ɵɵelementStart(5, "div", 4);
      ɵɵtemplate(6, ContextMenuItemComponent_ng_container_6_Template, 2, 1, "ng-container", 5)(7, ContextMenuItemComponent__svg_svg_7_Template, 1, 0, "svg", 6);
      ɵɵelementEnd();
      ɵɵprojection(8);
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.selectable && ctx.checked);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.selectable && ctx.icon);
      ɵɵadvance();
      ɵɵproperty("title", ctx.label);
      ɵɵadvance();
      ɵɵtextInterpolate(ctx.label);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.info);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.hasChildren);
    }
  },
  dependencies: [NgIf, IconDirective],
  styles: ["[_nghost-%COMP%]{grid-template-columns:1rem 1fr max-content}"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContextMenuItemComponent, [{
    type: Component,
    args: [{
      selector: "cds-menu-item, cds-context-menu-item, ibm-context-menu-item",
      template: `
		<div class="cds--menu-item__icon">
			<svg *ngIf="selectable && checked" cdsIcon="checkmark" size="16"></svg>
			<svg *ngIf="!selectable && icon" [cdsIcon]="icon" size="16"></svg>
		</div>
		<div class="cds--menu-item__label" [title]="label">{{label}}</div>
		<div class="cds--menu-item__shortcut">
			<ng-container *ngIf="info">{{info}}</ng-container>
			<svg *ngIf="hasChildren" cdsIcon="caret--right" size="16"></svg>
		</div>
		<ng-content></ng-content>
	`,
      styles: [":host{grid-template-columns:1rem 1fr max-content}\n"]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: ContextMenuSelectionService,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    optionClass: [{
      type: HostBinding,
      args: ["class.cds--menu-item"]
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    tabindex: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    ariaHasPopup: [{
      type: HostBinding,
      args: ["attr.aria-haspopup"]
    }],
    ariaExpanded: [{
      type: HostBinding,
      args: ["attr.aria-expanded"]
    }],
    ariaChecked: [{
      type: HostBinding,
      args: ["attr.aria-checked"]
    }],
    ariaDisabled: [{
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }],
    disabled: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.cds--menu-item--disabled"]
    }],
    danger: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.cds--menu-item--danger"]
    }],
    label: [{
      type: Input
    }],
    info: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    checked: [{
      type: Input
    }],
    icon: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    checkedChange: [{
      type: Output
    }],
    itemClick: [{
      type: Output
    }],
    childContextMenu: [{
      type: ContentChild,
      args: [ContextMenuComponent, {
        static: true
      }]
    }],
    handleClick: [{
      type: HostListener,
      args: ["keydown.enter", ["$event"]]
    }, {
      type: HostListener,
      args: ["keydown.space", ["$event"]]
    }, {
      type: HostListener,
      args: ["click", ["$event"]]
    }],
    handleMouseOver: [{
      type: HostListener,
      args: ["mouseover"]
    }],
    handleMouseOut: [{
      type: HostListener,
      args: ["mouseout"]
    }],
    handleFocus: [{
      type: HostListener,
      args: ["focus"]
    }],
    handleBlur: [{
      type: HostListener,
      args: ["blur"]
    }]
  });
})();
var ContextMenuModule = class {
};
ContextMenuModule.ɵfac = function ContextMenuModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ContextMenuModule)();
};
ContextMenuModule.ɵmod = ɵɵdefineNgModule({
  type: ContextMenuModule,
  declarations: [ContextMenuDividerComponent, ContextMenuGroupComponent, ContextMenuItemComponent, ContextMenuComponent],
  imports: [CommonModule, IconModule],
  exports: [ContextMenuDividerComponent, ContextMenuGroupComponent, ContextMenuItemComponent, ContextMenuComponent]
});
ContextMenuModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, IconModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContextMenuModule, [{
    type: NgModule,
    args: [{
      declarations: [ContextMenuDividerComponent, ContextMenuGroupComponent, ContextMenuItemComponent, ContextMenuComponent],
      exports: [ContextMenuDividerComponent, ContextMenuGroupComponent, ContextMenuItemComponent, ContextMenuComponent],
      imports: [CommonModule, IconModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-datepicker.mjs
var import_rangePlugin = __toESM(require_rangePlugin(), 1);

// node_modules/flatpickr/dist/esm/types/options.js
var HOOKS = ["onChange", "onClose", "onDayCreate", "onDestroy", "onKeyDown", "onMonthChange", "onOpen", "onParseConfig", "onReady", "onValueUpdate", "onYearChange", "onPreCalendarPosition"];
var defaults = {
  _disable: [],
  allowInput: false,
  allowInvalidPreload: false,
  altFormat: "F j, Y",
  altInput: false,
  altInputClass: "form-control input",
  animate: typeof window === "object" && window.navigator.userAgent.indexOf("MSIE") === -1,
  ariaDateFormat: "F j, Y",
  autoFillDefaultTime: true,
  clickOpens: true,
  closeOnSelect: true,
  conjunction: ", ",
  dateFormat: "Y-m-d",
  defaultHour: 12,
  defaultMinute: 0,
  defaultSeconds: 0,
  disable: [],
  disableMobile: false,
  enableSeconds: false,
  enableTime: false,
  errorHandler: function(err) {
    return typeof console !== "undefined" && console.warn(err);
  },
  getWeek: function(givenDate) {
    var date = new Date(givenDate.getTime());
    date.setHours(0, 0, 0, 0);
    date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
    var week1 = new Date(date.getFullYear(), 0, 4);
    return 1 + Math.round(((date.getTime() - week1.getTime()) / 864e5 - 3 + (week1.getDay() + 6) % 7) / 7);
  },
  hourIncrement: 1,
  ignoredFocusElements: [],
  inline: false,
  locale: "default",
  minuteIncrement: 5,
  mode: "single",
  monthSelectorType: "dropdown",
  nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
  noCalendar: false,
  now: /* @__PURE__ */ new Date(),
  onChange: [],
  onClose: [],
  onDayCreate: [],
  onDestroy: [],
  onKeyDown: [],
  onMonthChange: [],
  onOpen: [],
  onParseConfig: [],
  onReady: [],
  onValueUpdate: [],
  onYearChange: [],
  onPreCalendarPosition: [],
  plugins: [],
  position: "auto",
  positionElement: void 0,
  prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
  shorthandCurrentMonth: false,
  showMonths: 1,
  static: false,
  time_24hr: false,
  weekNumbers: false,
  wrap: false
};

// node_modules/flatpickr/dist/esm/l10n/default.js
var english = {
  weekdays: {
    shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    longhand: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
  },
  months: {
    shorthand: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    longhand: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
  },
  daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
  firstDayOfWeek: 0,
  ordinal: function(nth) {
    var s = nth % 100;
    if (s > 3 && s < 21) return "th";
    switch (s % 10) {
      case 1:
        return "st";
      case 2:
        return "nd";
      case 3:
        return "rd";
      default:
        return "th";
    }
  },
  rangeSeparator: " to ",
  weekAbbreviation: "Wk",
  scrollTitle: "Scroll to increment",
  toggleTitle: "Click to toggle",
  amPM: ["AM", "PM"],
  yearAriaLabel: "Year",
  monthAriaLabel: "Month",
  hourAriaLabel: "Hour",
  minuteAriaLabel: "Minute",
  time_24hr: false
};
var default_default = english;

// node_modules/flatpickr/dist/esm/utils/index.js
var pad = function(number, length) {
  if (length === void 0) {
    length = 2;
  }
  return ("000" + number).slice(length * -1);
};
var int = function(bool) {
  return bool === true ? 1 : 0;
};
function debounce(fn, wait) {
  var t;
  return function() {
    var _this = this;
    var args = arguments;
    clearTimeout(t);
    t = setTimeout(function() {
      return fn.apply(_this, args);
    }, wait);
  };
}
var arrayify = function(obj) {
  return obj instanceof Array ? obj : [obj];
};

// node_modules/flatpickr/dist/esm/utils/dom.js
function toggleClass(elem, className, bool) {
  if (bool === true) return elem.classList.add(className);
  elem.classList.remove(className);
}
function createElement(tag, className, content) {
  var e = window.document.createElement(tag);
  className = className || "";
  content = content || "";
  e.className = className;
  if (content !== void 0) e.textContent = content;
  return e;
}
function clearNode(node) {
  while (node.firstChild) node.removeChild(node.firstChild);
}
function findParent(node, condition) {
  if (condition(node)) return node;
  else if (node.parentNode) return findParent(node.parentNode, condition);
  return void 0;
}
function createNumberInput(inputClassName, opts) {
  var wrapper = createElement("div", "numInputWrapper"), numInput = createElement("input", "numInput " + inputClassName), arrowUp = createElement("span", "arrowUp"), arrowDown = createElement("span", "arrowDown");
  if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
    numInput.type = "number";
  } else {
    numInput.type = "text";
    numInput.pattern = "\\d*";
  }
  if (opts !== void 0) for (var key in opts) numInput.setAttribute(key, opts[key]);
  wrapper.appendChild(numInput);
  wrapper.appendChild(arrowUp);
  wrapper.appendChild(arrowDown);
  return wrapper;
}
function getEventTarget(event) {
  try {
    if (typeof event.composedPath === "function") {
      var path = event.composedPath();
      return path[0];
    }
    return event.target;
  } catch (error) {
    return event.target;
  }
}

// node_modules/flatpickr/dist/esm/utils/formatting.js
var doNothing = function() {
  return void 0;
};
var monthToStr = function(monthNumber, shorthand, locale) {
  return locale.months[shorthand ? "shorthand" : "longhand"][monthNumber];
};
var revFormat = {
  D: doNothing,
  F: function(dateObj, monthName, locale) {
    dateObj.setMonth(locale.months.longhand.indexOf(monthName));
  },
  G: function(dateObj, hour) {
    dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
  },
  H: function(dateObj, hour) {
    dateObj.setHours(parseFloat(hour));
  },
  J: function(dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  K: function(dateObj, amPM, locale) {
    dateObj.setHours(dateObj.getHours() % 12 + 12 * int(new RegExp(locale.amPM[1], "i").test(amPM)));
  },
  M: function(dateObj, shortMonth, locale) {
    dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
  },
  S: function(dateObj, seconds) {
    dateObj.setSeconds(parseFloat(seconds));
  },
  U: function(_, unixSeconds) {
    return new Date(parseFloat(unixSeconds) * 1e3);
  },
  W: function(dateObj, weekNum, locale) {
    var weekNumber = parseInt(weekNum);
    var date = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
    date.setDate(date.getDate() - date.getDay() + locale.firstDayOfWeek);
    return date;
  },
  Y: function(dateObj, year) {
    dateObj.setFullYear(parseFloat(year));
  },
  Z: function(_, ISODate) {
    return new Date(ISODate);
  },
  d: function(dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  h: function(dateObj, hour) {
    dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
  },
  i: function(dateObj, minutes) {
    dateObj.setMinutes(parseFloat(minutes));
  },
  j: function(dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  l: doNothing,
  m: function(dateObj, month) {
    dateObj.setMonth(parseFloat(month) - 1);
  },
  n: function(dateObj, month) {
    dateObj.setMonth(parseFloat(month) - 1);
  },
  s: function(dateObj, seconds) {
    dateObj.setSeconds(parseFloat(seconds));
  },
  u: function(_, unixMillSeconds) {
    return new Date(parseFloat(unixMillSeconds));
  },
  w: doNothing,
  y: function(dateObj, year) {
    dateObj.setFullYear(2e3 + parseFloat(year));
  }
};
var tokenRegex = {
  D: "",
  F: "",
  G: "(\\d\\d|\\d)",
  H: "(\\d\\d|\\d)",
  J: "(\\d\\d|\\d)\\w+",
  K: "",
  M: "",
  S: "(\\d\\d|\\d)",
  U: "(.+)",
  W: "(\\d\\d|\\d)",
  Y: "(\\d{4})",
  Z: "(.+)",
  d: "(\\d\\d|\\d)",
  h: "(\\d\\d|\\d)",
  i: "(\\d\\d|\\d)",
  j: "(\\d\\d|\\d)",
  l: "",
  m: "(\\d\\d|\\d)",
  n: "(\\d\\d|\\d)",
  s: "(\\d\\d|\\d)",
  u: "(.+)",
  w: "(\\d\\d|\\d)",
  y: "(\\d{2})"
};
var formats = {
  Z: function(date) {
    return date.toISOString();
  },
  D: function(date, locale, options) {
    return locale.weekdays.shorthand[formats.w(date, locale, options)];
  },
  F: function(date, locale, options) {
    return monthToStr(formats.n(date, locale, options) - 1, false, locale);
  },
  G: function(date, locale, options) {
    return pad(formats.h(date, locale, options));
  },
  H: function(date) {
    return pad(date.getHours());
  },
  J: function(date, locale) {
    return locale.ordinal !== void 0 ? date.getDate() + locale.ordinal(date.getDate()) : date.getDate();
  },
  K: function(date, locale) {
    return locale.amPM[int(date.getHours() > 11)];
  },
  M: function(date, locale) {
    return monthToStr(date.getMonth(), true, locale);
  },
  S: function(date) {
    return pad(date.getSeconds());
  },
  U: function(date) {
    return date.getTime() / 1e3;
  },
  W: function(date, _, options) {
    return options.getWeek(date);
  },
  Y: function(date) {
    return pad(date.getFullYear(), 4);
  },
  d: function(date) {
    return pad(date.getDate());
  },
  h: function(date) {
    return date.getHours() % 12 ? date.getHours() % 12 : 12;
  },
  i: function(date) {
    return pad(date.getMinutes());
  },
  j: function(date) {
    return date.getDate();
  },
  l: function(date, locale) {
    return locale.weekdays.longhand[date.getDay()];
  },
  m: function(date) {
    return pad(date.getMonth() + 1);
  },
  n: function(date) {
    return date.getMonth() + 1;
  },
  s: function(date) {
    return date.getSeconds();
  },
  u: function(date) {
    return date.getTime();
  },
  w: function(date) {
    return date.getDay();
  },
  y: function(date) {
    return String(date.getFullYear()).substring(2);
  }
};

// node_modules/flatpickr/dist/esm/utils/dates.js
var createDateFormatter = function(_a2) {
  var _b = _a2.config, config2 = _b === void 0 ? defaults : _b, _c = _a2.l10n, l10n = _c === void 0 ? english : _c, _d = _a2.isMobile, isMobile = _d === void 0 ? false : _d;
  return function(dateObj, frmt, overrideLocale) {
    var locale = overrideLocale || l10n;
    if (config2.formatDate !== void 0 && !isMobile) {
      return config2.formatDate(dateObj, frmt, locale);
    }
    return frmt.split("").map(function(c, i, arr) {
      return formats[c] && arr[i - 1] !== "\\" ? formats[c](dateObj, locale, config2) : c !== "\\" ? c : "";
    }).join("");
  };
};
var createDateParser = function(_a2) {
  var _b = _a2.config, config2 = _b === void 0 ? defaults : _b, _c = _a2.l10n, l10n = _c === void 0 ? english : _c;
  return function(date, givenFormat, timeless, customLocale) {
    if (date !== 0 && !date) return void 0;
    var locale = customLocale || l10n;
    var parsedDate;
    var dateOrig = date;
    if (date instanceof Date) parsedDate = new Date(date.getTime());
    else if (typeof date !== "string" && date.toFixed !== void 0) parsedDate = new Date(date);
    else if (typeof date === "string") {
      var format = givenFormat || (config2 || defaults).dateFormat;
      var datestr = String(date).trim();
      if (datestr === "today") {
        parsedDate = /* @__PURE__ */ new Date();
        timeless = true;
      } else if (config2 && config2.parseDate) {
        parsedDate = config2.parseDate(date, format);
      } else if (/Z$/.test(datestr) || /GMT$/.test(datestr)) {
        parsedDate = new Date(date);
      } else {
        var matched = void 0, ops = [];
        for (var i = 0, matchIndex = 0, regexStr = ""; i < format.length; i++) {
          var token = format[i];
          var isBackSlash = token === "\\";
          var escaped = format[i - 1] === "\\" || isBackSlash;
          if (tokenRegex[token] && !escaped) {
            regexStr += tokenRegex[token];
            var match = new RegExp(regexStr).exec(date);
            if (match && (matched = true)) {
              ops[token !== "Y" ? "push" : "unshift"]({
                fn: revFormat[token],
                val: match[++matchIndex]
              });
            }
          } else if (!isBackSlash) regexStr += ".";
        }
        parsedDate = !config2 || !config2.noCalendar ? new Date((/* @__PURE__ */ new Date()).getFullYear(), 0, 1, 0, 0, 0, 0) : new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0));
        ops.forEach(function(_a3) {
          var fn = _a3.fn, val = _a3.val;
          return parsedDate = fn(parsedDate, val, locale) || parsedDate;
        });
        parsedDate = matched ? parsedDate : void 0;
      }
    }
    if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
      config2.errorHandler(new Error("Invalid date provided: " + dateOrig));
      return void 0;
    }
    if (timeless === true) parsedDate.setHours(0, 0, 0, 0);
    return parsedDate;
  };
};
function compareDates(date1, date2, timeless) {
  if (timeless === void 0) {
    timeless = true;
  }
  if (timeless !== false) {
    return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);
  }
  return date1.getTime() - date2.getTime();
}
var isBetween = function(ts, ts1, ts2) {
  return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
};
var calculateSecondsSinceMidnight = function(hours, minutes, seconds) {
  return hours * 3600 + minutes * 60 + seconds;
};
var parseSeconds = function(secondsSinceMidnight) {
  var hours = Math.floor(secondsSinceMidnight / 3600), minutes = (secondsSinceMidnight - hours * 3600) / 60;
  return [hours, minutes, secondsSinceMidnight - hours * 3600 - minutes * 60];
};
var duration = {
  DAY: 864e5
};
function getDefaultHours(config2) {
  var hours = config2.defaultHour;
  var minutes = config2.defaultMinute;
  var seconds = config2.defaultSeconds;
  if (config2.minDate !== void 0) {
    var minHour = config2.minDate.getHours();
    var minMinutes = config2.minDate.getMinutes();
    var minSeconds = config2.minDate.getSeconds();
    if (hours < minHour) {
      hours = minHour;
    }
    if (hours === minHour && minutes < minMinutes) {
      minutes = minMinutes;
    }
    if (hours === minHour && minutes === minMinutes && seconds < minSeconds) seconds = config2.minDate.getSeconds();
  }
  if (config2.maxDate !== void 0) {
    var maxHr = config2.maxDate.getHours();
    var maxMinutes = config2.maxDate.getMinutes();
    hours = Math.min(hours, maxHr);
    if (hours === maxHr) minutes = Math.min(maxMinutes, minutes);
    if (hours === maxHr && minutes === maxMinutes) seconds = config2.maxDate.getSeconds();
  }
  return {
    hours,
    minutes,
    seconds
  };
}

// node_modules/flatpickr/dist/esm/utils/polyfills.js
if (typeof Object.assign !== "function") {
  Object.assign = function(target) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    if (!target) {
      throw TypeError("Cannot convert undefined or null to object");
    }
    var _loop_1 = function(source2) {
      if (source2) {
        Object.keys(source2).forEach(function(key) {
          return target[key] = source2[key];
        });
      }
    };
    for (var _a2 = 0, args_1 = args; _a2 < args_1.length; _a2++) {
      var source = args_1[_a2];
      _loop_1(source);
    }
    return target;
  };
}

// node_modules/flatpickr/dist/esm/index.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __spreadArrays = function() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];
  return r;
};
var DEBOUNCED_CHANGE_MS = 300;
function FlatpickrInstance(element, instanceConfig) {
  var self2 = {
    config: __assign(__assign({}, defaults), flatpickr.defaultConfig),
    l10n: default_default
  };
  self2.parseDate = createDateParser({
    config: self2.config,
    l10n: self2.l10n
  });
  self2._handlers = [];
  self2.pluginElements = [];
  self2.loadedPlugins = [];
  self2._bind = bind;
  self2._setHoursFromDate = setHoursFromDate;
  self2._positionCalendar = positionCalendar;
  self2.changeMonth = changeMonth;
  self2.changeYear = changeYear;
  self2.clear = clear;
  self2.close = close;
  self2.onMouseOver = onMouseOver;
  self2._createElement = createElement;
  self2.createDay = createDay;
  self2.destroy = destroy;
  self2.isEnabled = isEnabled;
  self2.jumpToDate = jumpToDate;
  self2.updateValue = updateValue;
  self2.open = open2;
  self2.redraw = redraw;
  self2.set = set;
  self2.setDate = setDate;
  self2.toggle = toggle;
  function setupHelperFunctions() {
    self2.utils = {
      getDaysInMonth: function(month, yr) {
        if (month === void 0) {
          month = self2.currentMonth;
        }
        if (yr === void 0) {
          yr = self2.currentYear;
        }
        if (month === 1 && (yr % 4 === 0 && yr % 100 !== 0 || yr % 400 === 0)) return 29;
        return self2.l10n.daysInMonth[month];
      }
    };
  }
  function init() {
    self2.element = self2.input = element;
    self2.isOpen = false;
    parseConfig();
    setupLocale();
    setupInputs();
    setupDates();
    setupHelperFunctions();
    if (!self2.isMobile) build();
    bindEvents();
    if (self2.selectedDates.length || self2.config.noCalendar) {
      if (self2.config.enableTime) {
        setHoursFromDate(self2.config.noCalendar ? self2.latestSelectedDateObj : void 0);
      }
      updateValue(false);
    }
    setCalendarWidth();
    var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    if (!self2.isMobile && isSafari) {
      positionCalendar();
    }
    triggerEvent("onReady");
  }
  function getClosestActiveElement() {
    var _a2;
    return ((_a2 = self2.calendarContainer) === null || _a2 === void 0 ? void 0 : _a2.getRootNode()).activeElement || document.activeElement;
  }
  function bindToInstance(fn) {
    return fn.bind(self2);
  }
  function setCalendarWidth() {
    var config2 = self2.config;
    if (config2.weekNumbers === false && config2.showMonths === 1) {
      return;
    } else if (config2.noCalendar !== true) {
      window.requestAnimationFrame(function() {
        if (self2.calendarContainer !== void 0) {
          self2.calendarContainer.style.visibility = "hidden";
          self2.calendarContainer.style.display = "block";
        }
        if (self2.daysContainer !== void 0) {
          var daysWidth = (self2.days.offsetWidth + 1) * config2.showMonths;
          self2.daysContainer.style.width = daysWidth + "px";
          self2.calendarContainer.style.width = daysWidth + (self2.weekWrapper !== void 0 ? self2.weekWrapper.offsetWidth : 0) + "px";
          self2.calendarContainer.style.removeProperty("visibility");
          self2.calendarContainer.style.removeProperty("display");
        }
      });
    }
  }
  function updateTime(e) {
    if (self2.selectedDates.length === 0) {
      var defaultDate = self2.config.minDate === void 0 || compareDates(/* @__PURE__ */ new Date(), self2.config.minDate) >= 0 ? /* @__PURE__ */ new Date() : new Date(self2.config.minDate.getTime());
      var defaults2 = getDefaultHours(self2.config);
      defaultDate.setHours(defaults2.hours, defaults2.minutes, defaults2.seconds, defaultDate.getMilliseconds());
      self2.selectedDates = [defaultDate];
      self2.latestSelectedDateObj = defaultDate;
    }
    if (e !== void 0 && e.type !== "blur") {
      timeWrapper(e);
    }
    var prevValue = self2._input.value;
    setHoursFromInputs();
    updateValue();
    if (self2._input.value !== prevValue) {
      self2._debouncedChange();
    }
  }
  function ampm2military(hour, amPM) {
    return hour % 12 + 12 * int(amPM === self2.l10n.amPM[1]);
  }
  function military2ampm(hour) {
    switch (hour % 24) {
      case 0:
      case 12:
        return 12;
      default:
        return hour % 12;
    }
  }
  function setHoursFromInputs() {
    if (self2.hourElement === void 0 || self2.minuteElement === void 0) return;
    var hours = (parseInt(self2.hourElement.value.slice(-2), 10) || 0) % 24, minutes = (parseInt(self2.minuteElement.value, 10) || 0) % 60, seconds = self2.secondElement !== void 0 ? (parseInt(self2.secondElement.value, 10) || 0) % 60 : 0;
    if (self2.amPM !== void 0) {
      hours = ampm2military(hours, self2.amPM.textContent);
    }
    var limitMinHours = self2.config.minTime !== void 0 || self2.config.minDate && self2.minDateHasTime && self2.latestSelectedDateObj && compareDates(self2.latestSelectedDateObj, self2.config.minDate, true) === 0;
    var limitMaxHours = self2.config.maxTime !== void 0 || self2.config.maxDate && self2.maxDateHasTime && self2.latestSelectedDateObj && compareDates(self2.latestSelectedDateObj, self2.config.maxDate, true) === 0;
    if (self2.config.maxTime !== void 0 && self2.config.minTime !== void 0 && self2.config.minTime > self2.config.maxTime) {
      var minBound = calculateSecondsSinceMidnight(self2.config.minTime.getHours(), self2.config.minTime.getMinutes(), self2.config.minTime.getSeconds());
      var maxBound = calculateSecondsSinceMidnight(self2.config.maxTime.getHours(), self2.config.maxTime.getMinutes(), self2.config.maxTime.getSeconds());
      var currentTime = calculateSecondsSinceMidnight(hours, minutes, seconds);
      if (currentTime > maxBound && currentTime < minBound) {
        var result = parseSeconds(minBound);
        hours = result[0];
        minutes = result[1];
        seconds = result[2];
      }
    } else {
      if (limitMaxHours) {
        var maxTime = self2.config.maxTime !== void 0 ? self2.config.maxTime : self2.config.maxDate;
        hours = Math.min(hours, maxTime.getHours());
        if (hours === maxTime.getHours()) minutes = Math.min(minutes, maxTime.getMinutes());
        if (minutes === maxTime.getMinutes()) seconds = Math.min(seconds, maxTime.getSeconds());
      }
      if (limitMinHours) {
        var minTime = self2.config.minTime !== void 0 ? self2.config.minTime : self2.config.minDate;
        hours = Math.max(hours, minTime.getHours());
        if (hours === minTime.getHours() && minutes < minTime.getMinutes()) minutes = minTime.getMinutes();
        if (minutes === minTime.getMinutes()) seconds = Math.max(seconds, minTime.getSeconds());
      }
    }
    setHours(hours, minutes, seconds);
  }
  function setHoursFromDate(dateObj) {
    var date = dateObj || self2.latestSelectedDateObj;
    if (date && date instanceof Date) {
      setHours(date.getHours(), date.getMinutes(), date.getSeconds());
    }
  }
  function setHours(hours, minutes, seconds) {
    if (self2.latestSelectedDateObj !== void 0) {
      self2.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
    }
    if (!self2.hourElement || !self2.minuteElement || self2.isMobile) return;
    self2.hourElement.value = pad(!self2.config.time_24hr ? (12 + hours) % 12 + 12 * int(hours % 12 === 0) : hours);
    self2.minuteElement.value = pad(minutes);
    if (self2.amPM !== void 0) self2.amPM.textContent = self2.l10n.amPM[int(hours >= 12)];
    if (self2.secondElement !== void 0) self2.secondElement.value = pad(seconds);
  }
  function onYearInput(event) {
    var eventTarget = getEventTarget(event);
    var year = parseInt(eventTarget.value) + (event.delta || 0);
    if (year / 1e3 > 1 || event.key === "Enter" && !/[^\d]/.test(year.toString())) {
      changeYear(year);
    }
  }
  function bind(element2, event, handler, options) {
    if (event instanceof Array) return event.forEach(function(ev) {
      return bind(element2, ev, handler, options);
    });
    if (element2 instanceof Array) return element2.forEach(function(el) {
      return bind(el, event, handler, options);
    });
    element2.addEventListener(event, handler, options);
    self2._handlers.push({
      remove: function() {
        return element2.removeEventListener(event, handler, options);
      }
    });
  }
  function triggerChange() {
    triggerEvent("onChange");
  }
  function bindEvents() {
    if (self2.config.wrap) {
      ["open", "close", "toggle", "clear"].forEach(function(evt) {
        Array.prototype.forEach.call(self2.element.querySelectorAll("[data-" + evt + "]"), function(el) {
          return bind(el, "click", self2[evt]);
        });
      });
    }
    if (self2.isMobile) {
      setupMobile();
      return;
    }
    var debouncedResize = debounce(onResize, 50);
    self2._debouncedChange = debounce(triggerChange, DEBOUNCED_CHANGE_MS);
    if (self2.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent)) bind(self2.daysContainer, "mouseover", function(e) {
      if (self2.config.mode === "range") onMouseOver(getEventTarget(e));
    });
    bind(self2._input, "keydown", onKeyDown);
    if (self2.calendarContainer !== void 0) {
      bind(self2.calendarContainer, "keydown", onKeyDown);
    }
    if (!self2.config.inline && !self2.config.static) bind(window, "resize", debouncedResize);
    if (window.ontouchstart !== void 0) bind(window.document, "touchstart", documentClick);
    else bind(window.document, "mousedown", documentClick);
    bind(window.document, "focus", documentClick, {
      capture: true
    });
    if (self2.config.clickOpens === true) {
      bind(self2._input, "focus", self2.open);
      bind(self2._input, "click", self2.open);
    }
    if (self2.daysContainer !== void 0) {
      bind(self2.monthNav, "click", onMonthNavClick);
      bind(self2.monthNav, ["keyup", "increment"], onYearInput);
      bind(self2.daysContainer, "click", selectDate);
    }
    if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0) {
      var selText = function(e) {
        return getEventTarget(e).select();
      };
      bind(self2.timeContainer, ["increment"], updateTime);
      bind(self2.timeContainer, "blur", updateTime, {
        capture: true
      });
      bind(self2.timeContainer, "click", timeIncrement);
      bind([self2.hourElement, self2.minuteElement], ["focus", "click"], selText);
      if (self2.secondElement !== void 0) bind(self2.secondElement, "focus", function() {
        return self2.secondElement && self2.secondElement.select();
      });
      if (self2.amPM !== void 0) {
        bind(self2.amPM, "click", function(e) {
          updateTime(e);
        });
      }
    }
    if (self2.config.allowInput) {
      bind(self2._input, "blur", onBlur);
    }
  }
  function jumpToDate(jumpDate, triggerChange2) {
    var jumpTo = jumpDate !== void 0 ? self2.parseDate(jumpDate) : self2.latestSelectedDateObj || (self2.config.minDate && self2.config.minDate > self2.now ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate < self2.now ? self2.config.maxDate : self2.now);
    var oldYear = self2.currentYear;
    var oldMonth = self2.currentMonth;
    try {
      if (jumpTo !== void 0) {
        self2.currentYear = jumpTo.getFullYear();
        self2.currentMonth = jumpTo.getMonth();
      }
    } catch (e) {
      e.message = "Invalid date supplied: " + jumpTo;
      self2.config.errorHandler(e);
    }
    if (triggerChange2 && self2.currentYear !== oldYear) {
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
    if (triggerChange2 && (self2.currentYear !== oldYear || self2.currentMonth !== oldMonth)) {
      triggerEvent("onMonthChange");
    }
    self2.redraw();
  }
  function timeIncrement(e) {
    var eventTarget = getEventTarget(e);
    if (~eventTarget.className.indexOf("arrow")) incrementNumInput(e, eventTarget.classList.contains("arrowUp") ? 1 : -1);
  }
  function incrementNumInput(e, delta, inputElem) {
    var target = e && getEventTarget(e);
    var input = inputElem || target && target.parentNode && target.parentNode.firstChild;
    var event = createEvent("increment");
    event.delta = delta;
    input && input.dispatchEvent(event);
  }
  function build() {
    var fragment = window.document.createDocumentFragment();
    self2.calendarContainer = createElement("div", "flatpickr-calendar");
    self2.calendarContainer.tabIndex = -1;
    if (!self2.config.noCalendar) {
      fragment.appendChild(buildMonthNav());
      self2.innerContainer = createElement("div", "flatpickr-innerContainer");
      if (self2.config.weekNumbers) {
        var _a2 = buildWeeks(), weekWrapper = _a2.weekWrapper, weekNumbers = _a2.weekNumbers;
        self2.innerContainer.appendChild(weekWrapper);
        self2.weekNumbers = weekNumbers;
        self2.weekWrapper = weekWrapper;
      }
      self2.rContainer = createElement("div", "flatpickr-rContainer");
      self2.rContainer.appendChild(buildWeekdays());
      if (!self2.daysContainer) {
        self2.daysContainer = createElement("div", "flatpickr-days");
        self2.daysContainer.tabIndex = -1;
      }
      buildDays();
      self2.rContainer.appendChild(self2.daysContainer);
      self2.innerContainer.appendChild(self2.rContainer);
      fragment.appendChild(self2.innerContainer);
    }
    if (self2.config.enableTime) {
      fragment.appendChild(buildTime());
    }
    toggleClass(self2.calendarContainer, "rangeMode", self2.config.mode === "range");
    toggleClass(self2.calendarContainer, "animate", self2.config.animate === true);
    toggleClass(self2.calendarContainer, "multiMonth", self2.config.showMonths > 1);
    self2.calendarContainer.appendChild(fragment);
    var customAppend = self2.config.appendTo !== void 0 && self2.config.appendTo.nodeType !== void 0;
    if (self2.config.inline || self2.config.static) {
      self2.calendarContainer.classList.add(self2.config.inline ? "inline" : "static");
      if (self2.config.inline) {
        if (!customAppend && self2.element.parentNode) self2.element.parentNode.insertBefore(self2.calendarContainer, self2._input.nextSibling);
        else if (self2.config.appendTo !== void 0) self2.config.appendTo.appendChild(self2.calendarContainer);
      }
      if (self2.config.static) {
        var wrapper = createElement("div", "flatpickr-wrapper");
        if (self2.element.parentNode) self2.element.parentNode.insertBefore(wrapper, self2.element);
        wrapper.appendChild(self2.element);
        if (self2.altInput) wrapper.appendChild(self2.altInput);
        wrapper.appendChild(self2.calendarContainer);
      }
    }
    if (!self2.config.static && !self2.config.inline) (self2.config.appendTo !== void 0 ? self2.config.appendTo : window.document.body).appendChild(self2.calendarContainer);
  }
  function createDay(className, date, _dayNumber, i) {
    var dateIsEnabled = isEnabled(date, true), dayElement = createElement("span", className, date.getDate().toString());
    dayElement.dateObj = date;
    dayElement.$i = i;
    dayElement.setAttribute("aria-label", self2.formatDate(date, self2.config.ariaDateFormat));
    if (className.indexOf("hidden") === -1 && compareDates(date, self2.now) === 0) {
      self2.todayDateElem = dayElement;
      dayElement.classList.add("today");
      dayElement.setAttribute("aria-current", "date");
    }
    if (dateIsEnabled) {
      dayElement.tabIndex = -1;
      if (isDateSelected(date)) {
        dayElement.classList.add("selected");
        self2.selectedDateElem = dayElement;
        if (self2.config.mode === "range") {
          toggleClass(dayElement, "startRange", self2.selectedDates[0] && compareDates(date, self2.selectedDates[0], true) === 0);
          toggleClass(dayElement, "endRange", self2.selectedDates[1] && compareDates(date, self2.selectedDates[1], true) === 0);
          if (className === "nextMonthDay") dayElement.classList.add("inRange");
        }
      }
    } else {
      dayElement.classList.add("flatpickr-disabled");
    }
    if (self2.config.mode === "range") {
      if (isDateInRange(date) && !isDateSelected(date)) dayElement.classList.add("inRange");
    }
    if (self2.weekNumbers && self2.config.showMonths === 1 && className !== "prevMonthDay" && i % 7 === 6) {
      self2.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self2.config.getWeek(date) + "</span>");
    }
    triggerEvent("onDayCreate", dayElement);
    return dayElement;
  }
  function focusOnDayElem(targetNode) {
    targetNode.focus();
    if (self2.config.mode === "range") onMouseOver(targetNode);
  }
  function getFirstAvailableDay(delta) {
    var startMonth = delta > 0 ? 0 : self2.config.showMonths - 1;
    var endMonth = delta > 0 ? self2.config.showMonths : -1;
    for (var m = startMonth; m != endMonth; m += delta) {
      var month = self2.daysContainer.children[m];
      var startIndex = delta > 0 ? 0 : month.children.length - 1;
      var endIndex = delta > 0 ? month.children.length : -1;
      for (var i = startIndex; i != endIndex; i += delta) {
        var c = month.children[i];
        if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj)) return c;
      }
    }
    return void 0;
  }
  function getNextAvailableDay(current, delta) {
    var givenMonth = current.className.indexOf("Month") === -1 ? current.dateObj.getMonth() : self2.currentMonth;
    var endMonth = delta > 0 ? self2.config.showMonths : -1;
    var loopDelta = delta > 0 ? 1 : -1;
    for (var m = givenMonth - self2.currentMonth; m != endMonth; m += loopDelta) {
      var month = self2.daysContainer.children[m];
      var startIndex = givenMonth - self2.currentMonth === m ? current.$i + delta : delta < 0 ? month.children.length - 1 : 0;
      var numMonthDays = month.children.length;
      for (var i = startIndex; i >= 0 && i < numMonthDays && i != (delta > 0 ? numMonthDays : -1); i += loopDelta) {
        var c = month.children[i];
        if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj) && Math.abs(current.$i - i) >= Math.abs(delta)) return focusOnDayElem(c);
      }
    }
    self2.changeMonth(loopDelta);
    focusOnDay(getFirstAvailableDay(loopDelta), 0);
    return void 0;
  }
  function focusOnDay(current, offset3) {
    var activeElement = getClosestActiveElement();
    var dayFocused = isInView(activeElement || document.body);
    var startElem = current !== void 0 ? current : dayFocused ? activeElement : self2.selectedDateElem !== void 0 && isInView(self2.selectedDateElem) ? self2.selectedDateElem : self2.todayDateElem !== void 0 && isInView(self2.todayDateElem) ? self2.todayDateElem : getFirstAvailableDay(offset3 > 0 ? 1 : -1);
    if (startElem === void 0) {
      self2._input.focus();
    } else if (!dayFocused) {
      focusOnDayElem(startElem);
    } else {
      getNextAvailableDay(startElem, offset3);
    }
  }
  function buildMonthDays(year, month) {
    var firstOfMonth = (new Date(year, month, 1).getDay() - self2.l10n.firstDayOfWeek + 7) % 7;
    var prevMonthDays = self2.utils.getDaysInMonth((month - 1 + 12) % 12, year);
    var daysInMonth = self2.utils.getDaysInMonth(month, year), days = window.document.createDocumentFragment(), isMultiMonth = self2.config.showMonths > 1, prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay", nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
    var dayNumber = prevMonthDays + 1 - firstOfMonth, dayIndex = 0;
    for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
      days.appendChild(createDay("flatpickr-day " + prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
    }
    for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {
      days.appendChild(createDay("flatpickr-day", new Date(year, month, dayNumber), dayNumber, dayIndex));
    }
    for (var dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth && (self2.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
      days.appendChild(createDay("flatpickr-day " + nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth), dayNum, dayIndex));
    }
    var dayContainer = createElement("div", "dayContainer");
    dayContainer.appendChild(days);
    return dayContainer;
  }
  function buildDays() {
    if (self2.daysContainer === void 0) {
      return;
    }
    clearNode(self2.daysContainer);
    if (self2.weekNumbers) clearNode(self2.weekNumbers);
    var frag = document.createDocumentFragment();
    for (var i = 0; i < self2.config.showMonths; i++) {
      var d = new Date(self2.currentYear, self2.currentMonth, 1);
      d.setMonth(self2.currentMonth + i);
      frag.appendChild(buildMonthDays(d.getFullYear(), d.getMonth()));
    }
    self2.daysContainer.appendChild(frag);
    self2.days = self2.daysContainer.firstChild;
    if (self2.config.mode === "range" && self2.selectedDates.length === 1) {
      onMouseOver();
    }
  }
  function buildMonthSwitch() {
    if (self2.config.showMonths > 1 || self2.config.monthSelectorType !== "dropdown") return;
    var shouldBuildMonth = function(month2) {
      if (self2.config.minDate !== void 0 && self2.currentYear === self2.config.minDate.getFullYear() && month2 < self2.config.minDate.getMonth()) {
        return false;
      }
      return !(self2.config.maxDate !== void 0 && self2.currentYear === self2.config.maxDate.getFullYear() && month2 > self2.config.maxDate.getMonth());
    };
    self2.monthsDropdownContainer.tabIndex = -1;
    self2.monthsDropdownContainer.innerHTML = "";
    for (var i = 0; i < 12; i++) {
      if (!shouldBuildMonth(i)) continue;
      var month = createElement("option", "flatpickr-monthDropdown-month");
      month.value = new Date(self2.currentYear, i).getMonth().toString();
      month.textContent = monthToStr(i, self2.config.shorthandCurrentMonth, self2.l10n);
      month.tabIndex = -1;
      if (self2.currentMonth === i) {
        month.selected = true;
      }
      self2.monthsDropdownContainer.appendChild(month);
    }
  }
  function buildMonth() {
    var container = createElement("div", "flatpickr-month");
    var monthNavFragment = window.document.createDocumentFragment();
    var monthElement;
    if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
      monthElement = createElement("span", "cur-month");
    } else {
      self2.monthsDropdownContainer = createElement("select", "flatpickr-monthDropdown-months");
      self2.monthsDropdownContainer.setAttribute("aria-label", self2.l10n.monthAriaLabel);
      bind(self2.monthsDropdownContainer, "change", function(e) {
        var target = getEventTarget(e);
        var selectedMonth = parseInt(target.value, 10);
        self2.changeMonth(selectedMonth - self2.currentMonth);
        triggerEvent("onMonthChange");
      });
      buildMonthSwitch();
      monthElement = self2.monthsDropdownContainer;
    }
    var yearInput = createNumberInput("cur-year", {
      tabindex: "-1"
    });
    var yearElement = yearInput.getElementsByTagName("input")[0];
    yearElement.setAttribute("aria-label", self2.l10n.yearAriaLabel);
    if (self2.config.minDate) {
      yearElement.setAttribute("min", self2.config.minDate.getFullYear().toString());
    }
    if (self2.config.maxDate) {
      yearElement.setAttribute("max", self2.config.maxDate.getFullYear().toString());
      yearElement.disabled = !!self2.config.minDate && self2.config.minDate.getFullYear() === self2.config.maxDate.getFullYear();
    }
    var currentMonth = createElement("div", "flatpickr-current-month");
    currentMonth.appendChild(monthElement);
    currentMonth.appendChild(yearInput);
    monthNavFragment.appendChild(currentMonth);
    container.appendChild(monthNavFragment);
    return {
      container,
      yearElement,
      monthElement
    };
  }
  function buildMonths() {
    clearNode(self2.monthNav);
    self2.monthNav.appendChild(self2.prevMonthNav);
    if (self2.config.showMonths) {
      self2.yearElements = [];
      self2.monthElements = [];
    }
    for (var m = self2.config.showMonths; m--; ) {
      var month = buildMonth();
      self2.yearElements.push(month.yearElement);
      self2.monthElements.push(month.monthElement);
      self2.monthNav.appendChild(month.container);
    }
    self2.monthNav.appendChild(self2.nextMonthNav);
  }
  function buildMonthNav() {
    self2.monthNav = createElement("div", "flatpickr-months");
    self2.yearElements = [];
    self2.monthElements = [];
    self2.prevMonthNav = createElement("span", "flatpickr-prev-month");
    self2.prevMonthNav.innerHTML = self2.config.prevArrow;
    self2.nextMonthNav = createElement("span", "flatpickr-next-month");
    self2.nextMonthNav.innerHTML = self2.config.nextArrow;
    buildMonths();
    Object.defineProperty(self2, "_hidePrevMonthArrow", {
      get: function() {
        return self2.__hidePrevMonthArrow;
      },
      set: function(bool) {
        if (self2.__hidePrevMonthArrow !== bool) {
          toggleClass(self2.prevMonthNav, "flatpickr-disabled", bool);
          self2.__hidePrevMonthArrow = bool;
        }
      }
    });
    Object.defineProperty(self2, "_hideNextMonthArrow", {
      get: function() {
        return self2.__hideNextMonthArrow;
      },
      set: function(bool) {
        if (self2.__hideNextMonthArrow !== bool) {
          toggleClass(self2.nextMonthNav, "flatpickr-disabled", bool);
          self2.__hideNextMonthArrow = bool;
        }
      }
    });
    self2.currentYearElement = self2.yearElements[0];
    updateNavigationCurrentMonth();
    return self2.monthNav;
  }
  function buildTime() {
    self2.calendarContainer.classList.add("hasTime");
    if (self2.config.noCalendar) self2.calendarContainer.classList.add("noCalendar");
    var defaults2 = getDefaultHours(self2.config);
    self2.timeContainer = createElement("div", "flatpickr-time");
    self2.timeContainer.tabIndex = -1;
    var separator = createElement("span", "flatpickr-time-separator", ":");
    var hourInput = createNumberInput("flatpickr-hour", {
      "aria-label": self2.l10n.hourAriaLabel
    });
    self2.hourElement = hourInput.getElementsByTagName("input")[0];
    var minuteInput = createNumberInput("flatpickr-minute", {
      "aria-label": self2.l10n.minuteAriaLabel
    });
    self2.minuteElement = minuteInput.getElementsByTagName("input")[0];
    self2.hourElement.tabIndex = self2.minuteElement.tabIndex = -1;
    self2.hourElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getHours() : self2.config.time_24hr ? defaults2.hours : military2ampm(defaults2.hours));
    self2.minuteElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getMinutes() : defaults2.minutes);
    self2.hourElement.setAttribute("step", self2.config.hourIncrement.toString());
    self2.minuteElement.setAttribute("step", self2.config.minuteIncrement.toString());
    self2.hourElement.setAttribute("min", self2.config.time_24hr ? "0" : "1");
    self2.hourElement.setAttribute("max", self2.config.time_24hr ? "23" : "12");
    self2.hourElement.setAttribute("maxlength", "2");
    self2.minuteElement.setAttribute("min", "0");
    self2.minuteElement.setAttribute("max", "59");
    self2.minuteElement.setAttribute("maxlength", "2");
    self2.timeContainer.appendChild(hourInput);
    self2.timeContainer.appendChild(separator);
    self2.timeContainer.appendChild(minuteInput);
    if (self2.config.time_24hr) self2.timeContainer.classList.add("time24hr");
    if (self2.config.enableSeconds) {
      self2.timeContainer.classList.add("hasSeconds");
      var secondInput = createNumberInput("flatpickr-second");
      self2.secondElement = secondInput.getElementsByTagName("input")[0];
      self2.secondElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getSeconds() : defaults2.seconds);
      self2.secondElement.setAttribute("step", self2.minuteElement.getAttribute("step"));
      self2.secondElement.setAttribute("min", "0");
      self2.secondElement.setAttribute("max", "59");
      self2.secondElement.setAttribute("maxlength", "2");
      self2.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
      self2.timeContainer.appendChild(secondInput);
    }
    if (!self2.config.time_24hr) {
      self2.amPM = createElement("span", "flatpickr-am-pm", self2.l10n.amPM[int((self2.latestSelectedDateObj ? self2.hourElement.value : self2.config.defaultHour) > 11)]);
      self2.amPM.title = self2.l10n.toggleTitle;
      self2.amPM.tabIndex = -1;
      self2.timeContainer.appendChild(self2.amPM);
    }
    return self2.timeContainer;
  }
  function buildWeekdays() {
    if (!self2.weekdayContainer) self2.weekdayContainer = createElement("div", "flatpickr-weekdays");
    else clearNode(self2.weekdayContainer);
    for (var i = self2.config.showMonths; i--; ) {
      var container = createElement("div", "flatpickr-weekdaycontainer");
      self2.weekdayContainer.appendChild(container);
    }
    updateWeekdays();
    return self2.weekdayContainer;
  }
  function updateWeekdays() {
    if (!self2.weekdayContainer) {
      return;
    }
    var firstDayOfWeek = self2.l10n.firstDayOfWeek;
    var weekdays = __spreadArrays(self2.l10n.weekdays.shorthand);
    if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
      weekdays = __spreadArrays(weekdays.splice(firstDayOfWeek, weekdays.length), weekdays.splice(0, firstDayOfWeek));
    }
    for (var i = self2.config.showMonths; i--; ) {
      self2.weekdayContainer.children[i].innerHTML = "\n      <span class='flatpickr-weekday'>\n        " + weekdays.join("</span><span class='flatpickr-weekday'>") + "\n      </span>\n      ";
    }
  }
  function buildWeeks() {
    self2.calendarContainer.classList.add("hasWeeks");
    var weekWrapper = createElement("div", "flatpickr-weekwrapper");
    weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self2.l10n.weekAbbreviation));
    var weekNumbers = createElement("div", "flatpickr-weeks");
    weekWrapper.appendChild(weekNumbers);
    return {
      weekWrapper,
      weekNumbers
    };
  }
  function changeMonth(value, isOffset) {
    if (isOffset === void 0) {
      isOffset = true;
    }
    var delta = isOffset ? value : value - self2.currentMonth;
    if (delta < 0 && self2._hidePrevMonthArrow === true || delta > 0 && self2._hideNextMonthArrow === true) return;
    self2.currentMonth += delta;
    if (self2.currentMonth < 0 || self2.currentMonth > 11) {
      self2.currentYear += self2.currentMonth > 11 ? 1 : -1;
      self2.currentMonth = (self2.currentMonth + 12) % 12;
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
    buildDays();
    triggerEvent("onMonthChange");
    updateNavigationCurrentMonth();
  }
  function clear(triggerChangeEvent, toInitial) {
    if (triggerChangeEvent === void 0) {
      triggerChangeEvent = true;
    }
    if (toInitial === void 0) {
      toInitial = true;
    }
    self2.input.value = "";
    if (self2.altInput !== void 0) self2.altInput.value = "";
    if (self2.mobileInput !== void 0) self2.mobileInput.value = "";
    self2.selectedDates = [];
    self2.latestSelectedDateObj = void 0;
    if (toInitial === true) {
      self2.currentYear = self2._initialDate.getFullYear();
      self2.currentMonth = self2._initialDate.getMonth();
    }
    if (self2.config.enableTime === true) {
      var _a2 = getDefaultHours(self2.config), hours = _a2.hours, minutes = _a2.minutes, seconds = _a2.seconds;
      setHours(hours, minutes, seconds);
    }
    self2.redraw();
    if (triggerChangeEvent) triggerEvent("onChange");
  }
  function close() {
    self2.isOpen = false;
    if (!self2.isMobile) {
      if (self2.calendarContainer !== void 0) {
        self2.calendarContainer.classList.remove("open");
      }
      if (self2._input !== void 0) {
        self2._input.classList.remove("active");
      }
    }
    triggerEvent("onClose");
  }
  function destroy() {
    if (self2.config !== void 0) triggerEvent("onDestroy");
    for (var i = self2._handlers.length; i--; ) {
      self2._handlers[i].remove();
    }
    self2._handlers = [];
    if (self2.mobileInput) {
      if (self2.mobileInput.parentNode) self2.mobileInput.parentNode.removeChild(self2.mobileInput);
      self2.mobileInput = void 0;
    } else if (self2.calendarContainer && self2.calendarContainer.parentNode) {
      if (self2.config.static && self2.calendarContainer.parentNode) {
        var wrapper = self2.calendarContainer.parentNode;
        wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
        if (wrapper.parentNode) {
          while (wrapper.firstChild) wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
          wrapper.parentNode.removeChild(wrapper);
        }
      } else self2.calendarContainer.parentNode.removeChild(self2.calendarContainer);
    }
    if (self2.altInput) {
      self2.input.type = "text";
      if (self2.altInput.parentNode) self2.altInput.parentNode.removeChild(self2.altInput);
      delete self2.altInput;
    }
    if (self2.input) {
      self2.input.type = self2.input._type;
      self2.input.classList.remove("flatpickr-input");
      self2.input.removeAttribute("readonly");
    }
    ["_showTimeInput", "latestSelectedDateObj", "_hideNextMonthArrow", "_hidePrevMonthArrow", "__hideNextMonthArrow", "__hidePrevMonthArrow", "isMobile", "isOpen", "selectedDateElem", "minDateHasTime", "maxDateHasTime", "days", "daysContainer", "_input", "_positionElement", "innerContainer", "rContainer", "monthNav", "todayDateElem", "calendarContainer", "weekdayContainer", "prevMonthNav", "nextMonthNav", "monthsDropdownContainer", "currentMonthElement", "currentYearElement", "navigationCurrentMonth", "selectedDateElem", "config"].forEach(function(k) {
      try {
        delete self2[k];
      } catch (_) {
      }
    });
  }
  function isCalendarElem(elem) {
    return self2.calendarContainer.contains(elem);
  }
  function documentClick(e) {
    if (self2.isOpen && !self2.config.inline) {
      var eventTarget_1 = getEventTarget(e);
      var isCalendarElement = isCalendarElem(eventTarget_1);
      var isInput = eventTarget_1 === self2.input || eventTarget_1 === self2.altInput || self2.element.contains(eventTarget_1) || e.path && e.path.indexOf && (~e.path.indexOf(self2.input) || ~e.path.indexOf(self2.altInput));
      var lostFocus = !isInput && !isCalendarElement && !isCalendarElem(e.relatedTarget);
      var isIgnored = !self2.config.ignoredFocusElements.some(function(elem) {
        return elem.contains(eventTarget_1);
      });
      if (lostFocus && isIgnored) {
        if (self2.config.allowInput) {
          self2.setDate(self2._input.value, false, self2.config.altInput ? self2.config.altFormat : self2.config.dateFormat);
        }
        if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0 && self2.input.value !== "" && self2.input.value !== void 0) {
          updateTime();
        }
        self2.close();
        if (self2.config && self2.config.mode === "range" && self2.selectedDates.length === 1) self2.clear(false);
      }
    }
  }
  function changeYear(newYear) {
    if (!newYear || self2.config.minDate && newYear < self2.config.minDate.getFullYear() || self2.config.maxDate && newYear > self2.config.maxDate.getFullYear()) return;
    var newYearNum = newYear, isNewYear = self2.currentYear !== newYearNum;
    self2.currentYear = newYearNum || self2.currentYear;
    if (self2.config.maxDate && self2.currentYear === self2.config.maxDate.getFullYear()) {
      self2.currentMonth = Math.min(self2.config.maxDate.getMonth(), self2.currentMonth);
    } else if (self2.config.minDate && self2.currentYear === self2.config.minDate.getFullYear()) {
      self2.currentMonth = Math.max(self2.config.minDate.getMonth(), self2.currentMonth);
    }
    if (isNewYear) {
      self2.redraw();
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
  }
  function isEnabled(date, timeless) {
    var _a2;
    if (timeless === void 0) {
      timeless = true;
    }
    var dateToCheck = self2.parseDate(date, void 0, timeless);
    if (self2.config.minDate && dateToCheck && compareDates(dateToCheck, self2.config.minDate, timeless !== void 0 ? timeless : !self2.minDateHasTime) < 0 || self2.config.maxDate && dateToCheck && compareDates(dateToCheck, self2.config.maxDate, timeless !== void 0 ? timeless : !self2.maxDateHasTime) > 0) return false;
    if (!self2.config.enable && self2.config.disable.length === 0) return true;
    if (dateToCheck === void 0) return false;
    var bool = !!self2.config.enable, array = (_a2 = self2.config.enable) !== null && _a2 !== void 0 ? _a2 : self2.config.disable;
    for (var i = 0, d = void 0; i < array.length; i++) {
      d = array[i];
      if (typeof d === "function" && d(dateToCheck)) return bool;
      else if (d instanceof Date && dateToCheck !== void 0 && d.getTime() === dateToCheck.getTime()) return bool;
      else if (typeof d === "string") {
        var parsed = self2.parseDate(d, void 0, true);
        return parsed && parsed.getTime() === dateToCheck.getTime() ? bool : !bool;
      } else if (typeof d === "object" && dateToCheck !== void 0 && d.from && d.to && dateToCheck.getTime() >= d.from.getTime() && dateToCheck.getTime() <= d.to.getTime()) return bool;
    }
    return !bool;
  }
  function isInView(elem) {
    if (self2.daysContainer !== void 0) return elem.className.indexOf("hidden") === -1 && elem.className.indexOf("flatpickr-disabled") === -1 && self2.daysContainer.contains(elem);
    return false;
  }
  function onBlur(e) {
    var isInput = e.target === self2._input;
    var valueChanged = self2._input.value.trimEnd() !== getDateStr();
    if (isInput && valueChanged && !(e.relatedTarget && isCalendarElem(e.relatedTarget))) {
      self2.setDate(self2._input.value, true, e.target === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
    }
  }
  function onKeyDown(e) {
    var eventTarget = getEventTarget(e);
    var isInput = self2.config.wrap ? element.contains(eventTarget) : eventTarget === self2._input;
    var allowInput = self2.config.allowInput;
    var allowKeydown = self2.isOpen && (!allowInput || !isInput);
    var allowInlineKeydown = self2.config.inline && isInput && !allowInput;
    if (e.keyCode === 13 && isInput) {
      if (allowInput) {
        self2.setDate(self2._input.value, true, eventTarget === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
        self2.close();
        return eventTarget.blur();
      } else {
        self2.open();
      }
    } else if (isCalendarElem(eventTarget) || allowKeydown || allowInlineKeydown) {
      var isTimeObj = !!self2.timeContainer && self2.timeContainer.contains(eventTarget);
      switch (e.keyCode) {
        case 13:
          if (isTimeObj) {
            e.preventDefault();
            updateTime();
            focusAndClose();
          } else selectDate(e);
          break;
        case 27:
          e.preventDefault();
          focusAndClose();
          break;
        case 8:
        case 46:
          if (isInput && !self2.config.allowInput) {
            e.preventDefault();
            self2.clear();
          }
          break;
        case 37:
        case 39:
          if (!isTimeObj && !isInput) {
            e.preventDefault();
            var activeElement = getClosestActiveElement();
            if (self2.daysContainer !== void 0 && (allowInput === false || activeElement && isInView(activeElement))) {
              var delta_1 = e.keyCode === 39 ? 1 : -1;
              if (!e.ctrlKey) focusOnDay(void 0, delta_1);
              else {
                e.stopPropagation();
                changeMonth(delta_1);
                focusOnDay(getFirstAvailableDay(1), 0);
              }
            }
          } else if (self2.hourElement) self2.hourElement.focus();
          break;
        case 38:
        case 40:
          e.preventDefault();
          var delta = e.keyCode === 40 ? 1 : -1;
          if (self2.daysContainer && eventTarget.$i !== void 0 || eventTarget === self2.input || eventTarget === self2.altInput) {
            if (e.ctrlKey) {
              e.stopPropagation();
              changeYear(self2.currentYear - delta);
              focusOnDay(getFirstAvailableDay(1), 0);
            } else if (!isTimeObj) focusOnDay(void 0, delta * 7);
          } else if (eventTarget === self2.currentYearElement) {
            changeYear(self2.currentYear - delta);
          } else if (self2.config.enableTime) {
            if (!isTimeObj && self2.hourElement) self2.hourElement.focus();
            updateTime(e);
            self2._debouncedChange();
          }
          break;
        case 9:
          if (isTimeObj) {
            var elems = [self2.hourElement, self2.minuteElement, self2.secondElement, self2.amPM].concat(self2.pluginElements).filter(function(x) {
              return x;
            });
            var i = elems.indexOf(eventTarget);
            if (i !== -1) {
              var target = elems[i + (e.shiftKey ? -1 : 1)];
              e.preventDefault();
              (target || self2._input).focus();
            }
          } else if (!self2.config.noCalendar && self2.daysContainer && self2.daysContainer.contains(eventTarget) && e.shiftKey) {
            e.preventDefault();
            self2._input.focus();
          }
          break;
        default:
          break;
      }
    }
    if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
      switch (e.key) {
        case self2.l10n.amPM[0].charAt(0):
        case self2.l10n.amPM[0].charAt(0).toLowerCase():
          self2.amPM.textContent = self2.l10n.amPM[0];
          setHoursFromInputs();
          updateValue();
          break;
        case self2.l10n.amPM[1].charAt(0):
        case self2.l10n.amPM[1].charAt(0).toLowerCase():
          self2.amPM.textContent = self2.l10n.amPM[1];
          setHoursFromInputs();
          updateValue();
          break;
      }
    }
    if (isInput || isCalendarElem(eventTarget)) {
      triggerEvent("onKeyDown", e);
    }
  }
  function onMouseOver(elem, cellClass) {
    if (cellClass === void 0) {
      cellClass = "flatpickr-day";
    }
    if (self2.selectedDates.length !== 1 || elem && (!elem.classList.contains(cellClass) || elem.classList.contains("flatpickr-disabled"))) return;
    var hoverDate = elem ? elem.dateObj.getTime() : self2.days.firstElementChild.dateObj.getTime(), initialDate = self2.parseDate(self2.selectedDates[0], void 0, true).getTime(), rangeStartDate = Math.min(hoverDate, self2.selectedDates[0].getTime()), rangeEndDate = Math.max(hoverDate, self2.selectedDates[0].getTime());
    var containsDisabled = false;
    var minRange = 0, maxRange = 0;
    for (var t = rangeStartDate; t < rangeEndDate; t += duration.DAY) {
      if (!isEnabled(new Date(t), true)) {
        containsDisabled = containsDisabled || t > rangeStartDate && t < rangeEndDate;
        if (t < initialDate && (!minRange || t > minRange)) minRange = t;
        else if (t > initialDate && (!maxRange || t < maxRange)) maxRange = t;
      }
    }
    var hoverableCells = Array.from(self2.rContainer.querySelectorAll("*:nth-child(-n+" + self2.config.showMonths + ") > ." + cellClass));
    hoverableCells.forEach(function(dayElem) {
      var date = dayElem.dateObj;
      var timestamp = date.getTime();
      var outOfRange = minRange > 0 && timestamp < minRange || maxRange > 0 && timestamp > maxRange;
      if (outOfRange) {
        dayElem.classList.add("notAllowed");
        ["inRange", "startRange", "endRange"].forEach(function(c) {
          dayElem.classList.remove(c);
        });
        return;
      } else if (containsDisabled && !outOfRange) return;
      ["startRange", "inRange", "endRange", "notAllowed"].forEach(function(c) {
        dayElem.classList.remove(c);
      });
      if (elem !== void 0) {
        elem.classList.add(hoverDate <= self2.selectedDates[0].getTime() ? "startRange" : "endRange");
        if (initialDate < hoverDate && timestamp === initialDate) dayElem.classList.add("startRange");
        else if (initialDate > hoverDate && timestamp === initialDate) dayElem.classList.add("endRange");
        if (timestamp >= minRange && (maxRange === 0 || timestamp <= maxRange) && isBetween(timestamp, initialDate, hoverDate)) dayElem.classList.add("inRange");
      }
    });
  }
  function onResize() {
    if (self2.isOpen && !self2.config.static && !self2.config.inline) positionCalendar();
  }
  function open2(e, positionElement) {
    if (positionElement === void 0) {
      positionElement = self2._positionElement;
    }
    if (self2.isMobile === true) {
      if (e) {
        e.preventDefault();
        var eventTarget = getEventTarget(e);
        if (eventTarget) {
          eventTarget.blur();
        }
      }
      if (self2.mobileInput !== void 0) {
        self2.mobileInput.focus();
        self2.mobileInput.click();
      }
      triggerEvent("onOpen");
      return;
    } else if (self2._input.disabled || self2.config.inline) {
      return;
    }
    var wasOpen = self2.isOpen;
    self2.isOpen = true;
    if (!wasOpen) {
      self2.calendarContainer.classList.add("open");
      self2._input.classList.add("active");
      triggerEvent("onOpen");
      positionCalendar(positionElement);
    }
    if (self2.config.enableTime === true && self2.config.noCalendar === true) {
      if (self2.config.allowInput === false && (e === void 0 || !self2.timeContainer.contains(e.relatedTarget))) {
        setTimeout(function() {
          return self2.hourElement.select();
        }, 50);
      }
    }
  }
  function minMaxDateSetter(type) {
    return function(date) {
      var dateObj = self2.config["_" + type + "Date"] = self2.parseDate(date, self2.config.dateFormat);
      var inverseDateObj = self2.config["_" + (type === "min" ? "max" : "min") + "Date"];
      if (dateObj !== void 0) {
        self2[type === "min" ? "minDateHasTime" : "maxDateHasTime"] = dateObj.getHours() > 0 || dateObj.getMinutes() > 0 || dateObj.getSeconds() > 0;
      }
      if (self2.selectedDates) {
        self2.selectedDates = self2.selectedDates.filter(function(d) {
          return isEnabled(d);
        });
        if (!self2.selectedDates.length && type === "min") setHoursFromDate(dateObj);
        updateValue();
      }
      if (self2.daysContainer) {
        redraw();
        if (dateObj !== void 0) self2.currentYearElement[type] = dateObj.getFullYear().toString();
        else self2.currentYearElement.removeAttribute(type);
        self2.currentYearElement.disabled = !!inverseDateObj && dateObj !== void 0 && inverseDateObj.getFullYear() === dateObj.getFullYear();
      }
    };
  }
  function parseConfig() {
    var boolOpts = ["wrap", "weekNumbers", "allowInput", "allowInvalidPreload", "clickOpens", "time_24hr", "enableTime", "noCalendar", "altInput", "shorthandCurrentMonth", "inline", "static", "enableSeconds", "disableMobile"];
    var userConfig = __assign(__assign({}, JSON.parse(JSON.stringify(element.dataset || {}))), instanceConfig);
    var formats2 = {};
    self2.config.parseDate = userConfig.parseDate;
    self2.config.formatDate = userConfig.formatDate;
    Object.defineProperty(self2.config, "enable", {
      get: function() {
        return self2.config._enable;
      },
      set: function(dates) {
        self2.config._enable = parseDateRules(dates);
      }
    });
    Object.defineProperty(self2.config, "disable", {
      get: function() {
        return self2.config._disable;
      },
      set: function(dates) {
        self2.config._disable = parseDateRules(dates);
      }
    });
    var timeMode = userConfig.mode === "time";
    if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
      var defaultDateFormat = flatpickr.defaultConfig.dateFormat || defaults.dateFormat;
      formats2.dateFormat = userConfig.noCalendar || timeMode ? "H:i" + (userConfig.enableSeconds ? ":S" : "") : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
    }
    if (userConfig.altInput && (userConfig.enableTime || timeMode) && !userConfig.altFormat) {
      var defaultAltFormat = flatpickr.defaultConfig.altFormat || defaults.altFormat;
      formats2.altFormat = userConfig.noCalendar || timeMode ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K") : defaultAltFormat + (" h:i" + (userConfig.enableSeconds ? ":S" : "") + " K");
    }
    Object.defineProperty(self2.config, "minDate", {
      get: function() {
        return self2.config._minDate;
      },
      set: minMaxDateSetter("min")
    });
    Object.defineProperty(self2.config, "maxDate", {
      get: function() {
        return self2.config._maxDate;
      },
      set: minMaxDateSetter("max")
    });
    var minMaxTimeSetter = function(type) {
      return function(val) {
        self2.config[type === "min" ? "_minTime" : "_maxTime"] = self2.parseDate(val, "H:i:S");
      };
    };
    Object.defineProperty(self2.config, "minTime", {
      get: function() {
        return self2.config._minTime;
      },
      set: minMaxTimeSetter("min")
    });
    Object.defineProperty(self2.config, "maxTime", {
      get: function() {
        return self2.config._maxTime;
      },
      set: minMaxTimeSetter("max")
    });
    if (userConfig.mode === "time") {
      self2.config.noCalendar = true;
      self2.config.enableTime = true;
    }
    Object.assign(self2.config, formats2, userConfig);
    for (var i = 0; i < boolOpts.length; i++) self2.config[boolOpts[i]] = self2.config[boolOpts[i]] === true || self2.config[boolOpts[i]] === "true";
    HOOKS.filter(function(hook) {
      return self2.config[hook] !== void 0;
    }).forEach(function(hook) {
      self2.config[hook] = arrayify(self2.config[hook] || []).map(bindToInstance);
    });
    self2.isMobile = !self2.config.disableMobile && !self2.config.inline && self2.config.mode === "single" && !self2.config.disable.length && !self2.config.enable && !self2.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    for (var i = 0; i < self2.config.plugins.length; i++) {
      var pluginConf = self2.config.plugins[i](self2) || {};
      for (var key in pluginConf) {
        if (HOOKS.indexOf(key) > -1) {
          self2.config[key] = arrayify(pluginConf[key]).map(bindToInstance).concat(self2.config[key]);
        } else if (typeof userConfig[key] === "undefined") self2.config[key] = pluginConf[key];
      }
    }
    if (!userConfig.altInputClass) {
      self2.config.altInputClass = getInputElem().className + " " + self2.config.altInputClass;
    }
    triggerEvent("onParseConfig");
  }
  function getInputElem() {
    return self2.config.wrap ? element.querySelector("[data-input]") : element;
  }
  function setupLocale() {
    if (typeof self2.config.locale !== "object" && typeof flatpickr.l10ns[self2.config.locale] === "undefined") self2.config.errorHandler(new Error("flatpickr: invalid locale " + self2.config.locale));
    self2.l10n = __assign(__assign({}, flatpickr.l10ns.default), typeof self2.config.locale === "object" ? self2.config.locale : self2.config.locale !== "default" ? flatpickr.l10ns[self2.config.locale] : void 0);
    tokenRegex.D = "(" + self2.l10n.weekdays.shorthand.join("|") + ")";
    tokenRegex.l = "(" + self2.l10n.weekdays.longhand.join("|") + ")";
    tokenRegex.M = "(" + self2.l10n.months.shorthand.join("|") + ")";
    tokenRegex.F = "(" + self2.l10n.months.longhand.join("|") + ")";
    tokenRegex.K = "(" + self2.l10n.amPM[0] + "|" + self2.l10n.amPM[1] + "|" + self2.l10n.amPM[0].toLowerCase() + "|" + self2.l10n.amPM[1].toLowerCase() + ")";
    var userConfig = __assign(__assign({}, instanceConfig), JSON.parse(JSON.stringify(element.dataset || {})));
    if (userConfig.time_24hr === void 0 && flatpickr.defaultConfig.time_24hr === void 0) {
      self2.config.time_24hr = self2.l10n.time_24hr;
    }
    self2.formatDate = createDateFormatter(self2);
    self2.parseDate = createDateParser({
      config: self2.config,
      l10n: self2.l10n
    });
  }
  function positionCalendar(customPositionElement) {
    if (typeof self2.config.position === "function") {
      return void self2.config.position(self2, customPositionElement);
    }
    if (self2.calendarContainer === void 0) return;
    triggerEvent("onPreCalendarPosition");
    var positionElement = customPositionElement || self2._positionElement;
    var calendarHeight = Array.prototype.reduce.call(self2.calendarContainer.children, function(acc, child) {
      return acc + child.offsetHeight;
    }, 0), calendarWidth = self2.calendarContainer.offsetWidth, configPos = self2.config.position.split(" "), configPosVertical = configPos[0], configPosHorizontal = configPos.length > 1 ? configPos[1] : null, inputBounds = positionElement.getBoundingClientRect(), distanceFromBottom = window.innerHeight - inputBounds.bottom, showOnTop = configPosVertical === "above" || configPosVertical !== "below" && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;
    var top = window.pageYOffset + inputBounds.top + (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
    toggleClass(self2.calendarContainer, "arrowTop", !showOnTop);
    toggleClass(self2.calendarContainer, "arrowBottom", showOnTop);
    if (self2.config.inline) return;
    var left = window.pageXOffset + inputBounds.left;
    var isCenter = false;
    var isRight = false;
    if (configPosHorizontal === "center") {
      left -= (calendarWidth - inputBounds.width) / 2;
      isCenter = true;
    } else if (configPosHorizontal === "right") {
      left -= calendarWidth - inputBounds.width;
      isRight = true;
    }
    toggleClass(self2.calendarContainer, "arrowLeft", !isCenter && !isRight);
    toggleClass(self2.calendarContainer, "arrowCenter", isCenter);
    toggleClass(self2.calendarContainer, "arrowRight", isRight);
    var right = window.document.body.offsetWidth - (window.pageXOffset + inputBounds.right);
    var rightMost = left + calendarWidth > window.document.body.offsetWidth;
    var centerMost = right + calendarWidth > window.document.body.offsetWidth;
    toggleClass(self2.calendarContainer, "rightMost", rightMost);
    if (self2.config.static) return;
    self2.calendarContainer.style.top = top + "px";
    if (!rightMost) {
      self2.calendarContainer.style.left = left + "px";
      self2.calendarContainer.style.right = "auto";
    } else if (!centerMost) {
      self2.calendarContainer.style.left = "auto";
      self2.calendarContainer.style.right = right + "px";
    } else {
      var doc = getDocumentStyleSheet();
      if (doc === void 0) return;
      var bodyWidth = window.document.body.offsetWidth;
      var centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
      var centerBefore = ".flatpickr-calendar.centerMost:before";
      var centerAfter = ".flatpickr-calendar.centerMost:after";
      var centerIndex = doc.cssRules.length;
      var centerStyle = "{left:" + inputBounds.left + "px;right:auto;}";
      toggleClass(self2.calendarContainer, "rightMost", false);
      toggleClass(self2.calendarContainer, "centerMost", true);
      doc.insertRule(centerBefore + "," + centerAfter + centerStyle, centerIndex);
      self2.calendarContainer.style.left = centerLeft + "px";
      self2.calendarContainer.style.right = "auto";
    }
  }
  function getDocumentStyleSheet() {
    var editableSheet = null;
    for (var i = 0; i < document.styleSheets.length; i++) {
      var sheet = document.styleSheets[i];
      if (!sheet.cssRules) continue;
      try {
        sheet.cssRules;
      } catch (err) {
        continue;
      }
      editableSheet = sheet;
      break;
    }
    return editableSheet != null ? editableSheet : createStyleSheet();
  }
  function createStyleSheet() {
    var style = document.createElement("style");
    document.head.appendChild(style);
    return style.sheet;
  }
  function redraw() {
    if (self2.config.noCalendar || self2.isMobile) return;
    buildMonthSwitch();
    updateNavigationCurrentMonth();
    buildDays();
  }
  function focusAndClose() {
    self2._input.focus();
    if (window.navigator.userAgent.indexOf("MSIE") !== -1 || navigator.msMaxTouchPoints !== void 0) {
      setTimeout(self2.close, 0);
    } else {
      self2.close();
    }
  }
  function selectDate(e) {
    e.preventDefault();
    e.stopPropagation();
    var isSelectable = function(day) {
      return day.classList && day.classList.contains("flatpickr-day") && !day.classList.contains("flatpickr-disabled") && !day.classList.contains("notAllowed");
    };
    var t = findParent(getEventTarget(e), isSelectable);
    if (t === void 0) return;
    var target = t;
    var selectedDate = self2.latestSelectedDateObj = new Date(target.dateObj.getTime());
    var shouldChangeMonth = (selectedDate.getMonth() < self2.currentMonth || selectedDate.getMonth() > self2.currentMonth + self2.config.showMonths - 1) && self2.config.mode !== "range";
    self2.selectedDateElem = target;
    if (self2.config.mode === "single") self2.selectedDates = [selectedDate];
    else if (self2.config.mode === "multiple") {
      var selectedIndex = isDateSelected(selectedDate);
      if (selectedIndex) self2.selectedDates.splice(parseInt(selectedIndex), 1);
      else self2.selectedDates.push(selectedDate);
    } else if (self2.config.mode === "range") {
      if (self2.selectedDates.length === 2) {
        self2.clear(false, false);
      }
      self2.latestSelectedDateObj = selectedDate;
      self2.selectedDates.push(selectedDate);
      if (compareDates(selectedDate, self2.selectedDates[0], true) !== 0) self2.selectedDates.sort(function(a, b) {
        return a.getTime() - b.getTime();
      });
    }
    setHoursFromInputs();
    if (shouldChangeMonth) {
      var isNewYear = self2.currentYear !== selectedDate.getFullYear();
      self2.currentYear = selectedDate.getFullYear();
      self2.currentMonth = selectedDate.getMonth();
      if (isNewYear) {
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }
      triggerEvent("onMonthChange");
    }
    updateNavigationCurrentMonth();
    buildDays();
    updateValue();
    if (!shouldChangeMonth && self2.config.mode !== "range" && self2.config.showMonths === 1) focusOnDayElem(target);
    else if (self2.selectedDateElem !== void 0 && self2.hourElement === void 0) {
      self2.selectedDateElem && self2.selectedDateElem.focus();
    }
    if (self2.hourElement !== void 0) self2.hourElement !== void 0 && self2.hourElement.focus();
    if (self2.config.closeOnSelect) {
      var single = self2.config.mode === "single" && !self2.config.enableTime;
      var range2 = self2.config.mode === "range" && self2.selectedDates.length === 2 && !self2.config.enableTime;
      if (single || range2) {
        focusAndClose();
      }
    }
    triggerChange();
  }
  var CALLBACKS = {
    locale: [setupLocale, updateWeekdays],
    showMonths: [buildMonths, setCalendarWidth, buildWeekdays],
    minDate: [jumpToDate],
    maxDate: [jumpToDate],
    positionElement: [updatePositionElement],
    clickOpens: [function() {
      if (self2.config.clickOpens === true) {
        bind(self2._input, "focus", self2.open);
        bind(self2._input, "click", self2.open);
      } else {
        self2._input.removeEventListener("focus", self2.open);
        self2._input.removeEventListener("click", self2.open);
      }
    }]
  };
  function set(option, value) {
    if (option !== null && typeof option === "object") {
      Object.assign(self2.config, option);
      for (var key in option) {
        if (CALLBACKS[key] !== void 0) CALLBACKS[key].forEach(function(x) {
          return x();
        });
      }
    } else {
      self2.config[option] = value;
      if (CALLBACKS[option] !== void 0) CALLBACKS[option].forEach(function(x) {
        return x();
      });
      else if (HOOKS.indexOf(option) > -1) self2.config[option] = arrayify(value);
    }
    self2.redraw();
    updateValue(true);
  }
  function setSelectedDate(inputDate, format) {
    var dates = [];
    if (inputDate instanceof Array) dates = inputDate.map(function(d) {
      return self2.parseDate(d, format);
    });
    else if (inputDate instanceof Date || typeof inputDate === "number") dates = [self2.parseDate(inputDate, format)];
    else if (typeof inputDate === "string") {
      switch (self2.config.mode) {
        case "single":
        case "time":
          dates = [self2.parseDate(inputDate, format)];
          break;
        case "multiple":
          dates = inputDate.split(self2.config.conjunction).map(function(date) {
            return self2.parseDate(date, format);
          });
          break;
        case "range":
          dates = inputDate.split(self2.l10n.rangeSeparator).map(function(date) {
            return self2.parseDate(date, format);
          });
          break;
        default:
          break;
      }
    } else self2.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));
    self2.selectedDates = self2.config.allowInvalidPreload ? dates : dates.filter(function(d) {
      return d instanceof Date && isEnabled(d, false);
    });
    if (self2.config.mode === "range") self2.selectedDates.sort(function(a, b) {
      return a.getTime() - b.getTime();
    });
  }
  function setDate(date, triggerChange2, format) {
    if (triggerChange2 === void 0) {
      triggerChange2 = false;
    }
    if (format === void 0) {
      format = self2.config.dateFormat;
    }
    if (date !== 0 && !date || date instanceof Array && date.length === 0) return self2.clear(triggerChange2);
    setSelectedDate(date, format);
    self2.latestSelectedDateObj = self2.selectedDates[self2.selectedDates.length - 1];
    self2.redraw();
    jumpToDate(void 0, triggerChange2);
    setHoursFromDate();
    if (self2.selectedDates.length === 0) {
      self2.clear(false);
    }
    updateValue(triggerChange2);
    if (triggerChange2) triggerEvent("onChange");
  }
  function parseDateRules(arr) {
    return arr.slice().map(function(rule) {
      if (typeof rule === "string" || typeof rule === "number" || rule instanceof Date) {
        return self2.parseDate(rule, void 0, true);
      } else if (rule && typeof rule === "object" && rule.from && rule.to) return {
        from: self2.parseDate(rule.from, void 0),
        to: self2.parseDate(rule.to, void 0)
      };
      return rule;
    }).filter(function(x) {
      return x;
    });
  }
  function setupDates() {
    self2.selectedDates = [];
    self2.now = self2.parseDate(self2.config.now) || /* @__PURE__ */ new Date();
    var preloadedDate = self2.config.defaultDate || ((self2.input.nodeName === "INPUT" || self2.input.nodeName === "TEXTAREA") && self2.input.placeholder && self2.input.value === self2.input.placeholder ? null : self2.input.value);
    if (preloadedDate) setSelectedDate(preloadedDate, self2.config.dateFormat);
    self2._initialDate = self2.selectedDates.length > 0 ? self2.selectedDates[0] : self2.config.minDate && self2.config.minDate.getTime() > self2.now.getTime() ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate.getTime() < self2.now.getTime() ? self2.config.maxDate : self2.now;
    self2.currentYear = self2._initialDate.getFullYear();
    self2.currentMonth = self2._initialDate.getMonth();
    if (self2.selectedDates.length > 0) self2.latestSelectedDateObj = self2.selectedDates[0];
    if (self2.config.minTime !== void 0) self2.config.minTime = self2.parseDate(self2.config.minTime, "H:i");
    if (self2.config.maxTime !== void 0) self2.config.maxTime = self2.parseDate(self2.config.maxTime, "H:i");
    self2.minDateHasTime = !!self2.config.minDate && (self2.config.minDate.getHours() > 0 || self2.config.minDate.getMinutes() > 0 || self2.config.minDate.getSeconds() > 0);
    self2.maxDateHasTime = !!self2.config.maxDate && (self2.config.maxDate.getHours() > 0 || self2.config.maxDate.getMinutes() > 0 || self2.config.maxDate.getSeconds() > 0);
  }
  function setupInputs() {
    self2.input = getInputElem();
    if (!self2.input) {
      self2.config.errorHandler(new Error("Invalid input element specified"));
      return;
    }
    self2.input._type = self2.input.type;
    self2.input.type = "text";
    self2.input.classList.add("flatpickr-input");
    self2._input = self2.input;
    if (self2.config.altInput) {
      self2.altInput = createElement(self2.input.nodeName, self2.config.altInputClass);
      self2._input = self2.altInput;
      self2.altInput.placeholder = self2.input.placeholder;
      self2.altInput.disabled = self2.input.disabled;
      self2.altInput.required = self2.input.required;
      self2.altInput.tabIndex = self2.input.tabIndex;
      self2.altInput.type = "text";
      self2.input.setAttribute("type", "hidden");
      if (!self2.config.static && self2.input.parentNode) self2.input.parentNode.insertBefore(self2.altInput, self2.input.nextSibling);
    }
    if (!self2.config.allowInput) self2._input.setAttribute("readonly", "readonly");
    updatePositionElement();
  }
  function updatePositionElement() {
    self2._positionElement = self2.config.positionElement || self2._input;
  }
  function setupMobile() {
    var inputType = self2.config.enableTime ? self2.config.noCalendar ? "time" : "datetime-local" : "date";
    self2.mobileInput = createElement("input", self2.input.className + " flatpickr-mobile");
    self2.mobileInput.tabIndex = 1;
    self2.mobileInput.type = inputType;
    self2.mobileInput.disabled = self2.input.disabled;
    self2.mobileInput.required = self2.input.required;
    self2.mobileInput.placeholder = self2.input.placeholder;
    self2.mobileFormatStr = inputType === "datetime-local" ? "Y-m-d\\TH:i:S" : inputType === "date" ? "Y-m-d" : "H:i:S";
    if (self2.selectedDates.length > 0) {
      self2.mobileInput.defaultValue = self2.mobileInput.value = self2.formatDate(self2.selectedDates[0], self2.mobileFormatStr);
    }
    if (self2.config.minDate) self2.mobileInput.min = self2.formatDate(self2.config.minDate, "Y-m-d");
    if (self2.config.maxDate) self2.mobileInput.max = self2.formatDate(self2.config.maxDate, "Y-m-d");
    if (self2.input.getAttribute("step")) self2.mobileInput.step = String(self2.input.getAttribute("step"));
    self2.input.type = "hidden";
    if (self2.altInput !== void 0) self2.altInput.type = "hidden";
    try {
      if (self2.input.parentNode) self2.input.parentNode.insertBefore(self2.mobileInput, self2.input.nextSibling);
    } catch (_a2) {
    }
    bind(self2.mobileInput, "change", function(e) {
      self2.setDate(getEventTarget(e).value, false, self2.mobileFormatStr);
      triggerEvent("onChange");
      triggerEvent("onClose");
    });
  }
  function toggle(e) {
    if (self2.isOpen === true) return self2.close();
    self2.open(e);
  }
  function triggerEvent(event, data) {
    if (self2.config === void 0) return;
    var hooks = self2.config[event];
    if (hooks !== void 0 && hooks.length > 0) {
      for (var i = 0; hooks[i] && i < hooks.length; i++) hooks[i](self2.selectedDates, self2.input.value, self2, data);
    }
    if (event === "onChange") {
      self2.input.dispatchEvent(createEvent("change"));
      self2.input.dispatchEvent(createEvent("input"));
    }
  }
  function createEvent(name) {
    var e = document.createEvent("Event");
    e.initEvent(name, true, true);
    return e;
  }
  function isDateSelected(date) {
    for (var i = 0; i < self2.selectedDates.length; i++) {
      var selectedDate = self2.selectedDates[i];
      if (selectedDate instanceof Date && compareDates(selectedDate, date) === 0) return "" + i;
    }
    return false;
  }
  function isDateInRange(date) {
    if (self2.config.mode !== "range" || self2.selectedDates.length < 2) return false;
    return compareDates(date, self2.selectedDates[0]) >= 0 && compareDates(date, self2.selectedDates[1]) <= 0;
  }
  function updateNavigationCurrentMonth() {
    if (self2.config.noCalendar || self2.isMobile || !self2.monthNav) return;
    self2.yearElements.forEach(function(yearElement, i) {
      var d = new Date(self2.currentYear, self2.currentMonth, 1);
      d.setMonth(self2.currentMonth + i);
      if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
        self2.monthElements[i].textContent = monthToStr(d.getMonth(), self2.config.shorthandCurrentMonth, self2.l10n) + " ";
      } else {
        self2.monthsDropdownContainer.value = d.getMonth().toString();
      }
      yearElement.value = d.getFullYear().toString();
    });
    self2._hidePrevMonthArrow = self2.config.minDate !== void 0 && (self2.currentYear === self2.config.minDate.getFullYear() ? self2.currentMonth <= self2.config.minDate.getMonth() : self2.currentYear < self2.config.minDate.getFullYear());
    self2._hideNextMonthArrow = self2.config.maxDate !== void 0 && (self2.currentYear === self2.config.maxDate.getFullYear() ? self2.currentMonth + 1 > self2.config.maxDate.getMonth() : self2.currentYear > self2.config.maxDate.getFullYear());
  }
  function getDateStr(specificFormat) {
    var format = specificFormat || (self2.config.altInput ? self2.config.altFormat : self2.config.dateFormat);
    return self2.selectedDates.map(function(dObj) {
      return self2.formatDate(dObj, format);
    }).filter(function(d, i, arr) {
      return self2.config.mode !== "range" || self2.config.enableTime || arr.indexOf(d) === i;
    }).join(self2.config.mode !== "range" ? self2.config.conjunction : self2.l10n.rangeSeparator);
  }
  function updateValue(triggerChange2) {
    if (triggerChange2 === void 0) {
      triggerChange2 = true;
    }
    if (self2.mobileInput !== void 0 && self2.mobileFormatStr) {
      self2.mobileInput.value = self2.latestSelectedDateObj !== void 0 ? self2.formatDate(self2.latestSelectedDateObj, self2.mobileFormatStr) : "";
    }
    self2.input.value = getDateStr(self2.config.dateFormat);
    if (self2.altInput !== void 0) {
      self2.altInput.value = getDateStr(self2.config.altFormat);
    }
    if (triggerChange2 !== false) triggerEvent("onValueUpdate");
  }
  function onMonthNavClick(e) {
    var eventTarget = getEventTarget(e);
    var isPrevMonth = self2.prevMonthNav.contains(eventTarget);
    var isNextMonth = self2.nextMonthNav.contains(eventTarget);
    if (isPrevMonth || isNextMonth) {
      changeMonth(isPrevMonth ? -1 : 1);
    } else if (self2.yearElements.indexOf(eventTarget) >= 0) {
      eventTarget.select();
    } else if (eventTarget.classList.contains("arrowUp")) {
      self2.changeYear(self2.currentYear + 1);
    } else if (eventTarget.classList.contains("arrowDown")) {
      self2.changeYear(self2.currentYear - 1);
    }
  }
  function timeWrapper(e) {
    e.preventDefault();
    var isKeyDown = e.type === "keydown", eventTarget = getEventTarget(e), input = eventTarget;
    if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
      self2.amPM.textContent = self2.l10n.amPM[int(self2.amPM.textContent === self2.l10n.amPM[0])];
    }
    var min2 = parseFloat(input.getAttribute("min")), max2 = parseFloat(input.getAttribute("max")), step = parseFloat(input.getAttribute("step")), curValue = parseInt(input.value, 10), delta = e.delta || (isKeyDown ? e.which === 38 ? 1 : -1 : 0);
    var newValue = curValue + step * delta;
    if (typeof input.value !== "undefined" && input.value.length === 2) {
      var isHourElem = input === self2.hourElement, isMinuteElem = input === self2.minuteElement;
      if (newValue < min2) {
        newValue = max2 + newValue + int(!isHourElem) + (int(isHourElem) && int(!self2.amPM));
        if (isMinuteElem) incrementNumInput(void 0, -1, self2.hourElement);
      } else if (newValue > max2) {
        newValue = input === self2.hourElement ? newValue - max2 - int(!self2.amPM) : min2;
        if (isMinuteElem) incrementNumInput(void 0, 1, self2.hourElement);
      }
      if (self2.amPM && isHourElem && (step === 1 ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) {
        self2.amPM.textContent = self2.l10n.amPM[int(self2.amPM.textContent === self2.l10n.amPM[0])];
      }
      input.value = pad(newValue);
    }
  }
  init();
  return self2;
}
function _flatpickr(nodeList, config2) {
  var nodes = Array.prototype.slice.call(nodeList).filter(function(x) {
    return x instanceof HTMLElement;
  });
  var instances = [];
  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    try {
      if (node.getAttribute("data-fp-omit") !== null) continue;
      if (node._flatpickr !== void 0) {
        node._flatpickr.destroy();
        node._flatpickr = void 0;
      }
      node._flatpickr = FlatpickrInstance(node, config2 || {});
      instances.push(node._flatpickr);
    } catch (e) {
      console.error(e);
    }
  }
  return instances.length === 1 ? instances[0] : instances;
}
if (typeof HTMLElement !== "undefined" && typeof HTMLCollection !== "undefined" && typeof NodeList !== "undefined") {
  HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function(config2) {
    return _flatpickr(this, config2);
  };
  HTMLElement.prototype.flatpickr = function(config2) {
    return _flatpickr([this], config2);
  };
}
var flatpickr = function(selector, config2) {
  if (typeof selector === "string") {
    return _flatpickr(window.document.querySelectorAll(selector), config2);
  } else if (selector instanceof Node) {
    return _flatpickr([selector], config2);
  } else {
    return _flatpickr(selector, config2);
  }
};
flatpickr.defaultConfig = {};
flatpickr.l10ns = {
  en: __assign({}, default_default),
  default: __assign({}, default_default)
};
flatpickr.localize = function(l10n) {
  flatpickr.l10ns.default = __assign(__assign({}, flatpickr.l10ns.default), l10n);
};
flatpickr.setDefaults = function(config2) {
  flatpickr.defaultConfig = __assign(__assign({}, flatpickr.defaultConfig), config2);
};
flatpickr.parseDate = createDateParser({});
flatpickr.formatDate = createDateFormatter({});
flatpickr.compareDates = compareDates;
if (typeof jQuery !== "undefined" && typeof jQuery.fn !== "undefined") {
  jQuery.fn.flatpickr = function(config2) {
    return _flatpickr(this, config2);
  };
}
Date.prototype.fp_incr = function(days) {
  return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
};
if (typeof window !== "undefined") {
  window.flatpickr = flatpickr;
}
var esm_default = flatpickr;

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-datepicker.mjs
var languages = __toESM(require_l10n(), 1);

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-datepicker-input.mjs
var _c015 = ["input"];
var _c114 = (a0, a1, a2, a3, a4) => ({
  "cds--date-picker--simple": a0,
  "cds--date-picker--single": a1,
  "cds--date-picker--range": a2,
  "cds--date-picker--light": a3,
  "cds--skeleton": a4
});
var _c210 = (a0) => ({
  "cds--label--disabled": a0
});
var _c37 = (a0, a1) => ({
  "cds--date-picker-input__wrapper--invalid": a0,
  "cds--date-picker-input__wrapper--warn": a1
});
var _c46 = (a0, a1, a2) => ({
  "cds--date-picker__input--sm": a0,
  "cds--date-picker__input--md": a1,
  "cds--date-picker__input--lg": a2
});
var _c54 = (a0) => ({
  "cds--form__helper-text--disabled": a0
});
function DatePickerInput_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "span", 9)(2, "div", 10);
    ɵɵelementContainerEnd();
  }
}
function DatePickerInput_label_4_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.label);
  }
}
function DatePickerInput_label_4_2_ng_template_0_Template(rf, ctx) {
}
function DatePickerInput_label_4_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, DatePickerInput_label_4_2_ng_template_0_Template, 0, 0, "ng-template", 12);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.label);
  }
}
function DatePickerInput_label_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "label", 11);
    ɵɵtemplate(1, DatePickerInput_label_4_ng_container_1_Template, 2, 1, "ng-container", 4)(2, DatePickerInput_label_4_2_Template, 1, 1, null, 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("for", ctx_r0.id)("ngClass", ɵɵpureFunction1(4, _c210, ctx_r0.disabled));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.label));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.label));
  }
}
function DatePickerInput_div_5__svg_svg_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 18);
  }
}
function DatePickerInput_div_5__svg_svg_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 19);
  }
}
function DatePickerInput_div_5__svg_svg_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 20);
  }
}
function DatePickerInput_div_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 13)(1, "span")(2, "input", 14, 0);
    ɵɵlistener("change", function DatePickerInput_div_5_Template_input_change_2_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onChange($event));
    });
    ɵɵelementEnd();
    ɵɵtemplate(4, DatePickerInput_div_5__svg_svg_4_Template, 1, 0, "svg", 15)(5, DatePickerInput_div_5__svg_svg_5_Template, 1, 0, "svg", 16)(6, DatePickerInput_div_5__svg_svg_6_Template, 1, 0, "svg", 17);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ɵɵpureFunction2(12, _c37, ctx_r0.invalid, ctx_r0.warn));
    ɵɵadvance(2);
    ɵɵproperty("ngClass", ɵɵpureFunction3(15, _c46, ctx_r0.size === "sm", ctx_r0.size === "md", ctx_r0.size === "lg"))("value", ctx_r0.value)("pattern", ctx_r0.pattern)("placeholder", ctx_r0.placeholder)("id", ctx_r0.id)("disabled", ctx_r0.disabled)("readonly", ctx_r0.readonly);
    ɵɵattribute("data-invalid", ctx_r0.invalid ? true : void 0);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r0.type !== "simple" && !ctx_r0.warn && !ctx_r0.invalid);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.invalid);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.invalid && ctx_r0.warn);
  }
}
function DatePickerInput_div_6_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.helperText);
  }
}
function DatePickerInput_div_6_2_ng_template_0_Template(rf, ctx) {
}
function DatePickerInput_div_6_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, DatePickerInput_div_6_2_ng_template_0_Template, 0, 0, "ng-template", 12);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.helperText);
  }
}
function DatePickerInput_div_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 21);
    ɵɵtemplate(1, DatePickerInput_div_6_ng_container_1_Template, 2, 1, "ng-container", 4)(2, DatePickerInput_div_6_2_Template, 1, 1, null, 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ɵɵpureFunction1(3, _c54, ctx_r0.disabled));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.helperText));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.helperText));
  }
}
function DatePickerInput_div_7_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.invalidText);
  }
}
function DatePickerInput_div_7_2_ng_template_0_Template(rf, ctx) {
}
function DatePickerInput_div_7_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, DatePickerInput_div_7_2_ng_template_0_Template, 0, 0, "ng-template", 12);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.invalidText);
  }
}
function DatePickerInput_div_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 22);
    ɵɵtemplate(1, DatePickerInput_div_7_ng_container_1_Template, 2, 1, "ng-container", 4)(2, DatePickerInput_div_7_2_Template, 1, 1, null, 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.invalidText));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.invalidText));
  }
}
function DatePickerInput_div_8_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.warnText);
  }
}
function DatePickerInput_div_8_2_ng_template_0_Template(rf, ctx) {
}
function DatePickerInput_div_8_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, DatePickerInput_div_8_2_ng_template_0_Template, 0, 0, "ng-template", 12);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.warnText);
  }
}
function DatePickerInput_div_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 22);
    ɵɵtemplate(1, DatePickerInput_div_8_ng_container_1_Template, 2, 1, "ng-container", 4)(2, DatePickerInput_div_8_2_Template, 1, 1, null, 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.warnText));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.warnText));
  }
}
var DatePickerInput = class _DatePickerInput {
  constructor(elementRef) {
    this.elementRef = elementRef;
    this.type = "simple";
    this.id = `datepicker-${_DatePickerInput.datePickerCount++}`;
    this.hasIcon = false;
    this.placeholder = "mm/dd/yyyy";
    this.pattern = "^\\d{1,2}/\\d{1,2}/\\d{4}$";
    this.valueChange = new EventEmitter();
    this.theme = "dark";
    this.disabled = false;
    this.readonly = false;
    this.invalid = false;
    this.warn = false;
    this.skeleton = false;
    this.value = "";
    this.size = "md";
    this.onTouched = () => {
    };
    this.propagateChange = (_) => {
    };
  }
  onChange(event) {
    this.value = event.target.value;
    this.valueChange.emit(this.value);
    this.propagateChange(this.value);
    this.onTouched();
  }
  writeValue(value) {
    this.value = value;
  }
  registerOnChange(fn) {
    this.propagateChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  isTemplate(value) {
    return value instanceof TemplateRef;
  }
};
DatePickerInput.datePickerCount = 0;
DatePickerInput.ɵfac = function DatePickerInput_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || DatePickerInput)(ɵɵdirectiveInject(ElementRef));
};
DatePickerInput.ɵcmp = ɵɵdefineComponent({
  type: DatePickerInput,
  selectors: [["cds-date-picker-input"], ["ibm-date-picker-input"]],
  viewQuery: function DatePickerInput_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c015, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.input = _t.first);
    }
  },
  inputs: {
    type: "type",
    id: "id",
    hasIcon: "hasIcon",
    label: "label",
    placeholder: "placeholder",
    pattern: "pattern",
    theme: "theme",
    disabled: "disabled",
    readonly: "readonly",
    invalid: "invalid",
    invalidText: "invalidText",
    warn: "warn",
    warnText: "warnText",
    helperText: "helperText",
    skeleton: "skeleton",
    value: "value",
    size: "size"
  },
  outputs: {
    valueChange: "valueChange"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: DatePickerInput,
    multi: true
  }])],
  decls: 9,
  vars: 13,
  consts: [["input", ""], [1, "cds--form-item"], [1, "cds--date-picker", 3, "ngClass"], [1, "cds--date-picker-container"], [4, "ngIf"], ["class", "cds--label", 3, "for", "ngClass", 4, "ngIf"], ["class", "cds--date-picker-input__wrapper", 3, "ngClass", 4, "ngIf"], ["class", "cds--form__helper-text", 3, "ngClass", 4, "ngIf"], ["class", "cds--form-requirement", 4, "ngIf"], [1, "cds--label", "cds--skeleton"], [1, "cds--date-picker__input", "cds--skeleton"], [1, "cds--label", 3, "for", "ngClass"], [3, "ngTemplateOutlet"], [1, "cds--date-picker-input__wrapper", 3, "ngClass"], ["autocomplete", "off", "type", "text", 1, "cds--date-picker__input", 3, "change", "ngClass", "value", "pattern", "placeholder", "id", "disabled", "readonly"], ["cdsIcon", "calendar", "size", "16", "class", "cds--date-picker__icon", 4, "ngIf"], ["class", "cds--date-picker__icon cds--date-picker__icon--invalid", "cdsIcon", "warning--filled", "size", "16", 4, "ngIf"], ["cdsIcon", "warning--alt--filled", "size", "16", "class", "cds--date-picker__icon cds--date-picker__icon--warn", 4, "ngIf"], ["cdsIcon", "calendar", "size", "16", 1, "cds--date-picker__icon"], ["cdsIcon", "warning--filled", "size", "16", 1, "cds--date-picker__icon", "cds--date-picker__icon--invalid"], ["cdsIcon", "warning--alt--filled", "size", "16", 1, "cds--date-picker__icon", "cds--date-picker__icon--warn"], [1, "cds--form__helper-text", 3, "ngClass"], [1, "cds--form-requirement"]],
  template: function DatePickerInput_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 1)(1, "div", 2)(2, "div", 3);
      ɵɵtemplate(3, DatePickerInput_ng_container_3_Template, 3, 0, "ng-container", 4)(4, DatePickerInput_label_4_Template, 3, 6, "label", 5)(5, DatePickerInput_div_5_Template, 7, 19, "div", 6)(6, DatePickerInput_div_6_Template, 3, 5, "div", 7)(7, DatePickerInput_div_7_Template, 3, 2, "div", 8)(8, DatePickerInput_div_8_Template, 3, 2, "div", 8);
      ɵɵelementEnd()()();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngClass", ɵɵpureFunction5(7, _c114, ctx.type === "simple", ctx.type === "single", ctx.type === "range", ctx.theme === "light", ctx.skeleton));
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.skeleton);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.label && !ctx.skeleton);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.skeleton);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.helperText && !ctx.invalid && !ctx.warn);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.invalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.invalid && ctx.warn);
    }
  },
  dependencies: [NgClass, NgIf, NgTemplateOutlet, IconDirective],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatePickerInput, [{
    type: Component,
    args: [{
      selector: "cds-date-picker-input, ibm-date-picker-input",
      template: `
	<div class="cds--form-item">
		<div class="cds--date-picker"
			[ngClass]="{
				'cds--date-picker--simple' : type === 'simple',
				'cds--date-picker--single' : type === 'single',
				'cds--date-picker--range' : type === 'range',
				'cds--date-picker--light' : theme === 'light',
				'cds--skeleton' : skeleton
			}">
			<div class="cds--date-picker-container">
				<!-- Skeleton structure -->
				<ng-container *ngIf="skeleton">
					<span class="cds--label cds--skeleton"></span>
					<div class="cds--date-picker__input cds--skeleton"></div>
				</ng-container>
				<label
					*ngIf="label && !skeleton"
					[for]="id"
					class="cds--label"
					[ngClass]="{'cds--label--disabled': disabled}">
					<ng-container *ngIf="!isTemplate(label)">{{label}}</ng-container>
					<ng-template *ngIf="isTemplate(label)" [ngTemplateOutlet]="label"></ng-template>
				</label>
				<div class="cds--date-picker-input__wrapper"
					*ngIf="!skeleton"
					[ngClass]="{
						'cds--date-picker-input__wrapper--invalid': invalid,
						'cds--date-picker-input__wrapper--warn': warn
					}">
					<span>
						<input
						#input
						autocomplete="off"
						type="text"
						class="cds--date-picker__input"
						[ngClass]="{
							'cds--date-picker__input--sm': size === 'sm',
							'cds--date-picker__input--md': size === 'md',
							'cds--date-picker__input--lg': size === 'lg'
						}"
						[attr.data-invalid]="invalid ? true : undefined"
						[value]="value"
						[pattern]="pattern"
						[placeholder]="placeholder"
						[id]= "id"
						[disabled]="disabled"
						[readonly]="readonly"
							(change)="onChange($event)"/>
							<svg
								*ngIf="type !== 'simple' && !warn && !invalid"
								cdsIcon="calendar"
								size="16"
								class="cds--date-picker__icon">
							</svg>
							<svg
								*ngIf="invalid"
								class="cds--date-picker__icon cds--date-picker__icon--invalid"
								cdsIcon="warning--filled"
								size="16">
							</svg>
							<svg
								*ngIf="!invalid && warn"
								cdsIcon="warning--alt--filled"
								size="16"
								class="cds--date-picker__icon cds--date-picker__icon--warn">
							</svg>
					</span>
				</div>
				<div
					*ngIf="helperText && !invalid && !warn"
					class="cds--form__helper-text"
					[ngClass]="{'cds--form__helper-text--disabled': disabled}">
					<ng-container *ngIf="!isTemplate(helperText)">{{helperText}}</ng-container>
					<ng-template *ngIf="isTemplate(helperText)" [ngTemplateOutlet]="helperText"></ng-template>
				</div>
				<div *ngIf="invalid" class="cds--form-requirement">
					<ng-container *ngIf="!isTemplate(invalidText)">{{invalidText}}</ng-container>
					<ng-template *ngIf="isTemplate(invalidText)" [ngTemplateOutlet]="invalidText"></ng-template>
				</div>
				<div *ngIf="!invalid && warn" class="cds--form-requirement">
					<ng-container *ngIf="!isTemplate(warnText)">{{warnText}}</ng-container>
					<ng-template *ngIf="isTemplate(warnText)" [ngTemplateOutlet]="warnText"></ng-template>
				</div>
			</div>
		</div>
</div>
	`,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: DatePickerInput,
        multi: true
      }]
    }]
  }], function() {
    return [{
      type: ElementRef
    }];
  }, {
    type: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    hasIcon: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    pattern: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    theme: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }],
    invalid: [{
      type: Input
    }],
    invalidText: [{
      type: Input
    }],
    warn: [{
      type: Input
    }],
    warnText: [{
      type: Input
    }],
    helperText: [{
      type: Input
    }],
    skeleton: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    input: [{
      type: ViewChild,
      args: ["input"]
    }]
  });
})();
var DatePickerInputModule = class {
};
DatePickerInputModule.ɵfac = function DatePickerInputModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || DatePickerInputModule)();
};
DatePickerInputModule.ɵmod = ɵɵdefineNgModule({
  type: DatePickerInputModule,
  declarations: [DatePickerInput],
  imports: [CommonModule, IconModule],
  exports: [DatePickerInput]
});
DatePickerInputModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, IconModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatePickerInputModule, [{
    type: NgModule,
    args: [{
      declarations: [DatePickerInput],
      exports: [DatePickerInput],
      imports: [CommonModule, IconModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-datepicker.mjs
var _c016 = ["input"];
var _c115 = ["rangeInput"];
var _c211 = (a0, a1, a2, a3) => ({
  "cds--date-picker--range": a0,
  "cds--date-picker--single": a1,
  "cds--date-picker--light": a2,
  "cds--skeleton": a3
});
function DatePicker_div_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 4)(1, "cds-date-picker-input", 5, 1);
    ɵɵlistener("valueChange", function DatePicker_div_5_Template_cds_date_picker_input_valueChange_1_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.onRangeValueChange($event));
    })("click", function DatePicker_div_5_Template_cds_date_picker_input_click_1_listener() {
      ɵɵrestoreView(_r3);
      const rangeInput_r5 = ɵɵreference(2);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.openCalendar(rangeInput_r5));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("label", ctx_r3.rangeLabel)("placeholder", ctx_r3.placeholder)("pattern", ctx_r3.inputPattern)("id", ctx_r3.id + "-rangeInput")("size", ctx_r3.size)("type", ctx_r3.range ? "range" : "single")("hasIcon", ctx_r3.range ? true : null)("disabled", ctx_r3.disabled)("readonly", ctx_r3.readonly)("invalid", ctx_r3.rangeInvalid)("invalidText", ctx_r3.rangeInvalidText)("warn", ctx_r3.rangeWarn)("warnText", ctx_r3.rangeWarnText)("skeleton", ctx_r3.skeleton)("helperText", ctx_r3.rangeHelperText);
  }
}
var monthToStr2 = (monthNumber, shorthand, locale) => locale.months[shorthand ? "shorthand" : "longhand"][monthNumber];
var config = {
  selectorInit: "[data-date-picker]",
  selectorDatePickerInput: "[data-date-picker-input]",
  selectorDatePickerInputFrom: "[data-date-picker-input-from]",
  selectorDatePickerInputTo: "[data-date-picker-input-to]",
  selectorDatePickerIcon: "[data-date-picker-icon]",
  selectorFlatpickrMonthYearContainer: ".flatpickr-current-month",
  selectorFlatpickrYearContainer: ".numInputWrapper",
  selectorFlatpickrCurrentMonth: ".cur-month",
  classCalendarContainer: `cds--date-picker__calendar`,
  classMonth: `cds--date-picker__month`,
  classWeekdays: `cds--date-picker__weekdays`,
  classDays: `cds--date-picker__days`,
  classWeekday: `cds--date-picker__weekday`,
  classDay: `cds--date-picker__day`,
  classFocused: `cds--focused`,
  classVisuallyHidden: `cds--visually-hidden`,
  classFlatpickrCurrentMonth: "cur-month",
  attribType: "data-date-picker-type",
  dateFormat: "m/d/Y",
  shorthand: false
};
var carbonFlatpickrMonthSelectPlugin = (fp) => {
  const setupElements = () => {
    if (!fp.monthElements || !fp.yearElements) {
      return;
    }
    fp.monthElements.forEach((elem) => {
      if (!elem.parentNode) {
        return;
      }
      elem.parentNode.removeChild(elem);
    });
    fp.monthElements.splice(0, fp.monthElements.length, ...fp.monthElements.map(() => {
      const monthElement = fp._createElement("span", config.classFlatpickrCurrentMonth);
      monthElement.textContent = monthToStr2(fp.currentMonth, config.shorthand === true, fp.l10n);
      fp.yearElements[0].closest(config.selectorFlatpickrMonthYearContainer).insertBefore(monthElement, fp.yearElements[0].closest(config.selectorFlatpickrYearContainer));
      return monthElement;
    }));
  };
  const updateCurrentMonth = () => {
    if (!fp.yearElements) {
      return;
    }
    const monthStr = monthToStr2(fp.currentMonth, config.shorthand === true, fp.l10n);
    fp.yearElements.forEach((elem) => {
      const currentMonthContainer = elem.closest(config.selectorFlatpickrMonthYearContainer);
      Array.prototype.forEach.call(currentMonthContainer.querySelectorAll(".cur-month"), (monthElement) => {
        monthElement.textContent = monthStr;
      });
    });
  };
  const register = () => {
    fp.loadedPlugins.push("carbonFlatpickrMonthSelectPlugin");
  };
  return {
    onMonthChange: updateCurrentMonth,
    onValueUpdate: updateCurrentMonth,
    onOpen: updateCurrentMonth,
    onReady: [setupElements, updateCurrentMonth, register]
  };
};
if (languages.default?.default["en"]?.weekdays) {
  languages.default.default["en"].weekdays.shorthand = languages.default.default["en"].weekdays.longhand.map((day) => {
    if (day === "Thursday") {
      return "Th";
    }
    return day.charAt(0);
  });
}
var DatePicker = class _DatePicker {
  constructor(elementRef, i18n) {
    this.elementRef = elementRef;
    this.i18n = i18n;
    this.range = false;
    this.dateFormat = "m/d/Y";
    this.language = "en";
    this.placeholder = "mm/dd/yyyy";
    this.ariaLabel = "calendar container";
    this.inputPattern = "^\\d{1,2}/\\d{1,2}/\\d{4}$";
    this.id = `datepicker-${_DatePicker.datePickerCount++}`;
    this.theme = "dark";
    this.disabled = false;
    this.readonly = false;
    this.invalid = false;
    this.warn = false;
    this.size = "md";
    this.rangeInvalid = false;
    this.rangeWarn = false;
    this.skeleton = false;
    this.plugins = [];
    this.valueChange = new EventEmitter();
    this.onClose = new EventEmitter();
    this._value = [];
    this._flatpickrOptions = {
      allowInput: true
    };
    this.flatpickrBaseOptions = {
      mode: "single",
      dateFormat: "m/d/Y",
      plugins: this.plugins,
      onOpen: () => {
        this.updateClassNames();
        this.updateAttributes();
        this.updateCalendarListeners();
      },
      onClose: (date) => {
        if (this.range && this.flatpickrInstance) {
          const inputValue = this.input.input.nativeElement.value;
          const rangeInputValue = this.rangeInput.input.nativeElement.value;
          if (inputValue || rangeInputValue) {
            const parseDate = (date2) => this.flatpickrInstance.parseDate(date2, this.dateFormat);
            this.setDateValues([parseDate(inputValue), parseDate(rangeInputValue || inputValue)]);
            this.doSelect(this.flatpickrInstance.selectedDates);
          }
        }
        this.onClose.emit(date);
      },
      onDayCreate: (_dObj, _dStr, _fp, dayElem) => {
        dayElem.classList.add("cds--date-picker__day");
      },
      nextArrow: this.rightArrowHTML(),
      prevArrow: this.leftArrowHTML(),
      value: this.value
    };
    this.flatpickrInstance = null;
    this.onTouched = () => {
    };
    this.propagateChange = (_) => {
    };
    this.preventCalendarClose = (event) => event.stopPropagation();
  }
  set value(v) {
    if (!v) {
      v = [];
    }
    this._value = v;
  }
  get value() {
    return this._value;
  }
  set flatpickrOptions(options) {
    this._flatpickrOptions = Object.assign({}, this._flatpickrOptions, options);
  }
  get flatpickrOptions() {
    const plugins = [...this.plugins, carbonFlatpickrMonthSelectPlugin];
    if (this.range) {
      plugins.push((0, import_rangePlugin.default)({
        input: `#${this.id}-rangeInput`,
        position: "left"
      }));
    }
    return Object.assign({}, this._flatpickrOptions, this.flatpickrBaseOptions, {
      mode: this.range ? "range" : "single",
      plugins,
      dateFormat: this.dateFormat,
      locale: languages.default?.default[this.language] || languages.default[this.language],
      // Little trick force "readonly mode" on datepicker input.
      // Docs: Whether clicking on the input should open the picker.
      // You could disable this if you wish to open the calendar manually with.open().
      clickOpens: !this.readonly
    });
  }
  ngOnInit() {
    if (this.i18n.getLocale() !== "en") {
      this.i18n.getLocaleObservable().subscribe((locale) => {
        this.language = locale;
        this.resetFlatpickrInstance();
      });
    }
  }
  ngOnChanges(changes) {
    const flatpickrChangeKeys = ["range", "dateFormat", "language", "id", "value", "plugins", "flatpickrOptions", "readonly"];
    const changeKeys = Object.keys(changes);
    if (changeKeys.some((key) => flatpickrChangeKeys.includes(key))) {
      this.resetFlatpickrInstance(changes.value);
    }
  }
  ngAfterViewInit() {
    if (!this.skeleton) {
      this.input.input.nativeElement.value = this._value[0] ?? "";
      if (this.range) {
        this.rangeInput.input.nativeElement.value = this._value[1] ?? "";
      }
    }
    setTimeout(() => {
      this.addInputListeners();
    }, 0);
  }
  // because the actual view may be delayed in loading (think projection into a tab pane)
  // and because we rely on a library that operates outside the Angular view of the world
  // we need to keep trying to load the library, until the relevant DOM is actually live
  ngAfterViewChecked() {
    if (!this.isFlatpickrLoaded()) {
      this.flatpickrInstance = esm_default(`#${this.id}-input`, this.flatpickrOptions);
      if (this.isFlatpickrLoaded()) {
        if (this.value.length > 0) {
          this.setDateValues(this.value);
        }
      }
    }
  }
  onFocus() {
    if (this.range) {
      if (this.rangeInput.input.nativeElement === document.activeElement && this.flatpickrInstance.selectedDates[1]) {
        const currentMonth = this.flatpickrInstance.selectedDates[1].getMonth();
        this.flatpickrInstance.changeMonth(currentMonth, false);
      } else if (this.input.input.nativeElement === document.activeElement && this.flatpickrInstance.selectedDates[0]) {
        const currentMonth = this.flatpickrInstance.selectedDates[0].getMonth();
        this.flatpickrInstance.changeMonth(currentMonth, false);
      }
    }
  }
  onFocusOut() {
    this.onTouched();
  }
  /**
   * Writes a value from the model to the component. Expects the value to be `null` or `(Date | string)[]`
   * @param value value received from the model
   */
  writeValue(value) {
    this.value = value;
    setTimeout(() => {
      if (this.isFlatpickrLoaded() && this.flatpickrInstance.config) {
        this.setDateValues(this.value);
      }
    });
  }
  /**
   * `ControlValueAccessor` method to programmatically disable the DatePicker.
   *
   * ex: `this.formGroup.get("myDatePicker").disable();`
   *
   * @param isDisabled `true` to disable the DatePicker
   */
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  registerOnChange(fn) {
    this.propagateChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  /**
   * Cleans up our flatpickr instance
   */
  ngOnDestroy() {
    if (!this.isFlatpickrLoaded()) {
      return;
    }
    this.flatpickrInstance.destroy();
  }
  /**
   * Handles the `valueChange` event from the primary/single input
   */
  onValueChange(event) {
    if (this.isFlatpickrLoaded()) {
      const date = this.flatpickrInstance.parseDate(event, this.dateFormat);
      if (this.range) {
        this.setDateValues([date, this.flatpickrInstance.selectedDates[1]]);
      } else {
        this.setDateValues([date]);
      }
      this.doSelect(this.flatpickrInstance.selectedDates);
    }
  }
  /**
   * Handles the `valueChange` event from the range input
   */
  onRangeValueChange(event) {
    if (this.isFlatpickrLoaded() && this.flatpickrInstance.isOpen) {
      const date = this.flatpickrInstance.parseDate(event, this.dateFormat);
      this.setDateValues([this.flatpickrInstance.selectedDates[0], date]);
      this.doSelect(this.flatpickrInstance.selectedDates);
    }
  }
  /**
   * Handles opening the calendar "properly" when the calendar icon is clicked.
   */
  openCalendar(datepickerInput) {
    if (this.readonly || this.skeleton) {
      return;
    }
    if (this.range) {
      datepickerInput.input.nativeElement.click();
      if (datepickerInput === this.input && this.flatpickrInstance.selectedDates[0]) {
        const currentMonth = this.flatpickrInstance.selectedDates[0].getMonth();
        this.flatpickrInstance.currentYear = this.flatpickrInstance.selectedDates[0].getFullYear();
        this.flatpickrInstance.changeMonth(currentMonth, false);
      }
    } else {
      this.flatpickrInstance.open();
    }
  }
  updateCalendarListeners() {
    const calendarContainer = document.querySelectorAll(".flatpickr-calendar");
    Array.from(calendarContainer).forEach((calendar) => {
      calendar.removeEventListener("click", this.preventCalendarClose);
      calendar.addEventListener("click", this.preventCalendarClose);
    });
  }
  /**
   * Handles the initialization of event listeners for the datepicker input and range input fields.
   */
  addInputListeners() {
    if (!this.isFlatpickrLoaded()) {
      return;
    }
    const addFocusCalendarListener = (element) => {
      element.addEventListener("keydown", (event) => {
        if (this.readonly) {
          return;
        }
        if (event.key === "Escape") {
          this.flatpickrInstance.close();
        }
        if (event.key === "ArrowDown") {
          if (!this.flatpickrInstance.isOpen) {
            this.flatpickrInstance.open();
          }
          const calendarContainer = this.flatpickrInstance.calendarContainer;
          const dayElement = calendarContainer && calendarContainer.querySelector(".flatpickr-day[tabindex]");
          if (dayElement) {
            dayElement.focus();
            if (document.activeElement !== dayElement && this.flatpickrInstance.selectedDateElem) {
              this.flatpickrInstance.selectedDateElem.focus();
            }
          }
        }
      });
    };
    if (this.input && this.input.input) {
      addFocusCalendarListener(this.input.input.nativeElement);
    }
    if (this.rangeInput && this.rangeInput.input) {
      addFocusCalendarListener(this.rangeInput.input.nativeElement);
    }
  }
  /**
   * Resets the flatpickr instance while keeping the date values (or updating them if newDates is provided)
   *
   * Used to pick up input changes or locale changes.
   *
   * @param newDates An optional SimpleChange of date values
   */
  resetFlatpickrInstance(newDates) {
    if (this.isFlatpickrLoaded()) {
      let dates = this.flatpickrInstance.selectedDates;
      if (newDates && this.didDateValueChange(newDates.currentValue, newDates.previousValue)) {
        dates = newDates.currentValue;
      }
      this.flatpickrInstance = esm_default(`#${this.id}-input`, this.flatpickrOptions);
      this.setDateValues(dates);
    }
  }
  /**
   * Carbon uses a number of specific classnames for parts of the flatpickr - this idempotent method applies them if needed.
   */
  updateClassNames() {
    if (!this.elementRef) {
      return;
    }
    const calendarContainer = document.querySelectorAll(".flatpickr-calendar");
    const monthContainer = document.querySelectorAll(".flatpickr-month");
    const weekdaysContainer = document.querySelectorAll(".flatpickr-weekdays");
    const weekdayContainer = document.querySelectorAll(".flatpickr-weekday");
    const daysContainer = document.querySelectorAll(".flatpickr-days");
    const dayContainer = document.querySelectorAll(".flatpickr-day");
    const addClassIfNotExists = (classname, elementList) => {
      Array.from(elementList).forEach((element) => {
        if (!element.classList.contains(classname)) {
          element.classList.add(classname);
        }
      });
    };
    addClassIfNotExists("cds--date-picker__calendar", calendarContainer);
    addClassIfNotExists("cds--date-picker__month", monthContainer);
    addClassIfNotExists("cds--date-picker__weekdays", weekdaysContainer);
    addClassIfNotExists("cds--date-picker__days", daysContainer);
    Array.from(weekdayContainer).forEach((element) => {
      element.innerHTML = element.innerHTML.replace(/\s+/g, "");
      element.classList.add("cds--date-picker__weekday");
    });
    Array.from(dayContainer).forEach((element) => {
      element.classList.add("cds--date-picker__day");
      if (!this.value) {
        return;
      }
      if (element.classList.contains("today") && this.value.length > 0) {
        element.classList.add("no-border");
      } else if (element.classList.contains("today") && this.value.length === 0) {
        element.classList.remove("no-border");
      }
    });
  }
  updateAttributes() {
    const calendarContainer = document.querySelectorAll(".flatpickr-calendar");
    Array.from(calendarContainer).forEach((calendar) => {
      calendar.setAttribute("role", "region");
      calendar.setAttribute("aria-label", this.ariaLabel);
    });
  }
  /**
   * Applies the given date value array to both the flatpickr instance and the `input`(s)
   * @param dates the date values to apply
   */
  setDateValues(dates) {
    if (this.isFlatpickrLoaded()) {
      const singleInput = this.elementRef.nativeElement.querySelector(`#${this.id}-input`);
      const rangeInput = this.elementRef.nativeElement.querySelector(`#${this.id}-rangeInput`);
      let shouldRefocusDateElement = this.flatpickrInstance.selectedDateElem === document.activeElement;
      this.flatpickrInstance.setDate(dates);
      if (shouldRefocusDateElement) {
        this.flatpickrInstance.selectedDateElem.focus();
      }
      let singleDate = "";
      if (typeof this.flatpickrInstance.selectedDates[0] === "string") {
        singleDate = this.flatpickrInstance.parseDate(this.flatpickrInstance.selectedDates[0], this.dateFormat);
        singleDate = this.flatpickrInstance.formatDate(singleDate, this.dateFormat);
      } else if (!!this.flatpickrInstance.selectedDates[0]) {
        singleDate = this.flatpickrInstance.formatDate(this.flatpickrInstance.selectedDates[0], this.dateFormat);
      }
      if (rangeInput) {
        let rangeDate = "";
        if (typeof this.flatpickrInstance.selectedDates[1] === "string") {
          rangeDate = this.flatpickrInstance.parseDate(this.flatpickrInstance.selectedDates[1].toString(), this.dateFormat);
          rangeDate = this.flatpickrInstance.formatDate(rangeDate, this.dateFormat);
        } else if (!!this.flatpickrInstance.selectedDates[1]) {
          rangeDate = this.flatpickrInstance.formatDate(this.flatpickrInstance.selectedDates[1], this.dateFormat);
        }
        setTimeout(() => {
          rangeInput.value = rangeDate;
          singleInput.value = singleDate;
        });
      }
    }
  }
  doSelect(selectedValue) {
    if (this.range && this.flatpickrInstance.selectedDates[0]) {
      const currentMonth = this.flatpickrInstance.selectedDates[0].getMonth();
      let shouldRefocusDateElement = this.flatpickrInstance.selectedDateElem === document.activeElement;
      this.flatpickrInstance.changeMonth(currentMonth, false);
      if (shouldRefocusDateElement) {
        this.flatpickrInstance.selectedDateElem.focus();
      }
    }
    this.valueChange.emit(selectedValue);
    this.propagateChange(selectedValue);
  }
  didDateValueChange(currentValue, previousValue) {
    return currentValue[0] !== previousValue[0] || currentValue[1] !== previousValue[1];
  }
  /**
   * More advanced checking of the loaded state of flatpickr
   */
  isFlatpickrLoaded() {
    return !!this.flatpickrInstance && !!this.flatpickrInstance.setDate;
  }
  /**
   * Right arrow HTML passed to flatpickr
   */
  rightArrowHTML() {
    return `
			<svg width="16px" height="16px" viewBox="0 0 16 16">
				<polygon points="11,8 6,13 5.3,12.3 9.6,8 5.3,3.7 6,3 "/>
				<rect width="16" height="16" style="fill:none" />
			</svg>`;
  }
  /**
   * Left arrow HTML passed to flatpickr
   */
  leftArrowHTML() {
    return `
			<svg width="16px" height="16px" viewBox="0 0 16 16">
				<polygon points="5,8 10,3 10.7,3.7 6.4,8 10.7,12.3 10,13 "/>
				<rect width="16" height="16" style="fill:none" />
			</svg>`;
  }
};
DatePicker.datePickerCount = 0;
DatePicker.ɵfac = function DatePicker_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || DatePicker)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(I18n));
};
DatePicker.ɵcmp = ɵɵdefineComponent({
  type: DatePicker,
  selectors: [["cds-date-picker"], ["ibm-date-picker"]],
  viewQuery: function DatePicker_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c016, 7);
      ɵɵviewQuery(_c115, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.input = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.rangeInput = _t.first);
    }
  },
  hostBindings: function DatePicker_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("focusin", function DatePicker_focusin_HostBindingHandler() {
        return ctx.onFocus();
      })("focusout", function DatePicker_focusout_HostBindingHandler() {
        return ctx.onFocusOut();
      });
    }
  },
  inputs: {
    range: "range",
    dateFormat: "dateFormat",
    language: "language",
    label: "label",
    helperText: "helperText",
    rangeHelperText: "rangeHelperText",
    rangeLabel: "rangeLabel",
    placeholder: "placeholder",
    ariaLabel: "ariaLabel",
    inputPattern: "inputPattern",
    id: "id",
    value: "value",
    theme: "theme",
    disabled: "disabled",
    readonly: "readonly",
    invalid: "invalid",
    invalidText: "invalidText",
    warn: "warn",
    warnText: "warnText",
    size: "size",
    rangeInvalid: "rangeInvalid",
    rangeInvalidText: "rangeInvalidText",
    rangeWarn: "rangeWarn",
    rangeWarnText: "rangeWarnText",
    skeleton: "skeleton",
    plugins: "plugins",
    flatpickrOptions: "flatpickrOptions"
  },
  outputs: {
    valueChange: "valueChange",
    onClose: "onClose"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: DatePicker,
    multi: true
  }]), ɵɵNgOnChangesFeature],
  decls: 6,
  vars: 22,
  consts: [["input", ""], ["rangeInput", ""], [1, "cds--form-item"], [1, "cds--date-picker", 3, "ngClass"], [1, "cds--date-picker-container"], [3, "valueChange", "click", "label", "placeholder", "pattern", "id", "size", "type", "hasIcon", "disabled", "readonly", "invalid", "invalidText", "warn", "warnText", "skeleton", "helperText"], ["class", "cds--date-picker-container", 4, "ngIf"]],
  template: function DatePicker_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵelementStart(0, "div", 2)(1, "div", 3)(2, "div", 4)(3, "cds-date-picker-input", 5, 0);
      ɵɵlistener("valueChange", function DatePicker_Template_cds_date_picker_input_valueChange_3_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onValueChange($event));
      })("click", function DatePicker_Template_cds_date_picker_input_click_3_listener() {
        ɵɵrestoreView(_r1);
        const input_r2 = ɵɵreference(4);
        return ɵɵresetView(ctx.openCalendar(input_r2));
      });
      ɵɵelementEnd()();
      ɵɵtemplate(5, DatePicker_div_5_Template, 3, 15, "div", 6);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngClass", ɵɵpureFunction4(17, _c211, ctx.range, !ctx.range, ctx.theme === "light", ctx.skeleton));
      ɵɵadvance(2);
      ɵɵproperty("label", ctx.label)("placeholder", ctx.placeholder)("pattern", ctx.inputPattern)("id", ctx.id + "-input")("size", ctx.size)("type", ctx.range ? "range" : "single")("hasIcon", ctx.range ? false : true)("disabled", ctx.disabled)("readonly", ctx.readonly)("invalid", ctx.invalid)("invalidText", ctx.invalidText)("warn", ctx.warn)("warnText", ctx.warnText)("skeleton", ctx.skeleton)("helperText", ctx.helperText);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.range);
    }
  },
  dependencies: [NgClass, NgIf, DatePickerInput],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatePicker, [{
    type: Component,
    args: [{
      selector: "cds-date-picker, ibm-date-picker",
      template: `
	<div class="cds--form-item">
		<div
			class="cds--date-picker"
			[ngClass]="{
				'cds--date-picker--range' : range,
				'cds--date-picker--single' : !range,
				'cds--date-picker--light' : theme === 'light',
				'cds--skeleton' : skeleton
			}">
			<div class="cds--date-picker-container">
				<cds-date-picker-input
					#input
					[label]="label"
					[placeholder]="placeholder"
					[pattern]="inputPattern"
					[id]="id + '-input'"
					[size]="size"
					[type]="(range ? 'range' : 'single')"
					[hasIcon]="(range ? false : true)"
					[disabled]="disabled"
					[readonly]="readonly"
					[invalid]="invalid"
					[invalidText]="invalidText"
					[warn]="warn"
					[warnText]="warnText"
					[skeleton]="skeleton"
					[helperText]="helperText"
					(valueChange)="onValueChange($event)"
					(click)="openCalendar(input)">
				</cds-date-picker-input>
			</div>

			<div *ngIf="range" class="cds--date-picker-container">
				<cds-date-picker-input
					#rangeInput
					[label]="rangeLabel"
					[placeholder]="placeholder"
					[pattern]="inputPattern"
					[id]="id + '-rangeInput'"
					[size]="size"
					[type]="(range ? 'range' : 'single')"
					[hasIcon]="(range ? true : null)"
					[disabled]="disabled"
					[readonly]="readonly"
					[invalid]="rangeInvalid"
					[invalidText]="rangeInvalidText"
					[warn]="rangeWarn"
					[warnText]="rangeWarnText"
					[skeleton]="skeleton"
					[helperText]="rangeHelperText"
					(valueChange)="onRangeValueChange($event)"
					(click)="openCalendar(rangeInput)">
				</cds-date-picker-input>
			</div>
		</div>
	</div>
	`,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: DatePicker,
        multi: true
      }],
      encapsulation: ViewEncapsulation.None
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: I18n
    }];
  }, {
    range: [{
      type: Input
    }],
    dateFormat: [{
      type: Input
    }],
    language: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    helperText: [{
      type: Input
    }],
    rangeHelperText: [{
      type: Input
    }],
    rangeLabel: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    inputPattern: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    theme: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }],
    invalid: [{
      type: Input
    }],
    invalidText: [{
      type: Input
    }],
    warn: [{
      type: Input
    }],
    warnText: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    rangeInvalid: [{
      type: Input
    }],
    rangeInvalidText: [{
      type: Input
    }],
    rangeWarn: [{
      type: Input
    }],
    rangeWarnText: [{
      type: Input
    }],
    skeleton: [{
      type: Input
    }],
    plugins: [{
      type: Input
    }],
    flatpickrOptions: [{
      type: Input
    }],
    input: [{
      type: ViewChild,
      args: ["input", {
        static: true
      }]
    }],
    rangeInput: [{
      type: ViewChild,
      args: ["rangeInput"]
    }],
    valueChange: [{
      type: Output
    }],
    onClose: [{
      type: Output
    }],
    onFocus: [{
      type: HostListener,
      args: ["focusin"]
    }],
    onFocusOut: [{
      type: HostListener,
      args: ["focusout"]
    }]
  });
})();
var DatePickerModule = class {
};
DatePickerModule.ɵfac = function DatePickerModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || DatePickerModule)();
};
DatePickerModule.ɵmod = ɵɵdefineNgModule({
  type: DatePickerModule,
  declarations: [DatePicker],
  imports: [CommonModule, DatePickerInputModule, UtilsModule, I18nModule],
  exports: [DatePicker, DatePickerInputModule]
});
DatePickerModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, DatePickerInputModule, UtilsModule, I18nModule, DatePickerInputModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatePickerModule, [{
    type: NgModule,
    args: [{
      declarations: [DatePicker],
      exports: [DatePicker, DatePickerInputModule],
      imports: [CommonModule, DatePickerInputModule, UtilsModule, I18nModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-loading.mjs
var _c017 = (a0, a1, a2) => ({
  "cds--loading--small": a0,
  "cds--loading--stop": a1,
  "cds--loading-overlay--stop": a2
});
var Loading = class {
  constructor(i18n) {
    this.i18n = i18n;
    this.title = this.i18n.get().LOADING.TITLE;
    this.isActive = true;
    this.size = "normal";
    this.overlay = false;
  }
};
Loading.ɵfac = function Loading_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Loading)(ɵɵdirectiveInject(I18n));
};
Loading.ɵcmp = ɵɵdefineComponent({
  type: Loading,
  selectors: [["cds-loading"], ["ibm-loading"]],
  hostVars: 2,
  hostBindings: function Loading_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--loading-overlay", ctx.overlay);
    }
  },
  inputs: {
    title: "title",
    isActive: "isActive",
    size: "size",
    overlay: "overlay"
  },
  standalone: false,
  decls: 5,
  vars: 6,
  consts: [[1, "cds--loading", 3, "ngClass"], ["viewBox", "0 0 100 100", 1, "cds--loading__svg"], ["cx", "50%", "cy", "50%", "r", "44", 1, "cds--loading__stroke"]],
  template: function Loading_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵnamespaceSVG();
      ɵɵelementStart(1, "svg", 1)(2, "title");
      ɵɵtext(3);
      ɵɵelementEnd();
      ɵɵelement(4, "circle", 2);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵproperty("ngClass", ɵɵpureFunction3(2, _c017, ctx.size === "sm", !ctx.isActive && !ctx.overlay, !ctx.isActive && ctx.overlay));
      ɵɵadvance(3);
      ɵɵtextInterpolate(ctx.title);
    }
  },
  dependencies: [NgClass],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Loading, [{
    type: Component,
    args: [{
      selector: "cds-loading, ibm-loading",
      template: `
		<div
			[ngClass]="{
				'cds--loading--small': size === 'sm',
				'cds--loading--stop': !isActive && !overlay,
				'cds--loading-overlay--stop': !isActive && overlay
			}"
			class="cds--loading">
			<svg class="cds--loading__svg" viewBox="0 0 100 100">
				<title>{{title}}</title>
				<circle class="cds--loading__stroke" cx="50%" cy="50%" r="44" />
			</svg>
		</div>
	`
    }]
  }], function() {
    return [{
      type: I18n
    }];
  }, {
    title: [{
      type: Input
    }],
    isActive: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    overlay: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.cds--loading-overlay"]
    }]
  });
})();
var LoadingModule = class {
};
LoadingModule.ɵfac = function LoadingModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || LoadingModule)();
};
LoadingModule.ɵmod = ɵɵdefineNgModule({
  type: LoadingModule,
  declarations: [Loading],
  imports: [CommonModule, I18nModule],
  exports: [Loading]
});
LoadingModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, I18nModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LoadingModule, [{
    type: NgModule,
    args: [{
      declarations: [Loading],
      exports: [Loading],
      imports: [CommonModule, I18nModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-file-uploader.mjs
function FileComponent_span_2__svg_svg_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 8);
  }
}
function FileComponent_span_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 4);
    ɵɵtemplate(1, FileComponent_span_2__svg_svg_1_Template, 1, 0, "svg", 5);
    ɵɵelementStart(2, "button", 6);
    ɵɵlistener("click", function FileComponent_span_2_Template_button_click_2_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.remove.emit());
    })("keyup.enter", function FileComponent_span_2_Template_button_keyup_enter_2_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.remove.emit());
    })("keyup.space", function FileComponent_span_2_Template_button_keyup_space_2_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.remove.emit());
    });
    ɵɵnamespaceSVG();
    ɵɵelement(3, "svg", 7);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.isInvalidText);
    ɵɵadvance();
    ɵɵattribute("aria-label", ctx_r1.translations.REMOVE_BUTTON);
  }
}
function FileComponent_span_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span")(1, "div", 9);
    ɵɵelement(2, "cds-loading", 10);
    ɵɵelementEnd()();
  }
}
function FileComponent_span_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 4);
    ɵɵnamespaceSVG();
    ɵɵelement(1, "svg", 11);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ariaLabel", ctx_r1.translations.CHECKMARK);
  }
}
function FileComponent_div_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 12)(1, "div", 13);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelementStart(3, "p", 14);
    ɵɵtext(4);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r1.fileItem.invalidTitle);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r1.fileItem.invalidText);
  }
}
var _c018 = ["fileInput"];
var _c116 = (a0) => ({
  "cds--file-browse-btn--disabled": a0
});
var _c212 = (a0) => ({
  "cds--file__drop-container--drag-over": a0
});
function FileUploader_ng_container_0_label_6_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r3.dropText);
  }
}
function FileUploader_ng_container_0_label_6_3_ng_template_0_Template(rf, ctx) {
}
function FileUploader_ng_container_0_label_6_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, FileUploader_ng_container_0_label_6_3_ng_template_0_Template, 0, 0, "ng-template", 14);
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(3);
    ɵɵproperty("ngTemplateOutlet", ctx_r3.dropText);
  }
}
function FileUploader_ng_container_0_label_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "label", 11);
    ɵɵlistener("keyup.enter", function FileUploader_ng_container_0_label_6_Template_label_keyup_enter_0_listener() {
      ɵɵrestoreView(_r2);
      ɵɵnextContext();
      const fileInput_r3 = ɵɵreference(9);
      return ɵɵresetView(fileInput_r3.click());
    })("keyup.space", function FileUploader_ng_container_0_label_6_Template_label_keyup_space_0_listener() {
      ɵɵrestoreView(_r2);
      ɵɵnextContext();
      const fileInput_r3 = ɵɵreference(9);
      return ɵɵresetView(fileInput_r3.click());
    });
    ɵɵelementStart(1, "div", 12);
    ɵɵlistener("click", function FileUploader_ng_container_0_label_6_Template_div_click_1_listener() {
      ɵɵrestoreView(_r2);
      ɵɵnextContext();
      const fileInput_r3 = ɵɵreference(9);
      return ɵɵresetView(fileInput_r3.click());
    })("dragover", function FileUploader_ng_container_0_label_6_Template_div_dragover_1_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r3 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r3.onDragOver($event));
    })("dragleave", function FileUploader_ng_container_0_label_6_Template_div_dragleave_1_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r3 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r3.onDragLeave($event));
    })("drop", function FileUploader_ng_container_0_label_6_Template_div_drop_1_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r3 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r3.onDrop($event));
    });
    ɵɵtemplate(2, FileUploader_ng_container_0_label_6_ng_container_2_Template, 2, 1, "ng-container", 13)(3, FileUploader_ng_container_0_label_6_3_Template, 1, 1, null, 13);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵproperty("ngClass", ɵɵpureFunction1(5, _c116, ctx_r3.disabled));
    ɵɵadvance();
    ɵɵproperty("ngClass", ɵɵpureFunction1(7, _c212, ctx_r3.dragOver));
    ɵɵattribute("for", ctx_r3.fileUploaderId);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r3.isTemplate(ctx_r3.dropText));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r3.isTemplate(ctx_r3.dropText));
  }
}
function FileUploader_ng_container_0_button_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 15);
    ɵɵlistener("click", function FileUploader_ng_container_0_button_7_Template_button_click_0_listener() {
      ɵɵrestoreView(_r5);
      ɵɵnextContext();
      const fileInput_r3 = ɵɵreference(9);
      return ɵɵresetView(fileInput_r3.click());
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵproperty("cdsButton", ctx_r3.buttonType)("size", ctx_r3.size)("disabled", ctx_r3.disabled);
    ɵɵattribute("for", ctx_r3.fileUploaderId);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r3.buttonText, " ");
  }
}
function FileUploader_ng_container_0_ng_container_11_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "cds-file", 16);
    ɵɵlistener("remove", function FileUploader_ng_container_0_ng_container_11_Template_cds_file_remove_1_listener() {
      const fileItem_r7 = ɵɵrestoreView(_r6).$implicit;
      const ctx_r3 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r3.removeFile(fileItem_r7));
    });
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const fileItem_r7 = ctx.$implicit;
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("fileItem", fileItem_r7)("size", ctx_r3.fileItemSize);
  }
}
function FileUploader_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "label", 3);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelementStart(3, "p", 4);
    ɵɵtext(4);
    ɵɵelementEnd();
    ɵɵelementStart(5, "div", 5);
    ɵɵtemplate(6, FileUploader_ng_container_0_label_6_Template, 4, 9, "label", 6)(7, FileUploader_ng_container_0_button_7_Template, 2, 5, "button", 7);
    ɵɵelementStart(8, "input", 8, 1);
    ɵɵlistener("change", function FileUploader_ng_container_0_Template_input_change_8_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.onFilesAdded());
    });
    ɵɵelementEnd();
    ɵɵelementStart(10, "div", 9);
    ɵɵtemplate(11, FileUploader_ng_container_0_ng_container_11_Template, 2, 2, "ng-container", 10);
    ɵɵelementEnd()();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("for", ctx_r3.fileUploaderId);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r3.title);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r3.description);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r3.drop);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r3.drop);
    ɵɵadvance();
    ɵɵproperty("accept", ctx_r3.accept)("id", ctx_r3.fileUploaderId)("multiple", ctx_r3.multiple)("disabled", ctx_r3.disabled);
    ɵɵadvance(3);
    ɵɵproperty("ngForOf", ctx_r3.files);
  }
}
function FileUploader_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 17)(1, "div", 18)(2, "button", 19);
  }
}
var FileComponent = class {
  constructor(i18n) {
    this.i18n = i18n;
    this.translations = this.i18n.get().FILE_UPLOADER;
    this.size = "lg";
    this.remove = new EventEmitter();
    this.selectedFile = true;
  }
  get isInvalidText() {
    return this.fileItem.invalidText;
  }
  get fileSizeSmall() {
    return this.size === "sm";
  }
  get fileSizeMedium() {
    return this.size === "md";
  }
  get fileSizeLarge() {
    return this.size === "lg";
  }
  ngOnDestroy() {
    this.remove.emit();
  }
};
FileComponent.ɵfac = function FileComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || FileComponent)(ɵɵdirectiveInject(I18n));
};
FileComponent.ɵcmp = ɵɵdefineComponent({
  type: FileComponent,
  selectors: [["cds-file"], ["ibm-file"]],
  hostVars: 10,
  hostBindings: function FileComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--file__selected-file", ctx.selectedFile)("cds--file__selected-file--invalid", ctx.isInvalidText)("cds--file__selected-file--sm", ctx.fileSizeSmall)("cds--file__selected-file--md", ctx.fileSizeMedium)("cds--file__selected-file--lg", ctx.fileSizeLarge);
    }
  },
  inputs: {
    translations: "translations",
    fileItem: "fileItem",
    size: "size"
  },
  outputs: {
    remove: "remove"
  },
  standalone: false,
  decls: 6,
  vars: 6,
  consts: [[1, "cds--file-filename", 3, "title"], ["class", "cds--file__state-container", 4, "ngIf"], [4, "ngIf"], ["class", "cds--form-requirement", "role", "alert", 4, "ngIf"], [1, "cds--file__state-container"], ["cdsIcon", "warning--filled", "class", "cds--file--invalid", "size", "16", 4, "ngIf"], ["type", "button", "tabindex", "0", 1, "cds--file-close", 3, "click", "keyup.enter", "keyup.space"], ["cdsIcon", "close", "size", "16"], ["cdsIcon", "warning--filled", "size", "16", 1, "cds--file--invalid"], [1, "cds--inline-loading__animation"], ["size", "sm"], ["cdsIcon", "checkmark--filled", "size", "16", 1, "cds--file-complete", 3, "ariaLabel"], ["role", "alert", 1, "cds--form-requirement"], [1, "cds--form-requirement__title"], [1, "cds--form-requirement__supplement"]],
  template: function FileComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "p", 0);
      ɵɵtext(1);
      ɵɵelementEnd();
      ɵɵtemplate(2, FileComponent_span_2_Template, 4, 2, "span", 1)(3, FileComponent_span_3_Template, 3, 0, "span", 2)(4, FileComponent_span_4_Template, 2, 1, "span", 1)(5, FileComponent_div_5_Template, 5, 2, "div", 3);
    }
    if (rf & 2) {
      ɵɵproperty("title", ctx.fileItem.file.name);
      ɵɵadvance();
      ɵɵtextInterpolate(ctx.fileItem.file.name);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.fileItem.state === "edit");
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.fileItem.state === "upload");
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.fileItem.state === "complete");
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.fileItem.invalid);
    }
  },
  dependencies: [NgIf, Loading, IconDirective],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FileComponent, [{
    type: Component,
    args: [{
      selector: "cds-file, ibm-file",
      template: `
		<p class="cds--file-filename" [title]="fileItem.file.name">{{fileItem.file.name}}</p>
		<span
			*ngIf="fileItem.state === 'edit'"
			class="cds--file__state-container">
			<svg
				*ngIf="isInvalidText"
				cdsIcon="warning--filled"
				class="cds--file--invalid"
				size="16">
			</svg>
			<button
				type="button"
				class="cds--file-close"
				[attr.aria-label]="translations.REMOVE_BUTTON"
				tabindex="0"
				(click)="remove.emit()"
				(keyup.enter)="remove.emit()"
				(keyup.space)="remove.emit()">
				<svg cdsIcon="close" size="16"></svg>
			</button>
		</span>
		<span *ngIf="fileItem.state === 'upload'">
			<div class="cds--inline-loading__animation">
				<cds-loading size="sm"></cds-loading>
			</div>
		</span>
		<span *ngIf="fileItem.state === 'complete'" class="cds--file__state-container">
			<svg
				cdsIcon="checkmark--filled"
				size="16"
				class="cds--file-complete"
				[ariaLabel]="translations.CHECKMARK">
			</svg>
		</span>
		<div class="cds--form-requirement" role="alert" *ngIf="fileItem.invalid">
			<div class="cds--form-requirement__title">{{fileItem.invalidTitle}}</div>
			<p class="cds--form-requirement__supplement">{{fileItem.invalidText}}</p>
		</div>
	`
    }]
  }], function() {
    return [{
      type: I18n
    }];
  }, {
    translations: [{
      type: Input
    }],
    fileItem: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    remove: [{
      type: Output
    }],
    selectedFile: [{
      type: HostBinding,
      args: ["class.cds--file__selected-file"]
    }],
    isInvalidText: [{
      type: HostBinding,
      args: ["class.cds--file__selected-file--invalid"]
    }],
    fileSizeSmall: [{
      type: HostBinding,
      args: ["class.cds--file__selected-file--sm"]
    }],
    fileSizeMedium: [{
      type: HostBinding,
      args: ["class.cds--file__selected-file--md"]
    }],
    fileSizeLarge: [{
      type: HostBinding,
      args: ["class.cds--file__selected-file--lg"]
    }]
  });
})();
var noop = () => {
};
var FileUploader = class _FileUploader {
  constructor(i18n) {
    this.i18n = i18n;
    this.buttonText = this.i18n.get().FILE_UPLOADER.OPEN;
    this.buttonType = "primary";
    this.accept = [];
    this.multiple = true;
    this.skeleton = false;
    this.fileItemSize = "lg";
    this.drop = false;
    this.fileUploaderId = `file-uploader-${_FileUploader.fileUploaderCount}`;
    this.files = /* @__PURE__ */ new Set();
    this.disabled = false;
    this.filesChange = new EventEmitter();
    this.dragOver = false;
    this.onTouchedCallback = noop;
    this.onChangeCallback = noop;
    _FileUploader.fileUploaderCount++;
  }
  /**
   * Specifies the property to be used as the return value to `ngModel` and reactive forms.
   * Updates `this.files`.
   */
  get value() {
    return this.files;
  }
  set value(v) {
    if (v !== this.files) {
      this.files = v;
      this.onChangeCallback(v);
    }
  }
  onBlur() {
    this.onTouchedCallback();
  }
  get fileList() {
    return Array.from(this.fileInput.nativeElement.files);
  }
  /**
   * Propagates the injected `value`.
   */
  writeValue(value) {
    if (value !== this.value) {
      this.files = value;
    }
  }
  createFileItem(file) {
    return {
      uploaded: false,
      state: "edit",
      invalid: false,
      invalidText: "",
      file
    };
  }
  onFilesAdded() {
    const newFiles = new Set(this.files);
    if (!this.multiple) {
      newFiles.clear();
    }
    for (let file of this.fileList) {
      const fileItem = this.createFileItem(file);
      newFiles.add(fileItem);
    }
    this.value = newFiles;
    this.filesChange.emit(newFiles);
  }
  onDragOver(event) {
    event.stopPropagation();
    event.preventDefault();
    if (this.disabled) {
      return;
    }
    this.dragOver = true;
  }
  onDragLeave(event) {
    event.stopPropagation();
    event.preventDefault();
    this.dragOver = false;
  }
  onDrop(event) {
    event.stopPropagation();
    event.preventDefault();
    if (this.disabled) {
      return;
    }
    const transferredFiles = Array.from(event.dataTransfer.files);
    const newFiles = new Set(this.files);
    transferredFiles.filter(({
      name,
      type
    }) => {
      const fileExtension = name.split(".").pop().replace(/^/, ".");
      return this.accept.includes(type) || this.accept.includes(fileExtension) || !this.accept.length;
    }).forEach((file) => {
      if (!newFiles.size || this.multiple) {
        const fileItem = this.createFileItem(file);
        newFiles.add(fileItem);
      }
    });
    this.value = newFiles;
    this.filesChange.emit(newFiles);
    this.dragOver = false;
  }
  removeFile(fileItem) {
    if (this.files && this.files.has(fileItem)) {
      const newFiles = new Set(this.files);
      newFiles.delete(fileItem);
      this.filesChange.emit(newFiles);
      this.value = newFiles;
    }
    this.fileInput.nativeElement.value = "";
  }
  isTemplate(value) {
    return value instanceof TemplateRef;
  }
  /**
   * Registers the injected function to control the touch use of the `FileUploader`.
   */
  registerOnTouched(fn) {
    this.onTouchedCallback = fn;
  }
  /**
   * Sets a method in order to propagate changes back to the form.
   */
  registerOnChange(fn) {
    this.onChangeCallback = fn;
  }
  /**
   * `ControlValueAccessor` method to programmatically disable the checkbox.
   *
   * ex: `this.formGroup.get("myFileUploader").disable();`
   *
   * @param isDisabled `true` to disable the file uploader
   */
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
};
FileUploader.fileUploaderCount = 0;
FileUploader.ɵfac = function FileUploader_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || FileUploader)(ɵɵdirectiveInject(I18n));
};
FileUploader.ɵcmp = ɵɵdefineComponent({
  type: FileUploader,
  selectors: [["cds-file-uploader"], ["ibm-file-uploader"]],
  viewQuery: function FileUploader_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c018, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.fileInput = _t.first);
    }
  },
  inputs: {
    buttonText: "buttonText",
    buttonType: "buttonType",
    title: "title",
    description: "description",
    accept: "accept",
    multiple: "multiple",
    skeleton: "skeleton",
    size: "size",
    fileItemSize: "fileItemSize",
    drop: "drop",
    dropText: "dropText",
    fileUploaderId: "fileUploaderId",
    files: "files",
    disabled: "disabled"
  },
  outputs: {
    filesChange: "filesChange"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: FileUploader,
    multi: true
  }])],
  decls: 3,
  vars: 2,
  consts: [["skeletonTemplate", ""], ["fileInput", ""], [4, "ngIf", "ngIfElse"], [1, "cds--file--label", 3, "for"], ["role", "alert", 1, "cds--label-description"], [1, "cds--file"], ["class", "cds--file-browse-btn", "tabindex", "0", 3, "ngClass", "keyup.enter", "keyup.space", 4, "ngIf"], ["type", "button", 3, "cdsButton", "size", "disabled", "click", 4, "ngIf"], ["type", "file", "tabindex", "-1", 1, "cds--file-input", 3, "change", "accept", "id", "multiple", "disabled"], [1, "cds--file-container"], [4, "ngFor", "ngForOf"], ["tabindex", "0", 1, "cds--file-browse-btn", 3, "keyup.enter", "keyup.space", "ngClass"], ["role", "button", 1, "cds--file__drop-container", 3, "click", "dragover", "dragleave", "drop", "ngClass"], [4, "ngIf"], [3, "ngTemplateOutlet"], ["type", "button", 3, "click", "cdsButton", "size", "disabled"], [3, "remove", "fileItem", "size"], [1, "cds--skeleton__text", 2, "width", "100px"], [1, "cds--skeleton__text", 2, "width", "225px"], ["cdsButton", "", "skeleton", "true"]],
  template: function FileUploader_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, FileUploader_ng_container_0_Template, 12, 10, "ng-container", 2)(1, FileUploader_ng_template_1_Template, 3, 0, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      const skeletonTemplate_r8 = ɵɵreference(2);
      ɵɵproperty("ngIf", !ctx.skeleton)("ngIfElse", skeletonTemplate_r8);
    }
  },
  dependencies: [NgClass, NgForOf, NgIf, NgTemplateOutlet, Button, FileComponent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FileUploader, [{
    type: Component,
    args: [{
      selector: "cds-file-uploader, ibm-file-uploader",
      template: `
		<ng-container *ngIf="!skeleton; else skeletonTemplate">
			<label [for]="fileUploaderId" class="cds--file--label">{{title}}</label>
			<p class="cds--label-description" role="alert">{{description}}</p>
			<div class="cds--file">
				<label
					*ngIf="drop"
					class="cds--file-browse-btn"
					(keyup.enter)="fileInput.click()"
					(keyup.space)="fileInput.click()"
					[ngClass]="{'cds--file-browse-btn--disabled': disabled}"
					tabindex="0">
					<div
						class="cds--file__drop-container"
						[ngClass]="{'cds--file__drop-container--drag-over': dragOver}"
						role="button"
						(click)="fileInput.click()"
						[attr.for]="fileUploaderId"
						(dragover)="onDragOver($event)"
						(dragleave)="onDragLeave($event)"
						(drop)="onDrop($event)">
						<ng-container *ngIf="!isTemplate(dropText)">{{dropText}}</ng-container>
						<ng-template *ngIf="isTemplate(dropText)" [ngTemplateOutlet]="dropText"></ng-template>
					</div>
				</label>
				<button
					*ngIf="!drop"
					type="button"
					[cdsButton]="buttonType"
					(click)="fileInput.click()"
					[attr.for]="fileUploaderId"
					[size]="size"
					[disabled]="disabled">
					{{buttonText}}
				</button>
				<input
					#fileInput
					type="file"
					class="cds--file-input"
					[accept]="accept"
					[id]="fileUploaderId"
					[multiple]="multiple"
					tabindex="-1"
					(change)="onFilesAdded()"
					[disabled]="disabled"/>
				<div class="cds--file-container">
					<ng-container *ngFor="let fileItem of files">
						<cds-file
							[fileItem]="fileItem"
							(remove)="removeFile(fileItem)"
							[size]="fileItemSize">
						</cds-file>
					</ng-container>
				</div>
			</div>
		</ng-container>

		<ng-template #skeletonTemplate>
			<div class="cds--skeleton__text" style="width: 100px"></div>
			<div class="cds--skeleton__text" style="width: 225px"></div>
			<button cdsButton skeleton="true"></button>
		</ng-template>
	`,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: FileUploader,
        multi: true
      }]
    }]
  }], function() {
    return [{
      type: I18n
    }];
  }, {
    buttonText: [{
      type: Input
    }],
    buttonType: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    description: [{
      type: Input
    }],
    accept: [{
      type: Input
    }],
    multiple: [{
      type: Input
    }],
    skeleton: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    fileItemSize: [{
      type: Input
    }],
    drop: [{
      type: Input
    }],
    dropText: [{
      type: Input
    }],
    fileUploaderId: [{
      type: Input
    }],
    fileInput: [{
      type: ViewChild,
      args: ["fileInput"]
    }],
    files: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    filesChange: [{
      type: Output
    }]
  });
})();
var FileUploaderModule = class {
};
FileUploaderModule.ɵfac = function FileUploaderModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || FileUploaderModule)();
};
FileUploaderModule.ɵmod = ɵɵdefineNgModule({
  type: FileUploaderModule,
  declarations: [FileUploader, FileComponent],
  imports: [CommonModule, ButtonModule, LoadingModule, IconModule],
  exports: [FileUploader, FileComponent]
});
FileUploaderModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ButtonModule, LoadingModule, IconModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FileUploaderModule, [{
    type: NgModule,
    args: [{
      declarations: [FileUploader, FileComponent],
      exports: [FileUploader, FileComponent],
      imports: [CommonModule, ButtonModule, LoadingModule, IconModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-toggle.mjs
var _c019 = (a0) => ({
  "cds--visually-hidden": a0
});
var _c117 = (a0) => ({
  "cds--toggle__appearance--sm": a0
});
var _c213 = (a0) => ({
  "cds--toggle__switch--checked": a0
});
function Toggle_ng_container_0_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.label);
  }
}
function Toggle_ng_container_0_5_ng_template_0_Template(rf, ctx) {
}
function Toggle_ng_container_0_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, Toggle_ng_container_0_5_ng_template_0_Template, 0, 0, "ng-template", 10);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.label);
  }
}
function Toggle_ng_container_0__svg_svg_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "svg", 11);
    ɵɵelement(1, "path", 12);
    ɵɵelementEnd();
  }
}
function Toggle_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "button", 2);
    ɵɵlistener("click", function Toggle_ng_container_0_Template_button_click_1_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onClick($event));
    });
    ɵɵelementEnd();
    ɵɵelementStart(2, "label", 3)(3, "span", 4);
    ɵɵtemplate(4, Toggle_ng_container_0_ng_container_4_Template, 2, 1, "ng-container", 5)(5, Toggle_ng_container_0_5_Template, 1, 1, null, 5);
    ɵɵelementEnd();
    ɵɵelementStart(6, "div", 6)(7, "div", 7);
    ɵɵtemplate(8, Toggle_ng_container_0__svg_svg_8_Template, 2, 0, "svg", 8);
    ɵɵelementEnd();
    ɵɵelementStart(9, "span", 9);
    ɵɵtext(10);
    ɵɵpipe(11, "async");
    ɵɵelementEnd()()();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("disabled", ctx_r1.disabled)("id", ctx_r1.id);
    ɵɵattribute("aria-checked", ctx_r1.checked)("aria-label", ctx_r1.ariaLabel);
    ɵɵadvance();
    ɵɵproperty("for", ctx_r1.id);
    ɵɵadvance();
    ɵɵproperty("ngClass", ɵɵpureFunction1(14, _c019, ctx_r1.hideLabel));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.isTemplate(ctx_r1.label));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.isTemplate(ctx_r1.label));
    ɵɵadvance();
    ɵɵproperty("ngClass", ɵɵpureFunction1(16, _c117, ctx_r1.size === "sm"));
    ɵɵadvance();
    ɵɵproperty("ngClass", ɵɵpureFunction1(18, _c213, ctx_r1.checked));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.size === "sm");
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r1.hideLabel ? ctx_r1.label : ɵɵpipeBind1(11, 12, ctx_r1.getCheckedText()), " ");
  }
}
function Toggle_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 13)(1, "div", 14);
  }
}
var ToggleState;
(function(ToggleState2) {
  ToggleState2[ToggleState2["Init"] = 0] = "Init";
  ToggleState2[ToggleState2["Checked"] = 1] = "Checked";
  ToggleState2[ToggleState2["Unchecked"] = 2] = "Unchecked";
})(ToggleState || (ToggleState = {}));
var Toggle = class _Toggle extends Checkbox {
  /**
   * Creates an instance of Toggle.
   */
  constructor(changeDetectorRef, i18n) {
    super(changeDetectorRef);
    this.changeDetectorRef = changeDetectorRef;
    this.i18n = i18n;
    this.size = "md";
    this.hideLabel = false;
    this.skeleton = false;
    this.toggleClass = true;
    this.id = "toggle-" + _Toggle.toggleCount;
    this._offValues = this.i18n.getOverridable("TOGGLE.OFF");
    this._onValues = this.i18n.getOverridable("TOGGLE.ON");
    _Toggle.toggleCount++;
  }
  /**
   * Text that is set on the left side of the toggle.
   */
  set offText(value) {
    this._offValues.override(value);
  }
  get offText() {
    return this._offValues.value;
  }
  /**
   * Text that is set on the right side of the toggle.
   */
  set onText(value) {
    this._onValues.override(value);
  }
  get onText() {
    return this._onValues.value;
  }
  get disabledClass() {
    return this.disabled;
  }
  get formItem() {
    return !this.skeleton;
  }
  /**
   * `ControlValueAccessor` method to programmatically disable the toggle input.
   *
   * ex: `this.formGroup.get("myToggle").disable();`
   *
   * @param isDisabled `true` to disable the input
   */
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  getOffText() {
    return this._offValues.subject;
  }
  getOnText() {
    return this._onValues.subject;
  }
  getCheckedText() {
    if (this.checked) {
      return this._onValues.subject;
    }
    return this._offValues.subject;
  }
  /**
   * Creates instance of `ToggleChange` used to propagate the change event.
   */
  emitChangeEvent() {
    this.checkedChange.emit(this.checked);
    this.propagateChange(this.checked);
  }
  isTemplate(value) {
    return value instanceof TemplateRef;
  }
};
Toggle.toggleCount = 0;
Toggle.ɵfac = function Toggle_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Toggle)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(I18n));
};
Toggle.ɵcmp = ɵɵdefineComponent({
  type: Toggle,
  selectors: [["cds-toggle"], ["ibm-toggle"]],
  hostVars: 8,
  hostBindings: function Toggle_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--toggle--skeleton", ctx.skeleton)("cds--toggle", ctx.toggleClass)("cds--toggle--disabled", ctx.disabledClass)("cds--form-item", ctx.formItem);
    }
  },
  inputs: {
    offText: "offText",
    onText: "onText",
    label: "label",
    size: "size",
    hideLabel: "hideLabel",
    ariaLabel: "ariaLabel",
    skeleton: "skeleton"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: Toggle,
    multi: true
  }]), ɵɵInheritDefinitionFeature],
  decls: 3,
  vars: 2,
  consts: [["skeletonTemplate", ""], [4, "ngIf", "ngIfElse"], ["role", "switch", "type", "button", 1, "cds--toggle__button", 3, "click", "disabled", "id"], [1, "cds--toggle__label", 3, "for"], [1, "cds--toggle__label-text", 3, "ngClass"], [4, "ngIf"], [1, "cds--toggle__appearance", 3, "ngClass"], [1, "cds--toggle__switch", 3, "ngClass"], ["class", "cds--toggle__check", "width", "6px", "height", "5px", "viewBox", "0 0 6 5", 4, "ngIf"], [1, "cds--toggle__text"], [3, "ngTemplateOutlet"], ["width", "6px", "height", "5px", "viewBox", "0 0 6 5", 1, "cds--toggle__check"], ["d", "M2.2 2.7L5 0 6 1 2.2 5 0 2.7 1 1.5z"], [1, "cds--toggle__skeleton-circle"], [1, "cds--toggle__skeleton-rectangle"]],
  template: function Toggle_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, Toggle_ng_container_0_Template, 12, 20, "ng-container", 1)(1, Toggle_ng_template_1_Template, 2, 0, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      const skeletonTemplate_r3 = ɵɵreference(2);
      ɵɵproperty("ngIf", !ctx.skeleton)("ngIfElse", skeletonTemplate_r3);
    }
  },
  dependencies: [NgClass, NgIf, NgTemplateOutlet, AsyncPipe],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Toggle, [{
    type: Component,
    args: [{
      selector: "cds-toggle, ibm-toggle",
      template: `
		<ng-container *ngIf="!skeleton; else skeletonTemplate;">
			<button
				class="cds--toggle__button"
				[disabled]="disabled"
				[id]="id"
				role="switch"
				type="button"
				[attr.aria-checked]="checked"
				(click)="onClick($event)"
				[attr.aria-label]="ariaLabel">
			</button>
			<label
				class="cds--toggle__label"
				[for]="id">
				<span
					class="cds--toggle__label-text"
					[ngClass]="{
						'cds--visually-hidden': hideLabel
					}">
					<ng-container *ngIf="!isTemplate(label)">{{label}}</ng-container>
					<ng-template *ngIf="isTemplate(label)" [ngTemplateOutlet]="label"></ng-template>
				</span>
				<div
					class="cds--toggle__appearance"
					[ngClass]="{
						'cds--toggle__appearance--sm': size === 'sm'
					}">
					<div
						class="cds--toggle__switch"
						[ngClass]="{
							'cds--toggle__switch--checked': checked
						}">
						<svg
							*ngIf="size === 'sm'"
							class='cds--toggle__check'
							width="6px"
							height="5px"
							viewBox="0 0 6 5">
							<path d="M2.2 2.7L5 0 6 1 2.2 5 0 2.7 1 1.5z" />
						</svg>
					</div>
					<span class="cds--toggle__text">
						{{(hideLabel ? label : (getCheckedText() | async))}}
					</span>
				</div>
			</label>
		</ng-container>
		<ng-template #skeletonTemplate>
			<div class="cds--toggle__skeleton-circle"></div>
			<div class="cds--toggle__skeleton-rectangle"></div>
		</ng-template>
	`,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: Toggle,
        multi: true
      }]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: I18n
    }];
  }, {
    offText: [{
      type: Input
    }],
    onText: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    hideLabel: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    skeleton: [{
      type: HostBinding,
      args: ["class.cds--toggle--skeleton"]
    }, {
      type: Input
    }],
    toggleClass: [{
      type: HostBinding,
      args: ["class.cds--toggle"]
    }],
    disabledClass: [{
      type: HostBinding,
      args: ["class.cds--toggle--disabled"]
    }],
    formItem: [{
      type: HostBinding,
      args: ["class.cds--form-item"]
    }]
  });
})();
var ToggleModule = class {
};
ToggleModule.ɵfac = function ToggleModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ToggleModule)();
};
ToggleModule.ɵmod = ɵɵdefineNgModule({
  type: ToggleModule,
  declarations: [Toggle],
  imports: [CommonModule, FormsModule, I18nModule],
  exports: [Toggle]
});
ToggleModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, FormsModule, I18nModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ToggleModule, [{
    type: NgModule,
    args: [{
      declarations: [Toggle],
      exports: [Toggle],
      imports: [CommonModule, FormsModule, I18nModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-radio.mjs
var _c020 = ["*"];
var _c118 = (a0) => ({
  "cds--skeleton": a0
});
function Radio_input_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "input", 4);
    ɵɵlistener("change", function Radio_input_0_Template_input_change_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onChange($event));
    })("click", function Radio_input_0_Template_input_click_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onClick($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("checked", ctx_r1.checked)("disabled", ctx_r1.disabled || ctx_r1.disabledFromGroup)("name", ctx_r1.name)("id", ctx_r1.id)("required", ctx_r1.required);
    ɵɵattribute("value", ctx_r1.value)("aria-labelledby", ctx_r1.ariaLabelledby);
  }
}
function Radio_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 5);
  }
}
var _c214 = (a0, a1, a2, a3) => ({
  "cds--radio-button-group--vertical": a0,
  "cds--radio-button-group--label-left": a1,
  "cds--radio-button-group--invalid": a2,
  "cds--radio-button-group--warning": a3
});
var _c38 = (a0) => ({
  "cds--form__helper-text--disabled": a0
});
function RadioGroup_legend_1_1_ng_template_0_Template(rf, ctx) {
}
function RadioGroup_legend_1_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, RadioGroup_legend_1_1_ng_template_0_Template, 0, 0, "ng-template", 8);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.legend);
  }
}
function RadioGroup_legend_1_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵtextInterpolate(ctx_r0.legend);
  }
}
function RadioGroup_legend_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "legend", 6);
    ɵɵtemplate(1, RadioGroup_legend_1_1_Template, 1, 1, null, 7)(2, RadioGroup_legend_1_ng_template_2_Template, 1, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const legendLabel_r2 = ɵɵreference(3);
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.legend))("ngIfElse", legendLabel_r2);
  }
}
function RadioGroup_ng_container_4_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.invalidText);
  }
}
function RadioGroup_ng_container_4_4_ng_template_0_Template(rf, ctx) {
}
function RadioGroup_ng_container_4_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, RadioGroup_ng_container_4_4_ng_template_0_Template, 0, 0, "ng-template", 8);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.invalidText);
  }
}
function RadioGroup_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵnamespaceSVG();
    ɵɵelement(1, "svg", 9);
    ɵɵnamespaceHTML();
    ɵɵelementStart(2, "div", 10);
    ɵɵtemplate(3, RadioGroup_ng_container_4_ng_container_3_Template, 2, 1, "ng-container", 4)(4, RadioGroup_ng_container_4_4_Template, 1, 1, null, 4);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance(3);
    ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.invalidText));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.invalidText));
  }
}
function RadioGroup_ng_container_5_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.warnText);
  }
}
function RadioGroup_ng_container_5_4_ng_template_0_Template(rf, ctx) {
}
function RadioGroup_ng_container_5_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, RadioGroup_ng_container_5_4_ng_template_0_Template, 0, 0, "ng-template", 8);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.warnText);
  }
}
function RadioGroup_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵnamespaceSVG();
    ɵɵelement(1, "svg", 11);
    ɵɵnamespaceHTML();
    ɵɵelementStart(2, "div", 10);
    ɵɵtemplate(3, RadioGroup_ng_container_5_ng_container_3_Template, 2, 1, "ng-container", 4)(4, RadioGroup_ng_container_5_4_Template, 1, 1, null, 4);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance(3);
    ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.warnText));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.warnText));
  }
}
function RadioGroup_div_6_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.helperText);
  }
}
function RadioGroup_div_6_2_ng_template_0_Template(rf, ctx) {
}
function RadioGroup_div_6_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, RadioGroup_div_6_2_ng_template_0_Template, 0, 0, "ng-template", 8);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.helperText);
  }
}
function RadioGroup_div_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 12);
    ɵɵtemplate(1, RadioGroup_div_6_ng_container_1_Template, 2, 1, "ng-container", 4)(2, RadioGroup_div_6_2_Template, 1, 1, null, 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ɵɵpureFunction1(3, _c38, ctx_r0.disabled));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.helperText));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.helperText));
  }
}
var RadioChange = class {
  constructor(source, value) {
    this.source = source;
    this.value = value;
  }
};
var Radio = class _Radio {
  constructor() {
    this.checked = false;
    this.name = "";
    this.disabled = false;
    this.labelPlacement = "right";
    this.required = false;
    this.skeleton = false;
    this.id = `radio-${_Radio.radioCount++}`;
    this.change = new EventEmitter();
    this.hostClass = true;
    this.disabledFromGroup = false;
    this._labelledby = "";
    this.radioChangeHandler = (event) => {
    };
  }
  set ariaLabelledby(value) {
    this._labelledby = value;
  }
  get ariaLabelledby() {
    if (this._labelledby) {
      return this._labelledby;
    }
    return `label-${this.id}`;
  }
  get labelLeft() {
    return this.labelPlacement === "left";
  }
  /**
   * Synchronizes with the `RadioGroup` in the event of a changed `Radio`.
   * Emits the changes of both the `RadioGroup` and `Radio`.
   */
  onChange(event) {
    event.stopPropagation();
  }
  onClick(event) {
    this.checked = event.target.checked;
    const radioEvent = new RadioChange(this, this.value);
    this.change.emit(radioEvent);
    this.radioChangeHandler(radioEvent);
  }
  /**
   * Method called by `RadioGroup` with a callback function to bubble `RadioChange` events
   * @param fn callback that expects a `RadioChange` as an argument
   */
  registerRadioChangeHandler(fn) {
    this.radioChangeHandler = fn;
  }
  setDisabledFromGroup(disabled) {
    this.disabledFromGroup = disabled;
  }
};
Radio.radioCount = 0;
Radio.ɵfac = function Radio_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Radio)();
};
Radio.ɵcmp = ɵɵdefineComponent({
  type: Radio,
  selectors: [["cds-radio"], ["ibm-radio"]],
  hostVars: 4,
  hostBindings: function Radio_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--radio-button-wrapper", ctx.hostClass)("cds--radio-button-wrapper--label-left", ctx.labelLeft);
    }
  },
  inputs: {
    checked: "checked",
    name: "name",
    disabled: "disabled",
    labelPlacement: "labelPlacement",
    ariaLabelledby: "ariaLabelledby",
    ariaLabel: "ariaLabel",
    required: "required",
    value: "value",
    skeleton: "skeleton",
    id: "id"
  },
  outputs: {
    change: "change"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: Radio,
    multi: true
  }])],
  ngContentSelectors: _c020,
  decls: 5,
  vars: 9,
  consts: [["class", "cds--radio-button", "type", "radio", 3, "checked", "disabled", "name", "id", "required", "change", "click", 4, "ngIf"], ["class", "cds--radio-button cds--skeleton", 4, "ngIf"], [1, "cds--radio-button__label", 3, "ngClass", "for", "id"], [1, "cds--radio-button__appearance"], ["type", "radio", 1, "cds--radio-button", 3, "change", "click", "checked", "disabled", "name", "id", "required"], [1, "cds--radio-button", "cds--skeleton"]],
  template: function Radio_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, Radio_input_0_Template, 1, 7, "input", 0)(1, Radio_div_1_Template, 1, 0, "div", 1);
      ɵɵelementStart(2, "label", 2);
      ɵɵelement(3, "span", 3);
      ɵɵprojection(4);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", !ctx.skeleton);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.skeleton);
      ɵɵadvance();
      ɵɵpropertyInterpolate1("id", "label-", ctx.id, "");
      ɵɵproperty("ngClass", ɵɵpureFunction1(7, _c118, ctx.skeleton))("for", ctx.id);
      ɵɵattribute("aria-label", ctx.ariaLabel);
    }
  },
  dependencies: [NgClass, NgIf],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Radio, [{
    type: Component,
    args: [{
      selector: "cds-radio, ibm-radio",
      template: `
		<input
			*ngIf="!skeleton"
			class="cds--radio-button"
			type="radio"
			[checked]="checked"
			[disabled]="disabled || disabledFromGroup"
			[name]="name"
			[id]="id"
			[required]="required"
			[attr.value]="value"
			[attr.aria-labelledby]="ariaLabelledby"
			(change)="onChange($event)"
			(click)="onClick($event)">
		<div *ngIf="skeleton" class="cds--radio-button cds--skeleton"></div>
		<label
			class="cds--radio-button__label"
			[attr.aria-label]="ariaLabel"
			[ngClass]="{
				'cds--skeleton': skeleton
			}"
			[for]="id"
			id="label-{{id}}">
			<span class="cds--radio-button__appearance"></span>
			<ng-content></ng-content>
		</label>
	`,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: Radio,
        multi: true
      }]
    }]
  }], null, {
    checked: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    labelPlacement: [{
      type: Input
    }],
    ariaLabelledby: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    required: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    skeleton: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    change: [{
      type: Output
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.cds--radio-button-wrapper"]
    }],
    labelLeft: [{
      type: HostBinding,
      args: ["class.cds--radio-button-wrapper--label-left"]
    }]
  });
})();
var RadioGroup = class _RadioGroup {
  constructor() {
    this.orientation = "horizontal";
    this.labelPlacement = "right";
    this.invalid = false;
    this.warn = false;
    this.change = new EventEmitter();
    this.radioButtonGroupClass = true;
    this.isInitialized = false;
    this._disabled = false;
    this._skeleton = false;
    this._value = null;
    this._selected = null;
    this._name = `radio-group-${_RadioGroup.radioGroupCount++}`;
    this.onTouched = () => {
    };
    this.propagateChange = (_) => {
    };
  }
  /**
   * Sets the passed in `Radio` item as the selected input within the `RadioGroup`.
   */
  set selected(selected) {
    const alreadySelected = (this._selected && this._selected.value) === (selected && selected.value);
    if (alreadySelected) {
      return;
    }
    if (this._selected) {
      this._selected.checked = false;
    }
    this._selected = selected;
    this.value = selected ? selected.value : null;
    this.checkSelectedRadio();
  }
  /**
   * Returns the `Radio` that is selected within the `RadioGroup`.
   */
  get selected() {
    return this._selected;
  }
  /**
   * Sets the value/state of the selected `Radio` within the `RadioGroup` to the passed in value.
   */
  set value(newValue) {
    if (this._value !== newValue) {
      this._value = newValue;
      this.updateSelectedRadioFromValue();
      this.checkSelectedRadio();
    }
  }
  /**
   * Returns the value/state of the selected `Radio` within the `RadioGroup`.
   */
  get value() {
    return this._value;
  }
  /**
   * Replaces the name associated with the `RadioGroup` with the provided parameter.
   */
  set name(name) {
    this._name = name;
    this.updateRadios();
  }
  /**
   * Returns the associated name of the `RadioGroup`.
   */
  get name() {
    return this._name;
  }
  /**
   * Set to true to disable the whole radio group
   */
  set disabled(disabled) {
    this._disabled = disabled;
    this.updateRadios();
  }
  /**
   * Returns the disabled value for the `RadioGroup`.
   */
  get disabled() {
    return this._disabled;
  }
  /**
   * Returns the skeleton value in the `RadioGroup` if there is one.
   */
  get skeleton() {
    return this._skeleton;
  }
  /**
   * Sets the skeleton value for all `Radio` to the skeleton value of `RadioGroup`.
   */
  set skeleton(value) {
    this._skeleton = value;
    this.updateChildren();
  }
  /**
   * Updates the selected `Radio` to be checked (selected).
   */
  checkSelectedRadio() {
    if (this.selected && !this._selected.checked) {
      this.selected.checked = true;
    }
  }
  /**
   * Use the value of the `RadioGroup` to update the selected radio to the right state (selected state).
   */
  updateSelectedRadioFromValue() {
    let alreadySelected = this._selected != null && this._selected.value === this._value;
    if (this.radios && !alreadySelected) {
      if (this.selected && this.value) {
        this.selected.checked = false;
      }
      this._selected = null;
      this.radios.forEach((radio) => {
        if (radio.checked || radio.value === this._value) {
          this._selected = radio;
        }
      });
      if (this.selected && !this.value) {
        this._value = this.selected.value;
      }
    }
  }
  /**
   * `ControlValueAccessor` method to programmatically disable the `RadioGroup`.
   *
   * ex: `this.formGroup.get("myRadioGroup").disable();`
   *
   * @param isDisabled `true` to disable the inputs
   */
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  /**
   * Creates a class of `RadioChange` to emit the change in the `RadioGroup`.
   */
  emitChangeEvent(event) {
    this.change.emit(event);
    this.propagateChange(event.value);
    this.onTouched();
  }
  /**
   * Synchronizes radio properties.
   */
  updateRadios() {
    if (this.radios) {
      setTimeout(() => {
        this.radios.forEach((radio) => {
          radio.name = this.name;
          radio.setDisabledFromGroup(this.disabled);
          if (this.labelPlacement === "left") {
            radio.labelPlacement = "left";
          }
        });
      });
    }
  }
  /**
   * Updates the value of the `RadioGroup` using the provided parameter.
   */
  writeValue(value) {
    this.value = value;
    setTimeout(() => {
      this.updateSelectedRadioFromValue();
      this.checkSelectedRadio();
    });
  }
  ngAfterContentInit() {
    this.radios.changes.subscribe(() => {
      this.updateRadios();
      this.updateRadioChangeHandler();
    });
    this.updateChildren();
    this.updateRadioChangeHandler();
  }
  ngAfterViewInit() {
    this.updateRadios();
  }
  /**
   * Used to set method to propagate changes back to the form.
   */
  registerOnChange(fn) {
    this.propagateChange = fn;
  }
  /**
   * Registers a callback to be triggered when the control has been touched.
   * @param fn Callback to be triggered when the checkbox is touched.
   */
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  focusOut() {
    this.onTouched();
  }
  isTemplate(value) {
    return value instanceof TemplateRef;
  }
  updateChildren() {
    if (this.radios) {
      this.radios.forEach((child) => child.skeleton = this.skeleton);
    }
  }
  updateRadioChangeHandler() {
    this.radios.forEach((radio) => {
      radio.registerRadioChangeHandler((event) => {
        if ((this.selected && this.selected.value) === event.value) {
          return;
        }
        if (this.selected) {
          this.selected.checked = false;
        }
        this._selected = event.source;
        this._value = event.value;
        this.emitChangeEvent(event);
      });
    });
  }
};
RadioGroup.radioGroupCount = 0;
RadioGroup.ɵfac = function RadioGroup_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RadioGroup)();
};
RadioGroup.ɵcmp = ɵɵdefineComponent({
  type: RadioGroup,
  selectors: [["cds-radio-group"], ["ibm-radio-group"]],
  contentQueries: function RadioGroup_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, Radio, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.radios = _t);
    }
  },
  hostVars: 2,
  hostBindings: function RadioGroup_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("focusout", function RadioGroup_focusout_HostBindingHandler() {
        return ctx.focusOut();
      });
    }
    if (rf & 2) {
      ɵɵclassProp("cds--form-item", ctx.radioButtonGroupClass);
    }
  },
  inputs: {
    selected: "selected",
    value: "value",
    name: "name",
    disabled: "disabled",
    skeleton: "skeleton",
    orientation: "orientation",
    labelPlacement: "labelPlacement",
    legend: "legend",
    ariaLabel: "ariaLabel",
    ariaLabelledby: "ariaLabelledby",
    helperText: "helperText",
    invalid: "invalid",
    invalidText: "invalidText",
    warn: "warn",
    warnText: "warnText"
  },
  outputs: {
    change: "change"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: RadioGroup,
    multi: true
  }])],
  ngContentSelectors: _c020,
  decls: 7,
  vars: 13,
  consts: [["legendLabel", ""], [1, "cds--radio-button-group", 3, "ngClass"], ["class", "cds--label", 4, "ngIf"], [1, "cds--radio-button__validation-msg"], [4, "ngIf"], ["class", "cds--form__helper-text", 3, "ngClass", 4, "ngIf"], [1, "cds--label"], [4, "ngIf", "ngIfElse"], [3, "ngTemplateOutlet"], ["cdsIcon", "warning--filled", "size", "16", 1, "cds--radio-button__invalid-icon"], [1, "cds--form-requirement"], ["cdsIcon", "warning--alt--filled", "size", "16", 1, "cds--radio-button__invalid-icon", "cds--radio-button__invalid-icon--warning"], [1, "cds--form__helper-text", 3, "ngClass"]],
  template: function RadioGroup_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "fieldset", 1);
      ɵɵtemplate(1, RadioGroup_legend_1_Template, 4, 2, "legend", 2);
      ɵɵprojection(2);
      ɵɵelementEnd();
      ɵɵelementStart(3, "div", 3);
      ɵɵtemplate(4, RadioGroup_ng_container_4_Template, 5, 2, "ng-container", 4)(5, RadioGroup_ng_container_5_Template, 5, 2, "ng-container", 4);
      ɵɵelementEnd();
      ɵɵtemplate(6, RadioGroup_div_6_Template, 3, 5, "div", 5);
    }
    if (rf & 2) {
      ɵɵproperty("ngClass", ɵɵpureFunction4(8, _c214, ctx.orientation === "vertical", ctx.labelPlacement === "left", ctx.invalid, !ctx.invalid && ctx.warn));
      ɵɵattribute("aria-label", ctx.ariaLabel)("aria-labelledby", ctx.ariaLabelledby)("data-invalid", ctx.invalid ? true : null);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.legend);
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.invalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.invalid && ctx.warn);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.helperText && !ctx.invalid && !ctx.warn);
    }
  },
  dependencies: [NgClass, NgIf, NgTemplateOutlet, IconDirective],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioGroup, [{
    type: Component,
    args: [{
      selector: "cds-radio-group, ibm-radio-group",
      template: `
		<fieldset
			class="cds--radio-button-group"
			[attr.aria-label]="ariaLabel"
			[attr.aria-labelledby]="ariaLabelledby"
			[ngClass]="{
				'cds--radio-button-group--vertical': orientation === 'vertical',
				'cds--radio-button-group--label-left': labelPlacement === 'left',
				'cds--radio-button-group--invalid': invalid,
				'cds--radio-button-group--warning': !invalid && warn
			}"
			[attr.data-invalid]="invalid ? true : null">
			<legend *ngIf="legend" class="cds--label">
				<ng-template *ngIf="isTemplate(legend); else legendLabel;" [ngTemplateOutlet]="legend"></ng-template>
				<ng-template #legendLabel>{{legend}}</ng-template>
			</legend>
			<ng-content></ng-content>
		</fieldset>
		<div class="cds--radio-button__validation-msg">
			<ng-container *ngIf="invalid">
				<svg
					cdsIcon="warning--filled"
					size="16"
					class="cds--radio-button__invalid-icon">
				</svg>
				<div class="cds--form-requirement">
					<ng-container *ngIf="!isTemplate(invalidText)">{{ invalidText }}</ng-container>
					<ng-template *ngIf="isTemplate(invalidText)" [ngTemplateOutlet]="invalidText"></ng-template>
				</div>
			</ng-container>
			<ng-container *ngIf="!invalid && warn">
				<svg
					cdsIcon="warning--alt--filled"
					class="cds--radio-button__invalid-icon cds--radio-button__invalid-icon--warning"
					size="16">
				</svg>
				<div class="cds--form-requirement">
					<ng-container *ngIf="!isTemplate(warnText)">{{warnText}}</ng-container>
					<ng-template *ngIf="isTemplate(warnText)" [ngTemplateOutlet]="warnText"></ng-template>
				</div>
			</ng-container>
		</div>
		<div
			*ngIf="helperText && !invalid && !warn"
			class="cds--form__helper-text"
			[ngClass]="{'cds--form__helper-text--disabled': disabled}">
			<ng-container *ngIf="!isTemplate(helperText)">{{helperText}}</ng-container>
			<ng-template *ngIf="isTemplate(helperText)" [ngTemplateOutlet]="helperText"></ng-template>
		</div>
	`,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: RadioGroup,
        multi: true
      }]
    }]
  }], null, {
    selected: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    skeleton: [{
      type: Input
    }],
    orientation: [{
      type: Input
    }],
    labelPlacement: [{
      type: Input
    }],
    legend: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    ariaLabelledby: [{
      type: Input
    }],
    helperText: [{
      type: Input
    }],
    invalid: [{
      type: Input
    }],
    invalidText: [{
      type: Input
    }],
    warn: [{
      type: Input
    }],
    warnText: [{
      type: Input
    }],
    change: [{
      type: Output
    }],
    radios: [{
      type: ContentChildren,
      args: [forwardRef(() => Radio)]
    }],
    radioButtonGroupClass: [{
      type: HostBinding,
      args: ["class.cds--form-item"]
    }],
    focusOut: [{
      type: HostListener,
      args: ["focusout"]
    }]
  });
})();
var RadioModule = class {
};
RadioModule.ɵfac = function RadioModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RadioModule)();
};
RadioModule.ɵmod = ɵɵdefineNgModule({
  type: RadioModule,
  declarations: [Radio, RadioGroup],
  imports: [CommonModule, FormsModule, IconModule],
  exports: [Radio, RadioGroup]
});
RadioModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, FormsModule, IconModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioModule, [{
    type: NgModule,
    args: [{
      declarations: [Radio, RadioGroup],
      exports: [Radio, RadioGroup],
      imports: [CommonModule, FormsModule, IconModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-input.mjs
var _c021 = ["wrapper"];
var _c119 = ["*", [["", "cdsTextArea", ""], ["", "ibmTextArea", ""], ["textarea"]]];
var _c215 = ["*", "[cdsTextArea],[ibmTextArea],textarea"];
var _c39 = (a0) => ({
  "cds--label--disabled": a0
});
var _c47 = (a0) => ({
  "cds--text-area__wrapper--warn": a0
});
var _c55 = (a0) => ({
  "cds--form__helper-text--disabled": a0
});
function TextareaLabelComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "span", 4)(2, "div", 5);
    ɵɵelementContainerEnd();
  }
}
function TextareaLabelComponent_ng_container_1_3_ng_template_0_Template(rf, ctx) {
}
function TextareaLabelComponent_ng_container_1_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TextareaLabelComponent_ng_container_1_3_ng_template_0_Template, 0, 0, "ng-template", 12);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.labelTemplate);
  }
}
function TextareaLabelComponent_ng_container_1_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
function TextareaLabelComponent_ng_container_1__svg_svg_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 13);
  }
}
function TextareaLabelComponent_ng_container_1__svg_svg_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 14);
  }
}
function TextareaLabelComponent_ng_container_1_10_ng_template_0_Template(rf, ctx) {
}
function TextareaLabelComponent_ng_container_1_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TextareaLabelComponent_ng_container_1_10_ng_template_0_Template, 0, 0, "ng-template", 12);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.textAreaTemplate);
  }
}
function TextareaLabelComponent_ng_container_1_ng_template_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 1);
  }
}
function TextareaLabelComponent_ng_container_1_ng_container_13_div_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.invalidText);
  }
}
function TextareaLabelComponent_ng_container_1_ng_container_13_div_2_2_ng_template_0_Template(rf, ctx) {
}
function TextareaLabelComponent_ng_container_1_ng_container_13_div_2_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TextareaLabelComponent_ng_container_1_ng_container_13_div_2_2_ng_template_0_Template, 0, 0, "ng-template", 12);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.invalidText);
  }
}
function TextareaLabelComponent_ng_container_1_ng_container_13_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 17);
    ɵɵtemplate(1, TextareaLabelComponent_ng_container_1_ng_container_13_div_2_ng_container_1_Template, 2, 1, "ng-container", 3)(2, TextareaLabelComponent_ng_container_1_ng_container_13_div_2_2_Template, 1, 1, null, 3);
    ɵɵnamespaceSVG();
    ɵɵelement(3, "svg", 13);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.invalidText));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.invalidText));
  }
}
function TextareaLabelComponent_ng_container_1_ng_container_13_div_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.warnText);
  }
}
function TextareaLabelComponent_ng_container_1_ng_container_13_div_3_2_ng_template_0_Template(rf, ctx) {
}
function TextareaLabelComponent_ng_container_1_ng_container_13_div_3_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TextareaLabelComponent_ng_container_1_ng_container_13_div_3_2_ng_template_0_Template, 0, 0, "ng-template", 12);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.warnText);
  }
}
function TextareaLabelComponent_ng_container_1_ng_container_13_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 17);
    ɵɵtemplate(1, TextareaLabelComponent_ng_container_1_ng_container_13_div_3_ng_container_1_Template, 2, 1, "ng-container", 3)(2, TextareaLabelComponent_ng_container_1_ng_container_13_div_3_2_Template, 1, 1, null, 3);
    ɵɵnamespaceSVG();
    ɵɵelement(3, "svg", 14);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.warnText));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.warnText));
  }
}
function TextareaLabelComponent_ng_container_1_ng_container_13_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "hr", 15);
    ɵɵtemplate(2, TextareaLabelComponent_ng_container_1_ng_container_13_div_2_Template, 4, 2, "div", 16)(3, TextareaLabelComponent_ng_container_1_ng_container_13_div_3_Template, 4, 2, "div", 16);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r0.invalid);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.invalid && ctx_r0.warn);
  }
}
function TextareaLabelComponent_ng_container_1_ng_container_14_div_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.helperText);
  }
}
function TextareaLabelComponent_ng_container_1_ng_container_14_div_1_2_ng_template_0_Template(rf, ctx) {
}
function TextareaLabelComponent_ng_container_1_ng_container_14_div_1_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TextareaLabelComponent_ng_container_1_ng_container_14_div_1_2_ng_template_0_Template, 0, 0, "ng-template", 12);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.helperText);
  }
}
function TextareaLabelComponent_ng_container_1_ng_container_14_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 19);
    ɵɵtemplate(1, TextareaLabelComponent_ng_container_1_ng_container_14_div_1_ng_container_1_Template, 2, 1, "ng-container", 3)(2, TextareaLabelComponent_ng_container_1_ng_container_14_div_1_2_Template, 1, 1, null, 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("ngClass", ɵɵpureFunction1(3, _c55, ctx_r0.disabled));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.helperText));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.helperText));
  }
}
function TextareaLabelComponent_ng_container_1_ng_container_14_div_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.invalidText);
  }
}
function TextareaLabelComponent_ng_container_1_ng_container_14_div_2_2_ng_template_0_Template(rf, ctx) {
}
function TextareaLabelComponent_ng_container_1_ng_container_14_div_2_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TextareaLabelComponent_ng_container_1_ng_container_14_div_2_2_ng_template_0_Template, 0, 0, "ng-template", 12);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.invalidText);
  }
}
function TextareaLabelComponent_ng_container_1_ng_container_14_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 17);
    ɵɵtemplate(1, TextareaLabelComponent_ng_container_1_ng_container_14_div_2_ng_container_1_Template, 2, 1, "ng-container", 3)(2, TextareaLabelComponent_ng_container_1_ng_container_14_div_2_2_Template, 1, 1, null, 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.invalidText));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.invalidText));
  }
}
function TextareaLabelComponent_ng_container_1_ng_container_14_div_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.warnText);
  }
}
function TextareaLabelComponent_ng_container_1_ng_container_14_div_3_2_ng_template_0_Template(rf, ctx) {
}
function TextareaLabelComponent_ng_container_1_ng_container_14_div_3_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TextareaLabelComponent_ng_container_1_ng_container_14_div_3_2_ng_template_0_Template, 0, 0, "ng-template", 12);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.warnText);
  }
}
function TextareaLabelComponent_ng_container_1_ng_container_14_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 17);
    ɵɵtemplate(1, TextareaLabelComponent_ng_container_1_ng_container_14_div_3_ng_container_1_Template, 2, 1, "ng-container", 3)(2, TextareaLabelComponent_ng_container_1_ng_container_14_div_3_2_Template, 1, 1, null, 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.warnText));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.warnText));
  }
}
function TextareaLabelComponent_ng_container_1_ng_container_14_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, TextareaLabelComponent_ng_container_1_ng_container_14_div_1_Template, 3, 5, "div", 18)(2, TextareaLabelComponent_ng_container_1_ng_container_14_div_2_Template, 3, 2, "div", 16)(3, TextareaLabelComponent_ng_container_1_ng_container_14_div_3_Template, 3, 2, "div", 16);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.helperText && !ctx_r0.invalid && !ctx_r0.warn);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.invalid);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.invalid && ctx_r0.warn);
  }
}
function TextareaLabelComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 6)(2, "label", 7);
    ɵɵtemplate(3, TextareaLabelComponent_ng_container_1_3_Template, 1, 1, null, 8)(4, TextareaLabelComponent_ng_container_1_ng_template_4_Template, 1, 0, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    ɵɵelementEnd()();
    ɵɵelementStart(6, "div", 9, 1);
    ɵɵtemplate(8, TextareaLabelComponent_ng_container_1__svg_svg_8_Template, 1, 0, "svg", 10)(9, TextareaLabelComponent_ng_container_1__svg_svg_9_Template, 1, 0, "svg", 11)(10, TextareaLabelComponent_ng_container_1_10_Template, 1, 1, null, 8)(11, TextareaLabelComponent_ng_container_1_ng_template_11_Template, 1, 0, "ng-template", null, 2, ɵɵtemplateRefExtractor)(13, TextareaLabelComponent_ng_container_1_ng_container_13_Template, 4, 2, "ng-container", 3);
    ɵɵelementEnd();
    ɵɵtemplate(14, TextareaLabelComponent_ng_container_1_ng_container_14_Template, 4, 3, "ng-container", 3);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const labelContent_r2 = ɵɵreference(5);
    const textAreaContent_r3 = ɵɵreference(12);
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵproperty("for", ctx_r0.labelInputID)("ngClass", ɵɵpureFunction1(13, _c39, ctx_r0.disabled));
    ɵɵattribute("aria-label", ctx_r0.ariaLabel);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.labelTemplate)("ngIfElse", labelContent_r2);
    ɵɵadvance(3);
    ɵɵproperty("ngClass", ɵɵpureFunction1(15, _c47, ctx_r0.warn));
    ɵɵattribute("data-invalid", ctx_r0.invalid ? true : null);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", !ctx_r0.fluid && ctx_r0.invalid);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.fluid && !ctx_r0.invalid && ctx_r0.warn);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.textAreaTemplate)("ngIfElse", textAreaContent_r3);
    ɵɵadvance(3);
    ɵɵproperty("ngIf", ctx_r0.fluid);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.fluid);
  }
}
var _c64 = ["*", [["", "cdsText", ""], ["", "ibmText", ""], ["input", "type", "text"], ["div"]]];
var _c73 = ["*", "[cdsText],[ibmText],input[type=text],div"];
var _c83 = (a0) => ({
  "cds--text-input__field-wrapper--warning": a0
});
function TextInputLabelComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "span", 6)(2, "div", 7);
    ɵɵelementContainerEnd();
  }
}
function TextInputLabelComponent_label_1_1_ng_template_0_Template(rf, ctx) {
}
function TextInputLabelComponent_label_1_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TextInputLabelComponent_label_1_1_ng_template_0_Template, 0, 0, "ng-template", 10);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.labelTemplate);
  }
}
function TextInputLabelComponent_label_1_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
function TextInputLabelComponent_label_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "label", 8);
    ɵɵtemplate(1, TextInputLabelComponent_label_1_1_Template, 1, 1, null, 9)(2, TextInputLabelComponent_label_1_ng_template_2_Template, 1, 0, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const labelContent_r2 = ɵɵreference(3);
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("for", ctx_r0.labelInputID)("ngClass", ɵɵpureFunction1(5, _c39, ctx_r0.disabled));
    ɵɵattribute("aria-label", ctx_r0.ariaLabel);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.labelTemplate)("ngIfElse", labelContent_r2);
  }
}
function TextInputLabelComponent_div_2__svg_svg_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 15);
  }
}
function TextInputLabelComponent_div_2__svg_svg_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 16);
  }
}
function TextInputLabelComponent_div_2_5_ng_template_0_Template(rf, ctx) {
}
function TextInputLabelComponent_div_2_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TextInputLabelComponent_div_2_5_ng_template_0_Template, 0, 0, "ng-template", 10);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.textInputTemplate);
  }
}
function TextInputLabelComponent_div_2_ng_template_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 1);
  }
}
function TextInputLabelComponent_div_2_ng_container_8_div_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.invalidText);
  }
}
function TextInputLabelComponent_div_2_ng_container_8_div_2_2_ng_template_0_Template(rf, ctx) {
}
function TextInputLabelComponent_div_2_ng_container_8_div_2_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TextInputLabelComponent_div_2_ng_container_8_div_2_2_ng_template_0_Template, 0, 0, "ng-template", 10);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.invalidText);
  }
}
function TextInputLabelComponent_div_2_ng_container_8_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 19);
    ɵɵtemplate(1, TextInputLabelComponent_div_2_ng_container_8_div_2_ng_container_1_Template, 2, 1, "ng-container", 3)(2, TextInputLabelComponent_div_2_ng_container_8_div_2_2_Template, 1, 1, null, 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.invalidText));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.invalidText));
  }
}
function TextInputLabelComponent_div_2_ng_container_8_div_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.warnText);
  }
}
function TextInputLabelComponent_div_2_ng_container_8_div_3_2_ng_template_0_Template(rf, ctx) {
}
function TextInputLabelComponent_div_2_ng_container_8_div_3_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TextInputLabelComponent_div_2_ng_container_8_div_3_2_ng_template_0_Template, 0, 0, "ng-template", 10);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.warnText);
  }
}
function TextInputLabelComponent_div_2_ng_container_8_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 19);
    ɵɵtemplate(1, TextInputLabelComponent_div_2_ng_container_8_div_3_ng_container_1_Template, 2, 1, "ng-container", 3)(2, TextInputLabelComponent_div_2_ng_container_8_div_3_2_Template, 1, 1, null, 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.warnText));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.warnText));
  }
}
function TextInputLabelComponent_div_2_ng_container_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "hr", 17);
    ɵɵtemplate(2, TextInputLabelComponent_div_2_ng_container_8_div_2_Template, 3, 2, "div", 18)(3, TextInputLabelComponent_div_2_ng_container_8_div_3_Template, 3, 2, "div", 18);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r0.invalid);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.invalid && ctx_r0.warn);
  }
}
function TextInputLabelComponent_div_2_ng_container_9_div_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.helperText);
  }
}
function TextInputLabelComponent_div_2_ng_container_9_div_1_2_ng_template_0_Template(rf, ctx) {
}
function TextInputLabelComponent_div_2_ng_container_9_div_1_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TextInputLabelComponent_div_2_ng_container_9_div_1_2_ng_template_0_Template, 0, 0, "ng-template", 10);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.helperText);
  }
}
function TextInputLabelComponent_div_2_ng_container_9_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 21);
    ɵɵtemplate(1, TextInputLabelComponent_div_2_ng_container_9_div_1_ng_container_1_Template, 2, 1, "ng-container", 3)(2, TextInputLabelComponent_div_2_ng_container_9_div_1_2_Template, 1, 1, null, 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("ngClass", ɵɵpureFunction1(3, _c55, ctx_r0.disabled));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.helperText));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.helperText));
  }
}
function TextInputLabelComponent_div_2_ng_container_9_div_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.invalidText);
  }
}
function TextInputLabelComponent_div_2_ng_container_9_div_2_2_ng_template_0_Template(rf, ctx) {
}
function TextInputLabelComponent_div_2_ng_container_9_div_2_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TextInputLabelComponent_div_2_ng_container_9_div_2_2_ng_template_0_Template, 0, 0, "ng-template", 10);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.invalidText);
  }
}
function TextInputLabelComponent_div_2_ng_container_9_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 19);
    ɵɵtemplate(1, TextInputLabelComponent_div_2_ng_container_9_div_2_ng_container_1_Template, 2, 1, "ng-container", 3)(2, TextInputLabelComponent_div_2_ng_container_9_div_2_2_Template, 1, 1, null, 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.invalidText));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.invalidText));
  }
}
function TextInputLabelComponent_div_2_ng_container_9_div_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.warnText);
  }
}
function TextInputLabelComponent_div_2_ng_container_9_div_3_2_ng_template_0_Template(rf, ctx) {
}
function TextInputLabelComponent_div_2_ng_container_9_div_3_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TextInputLabelComponent_div_2_ng_container_9_div_3_2_ng_template_0_Template, 0, 0, "ng-template", 10);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.warnText);
  }
}
function TextInputLabelComponent_div_2_ng_container_9_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 19);
    ɵɵtemplate(1, TextInputLabelComponent_div_2_ng_container_9_div_3_ng_container_1_Template, 2, 1, "ng-container", 3)(2, TextInputLabelComponent_div_2_ng_container_9_div_3_2_Template, 1, 1, null, 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.warnText));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.warnText));
  }
}
function TextInputLabelComponent_div_2_ng_container_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, TextInputLabelComponent_div_2_ng_container_9_div_1_Template, 3, 5, "div", 20)(2, TextInputLabelComponent_div_2_ng_container_9_div_2_Template, 3, 2, "div", 18)(3, TextInputLabelComponent_div_2_ng_container_9_div_3_Template, 3, 2, "div", 18);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.helperText && !ctx_r0.invalid && !ctx_r0.warn);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.invalid);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.invalid && ctx_r0.warn);
  }
}
function TextInputLabelComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 11)(1, "div", 12, 1);
    ɵɵtemplate(3, TextInputLabelComponent_div_2__svg_svg_3_Template, 1, 0, "svg", 13)(4, TextInputLabelComponent_div_2__svg_svg_4_Template, 1, 0, "svg", 14)(5, TextInputLabelComponent_div_2_5_Template, 1, 1, null, 9)(6, TextInputLabelComponent_div_2_ng_template_6_Template, 1, 0, "ng-template", null, 2, ɵɵtemplateRefExtractor)(8, TextInputLabelComponent_div_2_ng_container_8_Template, 4, 2, "ng-container", 3);
    ɵɵelementEnd();
    ɵɵtemplate(9, TextInputLabelComponent_div_2_ng_container_9_Template, 4, 3, "ng-container", 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const textInputContent_r3 = ɵɵreference(7);
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngClass", ɵɵpureFunction1(8, _c83, ctx_r0.warn));
    ɵɵattribute("data-invalid", ctx_r0.invalid ? true : null);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r0.invalid && !ctx_r0.warn);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.invalid && ctx_r0.warn);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.textInputTemplate)("ngIfElse", textInputContent_r3);
    ɵɵadvance(3);
    ɵɵproperty("ngIf", ctx_r0.fluid);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.fluid);
  }
}
var _c93 = ["*", [["", "cdsPassword", ""], ["", "ibmPassword", ""]]];
var _c103 = ["*", "[cdsPassword], [ibmPassword]"];
function PasswordInputLabelComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "span", 5)(2, "div", 6);
    ɵɵelementContainerEnd();
  }
}
function PasswordInputLabelComponent_label_1_1_ng_template_0_Template(rf, ctx) {
}
function PasswordInputLabelComponent_label_1_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PasswordInputLabelComponent_label_1_1_ng_template_0_Template, 0, 0, "ng-template", 9);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.labelTemplate);
  }
}
function PasswordInputLabelComponent_label_1_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
function PasswordInputLabelComponent_label_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "label", 7);
    ɵɵtemplate(1, PasswordInputLabelComponent_label_1_1_Template, 1, 1, null, 8)(2, PasswordInputLabelComponent_label_1_ng_template_2_Template, 1, 0, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const labelContent_r2 = ɵɵreference(3);
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("for", ctx_r0.labelInputID)("ngClass", ɵɵpureFunction1(5, _c39, ctx_r0.disabled));
    ɵɵattribute("aria-label", ctx_r0.ariaLabel);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.labelTemplate)("ngIfElse", labelContent_r2);
  }
}
function PasswordInputLabelComponent_div_2__svg_svg_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 15);
  }
}
function PasswordInputLabelComponent_div_2__svg_svg_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 16);
  }
}
function PasswordInputLabelComponent_div_2_cds_tooltip_6__svg_svg_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 22);
  }
}
function PasswordInputLabelComponent_div_2_cds_tooltip_6__svg_svg_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 23);
  }
}
function PasswordInputLabelComponent_div_2_cds_tooltip_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "cds-tooltip", 17)(1, "div", 18)(2, "button", 19);
    ɵɵlistener("click", function PasswordInputLabelComponent_div_2_cds_tooltip_6_Template_button_click_2_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.handleTogglePasswordVisibility($event));
    });
    ɵɵtemplate(3, PasswordInputLabelComponent_div_2_cds_tooltip_6__svg_svg_3_Template, 1, 0, "svg", 20)(4, PasswordInputLabelComponent_div_2_cds_tooltip_6__svg_svg_4_Template, 1, 0, "svg", 21);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("description", ctx_r0.passwordIsVisible ? ctx_r0.hidePasswordLabel : ctx_r0.showPasswordLabel)("disabled", ctx_r0.disabled)("caret", ctx_r0.caret)("dropShadow", ctx_r0.dropShadow)("highContrast", ctx_r0.highContrast)("isOpen", ctx_r0.isOpen)("align", ctx_r0.align)("autoAlign", ctx_r0.autoAlign)("enterDelayMs", ctx_r0.enterDelayMs)("leaveDelayMs", ctx_r0.leaveDelayMs);
    ɵɵadvance(2);
    ɵɵproperty("disabled", ctx_r0.disabled);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.passwordIsVisible);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.passwordIsVisible);
  }
}
function PasswordInputLabelComponent_div_2_ng_container_7_div_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.invalidText);
  }
}
function PasswordInputLabelComponent_div_2_ng_container_7_div_2_2_ng_template_0_Template(rf, ctx) {
}
function PasswordInputLabelComponent_div_2_ng_container_7_div_2_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PasswordInputLabelComponent_div_2_ng_container_7_div_2_2_ng_template_0_Template, 0, 0, "ng-template", 9);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.invalidText);
  }
}
function PasswordInputLabelComponent_div_2_ng_container_7_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 26);
    ɵɵtemplate(1, PasswordInputLabelComponent_div_2_ng_container_7_div_2_ng_container_1_Template, 2, 1, "ng-container", 2)(2, PasswordInputLabelComponent_div_2_ng_container_7_div_2_2_Template, 1, 1, null, 2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.invalidText));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.invalidText));
  }
}
function PasswordInputLabelComponent_div_2_ng_container_7_div_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.warnText);
  }
}
function PasswordInputLabelComponent_div_2_ng_container_7_div_3_2_ng_template_0_Template(rf, ctx) {
}
function PasswordInputLabelComponent_div_2_ng_container_7_div_3_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PasswordInputLabelComponent_div_2_ng_container_7_div_3_2_ng_template_0_Template, 0, 0, "ng-template", 9);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.warnText);
  }
}
function PasswordInputLabelComponent_div_2_ng_container_7_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 26);
    ɵɵtemplate(1, PasswordInputLabelComponent_div_2_ng_container_7_div_3_ng_container_1_Template, 2, 1, "ng-container", 2)(2, PasswordInputLabelComponent_div_2_ng_container_7_div_3_2_Template, 1, 1, null, 2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.warnText));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.warnText));
  }
}
function PasswordInputLabelComponent_div_2_ng_container_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "hr", 24);
    ɵɵtemplate(2, PasswordInputLabelComponent_div_2_ng_container_7_div_2_Template, 3, 2, "div", 25)(3, PasswordInputLabelComponent_div_2_ng_container_7_div_3_Template, 3, 2, "div", 25);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", !ctx_r0.warn && ctx_r0.invalid);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.invalid && ctx_r0.warn);
  }
}
function PasswordInputLabelComponent_div_2_ng_container_8_div_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.helperText);
  }
}
function PasswordInputLabelComponent_div_2_ng_container_8_div_1_2_ng_template_0_Template(rf, ctx) {
}
function PasswordInputLabelComponent_div_2_ng_container_8_div_1_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PasswordInputLabelComponent_div_2_ng_container_8_div_1_2_ng_template_0_Template, 0, 0, "ng-template", 9);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.helperText);
  }
}
function PasswordInputLabelComponent_div_2_ng_container_8_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 28);
    ɵɵtemplate(1, PasswordInputLabelComponent_div_2_ng_container_8_div_1_ng_container_1_Template, 2, 1, "ng-container", 2)(2, PasswordInputLabelComponent_div_2_ng_container_8_div_1_2_Template, 1, 1, null, 2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("ngClass", ɵɵpureFunction1(3, _c55, ctx_r0.disabled));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.helperText));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.helperText));
  }
}
function PasswordInputLabelComponent_div_2_ng_container_8_div_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.invalidText);
  }
}
function PasswordInputLabelComponent_div_2_ng_container_8_div_2_2_ng_template_0_Template(rf, ctx) {
}
function PasswordInputLabelComponent_div_2_ng_container_8_div_2_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PasswordInputLabelComponent_div_2_ng_container_8_div_2_2_ng_template_0_Template, 0, 0, "ng-template", 9);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.invalidText);
  }
}
function PasswordInputLabelComponent_div_2_ng_container_8_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 26);
    ɵɵtemplate(1, PasswordInputLabelComponent_div_2_ng_container_8_div_2_ng_container_1_Template, 2, 1, "ng-container", 2)(2, PasswordInputLabelComponent_div_2_ng_container_8_div_2_2_Template, 1, 1, null, 2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.invalidText));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.invalidText));
  }
}
function PasswordInputLabelComponent_div_2_ng_container_8_div_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.warnText);
  }
}
function PasswordInputLabelComponent_div_2_ng_container_8_div_3_2_ng_template_0_Template(rf, ctx) {
}
function PasswordInputLabelComponent_div_2_ng_container_8_div_3_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PasswordInputLabelComponent_div_2_ng_container_8_div_3_2_ng_template_0_Template, 0, 0, "ng-template", 9);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.warnText);
  }
}
function PasswordInputLabelComponent_div_2_ng_container_8_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 26);
    ɵɵtemplate(1, PasswordInputLabelComponent_div_2_ng_container_8_div_3_ng_container_1_Template, 2, 1, "ng-container", 2)(2, PasswordInputLabelComponent_div_2_ng_container_8_div_3_2_Template, 1, 1, null, 2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.warnText));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.warnText));
  }
}
function PasswordInputLabelComponent_div_2_ng_container_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, PasswordInputLabelComponent_div_2_ng_container_8_div_1_Template, 3, 5, "div", 27)(2, PasswordInputLabelComponent_div_2_ng_container_8_div_2_Template, 3, 2, "div", 25)(3, PasswordInputLabelComponent_div_2_ng_container_8_div_3_Template, 3, 2, "div", 25);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.skeleton && ctx_r0.helperText && !ctx_r0.invalid && !ctx_r0.warn);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.warn && ctx_r0.invalid);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.invalid && ctx_r0.warn);
  }
}
function PasswordInputLabelComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 10)(1, "div", 11, 1);
    ɵɵtemplate(3, PasswordInputLabelComponent_div_2__svg_svg_3_Template, 1, 0, "svg", 12)(4, PasswordInputLabelComponent_div_2__svg_svg_4_Template, 1, 0, "svg", 13);
    ɵɵprojection(5, 1);
    ɵɵtemplate(6, PasswordInputLabelComponent_div_2_cds_tooltip_6_Template, 5, 13, "cds-tooltip", 14)(7, PasswordInputLabelComponent_div_2_ng_container_7_Template, 4, 2, "ng-container", 2);
    ɵɵelementEnd();
    ɵɵtemplate(8, PasswordInputLabelComponent_div_2_ng_container_8_Template, 4, 3, "ng-container", 2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngClass", ɵɵpureFunction1(7, _c83, ctx_r0.warn));
    ɵɵattribute("data-invalid", ctx_r0.invalid ? true : null);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", !ctx_r0.warn && ctx_r0.invalid);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.invalid && ctx_r0.warn);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", !ctx_r0.skeleton);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.fluid);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.fluid);
  }
}
var _c1110 = [[["input"], ["textarea"], ["div"]], "*"];
var _c123 = ["input,textarea,div", "*"];
var _c132 = (a0, a1) => ({
  "cds--label--disabled": a0,
  "cds--skeleton": a1
});
function Label_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
function Label_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 1);
  }
}
function Label_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "cds-textarea-label", 7);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    const inputContentTemplate_r2 = ɵɵreference(1);
    const labelContentTemplate_r3 = ɵɵreference(3);
    ɵɵadvance();
    ɵɵproperty("labelInputID", ctx_r0.labelInputID)("disabled", ctx_r0.disabled)("skeleton", ctx_r0.skeleton)("helperText", ctx_r0.helperText)("invalid", ctx_r0.invalid)("invalidText", ctx_r0.invalidText)("warn", ctx_r0.warn)("warnText", ctx_r0.warnText)("ariaLabel", ctx_r0.ariaLabel)("labelTemplate", labelContentTemplate_r3)("textAreaTemplate", inputContentTemplate_r2);
  }
}
function Label_ng_container_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "cds-text-label", 8);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    const inputContentTemplate_r2 = ɵɵreference(1);
    const labelContentTemplate_r3 = ɵɵreference(3);
    ɵɵadvance();
    ɵɵproperty("labelInputID", ctx_r0.labelInputID)("disabled", ctx_r0.disabled)("skeleton", ctx_r0.skeleton)("helperText", ctx_r0.helperText)("invalid", ctx_r0.invalid)("invalidText", ctx_r0.invalidText)("warn", ctx_r0.warn)("warnText", ctx_r0.warnText)("ariaLabel", ctx_r0.ariaLabel)("labelTemplate", labelContentTemplate_r3)("textInputTemplate", inputContentTemplate_r2);
  }
}
function Label_ng_container_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "cds-password-label", 9);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    const inputContentTemplate_r2 = ɵɵreference(1);
    const labelContentTemplate_r3 = ɵɵreference(3);
    ɵɵadvance();
    ɵɵproperty("labelInputID", ctx_r0.labelInputID)("disabled", ctx_r0.disabled)("skeleton", ctx_r0.skeleton)("helperText", ctx_r0.helperText)("invalid", ctx_r0.invalid)("invalidText", ctx_r0.invalidText)("warn", ctx_r0.warn)("warnText", ctx_r0.warnText)("ariaLabel", ctx_r0.ariaLabel)("labelTemplate", labelContentTemplate_r3)("passwordInputTemplate", inputContentTemplate_r2);
  }
}
function Label_ng_container_8_ng_template_1_Template(rf, ctx) {
}
function Label_ng_container_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, Label_ng_container_8_ng_template_1_Template, 0, 0, "ng-template", 10);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    ɵɵnextContext();
    const default_r4 = ɵɵreference(10);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", default_r4);
  }
}
function Label_ng_template_9_ng_template_1_Template(rf, ctx) {
}
function Label_ng_template_9__svg_svg_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 17);
  }
}
function Label_ng_template_9__svg_svg_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 18);
  }
}
function Label_ng_template_9_ng_template_6_Template(rf, ctx) {
}
function Label_ng_template_9_div_7_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.helperText);
  }
}
function Label_ng_template_9_div_7_2_ng_template_0_Template(rf, ctx) {
}
function Label_ng_template_9_div_7_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, Label_ng_template_9_div_7_2_ng_template_0_Template, 0, 0, "ng-template", 10);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.helperText);
  }
}
function Label_ng_template_9_div_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 19);
    ɵɵtemplate(1, Label_ng_template_9_div_7_ng_container_1_Template, 2, 1, "ng-container", 20)(2, Label_ng_template_9_div_7_2_Template, 1, 1, null, 20);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngClass", ɵɵpureFunction1(3, _c55, ctx_r0.disabled));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.helperText));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.helperText));
  }
}
function Label_ng_template_9_div_8_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.invalidText);
  }
}
function Label_ng_template_9_div_8_2_ng_template_0_Template(rf, ctx) {
}
function Label_ng_template_9_div_8_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, Label_ng_template_9_div_8_2_ng_template_0_Template, 0, 0, "ng-template", 10);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.invalidText);
  }
}
function Label_ng_template_9_div_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 21);
    ɵɵtemplate(1, Label_ng_template_9_div_8_ng_container_1_Template, 2, 1, "ng-container", 20)(2, Label_ng_template_9_div_8_2_Template, 1, 1, null, 20);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.invalidText));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.invalidText));
  }
}
function Label_ng_template_9_div_9_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.warnText);
  }
}
function Label_ng_template_9_div_9_2_ng_template_0_Template(rf, ctx) {
}
function Label_ng_template_9_div_9_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, Label_ng_template_9_div_9_2_ng_template_0_Template, 0, 0, "ng-template", 10);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.warnText);
  }
}
function Label_ng_template_9_div_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 21);
    ɵɵtemplate(1, Label_ng_template_9_div_9_ng_container_1_Template, 2, 1, "ng-container", 20)(2, Label_ng_template_9_div_9_2_Template, 1, 1, null, 20);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.warnText));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.warnText));
  }
}
function Label_ng_template_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "label", 11);
    ɵɵtemplate(1, Label_ng_template_9_ng_template_1_Template, 0, 0, "ng-template", 10);
    ɵɵelementEnd();
    ɵɵelementStart(2, "div", 12, 3);
    ɵɵtemplate(4, Label_ng_template_9__svg_svg_4_Template, 1, 0, "svg", 13)(5, Label_ng_template_9__svg_svg_5_Template, 1, 0, "svg", 14)(6, Label_ng_template_9_ng_template_6_Template, 0, 0, "ng-template", 10);
    ɵɵelementEnd();
    ɵɵtemplate(7, Label_ng_template_9_div_7_Template, 3, 5, "div", 15)(8, Label_ng_template_9_div_8_Template, 3, 2, "div", 16)(9, Label_ng_template_9_div_9_Template, 3, 2, "div", 16);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    const inputContentTemplate_r2 = ɵɵreference(1);
    const labelContentTemplate_r3 = ɵɵreference(3);
    ɵɵproperty("for", ctx_r0.labelInputID)("ngClass", ɵɵpureFunction2(12, _c132, ctx_r0.disabled, ctx_r0.skeleton));
    ɵɵattribute("aria-label", ctx_r0.ariaLabel);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", labelContentTemplate_r3);
    ɵɵadvance();
    ɵɵproperty("ngClass", ɵɵpureFunction1(15, _c83, ctx_r0.warn));
    ɵɵattribute("data-invalid", ctx_r0.invalid ? true : null);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r0.invalid);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.invalid && ctx_r0.warn);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", inputContentTemplate_r2);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.skeleton && ctx_r0.helperText && !ctx_r0.invalid && !ctx_r0.warn);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.invalid);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.invalid && ctx_r0.warn);
  }
}
var TextInput = class {
  constructor() {
    this.theme = "dark";
    this.size = "md";
    this.inputClass = true;
    this.invalid = false;
    this.warn = false;
    this.skeleton = false;
  }
  /**
   * @todo - remove `cds--text-input--${size}` classes in v12
   */
  get isSizeSm() {
    return this.size === "sm";
  }
  get isSizeMd() {
    return this.size === "md";
  }
  get isSizelg() {
    return this.size === "lg";
  }
  // Size
  get sizeSm() {
    return this.size === "sm";
  }
  get sizeMd() {
    return this.size === "md";
  }
  get sizelg() {
    return this.size === "lg";
  }
  get isLightTheme() {
    return this.theme === "light";
  }
  get getInvalidAttribute() {
    return this.invalid ? true : void 0;
  }
};
TextInput.ɵfac = function TextInput_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TextInput)();
};
TextInput.ɵdir = ɵɵdefineDirective({
  type: TextInput,
  selectors: [["", "cdsText", ""], ["", "ibmText", ""]],
  hostVars: 23,
  hostBindings: function TextInput_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("data-invalid", ctx.getInvalidAttribute);
      ɵɵclassProp("cds--text-input", ctx.inputClass)("cds--text-input--sm", ctx.isSizeSm)("cds--text-input--md", ctx.isSizeMd)("cds--text-input--lg", ctx.isSizelg)("cds--layout--size-sm", ctx.sizeSm)("cds--layout--size-md", ctx.sizeMd)("cds--layout--size-lg", ctx.sizelg)("cds--text-input--invalid", ctx.invalid)("cds--text-input--warning", ctx.warn)("cds--skeleton", ctx.skeleton)("cds--text-input--light", ctx.isLightTheme);
    }
  },
  inputs: {
    theme: "theme",
    size: "size",
    invalid: "invalid",
    warn: "warn",
    skeleton: "skeleton"
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TextInput, [{
    type: Directive,
    args: [{
      selector: "[cdsText], [ibmText]"
    }]
  }], null, {
    theme: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    inputClass: [{
      type: HostBinding,
      args: ["class.cds--text-input"]
    }],
    isSizeSm: [{
      type: HostBinding,
      args: ["class.cds--text-input--sm"]
    }],
    isSizeMd: [{
      type: HostBinding,
      args: ["class.cds--text-input--md"]
    }],
    isSizelg: [{
      type: HostBinding,
      args: ["class.cds--text-input--lg"]
    }],
    sizeSm: [{
      type: HostBinding,
      args: ["class.cds--layout--size-sm"]
    }],
    sizeMd: [{
      type: HostBinding,
      args: ["class.cds--layout--size-md"]
    }],
    sizelg: [{
      type: HostBinding,
      args: ["class.cds--layout--size-lg"]
    }],
    invalid: [{
      type: HostBinding,
      args: ["class.cds--text-input--invalid"]
    }, {
      type: Input
    }],
    warn: [{
      type: HostBinding,
      args: ["class.cds--text-input--warning"]
    }, {
      type: Input
    }],
    skeleton: [{
      type: HostBinding,
      args: ["class.cds--skeleton"]
    }, {
      type: Input
    }],
    isLightTheme: [{
      type: HostBinding,
      args: ["class.cds--text-input--light"]
    }],
    getInvalidAttribute: [{
      type: HostBinding,
      args: ["attr.data-invalid"]
    }]
  });
})();
var TextArea = class {
  constructor() {
    this.theme = "dark";
    this.baseClass = true;
    this.invalid = false;
    this.skeleton = false;
  }
  get isLightTheme() {
    return this.theme === "light";
  }
  get getInvalidAttr() {
    return this.invalid ? true : void 0;
  }
};
TextArea.ɵfac = function TextArea_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TextArea)();
};
TextArea.ɵdir = ɵɵdefineDirective({
  type: TextArea,
  selectors: [["", "cdsTextArea", ""], ["", "ibmTextArea", ""]],
  hostVars: 9,
  hostBindings: function TextArea_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("data-invalid", ctx.getInvalidAttr);
      ɵɵclassProp("cds--text-area", ctx.baseClass)("cds--text-area--invalid", ctx.invalid)("cds--skeleton", ctx.skeleton)("cds--text-area--light", ctx.isLightTheme);
    }
  },
  inputs: {
    theme: "theme",
    invalid: "invalid",
    skeleton: "skeleton"
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TextArea, [{
    type: Directive,
    args: [{
      selector: "[cdsTextArea], [ibmTextArea]"
    }]
  }], null, {
    theme: [{
      type: Input
    }],
    baseClass: [{
      type: HostBinding,
      args: ["class.cds--text-area"]
    }],
    invalid: [{
      type: HostBinding,
      args: ["class.cds--text-area--invalid"]
    }, {
      type: Input
    }],
    skeleton: [{
      type: HostBinding,
      args: ["class.cds--skeleton"]
    }, {
      type: Input
    }],
    isLightTheme: [{
      type: HostBinding,
      args: ["class.cds--text-area--light"]
    }],
    getInvalidAttr: [{
      type: HostBinding,
      args: ["attr.data-invalid"]
    }]
  });
})();
var PasswordInput = class {
  constructor(elementRef, renderer) {
    this.elementRef = elementRef;
    this.renderer = renderer;
    this.passwordInputClass = true;
    this.inputClass = true;
    this.invalid = false;
    this.warn = false;
    this.skeleton = false;
    this.theme = "dark";
    this.size = "md";
    this._type = "password";
  }
  set type(type) {
    if (type) {
      this._type = type;
      if (this.elementRef) {
        this.renderer.setAttribute(this.elementRef.nativeElement, "type", this._type);
      }
    }
  }
  /**
   * @todo - remove `cds--text-input--${size}` classes in v12
   */
  get isSizeSm() {
    return this.size === "sm";
  }
  get isSizeMd() {
    return this.size === "md";
  }
  get isSizelg() {
    return this.size === "lg";
  }
  // Size
  get sizeSm() {
    return this.size === "sm";
  }
  get sizeMd() {
    return this.size === "md";
  }
  get sizelg() {
    return this.size === "lg";
  }
  get isLightTheme() {
    return this.theme === "light";
  }
  get getInvalidAttribute() {
    return this.invalid ? true : void 0;
  }
  ngAfterViewInit() {
    this.renderer.setAttribute(this.elementRef.nativeElement, "type", this._type);
  }
};
PasswordInput.ɵfac = function PasswordInput_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || PasswordInput)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
};
PasswordInput.ɵdir = ɵɵdefineDirective({
  type: PasswordInput,
  selectors: [["", "cdsPassword", ""], ["", "ibmPassword", ""]],
  hostVars: 25,
  hostBindings: function PasswordInput_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("data-invalid", ctx.getInvalidAttribute);
      ɵɵclassProp("cds--password-input", ctx.passwordInputClass)("cds--text-input--sm", ctx.isSizeSm)("cds--text-input--md", ctx.isSizeMd)("cds--text-input--lg", ctx.isSizelg)("cds--layout--size-sm", ctx.sizeSm)("cds--layout--size-md", ctx.sizeMd)("cds--layout--size-lg", ctx.sizelg)("cds--text-input--light", ctx.isLightTheme)("cds--text-input", ctx.inputClass)("cds--text-input--invalid", ctx.invalid)("cds--text-input--warning", ctx.warn)("cds--skeleton", ctx.skeleton);
    }
  },
  inputs: {
    type: "type",
    invalid: "invalid",
    warn: "warn",
    skeleton: "skeleton",
    theme: "theme",
    size: "size"
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PasswordInput, [{
    type: Directive,
    args: [{
      selector: "[cdsPassword], [ibmPassword]"
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }];
  }, {
    type: [{
      type: Input
    }],
    passwordInputClass: [{
      type: HostBinding,
      args: ["class.cds--password-input"]
    }],
    isSizeSm: [{
      type: HostBinding,
      args: ["class.cds--text-input--sm"]
    }],
    isSizeMd: [{
      type: HostBinding,
      args: ["class.cds--text-input--md"]
    }],
    isSizelg: [{
      type: HostBinding,
      args: ["class.cds--text-input--lg"]
    }],
    sizeSm: [{
      type: HostBinding,
      args: ["class.cds--layout--size-sm"]
    }],
    sizeMd: [{
      type: HostBinding,
      args: ["class.cds--layout--size-md"]
    }],
    sizelg: [{
      type: HostBinding,
      args: ["class.cds--layout--size-lg"]
    }],
    isLightTheme: [{
      type: HostBinding,
      args: ["class.cds--text-input--light"]
    }],
    inputClass: [{
      type: HostBinding,
      args: ["class.cds--text-input"]
    }],
    invalid: [{
      type: HostBinding,
      args: ["class.cds--text-input--invalid"]
    }, {
      type: Input
    }],
    warn: [{
      type: HostBinding,
      args: ["class.cds--text-input--warning"]
    }, {
      type: Input
    }],
    skeleton: [{
      type: HostBinding,
      args: ["class.cds--skeleton"]
    }, {
      type: Input
    }],
    theme: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    getInvalidAttribute: [{
      type: HostBinding,
      args: ["attr.data-invalid"]
    }]
  });
})();
var TextareaLabelComponent = class _TextareaLabelComponent {
  /**
   * Creates an instance of Label.
   */
  constructor(changeDetectorRef) {
    this.changeDetectorRef = changeDetectorRef;
    this.labelInputID = "ibm-textarea-" + _TextareaLabelComponent.labelCounter;
    this.disabled = false;
    this.skeleton = false;
    this.invalid = false;
    this.warn = false;
    this.fluid = false;
    this.labelClass = true;
  }
  get isReadonly() {
    return this.wrapper?.nativeElement.querySelector("textarea")?.readOnly ?? false;
  }
  get fluidClass() {
    return this.fluid && !this.skeleton;
  }
  get fluidSkeletonClass() {
    return this.fluid && this.skeleton;
  }
  /**
   * Sets the id on the input item associated with the `Label`.
   */
  ngAfterViewInit() {
    if (this.wrapper) {
      const inputElement = this.wrapper.nativeElement.querySelector("textarea");
      if (inputElement) {
        if (inputElement.id) {
          this.labelInputID = inputElement.id;
          this.changeDetectorRef.detectChanges();
        }
        inputElement.setAttribute("id", this.labelInputID);
        return;
      }
      const divElement = this.wrapper.nativeElement.querySelector("div");
      if (divElement) {
        if (divElement.id) {
          this.labelInputID = divElement.id;
          this.changeDetectorRef.detectChanges();
        }
        divElement.setAttribute("id", this.labelInputID);
      }
    }
  }
  isTemplate(value) {
    return value instanceof TemplateRef;
  }
};
TextareaLabelComponent.labelCounter = 0;
TextareaLabelComponent.ɵfac = function TextareaLabelComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TextareaLabelComponent)(ɵɵdirectiveInject(ChangeDetectorRef));
};
TextareaLabelComponent.ɵcmp = ɵɵdefineComponent({
  type: TextareaLabelComponent,
  selectors: [["cds-textarea-label"], ["ibm-textarea-label"]],
  contentQueries: function TextareaLabelComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, TextArea, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.textArea = _t.first);
    }
  },
  viewQuery: function TextareaLabelComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c021, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.wrapper = _t.first);
    }
  },
  hostVars: 8,
  hostBindings: function TextareaLabelComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--form-item", ctx.labelClass)("cds--text-area__wrapper--readonly", ctx.isReadonly)("cds--text-area--fluid", ctx.fluidClass)("cds--text-area--fluid__skeleton", ctx.fluidSkeletonClass);
    }
  },
  inputs: {
    labelInputID: "labelInputID",
    disabled: "disabled",
    skeleton: "skeleton",
    labelTemplate: "labelTemplate",
    textAreaTemplate: "textAreaTemplate",
    helperText: "helperText",
    invalidText: "invalidText",
    invalid: "invalid",
    warn: "warn",
    warnText: "warnText",
    ariaLabel: "ariaLabel",
    fluid: "fluid"
  },
  standalone: false,
  ngContentSelectors: _c215,
  decls: 2,
  vars: 2,
  consts: [["labelContent", ""], ["wrapper", ""], ["textAreaContent", ""], [4, "ngIf"], [1, "cds--label", "cds--skeleton"], [1, "cds--text-area", "cds--skeleton"], [1, "cds--text-area__label-wrapper"], [1, "cds--label", 3, "for", "ngClass"], [4, "ngIf", "ngIfElse"], [1, "cds--text-area__wrapper", 3, "ngClass"], ["cdsIcon", "warning--filled", "size", "16", "class", "cds--text-area__invalid-icon", 4, "ngIf"], ["cdsIcon", "warning--alt--filled", "size", "16", "class", "cds--text-area__invalid-icon cds--text-area__invalid-icon--warning", 4, "ngIf"], [3, "ngTemplateOutlet"], ["cdsIcon", "warning--filled", "size", "16", 1, "cds--text-area__invalid-icon"], ["cdsIcon", "warning--alt--filled", "size", "16", 1, "cds--text-area__invalid-icon", "cds--text-area__invalid-icon--warning"], [1, "cds--text-area__divider"], ["class", "cds--form-requirement", 4, "ngIf"], [1, "cds--form-requirement"], ["class", "cds--form__helper-text", 3, "ngClass", 4, "ngIf"], [1, "cds--form__helper-text", 3, "ngClass"]],
  template: function TextareaLabelComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c119);
      ɵɵtemplate(0, TextareaLabelComponent_ng_container_0_Template, 3, 0, "ng-container", 3)(1, TextareaLabelComponent_ng_container_1_Template, 15, 17, "ng-container", 3);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.skeleton);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.skeleton);
    }
  },
  dependencies: [NgClass, NgIf, NgTemplateOutlet, IconDirective],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TextareaLabelComponent, [{
    type: Component,
    args: [{
      selector: "cds-textarea-label, ibm-textarea-label",
      template: `
		<ng-container *ngIf="skeleton">
			<span class="cds--label cds--skeleton"></span>
			<div class="cds--text-area cds--skeleton"></div>
		</ng-container>
		<ng-container *ngIf="!skeleton">
			<div class="cds--text-area__label-wrapper">
				<label
					[for]="labelInputID"
					[attr.aria-label]="ariaLabel"
					class="cds--label"
					[ngClass]="{
						'cds--label--disabled': disabled
					}">
					<ng-template *ngIf="labelTemplate; else labelContent" [ngTemplateOutlet]="labelTemplate"></ng-template>
					<ng-template #labelContent>
						<ng-content></ng-content>
					</ng-template>
				</label>
			</div>
			<div
				class="cds--text-area__wrapper"
				[ngClass]="{
					'cds--text-area__wrapper--warn': warn
				}"
				[attr.data-invalid]="(invalid ? true : null)"
				#wrapper>
				<svg
					*ngIf="!fluid && invalid"
					cdsIcon="warning--filled"
					size="16"
					class="cds--text-area__invalid-icon">
				</svg>
				<svg
					*ngIf="!fluid && !invalid && warn"
					cdsIcon="warning--alt--filled"
					size="16"
					class="cds--text-area__invalid-icon cds--text-area__invalid-icon--warning">
				</svg>
				<ng-template *ngIf="textAreaTemplate; else textAreaContent" [ngTemplateOutlet]="textAreaTemplate"></ng-template>
				<ng-template #textAreaContent>
					<ng-content select="[cdsTextArea],[ibmTextArea],textarea"></ng-content>
				</ng-template>

				<ng-container *ngIf="fluid">
					<hr class="cds--text-area__divider" />
					<div *ngIf="invalid" class="cds--form-requirement">
						<ng-container *ngIf="!isTemplate(invalidText)">{{invalidText}}</ng-container>
						<ng-template *ngIf="isTemplate(invalidText)" [ngTemplateOutlet]="invalidText"></ng-template>
						<svg
							cdsIcon="warning--filled"
							size="16"
							class="cds--text-area__invalid-icon">
						</svg>
					</div>
					<div *ngIf="!invalid && warn" class="cds--form-requirement">
						<ng-container *ngIf="!isTemplate(warnText)">{{warnText}}</ng-container>
						<ng-template *ngIf="isTemplate(warnText)" [ngTemplateOutlet]="warnText"></ng-template>
						<svg
							cdsIcon="warning--alt--filled"
							size="16"
							class="cds--text-area__invalid-icon cds--text-area__invalid-icon--warning">
						</svg>
					</div>
				</ng-container>
			</div>
			<ng-container *ngIf="!fluid">
				<div
					*ngIf="helperText && !invalid && !warn"
					class="cds--form__helper-text"
					[ngClass]="{'cds--form__helper-text--disabled': disabled}">
					<ng-container *ngIf="!isTemplate(helperText)">{{helperText}}</ng-container>
					<ng-template *ngIf="isTemplate(helperText)" [ngTemplateOutlet]="helperText"></ng-template>
				</div>
				<div *ngIf="invalid" class="cds--form-requirement">
					<ng-container *ngIf="!isTemplate(invalidText)">{{invalidText}}</ng-container>
					<ng-template *ngIf="isTemplate(invalidText)" [ngTemplateOutlet]="invalidText"></ng-template>
				</div>
				<div *ngIf="!invalid && warn" class="cds--form-requirement">
					<ng-container *ngIf="!isTemplate(warnText)">{{warnText}}</ng-container>
					<ng-template *ngIf="isTemplate(warnText)" [ngTemplateOutlet]="warnText"></ng-template>
				</div>
			</ng-container>
		</ng-container>
	`
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }];
  }, {
    labelInputID: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    skeleton: [{
      type: Input
    }],
    labelTemplate: [{
      type: Input
    }],
    textAreaTemplate: [{
      type: Input
    }],
    helperText: [{
      type: Input
    }],
    invalidText: [{
      type: Input
    }],
    invalid: [{
      type: Input
    }],
    warn: [{
      type: Input
    }],
    warnText: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    fluid: [{
      type: Input
    }],
    wrapper: [{
      type: ViewChild,
      args: ["wrapper", {
        static: false
      }]
    }],
    textArea: [{
      type: ContentChild,
      args: [TextArea, {
        static: false
      }]
    }],
    labelClass: [{
      type: HostBinding,
      args: ["class.cds--form-item"]
    }],
    isReadonly: [{
      type: HostBinding,
      args: ["class.cds--text-area__wrapper--readonly"]
    }],
    fluidClass: [{
      type: HostBinding,
      args: ["class.cds--text-area--fluid"]
    }],
    fluidSkeletonClass: [{
      type: HostBinding,
      args: ["class.cds--text-area--fluid__skeleton"]
    }]
  });
})();
var TextInputLabelComponent = class _TextInputLabelComponent {
  /**
   * Creates an instance of Label.
   */
  constructor(changeDetectorRef) {
    this.changeDetectorRef = changeDetectorRef;
    this.labelInputID = "ibm-text-input-" + _TextInputLabelComponent.labelCounter++;
    this.disabled = false;
    this.skeleton = false;
    this.invalid = false;
    this.warn = false;
    this.fluid = false;
    this.labelClass = true;
    this.textInputWrapper = true;
  }
  get isReadonly() {
    return this.wrapper?.nativeElement.querySelector("input")?.readOnly ?? false;
  }
  get fluidClass() {
    return this.fluid && !this.skeleton;
  }
  get fluidSkeletonClass() {
    return this.fluid && this.skeleton;
  }
  /**
   * Sets the id on the input item associated with the `Label`.
   */
  ngAfterViewInit() {
    if (this.wrapper) {
      const inputElement = this.wrapper.nativeElement.querySelector("input");
      if (inputElement) {
        if (inputElement.id) {
          this.labelInputID = inputElement.id;
          this.changeDetectorRef.detectChanges();
        }
        inputElement.setAttribute("id", this.labelInputID);
        return;
      }
      const divElement = this.wrapper.nativeElement.querySelector("div");
      if (divElement) {
        if (divElement.id) {
          this.labelInputID = divElement.id;
          this.changeDetectorRef.detectChanges();
        }
        divElement.setAttribute("id", this.labelInputID);
      }
    }
  }
  ngAfterContentInit() {
    this.changeDetectorRef.detectChanges();
  }
  isTemplate(value) {
    return value instanceof TemplateRef;
  }
};
TextInputLabelComponent.labelCounter = 0;
TextInputLabelComponent.ɵfac = function TextInputLabelComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TextInputLabelComponent)(ɵɵdirectiveInject(ChangeDetectorRef));
};
TextInputLabelComponent.ɵcmp = ɵɵdefineComponent({
  type: TextInputLabelComponent,
  selectors: [["cds-text-label"], ["ibm-text-label"]],
  viewQuery: function TextInputLabelComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c021, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.wrapper = _t.first);
    }
  },
  hostVars: 10,
  hostBindings: function TextInputLabelComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--form-item", ctx.labelClass)("cds--text-input-wrapper", ctx.textInputWrapper)("cds--text-input-wrapper--readonly", ctx.isReadonly)("cds--text-input--fluid", ctx.fluidClass)("cds--text-input--fluid__skeleton", ctx.fluidSkeletonClass);
    }
  },
  inputs: {
    labelInputID: "labelInputID",
    disabled: "disabled",
    skeleton: "skeleton",
    labelTemplate: "labelTemplate",
    textInputTemplate: "textInputTemplate",
    helperText: "helperText",
    invalidText: "invalidText",
    invalid: "invalid",
    warn: "warn",
    warnText: "warnText",
    ariaLabel: "ariaLabel",
    fluid: "fluid"
  },
  standalone: false,
  ngContentSelectors: _c73,
  decls: 3,
  vars: 3,
  consts: [["labelContent", ""], ["wrapper", ""], ["textInputContent", ""], [4, "ngIf"], ["class", "cds--label", 3, "for", "ngClass", 4, "ngIf"], ["class", "cds--text-input__field-outer-wrapper", 4, "ngIf"], [1, "cds--label", "cds--skeleton"], [1, "cds--text-input", "cds--skeleton"], [1, "cds--label", 3, "for", "ngClass"], [4, "ngIf", "ngIfElse"], [3, "ngTemplateOutlet"], [1, "cds--text-input__field-outer-wrapper"], [1, "cds--text-input__field-wrapper", 3, "ngClass"], ["cdsIcon", "warning--filled", "size", "16", "class", "cds--text-input__invalid-icon", 4, "ngIf"], ["cdsIcon", "warning--alt--filled", "size", "16", "class", "cds--text-input__invalid-icon cds--text-input__invalid-icon--warning", 4, "ngIf"], ["cdsIcon", "warning--filled", "size", "16", 1, "cds--text-input__invalid-icon"], ["cdsIcon", "warning--alt--filled", "size", "16", 1, "cds--text-input__invalid-icon", "cds--text-input__invalid-icon--warning"], [1, "cds--text-input__divider"], ["class", "cds--form-requirement", 4, "ngIf"], [1, "cds--form-requirement"], ["class", "cds--form__helper-text", 3, "ngClass", 4, "ngIf"], [1, "cds--form__helper-text", 3, "ngClass"]],
  template: function TextInputLabelComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c64);
      ɵɵtemplate(0, TextInputLabelComponent_ng_container_0_Template, 3, 0, "ng-container", 3)(1, TextInputLabelComponent_label_1_Template, 4, 7, "label", 4)(2, TextInputLabelComponent_div_2_Template, 10, 10, "div", 5);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.skeleton);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.skeleton);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.skeleton);
    }
  },
  dependencies: [NgClass, NgIf, NgTemplateOutlet, IconDirective],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TextInputLabelComponent, [{
    type: Component,
    args: [{
      selector: "cds-text-label, ibm-text-label",
      template: `
		<ng-container *ngIf="skeleton">
			<span class="cds--label cds--skeleton"></span>
			<div class="cds--text-input cds--skeleton"></div>
		</ng-container>
		<label
			*ngIf="!skeleton"
			[for]="labelInputID"
			[attr.aria-label]="ariaLabel"
			class="cds--label"
			[ngClass]="{
				'cds--label--disabled': disabled
			}">
			<ng-template *ngIf="labelTemplate; else labelContent" [ngTemplateOutlet]="labelTemplate"></ng-template>
			<ng-template #labelContent>
				<ng-content></ng-content>
			</ng-template>
		</label>
		<div *ngIf="!skeleton" class="cds--text-input__field-outer-wrapper">
			<div
				class="cds--text-input__field-wrapper"
				[ngClass]="{
					'cds--text-input__field-wrapper--warning': warn
				}"
				[attr.data-invalid]="(invalid ? true : null)"
				#wrapper>
				<svg
					*ngIf="invalid && !warn"
					cdsIcon="warning--filled"
					size="16"
					class="cds--text-input__invalid-icon">
				</svg>
				<svg
					*ngIf="!invalid && warn"
					cdsIcon="warning--alt--filled"
					size="16"
					class="cds--text-input__invalid-icon cds--text-input__invalid-icon--warning">
				</svg>
				<ng-template *ngIf="textInputTemplate; else textInputContent" [ngTemplateOutlet]="textInputTemplate"></ng-template>
				<ng-template #textInputContent>
					<ng-content select="[cdsText],[ibmText],input[type=text],div"></ng-content>
				</ng-template>

				<ng-container *ngIf="fluid">
					<hr class="cds--text-input__divider" />
					<div *ngIf="invalid" class="cds--form-requirement">
						<ng-container *ngIf="!isTemplate(invalidText)">{{invalidText}}</ng-container>
						<ng-template *ngIf="isTemplate(invalidText)" [ngTemplateOutlet]="invalidText"></ng-template>
					</div>
					<div *ngIf="!invalid && warn" class="cds--form-requirement">
						<ng-container *ngIf="!isTemplate(warnText)">{{warnText}}</ng-container>
						<ng-template *ngIf="isTemplate(warnText)" [ngTemplateOutlet]="warnText"></ng-template>
					</div>
				</ng-container>
			</div>
			<ng-container *ngIf="!fluid">
				<div
					*ngIf="helperText && !invalid && !warn"
					class="cds--form__helper-text"
					[ngClass]="{'cds--form__helper-text--disabled': disabled}">
					<ng-container *ngIf="!isTemplate(helperText)">{{helperText}}</ng-container>
					<ng-template *ngIf="isTemplate(helperText)" [ngTemplateOutlet]="helperText"></ng-template>
				</div>
				<div *ngIf="invalid" class="cds--form-requirement">
					<ng-container *ngIf="!isTemplate(invalidText)">{{invalidText}}</ng-container>
					<ng-template *ngIf="isTemplate(invalidText)" [ngTemplateOutlet]="invalidText"></ng-template>
				</div>
				<div *ngIf="!invalid && warn" class="cds--form-requirement">
					<ng-container *ngIf="!isTemplate(warnText)">{{warnText}}</ng-container>
					<ng-template *ngIf="isTemplate(warnText)" [ngTemplateOutlet]="warnText"></ng-template>
				</div>
			</ng-container>
		</div>
	`
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }];
  }, {
    labelInputID: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    skeleton: [{
      type: Input
    }],
    labelTemplate: [{
      type: Input
    }],
    textInputTemplate: [{
      type: Input
    }],
    helperText: [{
      type: Input
    }],
    invalidText: [{
      type: Input
    }],
    invalid: [{
      type: Input
    }],
    warn: [{
      type: Input
    }],
    warnText: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    fluid: [{
      type: Input
    }],
    wrapper: [{
      type: ViewChild,
      args: ["wrapper", {
        static: false
      }]
    }],
    labelClass: [{
      type: HostBinding,
      args: ["class.cds--form-item"]
    }],
    textInputWrapper: [{
      type: HostBinding,
      args: ["class.cds--text-input-wrapper"]
    }],
    isReadonly: [{
      type: HostBinding,
      args: ["class.cds--text-input-wrapper--readonly"]
    }],
    fluidClass: [{
      type: HostBinding,
      args: ["class.cds--text-input--fluid"]
    }],
    fluidSkeletonClass: [{
      type: HostBinding,
      args: ["class.cds--text-input--fluid__skeleton"]
    }]
  });
})();
var PasswordInputLabelComponent = class _PasswordInputLabelComponent extends BaseIconButton {
  /**
   * Constructor for PasswordInputLabelComponent.
   * @param changeDetectorRef - Reference to ChangeDetectorRef.
   */
  constructor(changeDetectorRef) {
    super();
    this.changeDetectorRef = changeDetectorRef;
    this.labelInputID = "cds-password-input-" + _PasswordInputLabelComponent.labelCounter++;
    this.inputType = "password";
    this.passwordIsVisible = false;
    this.disabled = false;
    this.skeleton = false;
    this.invalid = false;
    this.warn = false;
    this.hidePasswordLabel = "Hide password";
    this.showPasswordLabel = "Show password";
    this.fluid = false;
    this.labelClass = true;
    this.passwordInputWrapper = true;
    this.textInputWrapper = true;
  }
  get isReadonly() {
    return this.wrapper?.nativeElement.querySelector("input")?.readOnly ?? false;
  }
  get fluidClass() {
    return this.fluid && !this.skeleton;
  }
  get fluidSkeletonClass() {
    return this.fluid && this.skeleton;
  }
  /**
   * Lifecycle hook called after the view has been initialized to set the ID of the input element
   */
  ngAfterViewInit() {
    if (this.wrapper) {
      const inputElement = this.wrapper.nativeElement.querySelector("input");
      if (inputElement) {
        if (inputElement.id) {
          this.labelInputID = inputElement.id;
          this.changeDetectorRef.detectChanges();
        }
        inputElement.setAttribute("id", this.labelInputID);
        return;
      }
    }
  }
  /**
   * Function to check if a value is a TemplateRef.
   * @param value - Value to check.
   * @returns Whether the value is a TemplateRef.
   */
  isTemplate(value) {
    return value instanceof TemplateRef;
  }
  /**
   * Handler for toggling password visibility.
   */
  handleTogglePasswordVisibility() {
    this.inputType = this.inputType === "password" ? "text" : "password";
    this.textInput.type = this.inputType;
    this.passwordIsVisible = this.inputType === "text";
  }
};
PasswordInputLabelComponent.labelCounter = 0;
PasswordInputLabelComponent.ɵfac = function PasswordInputLabelComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || PasswordInputLabelComponent)(ɵɵdirectiveInject(ChangeDetectorRef));
};
PasswordInputLabelComponent.ɵcmp = ɵɵdefineComponent({
  type: PasswordInputLabelComponent,
  selectors: [["cds-password-label"], ["ibm-password-label"]],
  contentQueries: function PasswordInputLabelComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, PasswordInput, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.textInput = _t.first);
    }
  },
  viewQuery: function PasswordInputLabelComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c021, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.wrapper = _t.first);
    }
  },
  hostVars: 12,
  hostBindings: function PasswordInputLabelComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--form-item", ctx.labelClass)("cds--password-input-wrapper", ctx.passwordInputWrapper)("cds--text-input-wrapper", ctx.textInputWrapper)("cds--text-input-wrapper--readonly", ctx.isReadonly)("cds--text-input--fluid", ctx.fluidClass)("cds--text-input--fluid__skeleton", ctx.fluidSkeletonClass);
    }
  },
  inputs: {
    labelInputID: "labelInputID",
    disabled: "disabled",
    skeleton: "skeleton",
    labelTemplate: "labelTemplate",
    passwordInputTemplate: "passwordInputTemplate",
    helperText: "helperText",
    invalidText: "invalidText",
    invalid: "invalid",
    warn: "warn",
    warnText: "warnText",
    ariaLabel: "ariaLabel",
    hidePasswordLabel: "hidePasswordLabel",
    showPasswordLabel: "showPasswordLabel",
    fluid: "fluid"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c103,
  decls: 3,
  vars: 3,
  consts: [["labelContent", ""], ["wrapper", ""], [4, "ngIf"], ["class", "cds--label", 3, "for", "ngClass", 4, "ngIf"], ["class", "cds--text-input__field-outer-wrapper", 4, "ngIf"], [1, "cds--label", "cds--skeleton"], [1, "cds--text-input", "cds--skeleton"], [1, "cds--label", 3, "for", "ngClass"], [4, "ngIf", "ngIfElse"], [3, "ngTemplateOutlet"], [1, "cds--text-input__field-outer-wrapper"], [1, "cds--text-input__field-wrapper", 3, "ngClass"], ["cdsIcon", "warning--filled", "size", "16", "class", "cds--text-input__invalid-icon", 4, "ngIf"], ["cdsIcon", "warning--alt--filled", "size", "16", "class", "cds--text-input__invalid-icon cds--text-input__invalid-icon--warning", 4, "ngIf"], ["class", "cds--toggle-password-tooltip", 3, "description", "disabled", "caret", "dropShadow", "highContrast", "isOpen", "align", "autoAlign", "enterDelayMs", "leaveDelayMs", 4, "ngIf"], ["cdsIcon", "warning--filled", "size", "16", 1, "cds--text-input__invalid-icon"], ["cdsIcon", "warning--alt--filled", "size", "16", 1, "cds--text-input__invalid-icon", "cds--text-input__invalid-icon--warning"], [1, "cds--toggle-password-tooltip", 3, "description", "disabled", "caret", "dropShadow", "highContrast", "isOpen", "align", "autoAlign", "enterDelayMs", "leaveDelayMs"], [1, "cds--tooltip-trigger__wrapper"], ["type", "button", 1, "cds--text-input--password__visibility__toggle", "cds--btn", "cds--tooltip__trigger", "cds--tooltip--a11y", 3, "click", "disabled"], ["cdsIcon", "view--off", "class", "cds--icon-visibility-off", "size", "16", 4, "ngIf"], ["cdsIcon", "view", "class", "cds--icon-visibility-on", "size", "16", 4, "ngIf"], ["cdsIcon", "view--off", "size", "16", 1, "cds--icon-visibility-off"], ["cdsIcon", "view", "size", "16", 1, "cds--icon-visibility-on"], [1, "cds--text-input__divider"], ["class", "cds--form-requirement", 4, "ngIf"], [1, "cds--form-requirement"], ["class", "cds--form__helper-text", 3, "ngClass", 4, "ngIf"], [1, "cds--form__helper-text", 3, "ngClass"]],
  template: function PasswordInputLabelComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c93);
      ɵɵtemplate(0, PasswordInputLabelComponent_ng_container_0_Template, 3, 0, "ng-container", 2)(1, PasswordInputLabelComponent_label_1_Template, 4, 7, "label", 3)(2, PasswordInputLabelComponent_div_2_Template, 9, 9, "div", 4);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.skeleton);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.skeleton);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.skeleton);
    }
  },
  dependencies: [NgClass, NgIf, NgTemplateOutlet, IconDirective, Tooltip],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PasswordInputLabelComponent, [{
    type: Component,
    args: [{
      selector: "cds-password-label, ibm-password-label",
      template: `
		<ng-container *ngIf="skeleton">
			<span class="cds--label cds--skeleton"></span>
			<div class="cds--text-input cds--skeleton"></div>
		</ng-container>
		<label
			*ngIf="!skeleton"
			[for]="labelInputID"
			[attr.aria-label]="ariaLabel"
			class="cds--label"
			[ngClass]="{
				'cds--label--disabled': disabled
			}">
			<ng-template *ngIf="labelTemplate; else labelContent" [ngTemplateOutlet]="labelTemplate"></ng-template>
			<ng-template #labelContent>
				<ng-content></ng-content>
			</ng-template>
		</label>

		<div *ngIf="!skeleton" class="cds--text-input__field-outer-wrapper">
			<div
			class="cds--text-input__field-wrapper"
			[ngClass]="{
				'cds--text-input__field-wrapper--warning': warn
			}"
			[attr.data-invalid]="invalid ? true : null"
			#wrapper>
				<svg
					*ngIf="!warn && invalid"
					cdsIcon="warning--filled"
					size="16"
					class="cds--text-input__invalid-icon">
				</svg>
				<svg
					*ngIf="!invalid && warn"
					cdsIcon="warning--alt--filled"
					size="16"
					class="cds--text-input__invalid-icon cds--text-input__invalid-icon--warning">
				</svg>
				<ng-content select="[cdsPassword], [ibmPassword]"></ng-content>
				<cds-tooltip
					*ngIf="!skeleton"
					[description]="passwordIsVisible ? hidePasswordLabel : showPasswordLabel"
					[disabled]="disabled"
					[caret]="caret"
					[dropShadow]="dropShadow"
					[highContrast]="highContrast"
					[isOpen]="isOpen"
					[align]="align"
					[autoAlign]="autoAlign"
					[enterDelayMs]="enterDelayMs"
					[leaveDelayMs]="leaveDelayMs"
					class="cds--toggle-password-tooltip">
						<div class="cds--tooltip-trigger__wrapper">
							<button
								class="cds--text-input--password__visibility__toggle cds--btn cds--tooltip__trigger cds--tooltip--a11y"
								[disabled]="disabled"
								type="button"
								(click)="handleTogglePasswordVisibility($event)">
								<svg *ngIf="passwordIsVisible" cdsIcon="view--off" class="cds--icon-visibility-off" size="16"></svg>
								<svg *ngIf="!passwordIsVisible" cdsIcon="view" class="cds--icon-visibility-on" size="16"></svg>
							</button>
						</div>
				</cds-tooltip>

				<ng-container *ngIf="fluid">
					<hr class="cds--text-input__divider" />
					<div *ngIf="!warn && invalid" class="cds--form-requirement">
						<ng-container *ngIf="!isTemplate(invalidText)">{{ invalidText }}</ng-container>
						<ng-template *ngIf="isTemplate(invalidText)" [ngTemplateOutlet]="invalidText"></ng-template>
					</div>
					<div *ngIf="!invalid && warn" class="cds--form-requirement">
						<ng-container *ngIf="!isTemplate(warnText)">{{ warnText }}</ng-container>
						<ng-template *ngIf="isTemplate(warnText)" [ngTemplateOutlet]="warnText"></ng-template>
					</div>
				</ng-container>
			</div>
			<ng-container *ngIf="!fluid">
				<div
					*ngIf="!skeleton && helperText && !invalid && !warn"
					class="cds--form__helper-text"
					[ngClass]="{ 'cds--form__helper-text--disabled': disabled }">
					<ng-container *ngIf="!isTemplate(helperText)">{{ helperText }}</ng-container>
					<ng-template *ngIf="isTemplate(helperText)" [ngTemplateOutlet]="helperText"></ng-template>
				</div>

				<div *ngIf="!warn && invalid" class="cds--form-requirement">
					<ng-container *ngIf="!isTemplate(invalidText)">{{ invalidText }}</ng-container>
					<ng-template *ngIf="isTemplate(invalidText)" [ngTemplateOutlet]="invalidText"></ng-template>
				</div>

				<div *ngIf="!invalid && warn" class="cds--form-requirement">
					<ng-container *ngIf="!isTemplate(warnText)">{{ warnText }}</ng-container>
					<ng-template *ngIf="isTemplate(warnText)" [ngTemplateOutlet]="warnText"></ng-template>
				</div>
			</ng-container>
		</div>
    `
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }];
  }, {
    textInput: [{
      type: ContentChild,
      args: [PasswordInput]
    }],
    labelInputID: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    skeleton: [{
      type: Input
    }],
    labelTemplate: [{
      type: Input
    }],
    passwordInputTemplate: [{
      type: Input
    }],
    helperText: [{
      type: Input
    }],
    invalidText: [{
      type: Input
    }],
    invalid: [{
      type: Input
    }],
    warn: [{
      type: Input
    }],
    warnText: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    hidePasswordLabel: [{
      type: Input
    }],
    showPasswordLabel: [{
      type: Input
    }],
    fluid: [{
      type: Input
    }],
    wrapper: [{
      type: ViewChild,
      args: ["wrapper", {
        static: true
      }]
    }],
    labelClass: [{
      type: HostBinding,
      args: ["class.cds--form-item"]
    }],
    passwordInputWrapper: [{
      type: HostBinding,
      args: ["class.cds--password-input-wrapper"]
    }],
    textInputWrapper: [{
      type: HostBinding,
      args: ["class.cds--text-input-wrapper"]
    }],
    isReadonly: [{
      type: HostBinding,
      args: ["class.cds--text-input-wrapper--readonly"]
    }],
    fluidClass: [{
      type: HostBinding,
      args: ["class.cds--text-input--fluid"]
    }],
    fluidSkeletonClass: [{
      type: HostBinding,
      args: ["class.cds--text-input--fluid__skeleton"]
    }]
  });
})();
var Label = class _Label {
  /**
   * Creates an instance of Label.
   */
  constructor(changeDetectorRef) {
    this.changeDetectorRef = changeDetectorRef;
    this.labelInputID = `cds-label-${_Label.labelCounter++}`;
    this.disabled = false;
    this.skeleton = false;
    this.invalid = false;
    this.warn = false;
  }
  get labelClass() {
    return this.type === void 0;
  }
  /**
   * Update wrapper class if a textarea is hosted.
   */
  ngAfterContentInit() {
    if (this.textArea) {
      this.type = "TextArea";
    } else if (this.textInput) {
      this.type = "TextInput";
    } else if (this.passwordInput) {
      this.type = "PasswordInput";
    }
  }
  /**
   * Sets the id on the input item associated with the `Label`.
   */
  ngAfterViewInit() {
    if (this.wrapper) {
      const inputElement = this.wrapper.nativeElement.querySelector("input,textarea");
      if (inputElement) {
        if (inputElement.id) {
          this.labelInputID = inputElement.id;
          this.changeDetectorRef.detectChanges();
        }
        inputElement.setAttribute("id", this.labelInputID);
        return;
      }
      const divElement = this.wrapper.nativeElement.querySelector("div");
      if (divElement) {
        if (divElement.id) {
          this.labelInputID = divElement.id;
          this.changeDetectorRef.detectChanges();
        }
        divElement.setAttribute("id", this.labelInputID);
      }
    }
  }
  isTemplate(value) {
    return value instanceof TemplateRef;
  }
};
Label.labelCounter = 0;
Label.ɵfac = function Label_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Label)(ɵɵdirectiveInject(ChangeDetectorRef));
};
Label.ɵcmp = ɵɵdefineComponent({
  type: Label,
  selectors: [["cds-label"], ["ibm-label"]],
  contentQueries: function Label_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, TextArea, 5);
      ɵɵcontentQuery(dirIndex, TextInput, 5);
      ɵɵcontentQuery(dirIndex, PasswordInput, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.textArea = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.textInput = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.passwordInput = _t.first);
    }
  },
  viewQuery: function Label_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c021, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.wrapper = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function Label_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--form-item", ctx.labelClass);
    }
  },
  inputs: {
    labelInputID: "labelInputID",
    disabled: "disabled",
    skeleton: "skeleton",
    helperText: "helperText",
    invalidText: "invalidText",
    invalid: "invalid",
    warn: "warn",
    warnText: "warnText",
    ariaLabel: "ariaLabel"
  },
  standalone: false,
  ngContentSelectors: _c123,
  decls: 11,
  vars: 4,
  consts: [["inputContentTemplate", ""], ["labelContentTemplate", ""], ["default", ""], ["wrapper", ""], [3, "ngSwitch"], [4, "ngSwitchCase"], [4, "ngSwitchDefault"], [3, "labelInputID", "disabled", "skeleton", "helperText", "invalid", "invalidText", "warn", "warnText", "ariaLabel", "labelTemplate", "textAreaTemplate"], [3, "labelInputID", "disabled", "skeleton", "helperText", "invalid", "invalidText", "warn", "warnText", "ariaLabel", "labelTemplate", "textInputTemplate"], [3, "labelInputID", "disabled", "skeleton", "helperText", "invalid", "invalidText", "warn", "warnText", "ariaLabel", "labelTemplate", "passwordInputTemplate"], [3, "ngTemplateOutlet"], [1, "cds--label", 3, "for", "ngClass"], [1, "cds--text-input__field-wrapper", 3, "ngClass"], ["cdsIcon", "warning--filled", "size", "16", "class", "cds--text-input__invalid-icon", 4, "ngIf"], ["cdsIcon", "warning--alt--filled", "size", "16", "class", "cds--text-input__invalid-icon cds--text-input__invalid-icon--warning", 4, "ngIf"], ["class", "cds--form__helper-text", 3, "ngClass", 4, "ngIf"], ["class", "cds--form-requirement", 4, "ngIf"], ["cdsIcon", "warning--filled", "size", "16", 1, "cds--text-input__invalid-icon"], ["cdsIcon", "warning--alt--filled", "size", "16", 1, "cds--text-input__invalid-icon", "cds--text-input__invalid-icon--warning"], [1, "cds--form__helper-text", 3, "ngClass"], [4, "ngIf"], [1, "cds--form-requirement"]],
  template: function Label_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c1110);
      ɵɵtemplate(0, Label_ng_template_0_Template, 1, 0, "ng-template", null, 0, ɵɵtemplateRefExtractor)(2, Label_ng_template_2_Template, 1, 0, "ng-template", null, 1, ɵɵtemplateRefExtractor);
      ɵɵelementContainerStart(4, 4);
      ɵɵtemplate(5, Label_ng_container_5_Template, 2, 11, "ng-container", 5)(6, Label_ng_container_6_Template, 2, 11, "ng-container", 5)(7, Label_ng_container_7_Template, 2, 11, "ng-container", 5)(8, Label_ng_container_8_Template, 2, 1, "ng-container", 6);
      ɵɵelementContainerEnd();
      ɵɵtemplate(9, Label_ng_template_9_Template, 10, 17, "ng-template", null, 2, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      ɵɵadvance(4);
      ɵɵproperty("ngSwitch", ctx.type);
      ɵɵadvance();
      ɵɵproperty("ngSwitchCase", "TextArea");
      ɵɵadvance();
      ɵɵproperty("ngSwitchCase", "TextInput");
      ɵɵadvance();
      ɵɵproperty("ngSwitchCase", "PasswordInput");
    }
  },
  dependencies: [NgClass, NgIf, NgTemplateOutlet, NgSwitch, NgSwitchCase, NgSwitchDefault, IconDirective, TextareaLabelComponent, TextInputLabelComponent, PasswordInputLabelComponent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Label, [{
    type: Component,
    args: [{
      selector: "cds-label, ibm-label",
      template: `
		<ng-template #inputContentTemplate>
			<ng-content select="input,textarea,div"></ng-content>
		</ng-template>

		<ng-template #labelContentTemplate>
			<ng-content></ng-content>
		</ng-template>

		<ng-container [ngSwitch]="type">
			<ng-container *ngSwitchCase="'TextArea'">
				<cds-textarea-label
					[labelInputID]="labelInputID"
					[disabled]="disabled"
					[skeleton]="skeleton"
					[helperText]="helperText"
					[invalid]="invalid"
					[invalidText]="invalidText"
					[warn]="warn"
					[warnText]="warnText"
					[ariaLabel]="ariaLabel"
					[labelTemplate]="labelContentTemplate"
					[textAreaTemplate]="inputContentTemplate">
				</cds-textarea-label>
			</ng-container>
			<ng-container *ngSwitchCase="'TextInput'">
				<cds-text-label
					[labelInputID]="labelInputID"
					[disabled]="disabled"
					[skeleton]="skeleton"
					[helperText]="helperText"
					[invalid]="invalid"
					[invalidText]="invalidText"
					[warn]="warn"
					[warnText]="warnText"
					[ariaLabel]="ariaLabel"
					[labelTemplate]="labelContentTemplate"
					[textInputTemplate]="inputContentTemplate">
				</cds-text-label>
			</ng-container>
			<ng-container *ngSwitchCase="'PasswordInput'">
				<cds-password-label
					[labelInputID]="labelInputID"
					[disabled]="disabled"
					[skeleton]="skeleton"
					[helperText]="helperText"
					[invalid]="invalid"
					[invalidText]="invalidText"
					[warn]="warn"
					[warnText]="warnText"
					[ariaLabel]="ariaLabel"
					[labelTemplate]="labelContentTemplate"
					[passwordInputTemplate]="inputContentTemplate">
				</cds-password-label>
			</ng-container>
			<ng-container *ngSwitchDefault>
				<ng-template [ngTemplateOutlet]="default"></ng-template>
			</ng-container>
		</ng-container>

		<ng-template #default>
			<label
				[for]="labelInputID"
				[attr.aria-label]="ariaLabel"
				class="cds--label"
				[ngClass]="{
					'cds--label--disabled': disabled,
					'cds--skeleton': skeleton
				}">
				<ng-template [ngTemplateOutlet]="labelContentTemplate"></ng-template>
			</label>
			<div
				class="cds--text-input__field-wrapper"
				[ngClass]="{
					'cds--text-input__field-wrapper--warning': warn
				}"
				[attr.data-invalid]="(invalid ? true : null)"
				#wrapper>
				<svg
					*ngIf="invalid"
					cdsIcon="warning--filled"
					size="16"
					class="cds--text-input__invalid-icon">
				</svg>
				<svg
					*ngIf="!invalid && warn"
					cdsIcon="warning--alt--filled"
					size="16"
					class="cds--text-input__invalid-icon cds--text-input__invalid-icon--warning">
				</svg>
				<ng-template [ngTemplateOutlet]="inputContentTemplate"></ng-template>
			</div>
			<div
				*ngIf="!skeleton && helperText && !invalid && !warn"
				class="cds--form__helper-text"
				[ngClass]="{'cds--form__helper-text--disabled': disabled}">
				<ng-container *ngIf="!isTemplate(helperText)">{{helperText}}</ng-container>
				<ng-template *ngIf="isTemplate(helperText)" [ngTemplateOutlet]="helperText"></ng-template>
			</div>
			<div *ngIf="invalid" class="cds--form-requirement">
				<ng-container *ngIf="!isTemplate(invalidText)">{{invalidText}}</ng-container>
				<ng-template *ngIf="isTemplate(invalidText)" [ngTemplateOutlet]="invalidText"></ng-template>
			</div>
			<div *ngIf="!invalid && warn" class="cds--form-requirement">
				<ng-container *ngIf="!isTemplate(warnText)">{{warnText}}</ng-container>
				<ng-template *ngIf="isTemplate(warnText)" [ngTemplateOutlet]="warnText"></ng-template>
			</div>
		</ng-template>
	`
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }];
  }, {
    labelInputID: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    skeleton: [{
      type: Input
    }],
    helperText: [{
      type: Input
    }],
    invalidText: [{
      type: Input
    }],
    invalid: [{
      type: Input
    }],
    warn: [{
      type: Input
    }],
    warnText: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    wrapper: [{
      type: ViewChild,
      args: ["wrapper"]
    }],
    textArea: [{
      type: ContentChild,
      args: [TextArea]
    }],
    textInput: [{
      type: ContentChild,
      args: [TextInput, {
        static: false
      }]
    }],
    passwordInput: [{
      type: ContentChild,
      args: [PasswordInput, {
        static: false
      }]
    }],
    labelClass: [{
      type: HostBinding,
      args: ["class.cds--form-item"]
    }]
  });
})();
var InputModule = class {
};
InputModule.ɵfac = function InputModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || InputModule)();
};
InputModule.ɵmod = ɵɵdefineNgModule({
  type: InputModule,
  declarations: [Label, TextInput, TextArea, PasswordInput, TextareaLabelComponent, TextInputLabelComponent, PasswordInputLabelComponent],
  imports: [CommonModule, FormsModule, IconModule, ButtonModule, TooltipModule],
  exports: [Label, TextareaLabelComponent, TextInputLabelComponent, PasswordInputLabelComponent, TextInput, TextArea, PasswordInput]
});
InputModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, FormsModule, IconModule, ButtonModule, TooltipModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InputModule, [{
    type: NgModule,
    args: [{
      declarations: [Label, TextInput, TextArea, PasswordInput, TextareaLabelComponent, TextInputLabelComponent, PasswordInputLabelComponent],
      exports: [Label, TextareaLabelComponent, TextInputLabelComponent, PasswordInputLabelComponent, TextInput, TextArea, PasswordInput],
      imports: [CommonModule, FormsModule, IconModule, ButtonModule, TooltipModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-forms.mjs
var NFormsModule = class {
};
NFormsModule.ɵfac = function NFormsModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || NFormsModule)();
};
NFormsModule.ɵmod = ɵɵdefineNgModule({
  type: NFormsModule,
  imports: [CommonModule, FormsModule, CheckboxModule, ToggleModule, RadioModule, InputModule, ButtonModule],
  exports: [CheckboxModule, ToggleModule, RadioModule, InputModule, ButtonModule, InputModule]
});
NFormsModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, FormsModule, CheckboxModule, ToggleModule, RadioModule, InputModule, ButtonModule, CheckboxModule, ToggleModule, RadioModule, InputModule, ButtonModule, InputModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NFormsModule, [{
    type: NgModule,
    args: [{
      exports: [CheckboxModule, ToggleModule, RadioModule, InputModule, ButtonModule, InputModule],
      imports: [CommonModule, FormsModule, CheckboxModule, ToggleModule, RadioModule, InputModule, ButtonModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-grid.mjs
var GridService = class {
  constructor() {
    this.gridSubject = new BehaviorSubject(false);
    this.cssGridEnabled = false;
    this.gridObservable = this.gridSubject.asObservable();
  }
  /**
   * Ping all subscribers to update to use Css Grid
   * @param enableCssGrid
   */
  updateGridType(enableCssGrid) {
    if (this.cssGridEnabled === enableCssGrid) {
      return;
    }
    this.cssGridEnabled = true;
    this.gridSubject.next(enableCssGrid);
  }
};
GridService.ɵfac = function GridService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || GridService)();
};
GridService.ɵprov = ɵɵdefineInjectable({
  token: GridService,
  factory: GridService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GridService, [{
    type: Injectable
  }], function() {
    return [];
  }, null);
})();
var ColumnDirective = class {
  constructor(gridService) {
    this.gridService = gridService;
    this.class = "";
    this.columnNumbers = {};
    this.offsets = {};
    this.columnHang = false;
    this._columnClasses = [];
    this.isCssGrid = false;
    this.subscription = new Subscription();
  }
  get columnClasses() {
    return this._columnClasses.join(" ");
  }
  set columnClasses(classes) {
    this._columnClasses = classes.split(" ");
  }
  ngOnInit() {
    if (this.gridService) {
      this.subscription = this.gridService.gridObservable.subscribe((isCssGrid) => {
        this.isCssGrid = isCssGrid;
        this.updateColumnClasses();
      });
    } else {
      this.updateColumnClasses();
    }
  }
  ngOnChanges() {
    this.updateColumnClasses();
  }
  /**
   * Unsubscribe from subscription
   */
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
  updateColumnClasses() {
    try {
      this._columnClasses = [];
      const columnKeys = Object.keys(this.columnNumbers);
      if (this.isCssGrid) {
        this._columnClasses.push("cds--css-grid-column");
        if (this.columnHang) {
          this._columnClasses.push("cds--grid-column-hang");
        }
        columnKeys.forEach((key) => {
          if (this.columnNumbers[key] === "auto") {
            this._columnClasses.push(`cds--${key}:col-span-auto`);
          } else if (typeof this.columnNumbers[key] === "object") {
            if (this.columnNumbers[key]["start"]) {
              this._columnClasses.push(`cds--${key}:col-start-${this.columnNumbers[key].start}`);
            }
            if (this.columnNumbers[key]["end"]) {
              this._columnClasses.push(`cds--${key}:col-end-${this.columnNumbers[key].end}`);
            }
            if (this.columnNumbers[key]["span"]) {
              this._columnClasses.push(`cds--${key}:col-span-${this.columnNumbers[key].span}`);
            }
          } else {
            this._columnClasses.push(`cds--${key}:col-span-${this.columnNumbers[key]}`);
          }
        });
        Object.keys(this.offsets).forEach((key) => {
          this._columnClasses.push(`cds--${key}:col-start${this.offsets[key] + 1}`);
        });
      } else {
        if (columnKeys.length <= 0) {
          this._columnClasses.push("cds--col");
        }
        columnKeys.forEach((key) => {
          if (this.columnNumbers[key] === "nobreak") {
            this._columnClasses.push(`cds--col-${key}`);
          } else {
            this._columnClasses.push(`cds--col-${key}-${this.columnNumbers[key]}`);
          }
        });
        Object.keys(this.offsets).forEach((key) => {
          this._columnClasses.push(`cds--offset-${key}-${this.offsets[key]}`);
        });
      }
    } catch (err) {
      console.error(`Malformed \`offsets\` or \`columnNumbers\`: ${err}`);
    }
    if (this.class) {
      this._columnClasses.push(this.class);
    }
  }
};
ColumnDirective.ɵfac = function ColumnDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ColumnDirective)(ɵɵdirectiveInject(GridService, 8));
};
ColumnDirective.ɵdir = ɵɵdefineDirective({
  type: ColumnDirective,
  selectors: [["", "cdsCol", ""], ["", "ibmCol", ""]],
  hostVars: 2,
  hostBindings: function ColumnDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassMap(ctx.columnClasses);
    }
  },
  inputs: {
    class: "class",
    columnNumbers: "columnNumbers",
    offsets: "offsets",
    columnHang: "columnHang"
  },
  standalone: false,
  features: [ɵɵNgOnChangesFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnDirective, [{
    type: Directive,
    args: [{
      selector: "[cdsCol], [ibmCol]"
    }]
  }], function() {
    return [{
      type: GridService,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    columnClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    class: [{
      type: Input
    }],
    columnNumbers: [{
      type: Input
    }],
    offsets: [{
      type: Input
    }],
    columnHang: [{
      type: Input
    }]
  });
})();
var RowDirective = class {
  constructor() {
    this.baseClass = true;
    this.condensed = false;
    this.narrow = false;
  }
};
RowDirective.ɵfac = function RowDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RowDirective)();
};
RowDirective.ɵdir = ɵɵdefineDirective({
  type: RowDirective,
  selectors: [["", "cdsRow", ""], ["", "ibmRow", ""]],
  hostVars: 6,
  hostBindings: function RowDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--row", ctx.baseClass)("cds--row--condensed", ctx.condensed)("cds--row--narrow", ctx.narrow);
    }
  },
  inputs: {
    condensed: "condensed",
    narrow: "narrow"
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RowDirective, [{
    type: Directive,
    args: [{
      selector: "[cdsRow], [ibmRow]"
    }]
  }], null, {
    baseClass: [{
      type: HostBinding,
      args: ["class.cds--row"]
    }],
    condensed: [{
      type: HostBinding,
      args: ["class.cds--row--condensed"]
    }, {
      type: Input
    }],
    narrow: [{
      type: HostBinding,
      args: ["class.cds--row--narrow"]
    }, {
      type: Input
    }]
  });
})();
var GridDirective = class {
  constructor(gridService) {
    this.gridService = gridService;
    this.condensed = false;
    this.narrow = false;
    this.fullWidth = false;
    this.cssGridEnabled = false;
    this.isSubgrid = false;
    this.subscription = new Subscription();
  }
  /**
   * Set to `true` to use css grid
   */
  set useCssGrid(enable) {
    this.cssGridEnabled = enable;
    this.gridService.updateGridType(enable);
  }
  // Flex grid
  get flexGrid() {
    return !this.cssGridEnabled;
  }
  get flexCondensed() {
    return !this.cssGridEnabled && this.condensed;
  }
  get flexNarrow() {
    return !this.cssGridEnabled && this.narrow;
  }
  get flexFullWidth() {
    return !this.cssGridEnabled && this.fullWidth;
  }
  // CSS Grid
  get ccsGrid() {
    return this.cssGridEnabled && !this.isSubgrid;
  }
  get ccsCondensed() {
    return this.cssGridEnabled && !this.isSubgrid && this.condensed;
  }
  get ccsNarrow() {
    return this.cssGridEnabled && !this.isSubgrid && this.narrow;
  }
  get ccsFullWidth() {
    return this.cssGridEnabled && !this.isSubgrid && this.fullWidth;
  }
  // CSS Sub Grid
  get subGrid() {
    return this.cssGridEnabled && this.isSubgrid;
  }
  get subCondensed() {
    return this.cssGridEnabled && this.isSubgrid && this.condensed;
  }
  get subNarrow() {
    return this.cssGridEnabled && this.isSubgrid && this.narrow;
  }
  get subFullWidth() {
    return this.cssGridEnabled && this.isSubgrid && this.fullWidth;
  }
  ngOnInit() {
    this.subscription = this.gridService.gridObservable.subscribe((isCssGrid) => {
      this.cssGridEnabled = isCssGrid;
    });
  }
  // Make all children grids a sub grid
  set cssGridChildren(list) {
    if (this.cssGridEnabled) {
      list.forEach((grid) => {
        if (grid === this) {
          return;
        }
        grid.isSubgrid = true;
      });
    }
  }
  /**
   * Unsubscribe from Grid Service subscription
   */
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
};
GridDirective.ɵfac = function GridDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || GridDirective)(ɵɵdirectiveInject(GridService));
};
GridDirective.ɵdir = ɵɵdefineDirective({
  type: GridDirective,
  selectors: [["", "cdsGrid", ""], ["", "ibmGrid", ""]],
  contentQueries: function GridDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, GridDirective, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.cssGridChildren = _t);
    }
  },
  hostVars: 24,
  hostBindings: function GridDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--grid", ctx.flexGrid)("cds--grid--condensed", ctx.flexCondensed)("cds--grid--narrow", ctx.flexNarrow)("cds--grid--full-width", ctx.flexFullWidth)("cds--css-grid", ctx.ccsGrid)("cds--css-grid--condensed", ctx.ccsCondensed)("cds--css-grid--narrow", ctx.ccsNarrow)("cds--css-grid--full-width", ctx.ccsFullWidth)("cds--subgrid", ctx.subGrid)("cds--subgrid--condensed", ctx.subCondensed)("cds--subgrid--narrow", ctx.subNarrow)("cds--subgrid--wide", ctx.subFullWidth);
    }
  },
  inputs: {
    condensed: "condensed",
    narrow: "narrow",
    fullWidth: "fullWidth",
    useCssGrid: "useCssGrid"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([{
    provide: GridService,
    deps: [[new Optional(), new SkipSelf(), GridService]],
    useFactory: (parentService) => {
      return parentService || new GridService();
    }
  }])]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GridDirective, [{
    type: Directive,
    args: [{
      selector: "[cdsGrid], [ibmGrid]",
      providers: [{
        provide: GridService,
        deps: [[new Optional(), new SkipSelf(), GridService]],
        useFactory: (parentService) => {
          return parentService || new GridService();
        }
      }]
    }]
  }], function() {
    return [{
      type: GridService
    }];
  }, {
    condensed: [{
      type: Input
    }],
    narrow: [{
      type: Input
    }],
    fullWidth: [{
      type: Input
    }],
    useCssGrid: [{
      type: Input
    }],
    flexGrid: [{
      type: HostBinding,
      args: ["class.cds--grid"]
    }],
    flexCondensed: [{
      type: HostBinding,
      args: ["class.cds--grid--condensed"]
    }],
    flexNarrow: [{
      type: HostBinding,
      args: ["class.cds--grid--narrow"]
    }],
    flexFullWidth: [{
      type: HostBinding,
      args: ["class.cds--grid--full-width"]
    }],
    ccsGrid: [{
      type: HostBinding,
      args: ["class.cds--css-grid"]
    }],
    ccsCondensed: [{
      type: HostBinding,
      args: ["class.cds--css-grid--condensed"]
    }],
    ccsNarrow: [{
      type: HostBinding,
      args: ["class.cds--css-grid--narrow"]
    }],
    ccsFullWidth: [{
      type: HostBinding,
      args: ["class.cds--css-grid--full-width"]
    }],
    subGrid: [{
      type: HostBinding,
      args: ["class.cds--subgrid"]
    }],
    subCondensed: [{
      type: HostBinding,
      args: ["class.cds--subgrid--condensed"]
    }],
    subNarrow: [{
      type: HostBinding,
      args: ["class.cds--subgrid--narrow"]
    }],
    subFullWidth: [{
      type: HostBinding,
      args: ["class.cds--subgrid--wide"]
    }],
    cssGridChildren: [{
      type: ContentChildren,
      args: [GridDirective, {
        descendants: true
      }]
    }]
  });
})();
var GridModule = class {
};
GridModule.ɵfac = function GridModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || GridModule)();
};
GridModule.ɵmod = ɵɵdefineNgModule({
  type: GridModule,
  declarations: [ColumnDirective, GridDirective, RowDirective],
  imports: [CommonModule],
  exports: [ColumnDirective, GridDirective, RowDirective]
});
GridModule.ɵinj = ɵɵdefineInjector({
  providers: [GridService],
  imports: [CommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GridModule, [{
    type: NgModule,
    args: [{
      declarations: [ColumnDirective, GridDirective, RowDirective],
      exports: [ColumnDirective, GridDirective, RowDirective],
      providers: [GridService],
      imports: [CommonModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-inline-loading.mjs
var _c022 = (a0) => ({
  "cds--loading--stop": a0
});
function InlineLoading_div_0_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 6);
    ɵɵnamespaceSVG();
    ɵɵelementStart(1, "svg", 7);
    ɵɵelement(2, "circle", 8)(3, "circle", 9);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngClass", ɵɵpureFunction1(1, _c022, ctx_r0.state === ctx_r0.InlineLoadingState.Inactive));
  }
}
function InlineLoading_div_0__svg_svg_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 10);
  }
}
function InlineLoading_div_0__svg_svg_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 11);
  }
}
function InlineLoading_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 2);
    ɵɵtemplate(1, InlineLoading_div_0_div_1_Template, 4, 3, "div", 3)(2, InlineLoading_div_0__svg_svg_2_Template, 1, 0, "svg", 4)(3, InlineLoading_div_0__svg_svg_3_Template, 1, 0, "svg", 5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.state === ctx_r0.InlineLoadingState.Inactive || ctx_r0.state === ctx_r0.InlineLoadingState.Active);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.state === ctx_r0.InlineLoadingState.Finished);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.state === ctx_r0.InlineLoadingState.Error);
  }
}
function InlineLoading_p_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "p", 12);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.loadingText);
  }
}
function InlineLoading_p_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "p", 12);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.successText);
  }
}
function InlineLoading_p_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "p", 12);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.errorText);
  }
}
var InlineLoadingState;
(function(InlineLoadingState2) {
  InlineLoadingState2["Hidden"] = "hidden";
  InlineLoadingState2["Inactive"] = "inactive";
  InlineLoadingState2["Active"] = "active";
  InlineLoadingState2["Finished"] = "finished";
  InlineLoadingState2["Error"] = "error";
})(InlineLoadingState || (InlineLoadingState = {}));
var InlineLoading = class {
  constructor() {
    this.InlineLoadingState = InlineLoadingState;
    this.state = InlineLoadingState.Active;
    this.successDelay = 1500;
    this.onSuccess = new EventEmitter();
    this.loadingClass = true;
  }
  /**
   * set to `false` to stop the loading animation
   */
  get isActive() {
    return this.state === InlineLoadingState.Active;
  }
  set isActive(active) {
    this.state = active ? InlineLoadingState.Active : InlineLoadingState.Inactive;
  }
  /**
   * Returns value `true` if the component is in the success state.
   */
  get success() {
    return this.state === InlineLoadingState.Finished;
  }
  /**
   * Set the component's state to match the parameter and emits onSuccess if it exits.
   */
  set success(success) {
    this.state = success ? InlineLoadingState.Finished : InlineLoadingState.Error;
    if (this.state === InlineLoadingState.Finished) {
      setTimeout(() => {
        this.onSuccess.emit();
      }, this.successDelay);
    }
  }
};
InlineLoading.ɵfac = function InlineLoading_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || InlineLoading)();
};
InlineLoading.ɵcmp = ɵɵdefineComponent({
  type: InlineLoading,
  selectors: [["cds-inline-loading"], ["ibm-inline-loading"]],
  hostVars: 2,
  hostBindings: function InlineLoading_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--inline-loading", ctx.loadingClass);
    }
  },
  inputs: {
    state: "state",
    loadingText: "loadingText",
    successText: "successText",
    successDelay: "successDelay",
    errorText: "errorText",
    isActive: "isActive",
    success: "success"
  },
  outputs: {
    onSuccess: "onSuccess"
  },
  standalone: false,
  decls: 4,
  vars: 4,
  consts: [["class", "cds--inline-loading__animation", 4, "ngIf"], ["class", "cds--inline-loading__text", 4, "ngIf"], [1, "cds--inline-loading__animation"], ["class", "cds--loading cds--loading--small", 3, "ngClass", 4, "ngIf"], ["cdsIcon", "checkmark--filled", "size", "16", "class", "cds--inline-loading__checkmark-container", 4, "ngIf"], ["cdsIcon", "error--filled", "size", "16", "class", "cds--inline-loading--error", 4, "ngIf"], [1, "cds--loading", "cds--loading--small", 3, "ngClass"], ["viewBox", "0 0 100 100", 1, "cds--loading__svg"], ["cx", "50%", "cy", "50%", "r", "44", 1, "cds--loading__background"], ["cx", "50%", "cy", "50%", "r", "44", 1, "cds--loading__stroke"], ["cdsIcon", "checkmark--filled", "size", "16", 1, "cds--inline-loading__checkmark-container"], ["cdsIcon", "error--filled", "size", "16", 1, "cds--inline-loading--error"], [1, "cds--inline-loading__text"]],
  template: function InlineLoading_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, InlineLoading_div_0_Template, 4, 3, "div", 0)(1, InlineLoading_p_1_Template, 2, 1, "p", 1)(2, InlineLoading_p_2_Template, 2, 1, "p", 1)(3, InlineLoading_p_3_Template, 2, 1, "p", 1);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.state !== ctx.InlineLoadingState.Hidden);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.state === ctx.InlineLoadingState.Inactive || ctx.state === ctx.InlineLoadingState.Active);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.state === ctx.InlineLoadingState.Finished);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.state === ctx.InlineLoadingState.Error);
    }
  },
  dependencies: [NgClass, NgIf, IconDirective],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InlineLoading, [{
    type: Component,
    args: [{
      selector: "cds-inline-loading, ibm-inline-loading",
      template: `
		<div *ngIf="state !== InlineLoadingState.Hidden"
			class="cds--inline-loading__animation">
			<div
				*ngIf="state === InlineLoadingState.Inactive || state === InlineLoadingState.Active"
				class="cds--loading cds--loading--small"
				[ngClass]="{
					'cds--loading--stop': state === InlineLoadingState.Inactive
				}">
				<svg class="cds--loading__svg" viewBox="0 0 100 100">
					<circle class="cds--loading__background" cx="50%" cy="50%" r="44" />
					<circle class="cds--loading__stroke" cx="50%" cy="50%" r="44" />
				</svg>
			</div>
			<svg
				*ngIf="state === InlineLoadingState.Finished"
				cdsIcon="checkmark--filled"
				size="16"
				class="cds--inline-loading__checkmark-container">
			</svg>
			<svg
				*ngIf="state === InlineLoadingState.Error"
				cdsIcon="error--filled"
				size="16"
				class="cds--inline-loading--error">
			</svg>
		</div>
		<p
			*ngIf="state === InlineLoadingState.Inactive || state === InlineLoadingState.Active"
			class="cds--inline-loading__text">{{loadingText}}</p>
		<p *ngIf="state === InlineLoadingState.Finished" class="cds--inline-loading__text">{{successText}}</p>
		<p *ngIf="state === InlineLoadingState.Error" class="cds--inline-loading__text">{{errorText}}</p>
	`
    }]
  }], null, {
    state: [{
      type: Input
    }],
    loadingText: [{
      type: Input
    }],
    successText: [{
      type: Input
    }],
    successDelay: [{
      type: Input
    }],
    errorText: [{
      type: Input
    }],
    isActive: [{
      type: Input
    }],
    success: [{
      type: Input
    }],
    onSuccess: [{
      type: Output
    }],
    loadingClass: [{
      type: HostBinding,
      args: ["class.cds--inline-loading"]
    }]
  });
})();
var InlineLoadingModule = class {
};
InlineLoadingModule.ɵfac = function InlineLoadingModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || InlineLoadingModule)();
};
InlineLoadingModule.ɵmod = ɵɵdefineNgModule({
  type: InlineLoadingModule,
  declarations: [InlineLoading],
  imports: [CommonModule, IconModule],
  exports: [InlineLoading]
});
InlineLoadingModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, IconModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InlineLoadingModule, [{
    type: NgModule,
    args: [{
      declarations: [InlineLoading],
      exports: [InlineLoading],
      imports: [CommonModule, IconModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-layer.mjs
var MAX_LEVEL = 2;
var LayerDirective = class {
  /**
   * @deprecated as of v5 - Use `cdsLayer` input property instead
   */
  set ibmLayer(level) {
    this.cdsLayer = level;
  }
  /**
   * Override layer level
   * Empty string has been added as an option for Angular 16+ to resolve type errors
   */
  set cdsLayer(level) {
    if (typeof level === "number") {
      this._passedLevel = level;
      this.layer = level;
    }
  }
  get cdsLayer() {
    return this._passedLevel;
  }
  /**
   * If cdsLayer is undefined, auto increment & iterate level
   */
  set layer(level) {
    if (typeof level === "number") {
      this._level = Math.max(0, Math.min(level, MAX_LEVEL));
      if (this.layerChildren) {
        this.layerChildren.forEach((layer) => {
          if (layer === this) {
            return;
          }
          layer.layer = typeof layer._passedLevel === "number" ? layer._passedLevel : this.layer + 1;
        });
      }
    }
  }
  get layer() {
    return this._level;
  }
  /**
   * Using host bindings with classes to ensure we do not
   * overwrite user added classes
   */
  get layerOneClass() {
    return this.layer === 0;
  }
  get layerTwoClass() {
    return this.layer === 1;
  }
  get layerThreeClass() {
    return this.layer === 2;
  }
  ngAfterContentInit() {
    if (typeof this.cdsLayer !== "number") {
      this.layer = 1;
    }
  }
};
LayerDirective.ɵfac = function LayerDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || LayerDirective)();
};
LayerDirective.ɵdir = ɵɵdefineDirective({
  type: LayerDirective,
  selectors: [["", "cdsLayer", ""], ["", "ibmLayer", ""]],
  contentQueries: function LayerDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, LayerDirective, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.layerChildren = _t);
    }
  },
  hostVars: 6,
  hostBindings: function LayerDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--layer-one", ctx.layerOneClass)("cds--layer-two", ctx.layerTwoClass)("cds--layer-three", ctx.layerThreeClass);
    }
  },
  inputs: {
    ibmLayer: "ibmLayer",
    cdsLayer: "cdsLayer"
  },
  exportAs: ["layer"],
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LayerDirective, [{
    type: Directive,
    args: [{
      selector: "[cdsLayer], [ibmLayer]",
      exportAs: "layer"
    }]
  }], null, {
    ibmLayer: [{
      type: Input
    }],
    cdsLayer: [{
      type: Input
    }],
    layerOneClass: [{
      type: HostBinding,
      args: ["class.cds--layer-one"]
    }],
    layerTwoClass: [{
      type: HostBinding,
      args: ["class.cds--layer-two"]
    }],
    layerThreeClass: [{
      type: HostBinding,
      args: ["class.cds--layer-three"]
    }],
    layerChildren: [{
      type: ContentChildren,
      args: [LayerDirective, {
        descendants: false
      }]
    }]
  });
})();
var LayerModule = class {
};
LayerModule.ɵfac = function LayerModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || LayerModule)();
};
LayerModule.ɵmod = ɵɵdefineNgModule({
  type: LayerModule,
  declarations: [LayerDirective],
  imports: [CommonModule],
  exports: [LayerDirective]
});
LayerModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LayerModule, [{
    type: NgModule,
    args: [{
      declarations: [LayerDirective],
      exports: [LayerDirective],
      imports: [CommonModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-layout.mjs
var StackDirective = class {
  constructor(render, hostElement) {
    this.render = render;
    this.hostElement = hostElement;
    this.cdsStack = "vertical";
  }
  get isHorizontal() {
    return this.cdsStack === "horizontal";
  }
  get isVertical() {
    return this.cdsStack === "vertical" || !this.cdsStack;
  }
  /**
   * @deprecated as of v5 - Use `cdsStack` input property instead
   */
  set ibmStack(type) {
    this.cdsStack = type;
  }
  /**
   * Gap in the layout, provide a custom value (string) or a step from the spacing scale (number)
   */
  set gap(num) {
    if (num !== void 0) {
      this.render.removeClass(this.hostElement.nativeElement, `cds--stack-scale-${this._gap}`);
      this.render.addClass(this.hostElement.nativeElement, `cds--stack-scale-${num}`);
      this._gap = num;
    }
  }
};
StackDirective.ɵfac = function StackDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || StackDirective)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
};
StackDirective.ɵdir = ɵɵdefineDirective({
  type: StackDirective,
  selectors: [["", "cdsStack", ""], ["", "ibmStack", ""]],
  hostVars: 4,
  hostBindings: function StackDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--stack-horizontal", ctx.isHorizontal)("cds--stack-vertical", ctx.isVertical);
    }
  },
  inputs: {
    ibmStack: "ibmStack",
    cdsStack: "cdsStack",
    gap: "gap"
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StackDirective, [{
    type: Directive,
    args: [{
      selector: "[cdsStack], [ibmStack]"
    }]
  }], function() {
    return [{
      type: Renderer2
    }, {
      type: ElementRef
    }];
  }, {
    isHorizontal: [{
      type: HostBinding,
      args: ["class.cds--stack-horizontal"]
    }],
    isVertical: [{
      type: HostBinding,
      args: ["class.cds--stack-vertical"]
    }],
    ibmStack: [{
      type: Input
    }],
    cdsStack: [{
      type: Input
    }],
    gap: [{
      type: Input
    }]
  });
})();
var LayoutModule = class {
};
LayoutModule.ɵfac = function LayoutModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || LayoutModule)();
};
LayoutModule.ɵmod = ɵɵdefineNgModule({
  type: LayoutModule,
  declarations: [StackDirective],
  imports: [CommonModule],
  exports: [StackDirective]
});
LayoutModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LayoutModule, [{
    type: NgModule,
    args: [{
      declarations: [StackDirective],
      exports: [StackDirective],
      imports: [CommonModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-link.mjs
var Link = class {
  constructor() {
    this.baseClass = true;
    this.inline = false;
  }
  /**
   * Set to true to disable link.
   */
  set disabled(disabled) {
    this._disabled = disabled;
    this.tabindex = this.disabled ? -1 : null;
  }
  get disabled() {
    return this._disabled;
  }
};
Link.ɵfac = function Link_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Link)();
};
Link.ɵdir = ɵɵdefineDirective({
  type: Link,
  selectors: [["", "cdsLink", ""], ["", "ibmLink", ""]],
  hostVars: 8,
  hostBindings: function Link_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("tabindex", ctx.tabindex)("aria-disabled", ctx.disabled);
      ɵɵclassProp("cds--link", ctx.baseClass)("cds--link--inline", ctx.inline)("cds--link--disabled", ctx.disabled);
    }
  },
  inputs: {
    inline: "inline",
    disabled: "disabled"
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Link, [{
    type: Directive,
    args: [{
      selector: "[cdsLink], [ibmLink]"
    }]
  }], null, {
    baseClass: [{
      type: HostBinding,
      args: ["class.cds--link"]
    }],
    tabindex: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    inline: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.cds--link--inline"]
    }],
    disabled: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }, {
      type: HostBinding,
      args: ["class.cds--link--disabled"]
    }]
  });
})();
var LinkIconDirective = class {
  constructor() {
    this.iconClass = true;
  }
};
LinkIconDirective.ɵfac = function LinkIconDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || LinkIconDirective)();
};
LinkIconDirective.ɵdir = ɵɵdefineDirective({
  type: LinkIconDirective,
  selectors: [["", "ibmLinkIcon", ""], ["", "cdsLinkIcon", ""]],
  hostVars: 2,
  hostBindings: function LinkIconDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--link__icon", ctx.iconClass);
    }
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LinkIconDirective, [{
    type: Directive,
    args: [{
      selector: "[ibmLinkIcon], [cdsLinkIcon]"
    }]
  }], null, {
    iconClass: [{
      type: HostBinding,
      args: ["class.cds--link__icon"]
    }]
  });
})();
var LinkModule = class {
};
LinkModule.ɵfac = function LinkModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || LinkModule)();
};
LinkModule.ɵmod = ɵɵdefineNgModule({
  type: LinkModule,
  declarations: [Link, LinkIconDirective],
  imports: [CommonModule],
  exports: [Link, LinkIconDirective]
});
LinkModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LinkModule, [{
    type: NgModule,
    args: [{
      declarations: [Link, LinkIconDirective],
      exports: [Link, LinkIconDirective],
      imports: [CommonModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-list.mjs
var ListItemDirective = class {
  constructor() {
    this.wrapper = true;
  }
};
ListItemDirective.ɵfac = function ListItemDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ListItemDirective)();
};
ListItemDirective.ɵdir = ɵɵdefineDirective({
  type: ListItemDirective,
  selectors: [["", "cdsListItem", ""], ["", "ibmListItem", ""]],
  hostVars: 2,
  hostBindings: function ListItemDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--list__item", ctx.wrapper);
    }
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ListItemDirective, [{
    type: Directive,
    args: [{
      selector: "[cdsListItem], [ibmListItem]"
    }]
  }], null, {
    wrapper: [{
      type: HostBinding,
      args: ["class.cds--list__item"]
    }]
  });
})();
var List = class {
  constructor(elementRef) {
    this.elementRef = elementRef;
    this.isExpressive = false;
  }
  get ordered() {
    if (this.nested) {
      return false;
    }
    return this.elementRef.nativeElement.tagName === "OL";
  }
  get unordered() {
    if (this.nested) {
      return false;
    }
    return this.elementRef.nativeElement.tagName === "UL";
  }
  get nested() {
    return !!(this.elementRef.nativeElement.parentElement && this.elementRef.nativeElement.parentElement.tagName === "LI");
  }
};
List.ɵfac = function List_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || List)(ɵɵdirectiveInject(ElementRef));
};
List.ɵdir = ɵɵdefineDirective({
  type: List,
  selectors: [["", "cdsList", ""], ["", "ibmList", ""]],
  hostVars: 8,
  hostBindings: function List_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--list--ordered", ctx.ordered)("cds--list--unordered", ctx.unordered)("cds--list--nested", ctx.nested)("cds--list--expressive", ctx.isExpressive);
    }
  },
  inputs: {
    isExpressive: "isExpressive"
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(List, [{
    type: Directive,
    args: [{
      selector: "[cdsList], [ibmList]"
    }]
  }], function() {
    return [{
      type: ElementRef
    }];
  }, {
    ordered: [{
      type: HostBinding,
      args: ["class.cds--list--ordered"]
    }],
    unordered: [{
      type: HostBinding,
      args: ["class.cds--list--unordered"]
    }],
    nested: [{
      type: HostBinding,
      args: ["class.cds--list--nested"]
    }],
    isExpressive: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.cds--list--expressive"]
    }]
  });
})();
var ListModule = class {
};
ListModule.ɵfac = function ListModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ListModule)();
};
ListModule.ɵmod = ɵɵdefineNgModule({
  type: ListModule,
  declarations: [ListItemDirective, List],
  imports: [CommonModule],
  exports: [ListItemDirective, List]
});
ListModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ListModule, [{
    type: NgModule,
    args: [{
      declarations: [ListItemDirective, List],
      exports: [ListItemDirective, List],
      imports: [CommonModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-modal.mjs
var _c023 = ["overlay"];
var _c120 = ["*"];
var _c216 = (a0, a1) => ({
  "cds--modal--danger": a0,
  "is-visible": a1
});
var _c310 = ["modal"];
var _c48 = (a0, a1, a2, a3) => ({
  "cds--modal-container--xs": a0,
  "cds--modal-container--sm": a1,
  "cds--modal-container--md": a2,
  "cds--modal-container--lg": a3
});
function ModalHeader_cds_icon_button_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "cds-icon-button", 2);
    ɵɵlistener("click", function ModalHeader_cds_icon_button_3_Template_cds_icon_button_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onClose());
    });
    ɵɵnamespaceSVG();
    ɵɵelement(1, "svg", 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("buttonNgClass", ctx_r1.buttonNgClass)("buttonAttributes", ctx_r1.buttonAttributes)("description", ctx_r1.closeLabel);
  }
}
var _c56 = ["modalContent"];
function AlertModal_cds_modal_footer_9_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "button", 9);
    ɵɵlistener("click", function AlertModal_cds_modal_footer_9_ng_container_1_Template_button_click_1_listener() {
      const i_r3 = ɵɵrestoreView(_r2).index;
      const ctx_r3 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r3.buttonClicked(i_r3));
    });
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const button_r5 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("cdsButton", button_r5.type)("id", button_r5.id);
    ɵɵattribute("modal-primary-focus", button_r5.type.indexOf("primary") !== -1 ? "" : null);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", button_r5.text, " ");
  }
}
function AlertModal_cds_modal_footer_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "cds-modal-footer");
    ɵɵtemplate(1, AlertModal_cds_modal_footer_9_ng_container_1_Template, 3, 4, "ng-container", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r3.buttons);
  }
}
var BaseModal = class {
  constructor() {
    this.close = new EventEmitter();
    this.open = false;
  }
  /**
   * Default method to handle closing the modal
   */
  closeModal() {
    this.close.emit();
  }
};
BaseModal.ɵfac = function BaseModal_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || BaseModal)();
};
BaseModal.ɵdir = ɵɵdefineDirective({
  type: BaseModal,
  selectors: [["", "cdsBaseModal", ""], ["", "ibmBaseModal", ""]],
  inputs: {
    open: "open"
  },
  outputs: {
    close: "close"
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseModal, [{
    type: Directive,
    args: [{
      selector: "[cdsBaseModal], [ibmBaseModal]"
    }]
  }], null, {
    close: [{
      type: Output
    }],
    open: [{
      type: Input
    }]
  });
})();
var BaseModalService = class _BaseModalService {
  /**
   * Creates an instance of `ModalService`.
   */
  constructor(placeholderService) {
    this.placeholderService = placeholderService;
    this.environment = inject(EnvironmentInjector);
  }
  /**
   * Creates and renders the modal component that is passed in.
   * `inputs` is an optional parameter of `data` that can be passed to the `Modal` component.
   */
  create(data) {
    let defaults2 = {
      inputs: {}
    };
    data = Object.assign({}, defaults2, data);
    const inputProviders = Object.keys(data.inputs).map((inputName) => ({
      provide: inputName,
      useValue: data.inputs[inputName]
    }));
    const injector = Injector.create({
      providers: inputProviders
    });
    const component = this.placeholderService.createComponent(data.component, injector, void 0, this.environment);
    let focusedElement = document.activeElement;
    setTimeout(() => {
      component.instance.open = true;
    });
    component["previouslyFocusedElement"] = focusedElement;
    component.instance.close.pipe(
      // trigger the close animation
      tap(() => {
        component.instance.open = false;
      }),
      // delay closing by an arbitrary amount to allow the animation to finish
      delay(240)
    ).subscribe(() => {
      this.placeholderService.destroyComponent(component);
      _BaseModalService.modalList = _BaseModalService.modalList.filter((c) => c !== component);
    });
    component.onDestroy(() => {
      focusedElement.focus();
    });
    _BaseModalService.modalList.push(component);
    return component;
  }
  /**
   * Destroys the modal on the supplied index.
   * When called without parameters it destroys the most recently created/top most modal.
   */
  destroy(index = -1) {
    if (index >= _BaseModalService.modalList.length || _BaseModalService.modalList.length === 0) {
      return;
    }
    if (index < 0) {
      index = _BaseModalService.modalList.length - 1;
    }
    setTimeout(() => {
      if (_BaseModalService.modalList[index]) {
        this.placeholderService.destroyComponent(_BaseModalService.modalList[index]);
        _BaseModalService.modalList.splice(index, 1);
      }
    }, 240);
  }
};
BaseModalService.modalList = [];
BaseModalService.ɵfac = function BaseModalService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || BaseModalService)(ɵɵinject(PlaceholderService));
};
BaseModalService.ɵprov = ɵɵdefineInjectable({
  token: BaseModalService,
  factory: BaseModalService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseModalService, [{
    type: Injectable
  }], function() {
    return [{
      type: PlaceholderService
    }];
  }, null);
})();
var Overlay = class {
  constructor() {
    this.theme = "default";
    this.open = false;
    this.overlaySelect = new EventEmitter();
  }
  /**
   * Handles the user clicking on the `Overlay` which resides outside the `Modal` object.
   */
  overlayClick(event) {
    if (event.target !== this.overlay.nativeElement) {
      return;
    }
    event.stopPropagation();
    this.overlaySelect.emit(event);
  }
};
Overlay.ɵfac = function Overlay_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Overlay)();
};
Overlay.ɵcmp = ɵɵdefineComponent({
  type: Overlay,
  selectors: [["cds-overlay"], ["ibm-overlay"]],
  viewQuery: function Overlay_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c023, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.overlay = _t.first);
    }
  },
  inputs: {
    theme: "theme",
    open: "open"
  },
  outputs: {
    overlaySelect: "overlaySelect"
  },
  standalone: false,
  ngContentSelectors: _c120,
  decls: 3,
  vars: 4,
  consts: [["overlay", ""], [1, "cds--modal", "cds--modal-tall", 3, "click", "ngClass"]],
  template: function Overlay_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵprojectionDef();
      ɵɵelementStart(0, "section", 1, 0);
      ɵɵlistener("click", function Overlay_Template_section_click_0_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.overlayClick($event));
      });
      ɵɵprojection(2);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngClass", ɵɵpureFunction2(1, _c216, ctx.theme === "danger", ctx.open));
    }
  },
  dependencies: [NgClass],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Overlay, [{
    type: Component,
    args: [{
      selector: "cds-overlay, ibm-overlay",
      template: `
		<section
			class="cds--modal cds--modal-tall"
			[ngClass]="{
				'cds--modal--danger': theme === 'danger',
				'is-visible': open
			}"
			(click)="overlayClick($event)"
			#overlay>
			<ng-content></ng-content>
		</section>
	`
    }]
  }], null, {
    theme: [{
      type: Input
    }],
    open: [{
      type: Input
    }],
    overlaySelect: [{
      type: Output
    }],
    overlay: [{
      type: ViewChild,
      args: ["overlay", {
        static: true
      }]
    }]
  });
})();
var Modal = class {
  /**
   * Creates an instance of `Modal`.
   */
  constructor(modalService, document2, renderer) {
    this.modalService = modalService;
    this.document = document2;
    this.renderer = renderer;
    this.size = "md";
    this.theme = "default";
    this.ariaLabel = "default";
    this.open = false;
    this.hasScrollingContent = null;
    this.overlaySelected = new EventEmitter();
    this.close = new EventEmitter();
    this.selectorPrimaryFocus = "[modal-primary-focus]";
  }
  ngOnChanges({
    open: open2,
    hasScrollingContent
  }) {
    if (open2) {
      if (open2.currentValue) {
        setTimeout(() => this.focusInitialElement(), 100);
        this.renderer.addClass(this.document.body, "cds--body--with-modal-open");
      } else if (!open2.currentValue) {
        this.renderer.removeClass(this.document.body, "cds--body--with-modal-open");
      } else if (this.trigger) {
        this.trigger.focus();
      }
    }
    if (hasScrollingContent) {
      this.updateScrollbar();
    }
  }
  /**
   * Set document focus to be on the modal component after it is initialized.
   */
  ngAfterViewInit() {
    this.focusInitialElement();
    this.updateScrollbar();
  }
  /**
   * Handle keyboard events to close modal and tab through the content within the modal.
   */
  handleKeyboardEvent(event) {
    switch (event.key) {
      case "Escape": {
        event.stopImmediatePropagation();
        this.open = false;
        this.close.emit();
        this.modalService.destroy();
        break;
      }
      case "Tab": {
        cycleTabs(event, this.modal.nativeElement);
        break;
      }
    }
  }
  /**
   * This detects whether or not the modal contains scrolling content.
   *
   * To force trigger a detection (ie. on window resize), change or reset the value of the modal content.
   *
   * Use the `hasScrollingContent` input to manually override the overflow indicator.
   */
  get shouldShowScrollbar() {
    const modalContent = this.modal ? this.modal.nativeElement.querySelector(".cds--modal-content") : null;
    if (modalContent) {
      const modalContentHeight = Math.ceil(modalContent.getBoundingClientRect().height);
      const modalContentScrollHeight = modalContent.scrollHeight;
      return modalContentScrollHeight > modalContentHeight;
    } else {
      return false;
    }
  }
  // Remove class preventing scrolling
  ngOnDestroy() {
    this.renderer.removeClass(this.document.body, "cds--body--with-modal-open");
  }
  focusInitialElement() {
    const primaryFocusElement = this.modal.nativeElement.querySelector(this.selectorPrimaryFocus);
    if (primaryFocusElement && primaryFocusElement.focus) {
      setTimeout(() => primaryFocusElement.focus());
    } else if (getFocusElementList(this.modal.nativeElement).length > 0) {
      setTimeout(() => getFocusElementList(this.modal.nativeElement)[0].focus());
    } else {
      setTimeout(() => this.modal.nativeElement.focus());
    }
  }
  updateScrollbar() {
    const modalContent = this.modal ? this.modal.nativeElement.querySelector(".cds--modal-content") : null;
    const showScrollbar = this.hasScrollingContent !== null ? this.hasScrollingContent : this.shouldShowScrollbar;
    if (modalContent) {
      if (showScrollbar) {
        this.renderer.addClass(modalContent, "cds--modal-scroll-content");
      } else {
        this.renderer.removeClass(modalContent, "cds--modal-scroll-content");
      }
    }
  }
};
Modal.ɵfac = function Modal_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Modal)(ɵɵdirectiveInject(BaseModalService), ɵɵdirectiveInject(DOCUMENT), ɵɵdirectiveInject(Renderer2));
};
Modal.ɵcmp = ɵɵdefineComponent({
  type: Modal,
  selectors: [["cds-modal"], ["ibm-modal"]],
  viewQuery: function Modal_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c310, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.modal = _t.first);
    }
  },
  hostBindings: function Modal_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("keydown", function Modal_keydown_HostBindingHandler($event) {
        return ctx.handleKeyboardEvent($event);
      });
    }
  },
  inputs: {
    size: "size",
    theme: "theme",
    ariaLabel: "ariaLabel",
    open: "open",
    trigger: "trigger",
    hasScrollingContent: "hasScrollingContent"
  },
  outputs: {
    overlaySelected: "overlaySelected",
    close: "close"
  },
  standalone: false,
  features: [ɵɵNgOnChangesFeature],
  ngContentSelectors: _c120,
  decls: 4,
  vars: 9,
  consts: [["modal", ""], [3, "overlaySelect", "theme", "open"], ["role", "dialog", "aria-modal", "true", 1, "cds--modal-container", 2, "z-index", "1", 3, "ngClass"]],
  template: function Modal_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵprojectionDef();
      ɵɵelementStart(0, "cds-overlay", 1);
      ɵɵlistener("overlaySelect", function Modal_Template_cds_overlay_overlaySelect_0_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.overlaySelected.emit());
      });
      ɵɵelementStart(1, "div", 2, 0);
      ɵɵprojection(3);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵproperty("theme", ctx.theme)("open", ctx.open);
      ɵɵadvance();
      ɵɵproperty("ngClass", ɵɵpureFunction4(4, _c48, ctx.size === "xs", ctx.size === "sm", ctx.size === "md", ctx.size === "lg"));
      ɵɵattribute("aria-label", ctx.ariaLabel);
    }
  },
  dependencies: [NgClass, Overlay],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Modal, [{
    type: Component,
    args: [{
      selector: "cds-modal, ibm-modal",
      template: `
		<cds-overlay
			[theme]="theme"
			[open]="open"
			(overlaySelect)="overlaySelected.emit()">
			<div
				class="cds--modal-container"
				[ngClass]="{
					'cds--modal-container--xs': size === 'xs',
					'cds--modal-container--sm': size === 'sm',
					'cds--modal-container--md': size === 'md',
					'cds--modal-container--lg': size === 'lg'
				}"
				role="dialog"
				aria-modal="true"
				style="z-index:1;"
				[attr.aria-label]="ariaLabel"
				#modal>
				<ng-content></ng-content>
			</div>
		</cds-overlay>
	`
    }]
  }], function() {
    return [{
      type: BaseModalService
    }, {
      type: Document,
      decorators: [{
        type: Inject,
        args: [DOCUMENT]
      }]
    }, {
      type: Renderer2
    }];
  }, {
    size: [{
      type: Input
    }],
    theme: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    open: [{
      type: Input
    }],
    trigger: [{
      type: Input
    }],
    hasScrollingContent: [{
      type: Input
    }],
    overlaySelected: [{
      type: Output
    }],
    close: [{
      type: Output
    }],
    modal: [{
      type: ViewChild,
      args: ["modal", {
        static: true
      }]
    }],
    handleKeyboardEvent: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }]
  });
})();
var ModalHeader = class {
  constructor(i18n) {
    this.i18n = i18n;
    this.theme = "default";
    this.closeLabel = this.i18n.get().MODAL.CLOSE;
    this.showCloseButton = true;
    this.closeSelect = new EventEmitter();
    this.buttonNgClass = {
      "cds--modal-close": true
    };
    this.buttonAttributes = {
      "aria-label": this.i18n.get().MODAL.CLOSE
    };
  }
  /**
   * Handles click for the close icon button within the `Modal`.
   */
  onClose() {
    this.closeSelect.emit();
  }
};
ModalHeader.ɵfac = function ModalHeader_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ModalHeader)(ɵɵdirectiveInject(I18n));
};
ModalHeader.ɵcmp = ɵɵdefineComponent({
  type: ModalHeader,
  selectors: [["cds-modal-header"], ["ibm-modal-header"]],
  inputs: {
    theme: "theme",
    closeLabel: "closeLabel",
    showCloseButton: "showCloseButton"
  },
  outputs: {
    closeSelect: "closeSelect"
  },
  standalone: false,
  ngContentSelectors: _c120,
  decls: 4,
  vars: 4,
  consts: [[1, "cds--modal-close-button"], ["type", "button", "align", "left", 3, "buttonNgClass", "buttonAttributes", "description", "click", 4, "ngIf"], ["type", "button", "align", "left", 3, "click", "buttonNgClass", "buttonAttributes", "description"], ["cdsIcon", "close", "size", "20", 1, "cds--modal-close__icon"]],
  template: function ModalHeader_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "header");
      ɵɵprojection(1);
      ɵɵelementStart(2, "div", 0);
      ɵɵtemplate(3, ModalHeader_cds_icon_button_3_Template, 2, 3, "cds-icon-button", 1);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵclassMapInterpolate1("cds--modal-header ", ctx.theme, "");
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.showCloseButton);
    }
  },
  dependencies: [NgIf, IconButton, IconDirective],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ModalHeader, [{
    type: Component,
    args: [{
      selector: "cds-modal-header, ibm-modal-header",
      template: `
		<header class="cds--modal-header {{theme}}">
			<ng-content></ng-content>
			<div class="cds--modal-close-button">
				<cds-icon-button
					*ngIf="showCloseButton"
					type="button"
					[buttonNgClass]="buttonNgClass"
					[buttonAttributes]="buttonAttributes"
					align="left"
					[description]="closeLabel"
					(click)="onClose()">
					<svg cdsIcon="close" size="20" class="cds--modal-close__icon"></svg>
				</cds-icon-button>
			</div>
		</header>

	`
    }]
  }], function() {
    return [{
      type: I18n
    }];
  }, {
    theme: [{
      type: Input
    }],
    closeLabel: [{
      type: Input
    }],
    showCloseButton: [{
      type: Input
    }],
    closeSelect: [{
      type: Output
    }]
  });
})();
var ModalFooter = class {
};
ModalFooter.ɵfac = function ModalFooter_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ModalFooter)();
};
ModalFooter.ɵcmp = ɵɵdefineComponent({
  type: ModalFooter,
  selectors: [["cds-modal-footer"], ["ibm-modal-footer"]],
  standalone: false,
  ngContentSelectors: _c120,
  decls: 2,
  vars: 0,
  consts: [[1, "cds--modal-footer"]],
  template: function ModalFooter_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "footer", 0);
      ɵɵprojection(1);
      ɵɵelementEnd();
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ModalFooter, [{
    type: Component,
    args: [{
      selector: "cds-modal-footer, ibm-modal-footer",
      template: `
		<footer class="cds--modal-footer">
			<ng-content></ng-content>
		</footer>
	`
    }]
  }], null, null);
})();
var ModalContent = class {
  constructor() {
    this.modalContentClass = true;
    this.hasForm = false;
  }
};
ModalContent.ɵfac = function ModalContent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ModalContent)();
};
ModalContent.ɵdir = ɵɵdefineDirective({
  type: ModalContent,
  selectors: [["", "cdsModalContent", ""], ["", "ibmModalContent", ""]],
  hostVars: 4,
  hostBindings: function ModalContent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--modal-content", ctx.modalContentClass)("cds--modal-content--with-form", ctx.hasForm);
    }
  },
  inputs: {
    hasForm: "hasForm"
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ModalContent, [{
    type: Directive,
    args: [{
      selector: "[cdsModalContent], [ibmModalContent]"
    }]
  }], null, {
    modalContentClass: [{
      type: HostBinding,
      args: ["class.cds--modal-content"]
    }],
    hasForm: [{
      type: HostBinding,
      args: ["class.cds--modal-content--with-form"]
    }, {
      type: Input
    }]
  });
})();
var ModalHeaderHeading = class {
  constructor() {
    this.modalHeaderHeadingClass = true;
  }
};
ModalHeaderHeading.ɵfac = function ModalHeaderHeading_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ModalHeaderHeading)();
};
ModalHeaderHeading.ɵdir = ɵɵdefineDirective({
  type: ModalHeaderHeading,
  selectors: [["", "cdsModalHeaderHeading", ""], ["", "ibmModalHeaderHeading", ""]],
  hostVars: 2,
  hostBindings: function ModalHeaderHeading_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--modal-header__heading", ctx.modalHeaderHeadingClass);
    }
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ModalHeaderHeading, [{
    type: Directive,
    args: [{
      selector: "[cdsModalHeaderHeading], [ibmModalHeaderHeading]"
    }]
  }], null, {
    modalHeaderHeadingClass: [{
      type: HostBinding,
      args: ["class.cds--modal-header__heading"]
    }]
  });
})();
var ModalHeaderLabel = class {
  constructor() {
    this.modalHeaderLabelClass = true;
  }
};
ModalHeaderLabel.ɵfac = function ModalHeaderLabel_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ModalHeaderLabel)();
};
ModalHeaderLabel.ɵdir = ɵɵdefineDirective({
  type: ModalHeaderLabel,
  selectors: [["", "cdsModalHeaderLabel", ""], ["", "ibmModalHeaderLabel", ""]],
  hostVars: 2,
  hostBindings: function ModalHeaderLabel_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--modal-header__label", ctx.modalHeaderLabelClass);
    }
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ModalHeaderLabel, [{
    type: Directive,
    args: [{
      selector: "[cdsModalHeaderLabel], [ibmModalHeaderLabel]"
    }]
  }], null, {
    modalHeaderLabelClass: [{
      type: HostBinding,
      args: ["class.cds--modal-header__label"]
    }]
  });
})();
var AlertModal = class extends BaseModal {
  /**
   * Creates an instance of `AlertModal`.
   */
  constructor(type = "default", label, title, content, size2, hasScrollingContent = null, buttons = [], onClose, showCloseButton = true) {
    super();
    this.type = type;
    this.label = label;
    this.title = title;
    this.content = content;
    this.size = size2;
    this.hasScrollingContent = hasScrollingContent;
    this.buttons = buttons;
    this.onClose = onClose;
    this.showCloseButton = showCloseButton;
    for (let i = 0; i < this.buttons.length; i++) {
      const button = this.buttons[i];
      if (!button.id) {
        button.id = `alert-modal-button-${i}`;
      }
      if (!button.type) {
        button.type = "secondary";
      }
    }
  }
  ngAfterViewInit() {
    if (!this.modalContent) {
      return false;
    }
    const element = this.modalContent.nativeElement;
    if (element.scrollHeight > element.clientHeight) {
      element.tabIndex = 0;
    } else {
      element.tabIndex = -1;
    }
  }
  buttonClicked(buttonIndex) {
    const button = this.buttons[buttonIndex];
    if (button.click) {
      button.click();
    }
    this.closeModal();
  }
  dismissModal(trigger) {
    if (this.onClose && this.onClose(trigger) === false) {
      return;
    }
    this.closeModal();
  }
};
AlertModal.ɵfac = function AlertModal_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || AlertModal)(ɵɵdirectiveInject("type", 8), ɵɵdirectiveInject("label", 8), ɵɵdirectiveInject("title", 8), ɵɵdirectiveInject("content", 8), ɵɵdirectiveInject("size", 8), ɵɵdirectiveInject("hasScrollingContent", 8), ɵɵdirectiveInject("buttons", 8), ɵɵdirectiveInject("close", 8), ɵɵdirectiveInject("showCloseButton", 8));
};
AlertModal.ɵcmp = ɵɵdefineComponent({
  type: AlertModal,
  selectors: [["cds-alert-modal"], ["ibm-alert-modal"]],
  viewQuery: function AlertModal_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c56, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.modalContent = _t.first);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature],
  decls: 10,
  vars: 10,
  consts: [["modalContent", ""], [3, "overlaySelected", "size", "theme", "ariaLabel", "hasScrollingContent", "open"], [3, "closeSelect", "showCloseButton"], ["cdsModalHeaderLabel", "", 1, "cds--type-delta"], ["cdsModalHeaderHeading", "", 1, "cds--type-beta"], ["cdsModalContent", ""], [3, "innerHTML"], [4, "ngIf"], [4, "ngFor", "ngForOf"], [3, "click", "cdsButton", "id"]],
  template: function AlertModal_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵelementStart(0, "cds-modal", 1);
      ɵɵlistener("overlaySelected", function AlertModal_Template_cds_modal_overlaySelected_0_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.dismissModal("overlay"));
      });
      ɵɵelementStart(1, "cds-modal-header", 2);
      ɵɵlistener("closeSelect", function AlertModal_Template_cds_modal_header_closeSelect_1_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.dismissModal("close"));
      });
      ɵɵelementStart(2, "p", 3);
      ɵɵtext(3);
      ɵɵelementEnd();
      ɵɵelementStart(4, "p", 4);
      ɵɵtext(5);
      ɵɵelementEnd()();
      ɵɵelementStart(6, "div", 5, 0);
      ɵɵelement(8, "p", 6);
      ɵɵelementEnd();
      ɵɵtemplate(9, AlertModal_cds_modal_footer_9_Template, 2, 1, "cds-modal-footer", 7);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("size", ctx.size)("theme", ctx.type)("ariaLabel", ctx.title)("hasScrollingContent", ctx.hasScrollingContent)("open", ctx.open);
      ɵɵadvance();
      ɵɵproperty("showCloseButton", ctx.showCloseButton);
      ɵɵadvance(2);
      ɵɵtextInterpolate(ctx.label);
      ɵɵadvance(2);
      ɵɵtextInterpolate(ctx.title);
      ɵɵadvance(3);
      ɵɵproperty("innerHTML", ctx.content, ɵɵsanitizeHtml);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.buttons.length > 0);
    }
  },
  dependencies: [NgForOf, NgIf, Button, Modal, ModalHeader, ModalFooter, ModalContent, ModalHeaderHeading, ModalHeaderLabel],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AlertModal, [{
    type: Component,
    args: [{
      selector: "cds-alert-modal, ibm-alert-modal",
      template: `
		<cds-modal
			[size]="size"
			[theme]="type"
			[ariaLabel]="title"
			[hasScrollingContent]="hasScrollingContent"
			[open]="open"
			(overlaySelected)="dismissModal('overlay')">
			<cds-modal-header (closeSelect)="dismissModal('close')" [showCloseButton]="showCloseButton">
				<p cdsModalHeaderLabel class="cds--type-delta">{{label}}</p>
				<p cdsModalHeaderHeading class="cds--type-beta">{{title}}</p>
			</cds-modal-header>
			<div cdsModalContent #modalContent>
				<p [innerHTML]="content"></p>
			</div>
			<cds-modal-footer *ngIf="buttons.length > 0">
				<ng-container *ngFor="let button of buttons; let i = index">
					<button
						[cdsButton]="button.type"
						(click)="buttonClicked(i)"
						[id]="button.id"
						[attr.modal-primary-focus]="(button.type.indexOf('primary') !== -1 ? '' : null)">
						{{button.text}}
					</button>
				</ng-container>
			</cds-modal-footer>
		</cds-modal>
	`
    }]
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: ["type"]
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: ["label"]
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: ["title"]
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: ["content"]
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: ["size"]
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: ["hasScrollingContent"]
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: ["buttons"]
      }]
    }, {
      type: Function,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: ["close"]
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: ["showCloseButton"]
      }]
    }];
  }, {
    modalContent: [{
      type: ViewChild,
      args: ["modalContent", {
        static: true
      }]
    }]
  });
})();
var AlertModalType;
(function(AlertModalType2) {
  AlertModalType2["default"] = "default";
  AlertModalType2["danger"] = "danger";
})(AlertModalType || (AlertModalType = {}));
var ModalButtonType;
(function(ModalButtonType2) {
  ModalButtonType2["primary"] = "primary";
  ModalButtonType2["secondary"] = "secondary";
  ModalButtonType2["tertiary"] = "tertiary";
  ModalButtonType2["ghost"] = "ghost";
  ModalButtonType2["danger"] = "danger";
  ModalButtonType2["danger_primary"] = "danger--primary";
})(ModalButtonType || (ModalButtonType = {}));
var ModalService = class extends BaseModalService {
  /**
   * Creates an instance of `ModalService`.
   */
  constructor(placeholderService) {
    super(placeholderService);
    this.placeholderService = placeholderService;
  }
  /**
   * Creates and renders a new alert modal component.
   * @param data You can pass in:
   * `type` - "default" | "danger" = "default",
   * `label` - a label shown over the title,
   * `title` - modal's title,
   * `content` - modal's content, could include HTML tags.
   * `buttons` is an array of objects
   * `close` custom close function
   * ```
   * {
   * 		text: "Button text",
   * 		type: "primary" | "secondary" | "tertiary" | "ghost" | "danger" | "danger--primary" = "primary",
   * 		click: clickFunction,
   * }
   * ```
   */
  show(data) {
    return this.create({
      component: AlertModal,
      inputs: {
        type: data.type,
        label: data.label,
        title: data.title,
        content: data.content,
        hasScrollingContent: data.hasScrollingContent !== void 0 ? data.hasScrollingContent : null,
        size: data.size,
        buttons: data.buttons || [],
        close: data.close || (() => {
        }),
        showCloseButton: data.showCloseButton
      }
    });
  }
};
ModalService.ɵfac = function ModalService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ModalService)(ɵɵinject(PlaceholderService));
};
ModalService.ɵprov = ɵɵdefineInjectable({
  token: ModalService,
  factory: ModalService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ModalService, [{
    type: Injectable
  }], function() {
    return [{
      type: PlaceholderService
    }];
  }, null);
})();
var ModalContentText = class {
  constructor() {
    this.modalContentTextClass = true;
  }
};
ModalContentText.ɵfac = function ModalContentText_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ModalContentText)();
};
ModalContentText.ɵdir = ɵɵdefineDirective({
  type: ModalContentText,
  selectors: [["", "cdsModalContentText", ""], ["", "ibmModalContentText", ""]],
  hostVars: 2,
  hostBindings: function ModalContentText_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--modal-content__text", ctx.modalContentTextClass);
    }
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ModalContentText, [{
    type: Directive,
    args: [{
      selector: "[cdsModalContentText], [ibmModalContentText]"
    }]
  }], null, {
    modalContentTextClass: [{
      type: HostBinding,
      args: ["class.cds--modal-content__text"]
    }]
  });
})();
var ModalModule = class {
};
ModalModule.ɵfac = function ModalModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ModalModule)();
};
ModalModule.ɵmod = ɵɵdefineNgModule({
  type: ModalModule,
  declarations: [AlertModal, Modal, ModalHeader, ModalFooter, Overlay, ModalContent, ModalContentText, ModalHeaderHeading, ModalHeaderLabel, BaseModal],
  imports: [CommonModule, ButtonModule, I18nModule, PlaceholderModule, ExperimentalModule, IconModule],
  exports: [AlertModal, Modal, ModalHeader, ModalFooter, ModalContent, ModalContentText, ModalHeaderHeading, ModalHeaderLabel, BaseModal]
});
ModalModule.ɵinj = ɵɵdefineInjector({
  providers: [BaseModalService, ModalService],
  imports: [CommonModule, ButtonModule, I18nModule, PlaceholderModule, ExperimentalModule, IconModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ModalModule, [{
    type: NgModule,
    args: [{
      declarations: [AlertModal, Modal, ModalHeader, ModalFooter, Overlay, ModalContent, ModalContentText, ModalHeaderHeading, ModalHeaderLabel, BaseModal],
      exports: [AlertModal, Modal, ModalHeader, ModalFooter, ModalContent, ModalContentText, ModalHeaderHeading, ModalHeaderLabel, BaseModal],
      providers: [BaseModalService, ModalService],
      imports: [CommonModule, ButtonModule, I18nModule, PlaceholderModule, ExperimentalModule, IconModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-menu-button.mjs
var _c024 = ["reference"];
var _c121 = ["menuTemplate"];
var _c217 = [[["cds-menu-item"], ["cds-menu-divider"]]];
var _c311 = ["cds-menu-item, cds-menu-divider"];
var _c49 = (a0) => ({
  "cds--menu-button__trigger--open": a0
});
var _c57 = (a0, a1, a2, a3, a4, a5) => ({
  "cds--menu-button__bottom": a0,
  "cds--menu-button__bottom-start": a1,
  "cds--menu-button__bottom-end": a2,
  "cds--menu-top": a3,
  "cds--menu-top-start": a4,
  "cds--menu-top-end": a5
});
function MenuButtonComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "cds-menu", 4);
    ɵɵprojection(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("size", ctx_r1.size)("open", ctx_r1.open)("ngClass", ɵɵpureFunction6(4, _c57, ctx_r1.menuAlignment === "bottom", ctx_r1.menuAlignment === "bottom-start", ctx_r1.menuAlignment === "bottom-end", ctx_r1.menuAlignment === "top", ctx_r1.menuAlignment === "top-start", ctx_r1.menuAlignment === "top-end"));
    ɵɵattribute("id", ctx_r1.menuId);
  }
}
var MenuButtonComponent = class _MenuButtonComponent {
  constructor(ngZone, renderer, hostElement, viewContainerRef, changeDetectorRef) {
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.hostElement = hostElement;
    this.viewContainerRef = viewContainerRef;
    this.changeDetectorRef = changeDetectorRef;
    this.menuId = `menu-button-${_MenuButtonComponent.menuButtonCounter++}`;
    this.containerClass = true;
    this.kind = "primary";
    this.size = "lg";
    this.menuAlignment = "bottom";
    this.buttonTabIndex = "0";
    this.disabled = false;
    this.open = false;
    this.documentClick = this.handleFocusOut.bind(this);
    this.subscriptions = [];
    this._alignment = "bottom";
  }
  // Listen for click & determine if menu should close
  set projectedMenuItems(itemList) {
    this.subscriptions.forEach((sub) => sub?.unsubscribe());
    this.subscriptions = [];
    itemList.forEach((item) => {
      this.subscriptions.push(item.itemClick.subscribe((clickEvent) => this.handleMenuItemClick(clickEvent)));
    });
  }
  /**
   * In case user updates alignment, store initial value.
   * This allows us to test user passed alignment on each open
   */
  ngOnChanges(changes) {
    if (changes.menuAlignment) {
      this._alignment = changes.menuAlignment.currentValue;
    }
  }
  /**
   * If user has passed in true for open, we dynamically open the menu
   */
  ngAfterViewInit() {
    if (this.open) {
      this.open = !this.open;
      this.toggleMenu();
    }
  }
  /**
  * Clean up Floating-ui & subscriptions
  */
  ngOnDestroy() {
    this.cleanUp();
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
  /**
   * As of now, menu button does not support nexted menu, on button click it should close
   */
  handleMenuItemClick(event) {
    if (!event.type) {
      this.toggleMenu();
    }
  }
  /**
   * On body click, close the menu
   * @param event
   */
  handleFocusOut(event) {
    if (!this.hostElement.nativeElement.contains(event.target)) {
      this.toggleMenu();
    }
  }
  /**
   * Clean up `autoUpdate` if auto alignment is enabled
   */
  cleanUp() {
    document.removeEventListener("click", this.documentClick);
    if (this.unmountFloatingElement) {
      this.menuRef.remove();
      this.viewContainerRef.clear();
      this.unmountFloatingElement();
    }
    this.unmountFloatingElement = void 0;
    this.changeDetectorRef.markForCheck();
  }
  /**
   * Handles emitting open/close event
   */
  toggleMenu() {
    this.open = !this.open;
    if (this.open) {
      const view = this.viewContainerRef.createEmbeddedView(this.menuTemplate);
      this.menuRef = document.body.appendChild(view.rootNodes[0]);
      Object.assign(this.menuRef.style, {
        width: `${this.referenceElement.nativeElement.clientWidth}px`,
        top: "0",
        left: "0"
      });
      this.menuAlignment = this._alignment;
      document.addEventListener("click", this.documentClick);
      this.unmountFloatingElement = autoUpdate(this.referenceElement.nativeElement, this.menuRef, this.recomputePosition.bind(this));
    } else {
      this.cleanUp();
    }
  }
  roundByDPR(value) {
    const dpr = window.devicePixelRatio || 1;
    return Math.round(value * dpr) / dpr;
  }
  /**
   * Compute position of menu
   */
  recomputePosition() {
    if (this.menuTemplate && this.referenceElement) {
      this.ngZone.runOutsideAngular(() => __async(this, null, function* () {
        const {
          x,
          y,
          placement
        } = yield computePosition2(this.referenceElement.nativeElement, this.menuRef, {
          placement: this.menuAlignment,
          strategy: "fixed",
          middleware: [flip2({
            crossAxis: false
          })]
        });
        this.menuAlignment = placement;
        Object.assign(this.menuRef.style, {
          position: "fixed",
          // Using transform instead of top/left position to improve performance
          transform: `translate(${this.roundByDPR(x)}px,${this.roundByDPR(y)}px)`
        });
        this.changeDetectorRef.markForCheck();
      }));
    }
  }
};
MenuButtonComponent.menuButtonCounter = 0;
MenuButtonComponent.ɵfac = function MenuButtonComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || MenuButtonComponent)(ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(ChangeDetectorRef));
};
MenuButtonComponent.ɵcmp = ɵɵdefineComponent({
  type: MenuButtonComponent,
  selectors: [["cds-menu-button"]],
  contentQueries: function MenuButtonComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ContextMenuItemComponent, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.projectedMenuItems = _t);
    }
  },
  viewQuery: function MenuButtonComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c024, 7);
      ɵɵviewQuery(_c121, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.referenceElement = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.menuTemplate = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function MenuButtonComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--menu-button__container", ctx.containerClass);
    }
  },
  inputs: {
    menuId: "menuId",
    kind: "kind",
    size: "size",
    menuAlignment: "menuAlignment",
    buttonTabIndex: "buttonTabIndex",
    disabled: "disabled",
    open: "open",
    label: "label"
  },
  standalone: false,
  features: [ɵɵNgOnChangesFeature],
  ngContentSelectors: _c311,
  decls: 6,
  vars: 11,
  consts: [["reference", ""], ["menuTemplate", ""], ["type", "button", 1, "cds--menu-button__trigger", 3, "click", "ngClass", "cdsButton", "size", "disabled"], ["cdsIcon", "chevron--down", "size", "16", 1, "cds--btn__icon"], ["mode", "basic", 3, "size", "open", "ngClass"]],
  template: function MenuButtonComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵprojectionDef(_c217);
      ɵɵelementStart(0, "button", 2, 0);
      ɵɵlistener("click", function MenuButtonComponent_Template_button_click_0_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.toggleMenu());
      });
      ɵɵtext(2);
      ɵɵnamespaceSVG();
      ɵɵelement(3, "svg", 3);
      ɵɵelementEnd();
      ɵɵtemplate(4, MenuButtonComponent_ng_template_4_Template, 2, 11, "ng-template", null, 1, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      ɵɵproperty("ngClass", ɵɵpureFunction1(9, _c49, ctx.open))("cdsButton", ctx.kind)("size", ctx.size)("disabled", ctx.disabled);
      ɵɵattribute("tabindex", ctx.buttonTabIndex)("aria-haspopup", true)("aria-expanded", ctx.open)("aria-controls", ctx.open ? ctx.menuId : void 0);
      ɵɵadvance(2);
      ɵɵtextInterpolate1(" ", ctx.label, " ");
    }
  },
  dependencies: [NgClass, Button, IconDirective, ContextMenuComponent],
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MenuButtonComponent, [{
    type: Component,
    args: [{
      selector: "cds-menu-button",
      template: `
		<button
			#reference
			class="cds--menu-button__trigger"
			[ngClass]="{'cds--menu-button__trigger--open': open}"
			[cdsButton]="kind"
			[size]="size"
			[attr.tabindex]="buttonTabIndex"
			[disabled]="disabled"
			type="button"
			[attr.aria-haspopup]="true"
			[attr.aria-expanded]="open"
			[attr.aria-controls]="open ? menuId : undefined"
			(click)="toggleMenu()">
			{{label}}
			<svg
				cdsIcon="chevron--down"
				size="16"
				class="cds--btn__icon">
			</svg>
		</button>
		<ng-template #menuTemplate>
			<cds-menu
				mode="basic"
				[size]="size"
				[open]="open"
				[attr.id]="menuId"
				[ngClass]="{
					'cds--menu-button__bottom': this.menuAlignment === 'bottom',
					'cds--menu-button__bottom-start': this.menuAlignment === 'bottom-start',
					'cds--menu-button__bottom-end': this.menuAlignment === 'bottom-end',
					'cds--menu-top': this.menuAlignment === 'top',
					'cds--menu-top-start': this.menuAlignment === 'top-start',
					'cds--menu-top-end': this.menuAlignment === 'top-end'
				}">
				<ng-content select="cds-menu-item, cds-menu-divider"></ng-content>
			</cds-menu>
		</ng-template>
	`,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], function() {
    return [{
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: ViewContainerRef
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    menuId: [{
      type: Input
    }],
    projectedMenuItems: [{
      type: ContentChildren,
      args: [ContextMenuItemComponent]
    }],
    containerClass: [{
      type: HostBinding,
      args: ["class.cds--menu-button__container"]
    }],
    kind: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    menuAlignment: [{
      type: Input
    }],
    buttonTabIndex: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    open: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    referenceElement: [{
      type: ViewChild,
      args: ["reference", {
        static: true
      }]
    }],
    menuTemplate: [{
      type: ViewChild,
      args: ["menuTemplate"]
    }]
  });
})();
var MenuButtonModule = class {
};
MenuButtonModule.ɵfac = function MenuButtonModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || MenuButtonModule)();
};
MenuButtonModule.ɵmod = ɵɵdefineNgModule({
  type: MenuButtonModule,
  declarations: [MenuButtonComponent],
  imports: [CommonModule, ButtonModule, IconModule, ContextMenuModule],
  exports: [MenuButtonComponent]
});
MenuButtonModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ButtonModule, IconModule, ContextMenuModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MenuButtonModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ButtonModule, IconModule, ContextMenuModule],
      exports: [MenuButtonComponent],
      declarations: [MenuButtonComponent],
      providers: []
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-notification.mjs
var _c025 = (a0) => ({
  $implicit: a0
});
var _c124 = (a0, a1) => ({
  "cds--inline-notification__icon": a0,
  "cds--toast-notification__icon": a1
});
function ActionableNotification__svg_svg_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 9);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("cdsIcon", ctx_r0.iconDictionary[ctx_r0.notificationObj.type])("ngClass", ɵɵpureFunction2(2, _c124, ctx_r0.notificationObj.variant === "inline", ctx_r0.notificationObj.variant === "toast"));
  }
}
function ActionableNotification_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 10);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("innerHTML", ctx_r0.notificationObj.title, ɵɵsanitizeHtml);
  }
}
function ActionableNotification_div_5_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "a", 14);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const link_r2 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("href", link_r2.href, ɵɵsanitizeUrl);
    ɵɵadvance();
    ɵɵtextInterpolate(link_r2.text);
  }
}
function ActionableNotification_div_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 11);
    ɵɵelement(1, "span", 12);
    ɵɵtemplate(2, ActionableNotification_div_5_ng_container_2_Template, 3, 2, "ng-container", 13);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("innerHTML", ctx_r0.notificationObj.message, ɵɵsanitizeHtml);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.notificationObj.links);
  }
}
function ActionableNotification_ng_container_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function ActionableNotification_ng_container_7_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 16);
    ɵɵlistener("click", function ActionableNotification_ng_container_7_button_1_Template_button_click_0_listener($event) {
      const action_r4 = ɵɵrestoreView(_r3).$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.onClick(action_r4, $event));
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const action_r4 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("cdsButton", ctx_r0.notificationObj.variant === "inline" ? "ghost" : "tertiary");
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", action_r4.text, " ");
  }
}
function ActionableNotification_ng_container_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, ActionableNotification_ng_container_7_button_1_Template, 2, 2, "button", 15);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.notificationObj.actions);
  }
}
function ActionableNotification_ng_container_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function ActionableNotification_button_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 17);
    ɵɵpipe(1, "async");
    ɵɵlistener("click", function ActionableNotification_button_9_Template_button_click_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onClose());
    });
    ɵɵnamespaceSVG();
    ɵɵelement(2, "svg", 18);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵattribute("aria-label", ɵɵpipeBind1(1, 1, ctx_r0.notificationObj.closeLabel));
  }
}
function Notification__svg_svg_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("cdsIcon", ctx_r0.iconDictionary[ctx_r0.notificationObj.type]);
  }
}
function Notification_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 8);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("innerHTML", ctx_r0.notificationObj.title, ɵɵsanitizeHtml);
  }
}
function Notification_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 9);
    ɵɵelement(1, "span", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("innerHTML", ctx_r0.notificationObj.message, ɵɵsanitizeHtml);
  }
}
function Notification_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function Notification_button_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 11);
    ɵɵpipe(1, "async");
    ɵɵlistener("click", function Notification_button_6_Template_button_click_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onClose());
    });
    ɵɵnamespaceSVG();
    ɵɵelement(2, "svg", 12);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵattribute("aria-label", ɵɵpipeBind1(1, 1, ctx_r0.notificationObj.closeLabel));
  }
}
function Toast__svg_svg_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("cdsIcon", ctx_r0.iconDictionary[ctx_r0.notificationObj.type]);
  }
}
function Toast_h3_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "h3", 8);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("innerHTML", ctx_r0.notificationObj.title, ɵɵsanitizeHtml);
  }
}
function Toast_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 9);
    ɵɵelement(1, "span", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("innerHTML", ctx_r0.notificationObj.subtitle, ɵɵsanitizeHtml);
  }
}
function Toast_p_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "p", 11);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("innerHTML", ctx_r0.notificationObj.caption, ɵɵsanitizeHtml);
  }
}
function Toast_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function Toast_button_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 12);
    ɵɵpipe(1, "async");
    ɵɵlistener("click", function Toast_button_6_Template_button_click_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onClose());
    });
    ɵɵnamespaceSVG();
    ɵɵelement(2, "svg", 13);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵattribute("aria-label", ɵɵpipeBind1(1, 1, ctx_r0.notificationObj.closeLabel));
  }
}
var ActionableButton = class {
  constructor() {
    this.actionableButton = true;
    this.type = "button";
  }
};
ActionableButton.ɵfac = function ActionableButton_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ActionableButton)();
};
ActionableButton.ɵdir = ɵɵdefineDirective({
  type: ActionableButton,
  selectors: [["", "cdsActionableButton", ""], ["", "ibmActionableButton", ""]],
  hostVars: 3,
  hostBindings: function ActionableButton_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("type", ctx.type);
      ɵɵclassProp("cds--actionable-notification__action-button", ctx.actionableButton);
    }
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ActionableButton, [{
    type: Directive,
    args: [{
      selector: "[cdsActionableButton], [ibmActionableButton]"
    }]
  }], null, {
    actionableButton: [{
      type: HostBinding,
      args: ["class.cds--actionable-notification__action-button"]
    }],
    type: [{
      type: HostBinding,
      args: ["attr.type"]
    }]
  });
})();
var ActionableSubtitle = class {
  constructor() {
    this.baseClass = true;
  }
};
ActionableSubtitle.ɵfac = function ActionableSubtitle_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ActionableSubtitle)();
};
ActionableSubtitle.ɵdir = ɵɵdefineDirective({
  type: ActionableSubtitle,
  selectors: [["", "cdsActionableSubtitle", ""], ["", "ibmActionableSubtitle", ""]],
  hostVars: 2,
  hostBindings: function ActionableSubtitle_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--actionable-notification__subtitle", ctx.baseClass);
    }
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ActionableSubtitle, [{
    type: Directive,
    args: [{
      selector: "[cdsActionableSubtitle], [ibmActionableSubtitle]"
    }]
  }], null, {
    baseClass: [{
      type: HostBinding,
      args: ["class.cds--actionable-notification__subtitle"]
    }]
  });
})();
var ActionableTitle = class {
  constructor() {
    this.baseClass = true;
  }
};
ActionableTitle.ɵfac = function ActionableTitle_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ActionableTitle)();
};
ActionableTitle.ɵdir = ɵɵdefineDirective({
  type: ActionableTitle,
  selectors: [["", "cdsActionableTitle", ""], ["", "ibmActionableTitle", ""]],
  hostVars: 2,
  hostBindings: function ActionableTitle_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--actionable-notification__title", ctx.baseClass);
    }
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ActionableTitle, [{
    type: Directive,
    args: [{
      selector: "[cdsActionableTitle], [ibmActionableTitle]"
    }]
  }], null, {
    baseClass: [{
      type: HostBinding,
      args: ["class.cds--actionable-notification__title"]
    }]
  });
})();
var NotificationDisplayService = class {
  constructor(applicationRef) {
    this.applicationRef = applicationRef;
  }
  /**
   * Programatically closes notification based on `notificationRef`.	 *
   */
  close(notificationRef) {
    if (notificationRef.hostView) {
      setTimeout(() => {
        this.applicationRef.detachView(notificationRef.hostView);
        notificationRef.destroy();
      }, 200);
    }
  }
};
NotificationDisplayService.ɵfac = function NotificationDisplayService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || NotificationDisplayService)(ɵɵinject(ApplicationRef));
};
NotificationDisplayService.ɵprov = ɵɵdefineInjectable({
  token: NotificationDisplayService,
  factory: NotificationDisplayService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NotificationDisplayService, [{
    type: Injectable
  }], function() {
    return [{
      type: ApplicationRef
    }];
  }, null);
})();
var BaseNotification = class {
  constructor(notificationDisplayService, i18n) {
    this.notificationDisplayService = notificationDisplayService;
    this.i18n = i18n;
    this.close = new EventEmitter();
    this.iconDictionary = {
      "error": "error--filled",
      "info": "information--filled",
      "info-square": "information--square--filled",
      "success": "checkmark--filled",
      "warning": "warning--filled",
      "warning-alt": "warning--alt--filled"
    };
    this.defaultNotificationObj = {
      title: "",
      message: "",
      type: "info",
      showClose: true,
      closeLabel: this.i18n.get("NOTIFICATION.CLOSE_BUTTON"),
      role: "status"
    };
    this._notificationObj = Object.assign({}, this.defaultNotificationObj);
  }
  /**
   * Set role attribute for component
   * `Status` is default for inline-notification & toast component
   * `alertdialog` is default for actionable-notification
   */
  get roleAttr() {
    return this._notificationObj.role;
  }
  /**
   * Emits close event.
   */
  onClose() {
    this.close.emit();
  }
  onClick(action, event) {
    if (!action.click) {
      return;
    }
    if (isObservable(action.click)) {
      action.click.next({
        event,
        action
      });
    } else {
      action.click({
        event,
        action
      });
    }
  }
  destroy() {
    this.notificationDisplayService.close(this);
  }
};
BaseNotification.ɵfac = function BaseNotification_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || BaseNotification)(ɵɵdirectiveInject(NotificationDisplayService), ɵɵdirectiveInject(I18n));
};
BaseNotification.ɵcmp = ɵɵdefineComponent({
  type: BaseNotification,
  selectors: [["ng-component"]],
  hostVars: 1,
  hostBindings: function BaseNotification_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", ctx.roleAttr);
    }
  },
  outputs: {
    close: "close"
  },
  standalone: false,
  decls: 0,
  vars: 0,
  template: function BaseNotification_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseNotification, [{
    type: Component,
    args: [{
      template: ""
    }]
  }], function() {
    return [{
      type: NotificationDisplayService
    }, {
      type: I18n
    }];
  }, {
    roleAttr: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    close: [{
      type: Output
    }]
  });
})();
var ActionableNotification = class _ActionableNotification extends BaseNotification {
  constructor(notificationDisplayService, i18n) {
    super(notificationDisplayService, i18n);
    this.notificationDisplayService = notificationDisplayService;
    this.i18n = i18n;
    this.notificationID = `notification-${_ActionableNotification.notificationCount++}`;
    this.notificationClass = true;
    this.defaultNotificationObj = __spreadProps(__spreadValues({}, this.defaultNotificationObj), {
      variant: "inline",
      role: "alertdialog"
    });
  }
  /**
   * Can have `type`, `title`, and `message` members.
   *
   * `type` can be one of `"error"`, `"info"`, `"info-square"`, `"warning"`, `"warning-alt"`, or `"success"`
   *
   * `message` is the message to display
   */
  get notificationObj() {
    return this._notificationObj;
  }
  set notificationObj(obj) {
    if (obj.closeLabel && !isObservable(obj.closeLabel)) {
      obj.closeLabel = of(obj.closeLabel);
    }
    this._notificationObj = Object.assign({}, this.defaultNotificationObj, obj);
  }
  get toastVariant() {
    return this.notificationObj.variant === "toast";
  }
  get isError() {
    return this.notificationObj.type === "error";
  }
  get isInfo() {
    return this.notificationObj.type === "info";
  }
  get isInfoSquare() {
    return this.notificationObj.type === "info-square";
  }
  get isSuccess() {
    return this.notificationObj.type === "success";
  }
  get isWarning() {
    return this.notificationObj.type === "warning";
  }
  get isWarningAlt() {
    return this.notificationObj.type === "warning-alt";
  }
  get isLowContrast() {
    return this.notificationObj.lowContrast;
  }
  get isCloseHidden() {
    return !this._notificationObj.showClose;
  }
};
ActionableNotification.notificationCount = 0;
ActionableNotification.ɵfac = function ActionableNotification_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ActionableNotification)(ɵɵdirectiveInject(NotificationDisplayService), ɵɵdirectiveInject(I18n));
};
ActionableNotification.ɵcmp = ɵɵdefineComponent({
  type: ActionableNotification,
  selectors: [["cds-actionable-notification"], ["ibm-actionable-notification"]],
  hostVars: 21,
  hostBindings: function ActionableNotification_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("id", ctx.notificationID);
      ɵɵclassProp("cds--actionable-notification", ctx.notificationClass)("cds--actionable-notification--toast", ctx.toastVariant)("cds--actionable-notification--error", ctx.isError)("cds--actionable-notification--info", ctx.isInfo)("cds--actionable-notification--info-square", ctx.isInfoSquare)("cds--actionable-notification--success", ctx.isSuccess)("cds--actionable-notification--warning", ctx.isWarning)("cds--actionable-notification--warning-alt", ctx.isWarningAlt)("cds--actionable-notification--low-contrast", ctx.isLowContrast)("cds--actionable-notification--hide-close-button", ctx.isCloseHidden);
    }
  },
  inputs: {
    notificationObj: "notificationObj"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature],
  decls: 10,
  vars: 13,
  consts: [[1, "cds--actionable-notification__details"], ["size", "20", "class", "cds--actionable-notification__icon", 3, "cdsIcon", "ngClass", 4, "ngIf"], [1, "cds--actionable-notification__text-wrapper"], [1, "cds--actionable-notification__content"], ["cdsActionableTitle", "", 3, "innerHTML", 4, "ngIf"], ["cdsActionableSubtitle", "", 4, "ngIf"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [4, "ngIf"], ["class", "cds--actionable-notification__close-button", "type", "button", 3, "click", 4, "ngIf"], ["size", "20", 1, "cds--actionable-notification__icon", 3, "cdsIcon", "ngClass"], ["cdsActionableTitle", "", 3, "innerHTML"], ["cdsActionableSubtitle", ""], [3, "innerHTML"], [4, "ngFor", "ngForOf"], ["cdsLink", "", 3, "href"], ["size", "sm", "cdsActionableButton", "", 3, "cdsButton", "click", 4, "ngFor", "ngForOf"], ["size", "sm", "cdsActionableButton", "", 3, "click", "cdsButton"], ["type", "button", 1, "cds--actionable-notification__close-button", 3, "click"], ["cdsIcon", "close", "size", "16", 1, "cds--actionable-notification__close-icon"]],
  template: function ActionableNotification_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵtemplate(1, ActionableNotification__svg_svg_1_Template, 1, 5, "svg", 1);
      ɵɵelementStart(2, "div", 2)(3, "div", 3);
      ɵɵtemplate(4, ActionableNotification_div_4_Template, 1, 1, "div", 4)(5, ActionableNotification_div_5_Template, 3, 2, "div", 5)(6, ActionableNotification_ng_container_6_Template, 1, 0, "ng-container", 6);
      ɵɵelementEnd()()();
      ɵɵtemplate(7, ActionableNotification_ng_container_7_Template, 2, 1, "ng-container", 7)(8, ActionableNotification_ng_container_8_Template, 1, 0, "ng-container", 6)(9, ActionableNotification_button_9_Template, 3, 3, "button", 8);
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.notificationObj.type);
      ɵɵadvance(3);
      ɵɵproperty("ngIf", !ctx.notificationObj.template);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.notificationObj.template);
      ɵɵadvance();
      ɵɵproperty("ngTemplateOutlet", ctx.notificationObj.template)("ngTemplateOutletContext", ɵɵpureFunction1(9, _c025, ctx.notificationObj));
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.notificationObj.actionsTemplate);
      ɵɵadvance();
      ɵɵproperty("ngTemplateOutlet", ctx.notificationObj.actionsTemplate)("ngTemplateOutletContext", ɵɵpureFunction1(11, _c025, ctx.notificationObj));
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.isCloseHidden);
    }
  },
  dependencies: [Button, NgClass, NgForOf, NgIf, NgTemplateOutlet, Link, IconDirective, ActionableButton, ActionableTitle, ActionableSubtitle, AsyncPipe],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ActionableNotification, [{
    type: Component,
    args: [{
      selector: "cds-actionable-notification, ibm-actionable-notification",
      template: `
		<div class="cds--actionable-notification__details">
			<svg
				[cdsIcon]="iconDictionary[notificationObj.type]"
				size="20"
				*ngIf="notificationObj.type"
				[ngClass]="{
					'cds--inline-notification__icon': notificationObj.variant === 'inline',
					'cds--toast-notification__icon': notificationObj.variant === 'toast'
				}"
				class="cds--actionable-notification__icon">
			</svg>
			<div class="cds--actionable-notification__text-wrapper">
				<div class="cds--actionable-notification__content">
					<div *ngIf="!notificationObj.template" cdsActionableTitle [innerHTML]="notificationObj.title"></div>
					<div *ngIf="!notificationObj.template" cdsActionableSubtitle>
						<span [innerHTML]="notificationObj.message"></span>
						<ng-container *ngFor="let link of notificationObj.links">
							<a cdsLink [href]="link.href">{{link.text}}</a>
						</ng-container>
					</div>
					<ng-container *ngTemplateOutlet="notificationObj.template; context: { $implicit: notificationObj }"></ng-container>
				</div>
			</div>
		</div>
		<ng-container *ngIf="!notificationObj.actionsTemplate">
			<button
				*ngFor="let action of notificationObj.actions"
				(click)="onClick(action, $event)"
				[cdsButton]="notificationObj.variant === 'inline' ? 'ghost' : 'tertiary'"
				size="sm"
				cdsActionableButton>
				{{action.text}}
			</button>
		</ng-container>
		<ng-container *ngTemplateOutlet="notificationObj.actionsTemplate; context: { $implicit: notificationObj }"></ng-container>
		<button
			*ngIf="!isCloseHidden"
			(click)="onClose()"
			class="cds--actionable-notification__close-button"
			[attr.aria-label]="notificationObj.closeLabel | async"
			type="button">
			<svg cdsIcon="close" size="16" class="cds--actionable-notification__close-icon"></svg>
		</button>
	`
    }]
  }], function() {
    return [{
      type: NotificationDisplayService
    }, {
      type: I18n
    }];
  }, {
    notificationObj: [{
      type: Input
    }],
    notificationID: [{
      type: HostBinding,
      args: ["attr.id"]
    }],
    notificationClass: [{
      type: HostBinding,
      args: ["class.cds--actionable-notification"]
    }],
    toastVariant: [{
      type: HostBinding,
      args: ["class.cds--actionable-notification--toast"]
    }],
    isError: [{
      type: HostBinding,
      args: ["class.cds--actionable-notification--error"]
    }],
    isInfo: [{
      type: HostBinding,
      args: ["class.cds--actionable-notification--info"]
    }],
    isInfoSquare: [{
      type: HostBinding,
      args: ["class.cds--actionable-notification--info-square"]
    }],
    isSuccess: [{
      type: HostBinding,
      args: ["class.cds--actionable-notification--success"]
    }],
    isWarning: [{
      type: HostBinding,
      args: ["class.cds--actionable-notification--warning"]
    }],
    isWarningAlt: [{
      type: HostBinding,
      args: ["class.cds--actionable-notification--warning-alt"]
    }],
    isLowContrast: [{
      type: HostBinding,
      args: ["class.cds--actionable-notification--low-contrast"]
    }],
    isCloseHidden: [{
      type: HostBinding,
      args: ["class.cds--actionable-notification--hide-close-button"]
    }]
  });
})();
var NotificationSubtitle = class {
  constructor() {
    this.baseClass = true;
  }
};
NotificationSubtitle.ɵfac = function NotificationSubtitle_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || NotificationSubtitle)();
};
NotificationSubtitle.ɵdir = ɵɵdefineDirective({
  type: NotificationSubtitle,
  selectors: [["", "cdsNotificationSubtitle", ""], ["", "ibmNotificationSubtitle", ""]],
  hostVars: 2,
  hostBindings: function NotificationSubtitle_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--inline-notification__subtitle", ctx.baseClass);
    }
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NotificationSubtitle, [{
    type: Directive,
    args: [{
      selector: "[cdsNotificationSubtitle], [ibmNotificationSubtitle]"
    }]
  }], null, {
    baseClass: [{
      type: HostBinding,
      args: ["class.cds--inline-notification__subtitle"]
    }]
  });
})();
var NotificationTitle = class {
  constructor() {
    this.baseClass = true;
  }
};
NotificationTitle.ɵfac = function NotificationTitle_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || NotificationTitle)();
};
NotificationTitle.ɵdir = ɵɵdefineDirective({
  type: NotificationTitle,
  selectors: [["", "cdsNotificationTitle", ""], ["", "ibmNotificationTitle", ""]],
  hostVars: 2,
  hostBindings: function NotificationTitle_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--inline-notification__title", ctx.baseClass);
    }
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NotificationTitle, [{
    type: Directive,
    args: [{
      selector: "[cdsNotificationTitle], [ibmNotificationTitle]"
    }]
  }], null, {
    baseClass: [{
      type: HostBinding,
      args: ["class.cds--inline-notification__title"]
    }]
  });
})();
var Notification = class _Notification extends BaseNotification {
  constructor(notificationDisplayService, i18n) {
    super(notificationDisplayService, i18n);
    this.notificationDisplayService = notificationDisplayService;
    this.i18n = i18n;
    this.notificationID = `notification-${_Notification.notificationCount++}`;
    this.notificationClass = true;
  }
  /**
   * Can have `type`, `title`, and `message` members.
   *
   * `type` can be one of `"error"`, `"info"`, `"info-square"`, `"warning"`, `"warning-alt"`, or `"success"`
   *
   * `message` is the message to display
   */
  get notificationObj() {
    return this._notificationObj;
  }
  set notificationObj(obj) {
    if (obj.closeLabel && !isObservable(obj.closeLabel)) {
      obj.closeLabel = of(obj.closeLabel);
    }
    this._notificationObj = Object.assign({}, this.defaultNotificationObj, obj);
  }
  get isError() {
    return this.notificationObj.type === "error";
  }
  get isInfo() {
    return this.notificationObj.type === "info";
  }
  get isInfoSquare() {
    return this.notificationObj.type === "info-square";
  }
  get isSuccess() {
    return this.notificationObj.type === "success";
  }
  get isWarning() {
    return this.notificationObj.type === "warning";
  }
  get isWarningAlt() {
    return this.notificationObj.type === "warning-alt";
  }
  get isLowContrast() {
    return this.notificationObj.lowContrast;
  }
  get isCloseHidden() {
    return !this.notificationObj.showClose;
  }
};
Notification.notificationCount = 0;
Notification.ɵfac = function Notification_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Notification)(ɵɵdirectiveInject(NotificationDisplayService), ɵɵdirectiveInject(I18n));
};
Notification.ɵcmp = ɵɵdefineComponent({
  type: Notification,
  selectors: [["cds-notification"], ["cds-inline-notification"], ["ibm-notification"], ["ibm-inline-notification"]],
  hostVars: 19,
  hostBindings: function Notification_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("id", ctx.notificationID);
      ɵɵclassProp("cds--inline-notification", ctx.notificationClass)("cds--inline-notification--error", ctx.isError)("cds--inline-notification--info", ctx.isInfo)("cds--inline-notification--info-square", ctx.isInfoSquare)("cds--inline-notification--success", ctx.isSuccess)("cds--inline-notification--warning", ctx.isWarning)("cds--inline-notification--warning-alt", ctx.isWarningAlt)("cds--inline-notification--low-contrast", ctx.isLowContrast)("cds--inline-notification--hide-close-button", ctx.isCloseHidden);
    }
  },
  inputs: {
    notificationObj: "notificationObj"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature],
  decls: 7,
  vars: 8,
  consts: [[1, "cds--inline-notification__details"], ["size", "20", "class", "cds--inline-notification__icon", 3, "cdsIcon", 4, "ngIf"], [1, "cds--inline-notification__text-wrapper"], ["cdsNotificationTitle", "", 3, "innerHTML", 4, "ngIf"], ["cdsNotificationSubtitle", "", 4, "ngIf"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["class", "cds--inline-notification__close-button", "type", "button", 3, "click", 4, "ngIf"], ["size", "20", 1, "cds--inline-notification__icon", 3, "cdsIcon"], ["cdsNotificationTitle", "", 3, "innerHTML"], ["cdsNotificationSubtitle", ""], [3, "innerHTML"], ["type", "button", 1, "cds--inline-notification__close-button", 3, "click"], ["cdsIcon", "close", "size", "16", 1, "cds--inline-notification__close-icon"]],
  template: function Notification_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵtemplate(1, Notification__svg_svg_1_Template, 1, 1, "svg", 1);
      ɵɵelementStart(2, "div", 2);
      ɵɵtemplate(3, Notification_div_3_Template, 1, 1, "div", 3)(4, Notification_div_4_Template, 2, 1, "div", 4)(5, Notification_ng_container_5_Template, 1, 0, "ng-container", 5);
      ɵɵelementEnd()();
      ɵɵtemplate(6, Notification_button_6_Template, 3, 3, "button", 6);
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.notificationObj.type);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", !ctx.notificationObj.template);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.notificationObj.template);
      ɵɵadvance();
      ɵɵproperty("ngTemplateOutlet", ctx.notificationObj.template)("ngTemplateOutletContext", ɵɵpureFunction1(6, _c025, ctx.notificationObj));
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.isCloseHidden);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet, IconDirective, NotificationTitle, NotificationSubtitle, AsyncPipe],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Notification, [{
    type: Component,
    args: [{
      selector: "cds-notification, cds-inline-notification, ibm-notification, ibm-inline-notification",
      template: `
		<div class="cds--inline-notification__details">
			<svg
				[cdsIcon]="iconDictionary[notificationObj.type]"
				size="20"
				*ngIf="notificationObj.type"
				class="cds--inline-notification__icon">
			</svg>
			<div class="cds--inline-notification__text-wrapper">
				<div *ngIf="!notificationObj.template" cdsNotificationTitle [innerHTML]="notificationObj.title"></div>
				<div *ngIf="!notificationObj.template" cdsNotificationSubtitle>
					<span [innerHTML]="notificationObj.message"></span>
				</div>
				<ng-container *ngTemplateOutlet="notificationObj.template; context: { $implicit: notificationObj}"></ng-container>
			</div>
		</div>
		<button
			*ngIf="!isCloseHidden"
			(click)="onClose()"
			class="cds--inline-notification__close-button"
			[attr.aria-label]="notificationObj.closeLabel | async"
			type="button">
			<svg cdsIcon="close" size="16" class="cds--inline-notification__close-icon"></svg>
		</button>
	`
    }]
  }], function() {
    return [{
      type: NotificationDisplayService
    }, {
      type: I18n
    }];
  }, {
    notificationObj: [{
      type: Input
    }],
    notificationID: [{
      type: HostBinding,
      args: ["attr.id"]
    }],
    notificationClass: [{
      type: HostBinding,
      args: ["class.cds--inline-notification"]
    }],
    isError: [{
      type: HostBinding,
      args: ["class.cds--inline-notification--error"]
    }],
    isInfo: [{
      type: HostBinding,
      args: ["class.cds--inline-notification--info"]
    }],
    isInfoSquare: [{
      type: HostBinding,
      args: ["class.cds--inline-notification--info-square"]
    }],
    isSuccess: [{
      type: HostBinding,
      args: ["class.cds--inline-notification--success"]
    }],
    isWarning: [{
      type: HostBinding,
      args: ["class.cds--inline-notification--warning"]
    }],
    isWarningAlt: [{
      type: HostBinding,
      args: ["class.cds--inline-notification--warning-alt"]
    }],
    isLowContrast: [{
      type: HostBinding,
      args: ["class.cds--inline-notification--low-contrast"]
    }],
    isCloseHidden: [{
      type: HostBinding,
      args: ["class.cds--inline-notification--hide-close-button"]
    }]
  });
})();
var ToastTitle = class {
  constructor() {
    this.baseClass = true;
  }
};
ToastTitle.ɵfac = function ToastTitle_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ToastTitle)();
};
ToastTitle.ɵdir = ɵɵdefineDirective({
  type: ToastTitle,
  selectors: [["", "cdsToastTitle", ""], ["", "ibmToastTitle", ""]],
  hostVars: 2,
  hostBindings: function ToastTitle_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--toast-notification__title", ctx.baseClass);
    }
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ToastTitle, [{
    type: Directive,
    args: [{
      selector: "[cdsToastTitle], [ibmToastTitle]"
    }]
  }], null, {
    baseClass: [{
      type: HostBinding,
      args: ["class.cds--toast-notification__title"]
    }]
  });
})();
var ToastSubtitle = class {
  constructor() {
    this.baseClass = true;
  }
};
ToastSubtitle.ɵfac = function ToastSubtitle_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ToastSubtitle)();
};
ToastSubtitle.ɵdir = ɵɵdefineDirective({
  type: ToastSubtitle,
  selectors: [["", "cdsToastSubtitle", ""], ["", "ibmToastSubtitle", ""]],
  hostVars: 2,
  hostBindings: function ToastSubtitle_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--toast-notification__subtitle", ctx.baseClass);
    }
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ToastSubtitle, [{
    type: Directive,
    args: [{
      selector: "[cdsToastSubtitle], [ibmToastSubtitle]"
    }]
  }], null, {
    baseClass: [{
      type: HostBinding,
      args: ["class.cds--toast-notification__subtitle"]
    }]
  });
})();
var ToastCaption = class {
  constructor() {
    this.baseClass = true;
  }
};
ToastCaption.ɵfac = function ToastCaption_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ToastCaption)();
};
ToastCaption.ɵdir = ɵɵdefineDirective({
  type: ToastCaption,
  selectors: [["", "cdsToastCaption", ""], ["", "ibmToastCaption", ""]],
  hostVars: 2,
  hostBindings: function ToastCaption_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--toast-notification__caption", ctx.baseClass);
    }
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ToastCaption, [{
    type: Directive,
    args: [{
      selector: "[cdsToastCaption], [ibmToastCaption]"
    }]
  }], null, {
    baseClass: [{
      type: HostBinding,
      args: ["class.cds--toast-notification__caption"]
    }]
  });
})();
var Toast = class _Toast extends BaseNotification {
  constructor(notificationDisplayService, i18n) {
    super(notificationDisplayService, i18n);
    this.notificationDisplayService = notificationDisplayService;
    this.i18n = i18n;
    this.toastID = `toast-${_Toast.toastCount++}`;
    this.toastClass = true;
  }
  /**
   * Can have `type`, `title`, `subtitle`, and `caption` members.
   *
   * `type` can be one of `"error"`, `"info"`, `"info-square"`, `"warning"`, `"warning-alt"`, or `"success"`
   */
  set notificationObj(obj) {
    if (obj.closeLabel && !isObservable(obj.closeLabel)) {
      obj.closeLabel = of(obj.closeLabel);
    }
    this._notificationObj = Object.assign({}, this.defaultNotificationObj, obj);
  }
  get notificationObj() {
    return this._notificationObj;
  }
  get isError() {
    return this.notificationObj.type === "error";
  }
  get isInfo() {
    return this.notificationObj.type === "info";
  }
  get isInfoSquare() {
    return this.notificationObj.type === "info-square";
  }
  get isSuccess() {
    return this.notificationObj.type === "success";
  }
  get isWarning() {
    return this.notificationObj.type === "warning";
  }
  get isWarningAlt() {
    return this.notificationObj.type === "warning-alt";
  }
  get isLowContrast() {
    return this.notificationObj.lowContrast;
  }
  get isCloseHidden() {
    return !this.notificationObj.showClose;
  }
  ngOnInit() {
    if (!this.notificationObj.closeLabel) {
      this.notificationObj.closeLabel = this.i18n.get().NOTIFICATION.CLOSE_BUTTON;
    }
  }
};
Toast.toastCount = 0;
Toast.ɵfac = function Toast_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Toast)(ɵɵdirectiveInject(NotificationDisplayService), ɵɵdirectiveInject(I18n));
};
Toast.ɵcmp = ɵɵdefineComponent({
  type: Toast,
  selectors: [["cds-toast"], ["ibm-toast"]],
  hostVars: 19,
  hostBindings: function Toast_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("id", ctx.toastID);
      ɵɵclassProp("cds--toast-notification", ctx.toastClass)("cds--toast-notification--error", ctx.isError)("cds--toast-notification--info", ctx.isInfo)("cds--toast-notification--info-square", ctx.isInfoSquare)("cds--toast-notification--success", ctx.isSuccess)("cds--toast-notification--warning", ctx.isWarning)("cds--toast-notification--warning-alt", ctx.isWarningAlt)("cds--toast-notification--low-contrast", ctx.isLowContrast)("cds--toast-notification--hide-close-button", ctx.isCloseHidden);
    }
  },
  inputs: {
    notificationObj: "notificationObj"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature],
  decls: 7,
  vars: 9,
  consts: [["size", "20", "class", "cds--toast-notification__icon", 3, "cdsIcon", 4, "ngIf"], [1, "cds--toast-notification__details"], ["cdsToastTitle", "", 3, "innerHTML", 4, "ngIf"], ["cdsToastSubtitle", "", 4, "ngIf"], ["cdsToastCaption", "", 3, "innerHTML", 4, "ngIf"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["class", "cds--toast-notification__close-button", "type", "button", 3, "click", 4, "ngIf"], ["size", "20", 1, "cds--toast-notification__icon", 3, "cdsIcon"], ["cdsToastTitle", "", 3, "innerHTML"], ["cdsToastSubtitle", ""], [3, "innerHTML"], ["cdsToastCaption", "", 3, "innerHTML"], ["type", "button", 1, "cds--toast-notification__close-button", 3, "click"], ["cdsIcon", "close", "size", "16", 1, "cds--toast-notification__close-icon"]],
  template: function Toast_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, Toast__svg_svg_0_Template, 1, 1, "svg", 0);
      ɵɵelementStart(1, "div", 1);
      ɵɵtemplate(2, Toast_h3_2_Template, 1, 1, "h3", 2)(3, Toast_div_3_Template, 2, 1, "div", 3)(4, Toast_p_4_Template, 1, 1, "p", 4)(5, Toast_ng_container_5_Template, 1, 0, "ng-container", 5);
      ɵɵelementEnd();
      ɵɵtemplate(6, Toast_button_6_Template, 3, 3, "button", 6);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.notificationObj.type);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", !ctx.notificationObj.template);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.notificationObj.template);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.notificationObj.template);
      ɵɵadvance();
      ɵɵproperty("ngTemplateOutlet", ctx.notificationObj.template)("ngTemplateOutletContext", ɵɵpureFunction1(7, _c025, ctx.notificationObj));
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.isCloseHidden);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet, IconDirective, ToastTitle, ToastSubtitle, ToastCaption, AsyncPipe],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Toast, [{
    type: Component,
    args: [{
      selector: "cds-toast, ibm-toast",
      template: `
		<svg
			[cdsIcon]="iconDictionary[notificationObj.type]"
			size="20"
			*ngIf="notificationObj.type"
			class="cds--toast-notification__icon">
		</svg>
		<div class="cds--toast-notification__details">
			<h3 *ngIf="!notificationObj.template" cdsToastTitle [innerHTML]="notificationObj.title"></h3>
			<div *ngIf="!notificationObj.template" cdsToastSubtitle>
				<span [innerHTML]="notificationObj.subtitle"></span>
			</div>
			<p *ngIf="!notificationObj.template" cdsToastCaption [innerHTML]="notificationObj.caption"></p>
			<ng-container *ngTemplateOutlet="notificationObj.template; context: { $implicit: notificationObj }"></ng-container>
		</div>
		<button
			*ngIf="!isCloseHidden"
			class="cds--toast-notification__close-button"
			type="button"
			[attr.aria-label]="notificationObj.closeLabel | async"
			(click)="onClose()">
			<svg cdsIcon="close" size="16" class="cds--toast-notification__close-icon"></svg>
		</button>
	`
    }]
  }], function() {
    return [{
      type: NotificationDisplayService
    }, {
      type: I18n
    }];
  }, {
    notificationObj: [{
      type: Input
    }],
    toastID: [{
      type: HostBinding,
      args: ["attr.id"]
    }],
    toastClass: [{
      type: HostBinding,
      args: ["class.cds--toast-notification"]
    }],
    isError: [{
      type: HostBinding,
      args: ["class.cds--toast-notification--error"]
    }],
    isInfo: [{
      type: HostBinding,
      args: ["class.cds--toast-notification--info"]
    }],
    isInfoSquare: [{
      type: HostBinding,
      args: ["class.cds--toast-notification--info-square"]
    }],
    isSuccess: [{
      type: HostBinding,
      args: ["class.cds--toast-notification--success"]
    }],
    isWarning: [{
      type: HostBinding,
      args: ["class.cds--toast-notification--warning"]
    }],
    isWarningAlt: [{
      type: HostBinding,
      args: ["class.cds--toast-notification--warning-alt"]
    }],
    isLowContrast: [{
      type: HostBinding,
      args: ["class.cds--toast-notification--low-contrast"]
    }],
    isCloseHidden: [{
      type: HostBinding,
      args: ["class.cds--toast-notification--hide-close-button"]
    }]
  });
})();
var NotificationService = class {
  /**
   * Constructs Notification Service
   */
  constructor(injector, viewContainer, ngZone) {
    this.injector = injector;
    this.viewContainer = viewContainer;
    this.ngZone = ngZone;
    this.notificationRefs = new Array();
    this.onClose = new EventEmitter();
  }
  /**
   * Shows the notification based on the `notificationObj`.
   *
   * @param notificationObj Can have `type`, `message`, `target`, `duration` and `smart` members.
   *
   * **Members:**
   *
   * * `type` can be one of `"info"`, `"warning"`, `"danger"`, `"success"`
   * * `message` is message for notification to display
   * * `target` is css selector defining an element to append notification to. If not provided,
   * `showNotification()` creates a place for the notification in `body`
   * * `duration` is number of ms to close the notification after. If used in combination with `smart`,
   * it's added to the calculated timeout
   * * `smart`, set to `true` if you want to use smart notification.
   *
   * **Example:**
   * ```typescript
   * // Info notification, saying "Sample message." added to the element with id notification-container
   * // uses smart timeout with added duration of 1 second.
   * {
   *	type: "info",
   *	message: "Sample message.",
   *	target: "#notification-container",
   *	duration: 1000,
   *	smart: true
   * }
   * ```
   *
   * @param [notificationComp=Notification] If provided, used to resolve component factory
   */
  showNotification(notificationObj, notificationComp = Notification) {
    const notificationRef = this.viewContainer.createComponent(notificationComp);
    notificationRef.instance.notificationObj = notificationObj;
    this.notificationRefs.push(notificationRef);
    this.onClose = notificationRef.instance.close;
    if (notificationObj.target) {
      document.querySelector(notificationObj.target).appendChild(notificationRef.location.nativeElement);
    } else {
      let body = document.querySelector("body");
      let notificationClassName = "notification-overlay";
      let notificationList = body.querySelector(`.${notificationClassName}`);
      if (!notificationList) {
        notificationList = document.createElement("div");
        notificationList.className = notificationClassName;
        body.appendChild(notificationList);
      }
      if (notificationList.firstChild) {
        notificationList.insertBefore(notificationRef.location.nativeElement, notificationList.firstChild);
      } else {
        notificationList.appendChild(notificationRef.location.nativeElement);
      }
    }
    if (notificationObj.duration && notificationObj.duration > 0) {
      this.ngZone.runOutsideAngular(() => {
        setTimeout(() => {
          this.ngZone.run(() => {
            this.close(notificationRef);
          });
        }, notificationObj.duration);
      });
    }
    if (notificationObj.smart) {
      this.ngZone.runOutsideAngular(() => {
        setTimeout(() => {
          this.ngZone.run(() => {
            this.close(notificationRef);
          });
        }, this.getSmartTimeout(notificationObj));
      });
    }
    this.onClose.subscribe(() => {
      this.close(notificationRef);
    });
    notificationRef.instance.componentRef = notificationRef;
    return notificationRef.instance;
  }
  showToast(notificationObj, notificationComp = Toast) {
    return this.showNotification(notificationObj, notificationComp);
  }
  showActionable(notificationObj, notificationComp = ActionableNotification) {
    return this.showNotification(notificationObj, notificationComp);
  }
  /**
   * Programatically closes notification based on `notificationRef`.
   *
   * @param notificationRef `ComponentRef` of a notification or `Notification` component you wish to close
   */
  close(notificationRef) {
    if (notificationRef) {
      if (notificationRef instanceof Notification) {
        this.close(notificationRef.componentRef);
      } else {
        notificationRef.destroy();
        const index = this.notificationRefs.indexOf(notificationRef);
        if (index !== -1) {
          this.notificationRefs.splice(index, 1);
        }
      }
    }
  }
  /**
   * Calculates the amount of time user needs to read the message in the notification.
   *
   * @param notificationObj Same object used to instantiate notification.
   *
   * In addition to `type` and `message` members, use `duration` member to add
   * some extra time (in ms) to timeout if you need to.
   * @returns calculated timeout (in ms) for smart notification
   */
  getSmartTimeout(notificationObj) {
    let timeout = 600;
    timeout += notificationObj.duration || 0;
    switch (notificationObj.type) {
      case "info":
      case "info-square":
      case "success":
      default: {
        break;
      }
      case "danger": {
        timeout += 3e3;
        break;
      }
      case "warning":
      case "warning-alt": {
        timeout += 1500;
        break;
      }
    }
    let wordCount = notificationObj.message.trim().split(/\s+/).length;
    timeout += wordCount * 450;
    return timeout;
  }
  /**
   * OnDestroy hook.
   *
   * Destroys all living notifications it is responsible for.
   *
   */
  ngOnDestroy() {
    this.notificationRefs.forEach((ref) => {
      ref.destroy();
    });
  }
};
NotificationService.ɵfac = function NotificationService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || NotificationService)(ɵɵinject(Injector), ɵɵinject(ViewContainerRef), ɵɵinject(NgZone));
};
NotificationService.ɵprov = ɵɵdefineInjectable({
  token: NotificationService,
  factory: NotificationService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NotificationService, [{
    type: Injectable
  }], function() {
    return [{
      type: Injector
    }, {
      type: ViewContainerRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var NotificationModule = class {
};
NotificationModule.ɵfac = function NotificationModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || NotificationModule)();
};
NotificationModule.ɵmod = ɵɵdefineNgModule({
  type: NotificationModule,
  declarations: [ActionableButton, ActionableNotification, ActionableTitle, ActionableSubtitle, BaseNotification, Notification, Toast, ToastTitle, ToastSubtitle, ToastCaption, NotificationTitle, NotificationSubtitle],
  imports: [ButtonModule, CommonModule, I18nModule, ExperimentalModule, LinkModule, IconModule],
  exports: [Notification, ActionableButton, ActionableNotification, ActionableTitle, ActionableSubtitle, Toast, ToastTitle, ToastSubtitle, ToastCaption, NotificationTitle, NotificationSubtitle]
});
NotificationModule.ɵinj = ɵɵdefineInjector({
  providers: [NotificationService, NotificationDisplayService],
  imports: [ButtonModule, CommonModule, I18nModule, ExperimentalModule, LinkModule, IconModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NotificationModule, [{
    type: NgModule,
    args: [{
      declarations: [ActionableButton, ActionableNotification, ActionableTitle, ActionableSubtitle, BaseNotification, Notification, Toast, ToastTitle, ToastSubtitle, ToastCaption, NotificationTitle, NotificationSubtitle],
      exports: [Notification, ActionableButton, ActionableNotification, ActionableTitle, ActionableSubtitle, Toast, ToastTitle, ToastSubtitle, ToastCaption, NotificationTitle, NotificationSubtitle],
      imports: [ButtonModule, CommonModule, I18nModule, ExperimentalModule, LinkModule, IconModule],
      providers: [NotificationService, NotificationDisplayService]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-number-input.mjs
var _c026 = (a0, a1, a2, a3, a4, a5, a6) => ({
  "cds--number--light": a0,
  "cds--number--nolabel": a1,
  "cds--number--helpertext": a2,
  "cds--skeleton": a3,
  "cds--number--sm": a4,
  "cds--number--md": a5,
  "cds--number--lg": a6
});
var _c125 = (a0) => ({
  "cds--number__input-wrapper--warning": a0
});
var _c218 = (a0) => ({
  "cds--label--disabled": a0
});
var _c312 = (a0) => ({
  "cds--form__helper-text--disabled": a0
});
function NumberComponent_label_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "label", 11);
  }
}
function NumberComponent_label_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.label);
  }
}
function NumberComponent_label_2_2_ng_template_0_Template(rf, ctx) {
}
function NumberComponent_label_2_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, NumberComponent_label_2_2_ng_template_0_Template, 0, 0, "ng-template", 14);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.label);
  }
}
function NumberComponent_label_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "label", 12);
    ɵɵtemplate(1, NumberComponent_label_2_ng_container_1_Template, 2, 1, "ng-container", 13)(2, NumberComponent_label_2_2_Template, 1, 1, null, 13);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("for", ctx_r0.id)("ngClass", ɵɵpureFunction1(4, _c218, ctx_r0.disabled));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.label));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.label));
  }
}
function NumberComponent__svg_svg_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 15);
  }
}
function NumberComponent__svg_svg_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 16);
  }
}
function NumberComponent_div_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 17)(1, "button", 18);
    ɵɵpipe(2, "async");
    ɵɵlistener("click", function NumberComponent_div_7_Template_button_click_1_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onDecrement());
    });
    ɵɵnamespaceSVG();
    ɵɵelement(3, "svg", 19);
    ɵɵelementEnd();
    ɵɵnamespaceHTML();
    ɵɵelement(4, "div", 20);
    ɵɵelementStart(5, "button", 21);
    ɵɵpipe(6, "async");
    ɵɵlistener("click", function NumberComponent_div_7_Template_button_click_5_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onIncrement());
    });
    ɵɵnamespaceSVG();
    ɵɵelement(7, "svg", 22);
    ɵɵelementEnd();
    ɵɵnamespaceHTML();
    ɵɵelement(8, "div", 20);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵattribute("disabled", ctx_r0.disabled ? true : null)("aria-label", ɵɵpipeBind1(2, 4, ctx_r0.getDecrementLabel()));
    ɵɵadvance(4);
    ɵɵattribute("disabled", ctx_r0.disabled ? true : null)("aria-label", ɵɵpipeBind1(6, 6, ctx_r0.getIncrementLabel()));
  }
}
function NumberComponent_hr_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "hr", 23);
  }
}
function NumberComponent_div_9_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.helperText);
  }
}
function NumberComponent_div_9_2_ng_template_0_Template(rf, ctx) {
}
function NumberComponent_div_9_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, NumberComponent_div_9_2_ng_template_0_Template, 0, 0, "ng-template", 14);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.helperText);
  }
}
function NumberComponent_div_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 24);
    ɵɵtemplate(1, NumberComponent_div_9_ng_container_1_Template, 2, 1, "ng-container", 13)(2, NumberComponent_div_9_2_Template, 1, 1, null, 13);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ɵɵpureFunction1(3, _c312, ctx_r0.disabled));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.helperText));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.helperText));
  }
}
function NumberComponent_div_10_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.invalidText);
  }
}
function NumberComponent_div_10_2_ng_template_0_Template(rf, ctx) {
}
function NumberComponent_div_10_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, NumberComponent_div_10_2_ng_template_0_Template, 0, 0, "ng-template", 14);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.invalidText);
  }
}
function NumberComponent_div_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 25);
    ɵɵtemplate(1, NumberComponent_div_10_ng_container_1_Template, 2, 1, "ng-container", 13)(2, NumberComponent_div_10_2_Template, 1, 1, null, 13);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.invalidText));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.invalidText));
  }
}
function NumberComponent_div_11_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.warnText);
  }
}
function NumberComponent_div_11_2_ng_template_0_Template(rf, ctx) {
}
function NumberComponent_div_11_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, NumberComponent_div_11_2_ng_template_0_Template, 0, 0, "ng-template", 14);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.warnText);
  }
}
function NumberComponent_div_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 25);
    ɵɵtemplate(1, NumberComponent_div_11_ng_container_1_Template, 2, 1, "ng-container", 13)(2, NumberComponent_div_11_2_Template, 1, 1, null, 13);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.warnText));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.warnText));
  }
}
var NumberChange = class {
};
var NumberComponent = class _NumberComponent {
  /**
   * Creates an instance of `Number`.
   */
  constructor(i18n) {
    this.i18n = i18n;
    this.containerClass = true;
    this.readonly = false;
    this.theme = "dark";
    this.disabled = false;
    this.skeleton = false;
    this.invalid = false;
    this.id = `number-${_NumberComponent.numberCount}`;
    this.placeholder = "";
    this.size = "md";
    this.min = null;
    this.max = null;
    this.step = 1;
    this.warn = false;
    this.change = new EventEmitter();
    this.fluid = false;
    this._isFocused = false;
    this._value = 0;
    this._decrementLabel = this.i18n.getOverridable("NUMBER.DECREMENT");
    this._incrementLabel = this.i18n.getOverridable("NUMBER.INCREMENT");
    this.onTouched = () => {
    };
    this.propagateChange = (_) => {
    };
    _NumberComponent.numberCount++;
  }
  /**
   * Sets the value attribute on the `input` element.
   */
  set value(v) {
    if (v === "" || v === null) {
      this._value = null;
      return;
    }
    this._value = Number(v);
  }
  get value() {
    return this._value;
  }
  set decrementLabel(value) {
    this._decrementLabel.override(value);
  }
  get decrementLabel() {
    return this._decrementLabel.value;
  }
  set incrementLabel(value) {
    this._incrementLabel.override(value);
  }
  get incrementLabel() {
    return this._incrementLabel.value;
  }
  get fluidInvalid() {
    return this.fluid && this.invalid;
  }
  get fluidDisabled() {
    return this.fluid && this.disabled;
  }
  get fluidFocus() {
    return this.fluid && this._isFocused;
  }
  get fluidSkeleton() {
    return this.fluid && this.skeleton;
  }
  /**
   * This is the initial value set to the component
   * @param value The input value.
   */
  writeValue(value) {
    this.value = value;
  }
  /**
   * Sets a method in order to propagate changes back to the form.
   */
  registerOnChange(fn) {
    this.propagateChange = fn;
  }
  /**
   * Registers a callback to be triggered when the control has been touched.
   * @param fn Callback to be triggered when the number input is touched.
   */
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  focusOut() {
    this.onTouched();
  }
  /**
   * Sets the disabled state through the model
   */
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  /**
   * Adds `step` to the current `value`.
   */
  onIncrement() {
    if (this.max !== null && this.value + this.step > this.max) {
      this.value = this.max;
      this.emitChangeEvent();
      return;
    }
    if (this.min !== null && this.value + this.step < this.min) {
      this.value = this.min;
      this.emitChangeEvent();
      return;
    }
    if (this.max === null || this.value + this.step <= this.max) {
      this.value += this.step;
      this.value = parseFloat(this.value.toPrecision(this.precision));
      this.emitChangeEvent();
    }
  }
  /**
   * Subtracts `step` to the current `value`.
   */
  onDecrement() {
    if (this.max !== null && this.value - this.step > this.max) {
      this.value = this.max;
      this.emitChangeEvent();
      return;
    }
    if (this.min !== null && this.value - this.step < this.min) {
      this.value = this.min;
      this.emitChangeEvent();
      return;
    }
    if (this.min === null || this.value - this.step >= this.min) {
      this.value -= this.step;
      this.value = parseFloat(this.value.toPrecision(this.precision));
      this.emitChangeEvent();
    }
  }
  getDecrementLabel() {
    return this._decrementLabel.subject;
  }
  getIncrementLabel() {
    return this._incrementLabel.subject;
  }
  /**
   * Creates a class of `NumberChange` to emit the change in the `Number`.
   */
  emitChangeEvent() {
    let event = new NumberChange();
    event.source = this;
    event.value = this.value;
    this.change.emit(event);
    this.propagateChange(this.value);
  }
  onNumberInputChange(event) {
    this.value = event.target.value;
    this.emitChangeEvent();
  }
  isTemplate(value) {
    return value instanceof TemplateRef;
  }
  handleFocus(event) {
    if ("type" in event.target && event.target.type === "button") {
      this._isFocused = false;
    } else {
      this._isFocused = event.type === "focus";
    }
  }
};
NumberComponent.numberCount = 0;
NumberComponent.ɵfac = function NumberComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || NumberComponent)(ɵɵdirectiveInject(I18n));
};
NumberComponent.ɵcmp = ɵɵdefineComponent({
  type: NumberComponent,
  selectors: [["cds-number"], ["ibm-number"]],
  hostVars: 14,
  hostBindings: function NumberComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("focusout", function NumberComponent_focusout_HostBindingHandler() {
        return ctx.focusOut();
      });
    }
    if (rf & 2) {
      ɵɵclassProp("cds--form-item", ctx.containerClass)("cds--number--readonly", ctx.readonly)("cds--number-input--fluid", ctx.fluid)("cds--number-input--fluid--invalid", ctx.fluidInvalid)("cds--number-input--fluid--disabled", ctx.fluidDisabled)("cds--number-input--fluid--focus", ctx.fluidFocus)("cds--text-input--fluid__skeleton", ctx.fluidSkeleton);
    }
  },
  inputs: {
    readonly: "readonly",
    theme: "theme",
    disabled: "disabled",
    skeleton: "skeleton",
    invalid: "invalid",
    id: "id",
    placeholder: "placeholder",
    size: "size",
    required: "required",
    value: "value",
    min: "min",
    max: "max",
    label: "label",
    helperText: "helperText",
    invalidText: "invalidText",
    step: "step",
    precision: "precision",
    warn: "warn",
    warnText: "warnText",
    ariaLabel: "ariaLabel",
    decrementLabel: "decrementLabel",
    incrementLabel: "incrementLabel",
    fluid: "fluid"
  },
  outputs: {
    change: "change"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: NumberComponent,
    multi: true
  }])],
  decls: 12,
  vars: 33,
  consts: [["class", "cds--label cds--skeleton", 4, "ngIf"], ["data-numberinput", "", 1, "cds--number", 3, "ngClass"], ["class", "cds--label", 3, "for", "ngClass", 4, "ngIf"], [1, "cds--number__input-wrapper", 3, "ngClass"], ["type", "number", 3, "focus", "blur", "change", "id", "value", "disabled", "readonly", "required", "placeholder"], ["cdsIcon", "warning--filled", "size", "16", "class", "cds--number__invalid", 4, "ngIf"], ["cdsIcon", "warning--alt--filled", "size", "16", "class", "cds--number__invalid cds--number__invalid--warning", 4, "ngIf"], ["class", "cds--number__controls", 4, "ngIf"], ["class", "cds--number-input__divider", 4, "ngIf"], ["class", "cds--form__helper-text", 3, "ngClass", 4, "ngIf"], ["class", "cds--form-requirement", 4, "ngIf"], [1, "cds--label", "cds--skeleton"], [1, "cds--label", 3, "for", "ngClass"], [4, "ngIf"], [3, "ngTemplateOutlet"], ["cdsIcon", "warning--filled", "size", "16", 1, "cds--number__invalid"], ["cdsIcon", "warning--alt--filled", "size", "16", 1, "cds--number__invalid", "cds--number__invalid--warning"], [1, "cds--number__controls"], ["type", "button", "aria-live", "polite", "aria-atomic", "true", 1, "cds--number__control-btn", "down-icon", 3, "click"], ["cdsIcon", "subtract", "size", "16"], [1, "cds--number__rule-divider"], ["type", "button", "aria-live", "polite", "aria-atomic", "true", 1, "cds--number__control-btn", "up-icon", 3, "click"], ["cdsIcon", "add", "size", "16"], [1, "cds--number-input__divider"], [1, "cds--form__helper-text", 3, "ngClass"], [1, "cds--form-requirement"]],
  template: function NumberComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, NumberComponent_label_0_Template, 1, 0, "label", 0);
      ɵɵelementStart(1, "div", 1);
      ɵɵtemplate(2, NumberComponent_label_2_Template, 3, 6, "label", 2);
      ɵɵelementStart(3, "div", 3)(4, "input", 4);
      ɵɵlistener("focus", function NumberComponent_Template_input_focus_4_listener($event) {
        return ctx.fluid ? ctx.handleFocus($event) : null;
      })("blur", function NumberComponent_Template_input_blur_4_listener($event) {
        return ctx.fluid ? ctx.handleFocus($event) : null;
      })("change", function NumberComponent_Template_input_change_4_listener($event) {
        return ctx.onNumberInputChange($event);
      });
      ɵɵelementEnd();
      ɵɵtemplate(5, NumberComponent__svg_svg_5_Template, 1, 0, "svg", 5)(6, NumberComponent__svg_svg_6_Template, 1, 0, "svg", 6)(7, NumberComponent_div_7_Template, 9, 8, "div", 7);
      ɵɵelementEnd();
      ɵɵtemplate(8, NumberComponent_hr_8_Template, 1, 0, "hr", 8)(9, NumberComponent_div_9_Template, 3, 5, "div", 9)(10, NumberComponent_div_10_Template, 3, 2, "div", 10)(11, NumberComponent_div_11_Template, 3, 2, "div", 10);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.skeleton && ctx.label);
      ɵɵadvance();
      ɵɵproperty("ngClass", ɵɵpureFunction7(23, _c026, ctx.theme === "light", !ctx.label, ctx.helperText, ctx.skeleton, ctx.size === "sm", ctx.size === "md", ctx.size === "lg"));
      ɵɵattribute("data-invalid", ctx.invalid ? true : null);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.skeleton && ctx.label);
      ɵɵadvance();
      ɵɵproperty("ngClass", ɵɵpureFunction1(31, _c125, ctx.warn));
      ɵɵadvance();
      ɵɵproperty("id", ctx.id)("value", ctx.value)("disabled", ctx.disabled)("readonly", ctx.readonly)("required", ctx.required)("placeholder", ctx.placeholder);
      ɵɵattribute("min", ctx.min)("max", ctx.max)("step", ctx.step)("aria-label", ctx.ariaLabel)("data-invalid", ctx.invalid ? ctx.invalid : null);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.skeleton && ctx.invalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.skeleton && !ctx.invalid && ctx.warn);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.skeleton);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.fluid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.helperText && !ctx.invalid && !ctx.warn && !ctx.fluid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.invalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.invalid && ctx.warn);
    }
  },
  dependencies: [NgClass, NgIf, NgTemplateOutlet, IconDirective, AsyncPipe],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumberComponent, [{
    type: Component,
    args: [{
      selector: "cds-number, ibm-number",
      template: `
		<label *ngIf="skeleton && label" class="cds--label cds--skeleton"></label>
		<div
			data-numberinput
			[attr.data-invalid]="(invalid ? true : null)"
			class="cds--number"
			[ngClass]="{
				'cds--number--light': theme === 'light',
				'cds--number--nolabel': !label,
				'cds--number--helpertext': helperText,
				'cds--skeleton' : skeleton,
				'cds--number--sm': size === 'sm',
				'cds--number--md': size === 'md',
				'cds--number--lg': size === 'lg'
			}">
			<label
				*ngIf="!skeleton && label"
				[for]="id"
				class="cds--label"
				[ngClass]="{'cds--label--disabled': disabled}">
				<ng-container *ngIf="!isTemplate(label)">{{label}}</ng-container>
				<ng-template *ngIf="isTemplate(label)" [ngTemplateOutlet]="label"></ng-template>
			</label>
			<div
				class="cds--number__input-wrapper"
				[ngClass]="{
					'cds--number__input-wrapper--warning': warn
				}">
				<input
					type="number"
					[id]="id"
					[value]="value"
					[attr.min]="min"
					[attr.max]="max"
					[attr.step]="step"
					[disabled]="disabled"
					[readonly]="readonly"
					[required]="required"
					[attr.aria-label]="ariaLabel"
					[attr.data-invalid]="invalid ? invalid : null"
					[placeholder]="placeholder"
					(focus)="fluid ? handleFocus($event): null"
					(blur)="fluid ? handleFocus($event): null"
					(change)="onNumberInputChange($event)"/>
				<svg
					*ngIf="!skeleton && invalid"
					cdsIcon="warning--filled"
					size="16"
					class="cds--number__invalid">
				</svg>
				<svg
					*ngIf="!skeleton && !invalid && warn"
					cdsIcon="warning--alt--filled"
					size="16"
					class="cds--number__invalid cds--number__invalid--warning">
				</svg>
				<div *ngIf="!skeleton" class="cds--number__controls">
					<button
						class="cds--number__control-btn down-icon"
						type="button"
						[attr.disabled]="disabled ? true : null"
						aria-live="polite"
						aria-atomic="true"
						[attr.aria-label]="getDecrementLabel() | async"
						(click)="onDecrement()">
						<svg cdsIcon="subtract" size="16"></svg>
					</button>
					<div class="cds--number__rule-divider"></div>
					<button
						class="cds--number__control-btn up-icon"
						type="button"
						[attr.disabled]="disabled ? true : null"
						aria-live="polite"
						aria-atomic="true"
						[attr.aria-label]="getIncrementLabel() | async"
						(click)="onIncrement()">
						<svg cdsIcon="add" size="16"></svg>
					</button>
					<div class="cds--number__rule-divider"></div>
				</div>
			</div>
			<hr *ngIf="fluid" class="cds--number-input__divider" />
			<div
				*ngIf="helperText && !invalid && !warn && !fluid"
				class="cds--form__helper-text"
				[ngClass]="{
					'cds--form__helper-text--disabled': disabled
				}">
				<ng-container *ngIf="!isTemplate(helperText)">{{helperText}}</ng-container>
				<ng-template *ngIf="isTemplate(helperText)" [ngTemplateOutlet]="helperText"></ng-template>
			</div>
			<div *ngIf="invalid" class="cds--form-requirement">
				<ng-container *ngIf="!isTemplate(invalidText)">{{invalidText}}</ng-container>
				<ng-template *ngIf="isTemplate(invalidText)" [ngTemplateOutlet]="invalidText"></ng-template>
			</div>
			<div *ngIf="!invalid && warn" class="cds--form-requirement">
				<ng-container *ngIf="!isTemplate(warnText)">{{warnText}}</ng-container>
				<ng-template *ngIf="isTemplate(warnText)" [ngTemplateOutlet]="warnText"></ng-template>
			</div>
		</div>
	`,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: NumberComponent,
        multi: true
      }]
    }]
  }], function() {
    return [{
      type: I18n
    }];
  }, {
    containerClass: [{
      type: HostBinding,
      args: ["class.cds--form-item"]
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.cds--number--readonly"]
    }],
    theme: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    skeleton: [{
      type: Input
    }],
    invalid: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    required: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    helperText: [{
      type: Input
    }],
    invalidText: [{
      type: Input
    }],
    step: [{
      type: Input
    }],
    precision: [{
      type: Input
    }],
    warn: [{
      type: Input
    }],
    warnText: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    change: [{
      type: Output
    }],
    decrementLabel: [{
      type: Input
    }],
    incrementLabel: [{
      type: Input
    }],
    fluid: [{
      type: HostBinding,
      args: ["class.cds--number-input--fluid"]
    }, {
      type: Input
    }],
    fluidInvalid: [{
      type: HostBinding,
      args: ["class.cds--number-input--fluid--invalid"]
    }],
    fluidDisabled: [{
      type: HostBinding,
      args: ["class.cds--number-input--fluid--disabled"]
    }],
    fluidFocus: [{
      type: HostBinding,
      args: ["class.cds--number-input--fluid--focus"]
    }],
    fluidSkeleton: [{
      type: HostBinding,
      args: ["class.cds--text-input--fluid__skeleton"]
    }],
    focusOut: [{
      type: HostListener,
      args: ["focusout"]
    }]
  });
})();
var NumberModule = class {
};
NumberModule.ɵfac = function NumberModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || NumberModule)();
};
NumberModule.ɵmod = ɵɵdefineNgModule({
  type: NumberModule,
  declarations: [NumberComponent],
  imports: [FormsModule, CommonModule, I18nModule, IconModule],
  exports: [NumberComponent]
});
NumberModule.ɵinj = ɵɵdefineInjector({
  imports: [FormsModule, CommonModule, I18nModule, IconModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumberModule, [{
    type: NgModule,
    args: [{
      declarations: [NumberComponent],
      exports: [NumberComponent],
      imports: [FormsModule, CommonModule, I18nModule, IconModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-pagination.mjs
var _c027 = (a0) => ({
  "cds--skeleton": a0
});
var _c126 = (a0) => ({
  "margin-left": a0
});
var _c219 = (a0, a1, a2) => ({
  start: a0,
  end: a1,
  total: a2
});
var _c313 = (a0, a1) => ({
  start: a0,
  end: a1
});
var _c410 = (a0) => ({
  "cds--pagination__button--no-index": a0
});
var _c58 = (a0) => ({
  last: a0
});
function Pagination_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 3);
    ɵɵelement(1, "p", 4)(2, "p", 5)(3, "p", 6);
    ɵɵelementEnd();
  }
}
function Pagination_div_2_ng_container_1_option_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "option", 14);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const option_r3 = ctx.$implicit;
    ɵɵproperty("value", option_r3);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", option_r3, " ");
  }
}
function Pagination_div_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "label", 9);
    ɵɵtext(2);
    ɵɵpipe(3, "async");
    ɵɵelementEnd();
    ɵɵelementStart(4, "div", 10)(5, "select", 11);
    ɵɵtwoWayListener("ngModelChange", function Pagination_div_2_ng_container_1_Template_select_ngModelChange_5_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r1.itemsPerPage, $event) || (ctx_r1.itemsPerPage = $event);
      return ɵɵresetView($event);
    });
    ɵɵtemplate(6, Pagination_div_2_ng_container_1_option_6_Template, 2, 2, "option", 12);
    ɵɵelementEnd();
    ɵɵnamespaceSVG();
    ɵɵelement(7, "svg", 13);
    ɵɵpipe(8, "async");
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("for", ctx_r1.itemsPerPageSelectId);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind1(3, 9, ctx_r1.itemsPerPageText.subject), " ");
    ɵɵadvance(2);
    ɵɵclassProp("cds--select--disabled", ctx_r1.pageInputDisabled);
    ɵɵadvance();
    ɵɵproperty("id", ctx_r1.itemsPerPageSelectId);
    ɵɵtwoWayProperty("ngModel", ctx_r1.itemsPerPage);
    ɵɵproperty("disabled", ctx_r1.pageInputDisabled);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1.itemsPerPageOptions);
    ɵɵadvance();
    ɵɵattribute("ariaLabel", ɵɵpipeBind1(8, 11, ctx_r1.optionsListText.subject));
  }
}
function Pagination_div_2_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 15);
    ɵɵtext(1);
    ɵɵpipe(2, "i18nReplace");
    ɵɵpipe(3, "async");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngStyle", ɵɵpureFunction1(7, _c126, ctx_r1.showPageInput ? null : 0));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind1(3, 5, ɵɵpipeBind2(2, 2, ctx_r1.totalItemText.subject, ɵɵpureFunction3(9, _c219, ctx_r1.startItemIndex, ctx_r1.endItemIndex, ctx_r1.totalDataLength))), " ");
  }
}
function Pagination_div_2_span_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 15);
    ɵɵtext(1);
    ɵɵpipe(2, "i18nReplace");
    ɵɵpipe(3, "async");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngStyle", ɵɵpureFunction1(7, _c126, ctx_r1.showPageInput ? null : 0));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind1(3, 5, ɵɵpipeBind2(2, 2, ctx_r1.totalItemsText.subject, ɵɵpureFunction3(9, _c219, ctx_r1.startItemIndex, ctx_r1.endItemIndex, ctx_r1.totalDataLength))), " ");
  }
}
function Pagination_div_2_span_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 15);
    ɵɵtext(1);
    ɵɵpipe(2, "i18nReplace");
    ɵɵpipe(3, "async");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngStyle", ɵɵpureFunction1(7, _c126, ctx_r1.showPageInput ? null : 0));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind1(3, 5, ɵɵpipeBind2(2, 2, ctx_r1.totalItemsUnknownText.subject, ɵɵpureFunction2(9, _c313, ctx_r1.startItemIndex, ctx_r1.endItemIndex))), " ");
  }
}
function Pagination_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 3);
    ɵɵtemplate(1, Pagination_div_2_ng_container_1_Template, 9, 13, "ng-container", 7)(2, Pagination_div_2_span_2_Template, 4, 13, "span", 8)(3, Pagination_div_2_span_3_Template, 4, 13, "span", 8)(4, Pagination_div_2_span_4_Template, 4, 12, "span", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.showPageInput);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.pagesUnknown && ctx_r1.totalDataLength <= 1);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.pagesUnknown && ctx_r1.totalDataLength > 1);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.pagesUnknown);
  }
}
function Pagination_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 16);
    ɵɵelement(1, "p", 4);
    ɵɵelementEnd();
  }
}
function Pagination_div_4_span_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.currentPage);
  }
}
function Pagination_div_4_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 24);
    ɵɵtemplate(1, Pagination_div_4_span_1_ng_container_1_Template, 2, 1, "ng-container", 7);
    ɵɵtext(2);
    ɵɵpipe(3, "async");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.showPageInput);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind1(3, 2, ctx_r1.pageText.subject), " ");
  }
}
function Pagination_div_4_ng_container_2_input_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "input", 30);
    ɵɵtwoWayListener("ngModelChange", function Pagination_div_4_ng_container_2_input_5_Template_input_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext(3);
      ɵɵtwoWayBindingSet(ctx_r1.currentPage, $event) || (ctx_r1.currentPage = $event);
      return ɵɵresetView($event);
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("id", ctx_r1.currentPageSelectId)("max", ctx_r1.pageOptions.length);
    ɵɵtwoWayProperty("ngModel", ctx_r1.currentPage);
  }
}
function Pagination_div_4_ng_container_2_select_6_option_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "option", 14);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const i_r7 = ctx.index;
    ɵɵproperty("value", i_r7 + 1);
    ɵɵadvance();
    ɵɵtextInterpolate(i_r7 + 1);
  }
}
function Pagination_div_4_ng_container_2_select_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "select", 31);
    ɵɵtwoWayListener("ngModelChange", function Pagination_div_4_ng_container_2_select_6_Template_select_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext(3);
      ɵɵtwoWayBindingSet(ctx_r1.currentPage, $event) || (ctx_r1.currentPage = $event);
      return ɵɵresetView($event);
    });
    ɵɵtemplate(1, Pagination_div_4_ng_container_2_select_6_option_1_Template, 2, 2, "option", 12);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("id", ctx_r1.currentPageSelectId)("disabled", ctx_r1.pageInputDisabled);
    ɵɵtwoWayProperty("ngModel", ctx_r1.currentPage);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1.pageOptions);
  }
}
function Pagination_div_4_ng_container_2__svg_svg_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 32);
    ɵɵpipe(1, "async");
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵattribute("ariaLabel", ɵɵpipeBind1(1, 1, ctx_r1.optionsListText.subject));
  }
}
function Pagination_div_4_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 25)(2, "label", 26);
    ɵɵtext(3);
    ɵɵpipe(4, "async");
    ɵɵelementEnd();
    ɵɵtemplate(5, Pagination_div_4_ng_container_2_input_5_Template, 1, 3, "input", 27)(6, Pagination_div_4_ng_container_2_select_6_Template, 2, 4, "select", 28)(7, Pagination_div_4_ng_container_2__svg_svg_7_Template, 2, 3, "svg", 29);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵclassProp("cds--select--disabled", ctx_r1.pageInputDisabled);
    ɵɵadvance();
    ɵɵproperty("for", ctx_r1.currentPageSelectId);
    ɵɵadvance();
    ɵɵtextInterpolate(ɵɵpipeBind1(4, 7, ctx_r1.pageText.subject));
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r1.pageOptions.length > ctx_r1.pageSelectThreshold);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.pageOptions.length <= ctx_r1.pageSelectThreshold);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.pageOptions.length <= ctx_r1.pageSelectThreshold);
  }
}
function Pagination_div_4_span_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.currentPage);
  }
}
function Pagination_div_4_span_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 33);
    ɵɵtemplate(1, Pagination_div_4_span_3_ng_container_1_Template, 2, 1, "ng-container", 7);
    ɵɵtext(2);
    ɵɵpipe(3, "i18nReplace");
    ɵɵpipe(4, "async");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.showPageInput);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind1(4, 5, ɵɵpipeBind2(3, 2, ctx_r1.ofLastPageText.subject, ɵɵpureFunction1(7, _c58, ctx_r1.lastPage))), " ");
  }
}
function Pagination_div_4_span_4_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.currentPage);
  }
}
function Pagination_div_4_span_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 33);
    ɵɵtemplate(1, Pagination_div_4_span_4_ng_container_1_Template, 2, 1, "ng-container", 7);
    ɵɵtext(2);
    ɵɵpipe(3, "i18nReplace");
    ɵɵpipe(4, "async");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.showPageInput);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind1(4, 5, ɵɵpipeBind2(3, 2, ctx_r1.ofLastPagesText.subject, ɵɵpureFunction1(7, _c58, ctx_r1.lastPage))), " ");
  }
}
function Pagination_div_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 16);
    ɵɵtemplate(1, Pagination_div_4_span_1_Template, 4, 4, "span", 17)(2, Pagination_div_4_ng_container_2_Template, 8, 9, "ng-container", 7)(3, Pagination_div_4_span_3_Template, 5, 9, "span", 18)(4, Pagination_div_4_span_4_Template, 5, 9, "span", 18);
    ɵɵelementStart(5, "div", 19)(6, "button", 20);
    ɵɵpipe(7, "async");
    ɵɵlistener("click", function Pagination_div_4_Template_button_click_6_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.selectPage.emit(ctx_r1.previousPage));
    });
    ɵɵnamespaceSVG();
    ɵɵelement(8, "svg", 21);
    ɵɵelementEnd();
    ɵɵnamespaceHTML();
    ɵɵelementStart(9, "button", 22);
    ɵɵpipe(10, "async");
    ɵɵlistener("click", function Pagination_div_4_Template_button_click_9_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.selectPage.emit(ctx_r1.nextPage));
    });
    ɵɵnamespaceSVG();
    ɵɵelement(11, "svg", 23);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.pagesUnknown);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.showPageInput);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.pagesUnknown && ctx_r1.lastPage <= 1);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.pagesUnknown && ctx_r1.lastPage > 1);
    ɵɵadvance(2);
    ɵɵproperty("ngClass", ɵɵpureFunction1(14, _c410, ctx_r1.currentPage <= 1 || ctx_r1.disabled))("disabled", ctx_r1.currentPage <= 1 || ctx_r1.disabled ? true : null);
    ɵɵattribute("aria-label", ɵɵpipeBind1(7, 10, ctx_r1.backwardText.subject));
    ɵɵadvance(3);
    ɵɵproperty("ngClass", ɵɵpureFunction1(16, _c410, ctx_r1.currentPage >= ctx_r1.lastPage || ctx_r1.disabled))("disabled", ctx_r1.currentPage >= ctx_r1.lastPage || ctx_r1.disabled ? true : null);
    ɵɵattribute("aria-label", ɵɵpipeBind1(10, 12, ctx_r1.forwardText.subject));
  }
}
var _c65 = (a0) => ({
  "cds--pagination-nav__page--active": a0
});
function PaginationOverflow_li_0_option_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "option");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const i_r3 = ctx.index;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.fromIndex + i_r3 + 1, " ");
  }
}
function PaginationOverflow_li_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "li", 2)(1, "div", 3)(2, "select", 4);
    ɵɵlistener("change", function PaginationOverflow_li_0_Template_select_change_2_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleChange($event));
    });
    ɵɵelement(3, "option", 5);
    ɵɵtemplate(4, PaginationOverflow_li_0_option_4_Template, 2, 1, "option", 6);
    ɵɵelementEnd();
    ɵɵelementStart(5, "div", 7);
    ɵɵnamespaceSVG();
    ɵɵelement(6, "svg", 8);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵattribute("aria-label", ctx_r1.ariaLabel);
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r1.countAsArray);
  }
}
function PaginationOverflow_cds_pagination_nav_item_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-pagination-nav-item", 9);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("page", ctx_r1.fromIndex + 1);
  }
}
function PaginationNav_cds_pagination_nav_item_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "cds-pagination-nav-item", 10);
    ɵɵlistener("click", function PaginationNav_cds_pagination_nav_item_7_Template_cds_pagination_nav_item_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.currentPage = 1);
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("isActive", ctx_r1.currentPage == 1);
  }
}
function PaginationNav_cds_pagination_overflow_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "cds-pagination-overflow", 11);
    ɵɵlistener("change", function PaginationNav_cds_pagination_overflow_8_Template_cds_pagination_overflow_change_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleOverflowSelection($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("count", ctx_r1.frontCuts)("fromIndex", ctx_r1.startOffset);
  }
}
function PaginationNav_cds_pagination_nav_item_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "cds-pagination-nav-item", 12);
    ɵɵlistener("click", function PaginationNav_cds_pagination_nav_item_9_Template_cds_pagination_nav_item_click_0_listener() {
      const page_r5 = ɵɵrestoreView(_r4).$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.currentPage = page_r5);
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const page_r5 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("page", page_r5)("isActive", ctx_r1.currentPage == page_r5);
  }
}
function PaginationNav_cds_pagination_overflow_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "cds-pagination-overflow", 11);
    ɵɵlistener("change", function PaginationNav_cds_pagination_overflow_10_Template_cds_pagination_overflow_change_0_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleOverflowSelection($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("count", ctx_r1.backCuts)("fromIndex", ctx_r1.totalNumbersArray.length - ctx_r1.backCuts - 1);
  }
}
function PaginationNav_cds_pagination_nav_item_11_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "cds-pagination-nav-item", 12);
    ɵɵlistener("click", function PaginationNav_cds_pagination_nav_item_11_Template_cds_pagination_nav_item_click_0_listener() {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.currentPage = ctx_r1.totalNumbersArray.length);
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("page", ctx_r1.totalNumbersArray.length)("isActive", ctx_r1.currentPage == ctx_r1.totalNumbersArray.length);
  }
}
var PaginationModel = class {
  constructor() {
    this.currentPage = 1;
    this.pageLength = 10;
    this.totalDataLength = 0;
  }
};
var Pagination = class _Pagination {
  constructor(i18n, experimental) {
    this.i18n = i18n;
    this.experimental = experimental;
    this.skeleton = false;
    this.disabled = false;
    this.pageInputDisabled = false;
    this.showPageInput = true;
    this.pagesUnknown = false;
    this.pageSelectThreshold = 1e3;
    this.itemsPerPageOptions = [10, 20, 30, 40, 50];
    this.selectPage = new EventEmitter();
    this.itemsPerPageSelectId = `pagination-select-items-per-page-${_Pagination.paginationCounter}`;
    this.currentPageSelectId = `pagination-select-current-page-${_Pagination.paginationCounter}`;
    this.itemsPerPageText = this.i18n.getOverridable("PAGINATION.ITEMS_PER_PAGE");
    this.optionsListText = this.i18n.getOverridable("PAGINATION.OPEN_LIST_OF_OPTIONS");
    this.backwardText = this.i18n.getOverridable("PAGINATION.BACKWARD");
    this.forwardText = this.i18n.getOverridable("PAGINATION.FORWARD");
    this.totalItemsText = this.i18n.getOverridable("PAGINATION.TOTAL_ITEMS");
    this.totalItemText = this.i18n.getOverridable("PAGINATION.TOTAL_ITEM");
    this.totalItemsUnknownText = this.i18n.getOverridable("PAGINATION.TOTAL_ITEMS_UNKNOWN");
    this.pageText = this.i18n.getOverridable("PAGINATION.PAGE");
    this.ofLastPagesText = this.i18n.getOverridable("PAGINATION.OF_LAST_PAGES");
    this.ofLastPageText = this.i18n.getOverridable("PAGINATION.OF_LAST_PAGE");
    this._pageOptions = [];
    _Pagination.paginationCounter++;
  }
  /**
   * Expects an object that contains some or all of:
   * ```
   * {
   *		"ITEMS_PER_PAGE": "Items per page:",
   *		"OPEN_LIST_OF_OPTIONS": "Open list of options",
   *		"BACKWARD": "Backward",
   *		"FORWARD": "Forward",
   *		"TOTAL_ITEMS_UNKNOWN": "{{start}}-{{end}} items",
   *		"TOTAL_ITEMS": "{{start}}-{{end}} of {{total}} items",
   *		"TOTAL_ITEM": "{{start}}-{{end}} of {{total}} item",
   *		"OF_LAST_PAGES": "of {{last}} pages",
   *		"OF_LAST_PAGE": "of {{last}} page"
   * }
   * ```
   */
  set translations(value) {
    const valueWithDefaults = merge2(this.i18n.getMultiple("PAGINATION"), value);
    this.itemsPerPageText.override(valueWithDefaults.ITEMS_PER_PAGE);
    this.optionsListText.override(valueWithDefaults.OPEN_LIST_OF_OPTIONS);
    this.backwardText.override(valueWithDefaults.BACKWARD);
    this.forwardText.override(valueWithDefaults.FORWARD);
    this.totalItemsText.override(valueWithDefaults.TOTAL_ITEMS);
    this.totalItemText.override(valueWithDefaults.TOTAL_ITEM);
    this.totalItemsUnknownText.override(valueWithDefaults.TOTAL_ITEMS_UNKNOWN);
    this.pageText.override(valueWithDefaults.PAGE);
    this.ofLastPagesText.override(valueWithDefaults.OF_LAST_PAGES);
    this.ofLastPageText.override(valueWithDefaults.OF_LAST_PAGE);
  }
  get itemsPerPage() {
    return this.model.pageLength;
  }
  set itemsPerPage(value) {
    this.model.pageLength = Number(value);
    this.currentPage = 1;
  }
  get currentPage() {
    return this.model.currentPage;
  }
  set currentPage(value) {
    value = Number(value);
    this.selectPage.emit(value);
  }
  get totalDataLength() {
    return this.model.totalDataLength;
  }
  /**
   * The last page number to display in the pagination view.
   */
  get lastPage() {
    const last = Math.ceil(this.totalDataLength / this.itemsPerPage);
    return last > 0 ? last : 1;
  }
  get startItemIndex() {
    return this.endItemIndex > 0 ? (this.currentPage - 1) * this.itemsPerPage + 1 : 0;
  }
  get endItemIndex() {
    const projectedEndItemIndex = this.currentPage * this.itemsPerPage;
    return projectedEndItemIndex < this.totalDataLength ? projectedEndItemIndex : this.totalDataLength;
  }
  /**
   * The previous page number to navigate to, from the current page.
   */
  get previousPage() {
    return this.currentPage <= 1 ? 1 : this.currentPage - 1;
  }
  /**
   * The next page number to navigate to, from the current page.
   */
  get nextPage() {
    const lastPage = this.lastPage;
    return this.currentPage >= lastPage ? lastPage : this.currentPage + 1;
  }
  get pageOptions() {
    const numberOfPages = Math.max(Math.ceil(this.totalDataLength / this.itemsPerPage), 1);
    if (this._pageOptions.length !== numberOfPages) {
      this._pageOptions = Array(numberOfPages);
    }
    return this._pageOptions;
  }
};
Pagination.paginationCounter = 0;
Pagination.ɵfac = function Pagination_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Pagination)(ɵɵdirectiveInject(I18n), ɵɵdirectiveInject(ExperimentalService));
};
Pagination.ɵcmp = ɵɵdefineComponent({
  type: Pagination,
  selectors: [["cds-pagination"], ["ibm-pagination"]],
  inputs: {
    skeleton: "skeleton",
    model: "model",
    disabled: "disabled",
    pageInputDisabled: "pageInputDisabled",
    showPageInput: "showPageInput",
    pagesUnknown: "pagesUnknown",
    pageSelectThreshold: "pageSelectThreshold",
    translations: "translations",
    itemsPerPageOptions: "itemsPerPageOptions"
  },
  outputs: {
    selectPage: "selectPage"
  },
  standalone: false,
  decls: 5,
  vars: 7,
  consts: [[1, "cds--pagination", 3, "ngClass"], ["class", "cds--pagination__left", 4, "ngIf"], ["class", "cds--pagination__right", 4, "ngIf"], [1, "cds--pagination__left"], [1, "cds--skeleton__text", 2, "width", "70px"], [1, "cds--skeleton__text", 2, "width", "35px"], [1, "cds--skeleton__text", 2, "width", "105px"], [4, "ngIf"], ["class", "cds--pagination__text cds--pagination__items-count", 3, "ngStyle", 4, "ngIf"], [1, "cds--pagination__text", 3, "for"], [1, "cds--select", "cds--select--inline", "cds--select__item-count"], [1, "cds--select-input", 3, "ngModelChange", "id", "ngModel", "disabled"], ["class", "cds--select-option", 3, "value", 4, "ngFor", "ngForOf"], ["cdsIcon", "chevron--down", "size", "16", "aria-hidden", "true", 1, "cds--select__arrow", 2, "display", "inherit"], [1, "cds--select-option", 3, "value"], [1, "cds--pagination__text", "cds--pagination__items-count", 3, "ngStyle"], [1, "cds--pagination__right"], ["class", "cds--pagination__text cds--pagination__page-text", 4, "ngIf"], ["class", "cds--pagination__text", 4, "ngIf"], [1, "cds--pagination__control-buttons"], ["cdsButton", "ghost", "iconOnly", "true", "tabindex", "0", 1, "cds--pagination__button", "cds--pagination__button--backward", 3, "click", "ngClass", "disabled"], ["cdsIcon", "caret--left", "size", "16", 1, "cds--btn__icon"], ["cdsButton", "ghost", "iconOnly", "true", "tabindex", "0", 1, "cds--pagination__button", "cds--pagination__button--forward", 3, "click", "ngClass", "disabled"], ["cdsIcon", "caret--right", "size", "16", 1, "cds--btn__icon"], [1, "cds--pagination__text", "cds--pagination__page-text"], [1, "cds--select", "cds--select--inline", "cds--select__page-number"], [1, "cds--label", "cds--visually-hidden", 3, "for"], ["style", "padding-right: 1rem; margin-right: 1rem;", "type", "number", "min", "1", "class", "cds--select-input", 3, "id", "max", "ngModel", "ngModelChange", 4, "ngIf"], ["class", "cds--select-input", 3, "id", "disabled", "ngModel", "ngModelChange", 4, "ngIf"], ["cdsIcon", "chevron--down", "size", "16", "style", "display: inherit;", "class", "cds--select__arrow", 4, "ngIf"], ["type", "number", "min", "1", 1, "cds--select-input", 2, "padding-right", "1rem", "margin-right", "1rem", 3, "ngModelChange", "id", "max", "ngModel"], [1, "cds--select-input", 3, "ngModelChange", "id", "disabled", "ngModel"], ["cdsIcon", "chevron--down", "size", "16", 1, "cds--select__arrow", 2, "display", "inherit"], [1, "cds--pagination__text"]],
  template: function Pagination_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵtemplate(1, Pagination_div_1_Template, 4, 0, "div", 1)(2, Pagination_div_2_Template, 5, 4, "div", 1)(3, Pagination_div_3_Template, 2, 0, "div", 2)(4, Pagination_div_4_Template, 12, 18, "div", 2);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngClass", ɵɵpureFunction1(5, _c027, ctx.skeleton));
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.skeleton);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.skeleton);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.skeleton);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.skeleton);
    }
  },
  dependencies: [NgClass, NgForOf, NgIf, NgStyle, NgSelectOption, ɵNgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, SelectControlValueAccessor, NgControlStatus, MinValidator, MaxValidator, NgModel, IconDirective, Button, AsyncPipe, ReplacePipe],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Pagination, [{
    type: Component,
    args: [{
      selector: "cds-pagination, ibm-pagination",
      template: `
	<div
		class="cds--pagination"
		[ngClass]="{
			'cds--skeleton': skeleton
		}">
		<!-- left skeleton div -->
		<div *ngIf="skeleton" class="cds--pagination__left">
			<p class="cds--skeleton__text" style="width: 70px"></p>
			<p class="cds--skeleton__text" style="width: 35px"></p>
			<p class="cds--skeleton__text" style="width: 105px"></p>
		</div>

		<div *ngIf="!skeleton" class="cds--pagination__left">
			<ng-container *ngIf="showPageInput">
				<label class="cds--pagination__text" [for]="itemsPerPageSelectId">
					{{itemsPerPageText.subject | async}}
				</label>
				<div
					class="cds--select cds--select--inline cds--select__item-count"
					[class.cds--select--disabled]="pageInputDisabled">
					<select
						[id]="itemsPerPageSelectId"
						[(ngModel)]="itemsPerPage"
						[disabled]="pageInputDisabled"
						class="cds--select-input">
						<option
							class="cds--select-option"
							*ngFor="let option of itemsPerPageOptions"
							[value]="option">
								{{ option }}
						</option>
					</select>
					<svg
						cdsIcon="chevron--down"
						size="16"
						style="display: inherit"
						class="cds--select__arrow"
						aria-hidden="true"
						[attr.ariaLabel]="optionsListText.subject | async">
					</svg>
				</div>
			</ng-container>
			<span *ngIf="!pagesUnknown && totalDataLength <= 1" class="cds--pagination__text cds--pagination__items-count" [ngStyle]="{'margin-left': showPageInput ? null : 0}">
				{{totalItemText.subject | i18nReplace:{start: startItemIndex, end: endItemIndex, total: totalDataLength } | async}}
			</span>
			<span *ngIf="!pagesUnknown && totalDataLength > 1" class="cds--pagination__text cds--pagination__items-count" [ngStyle]="{'margin-left': showPageInput ? null : 0}">
				{{totalItemsText.subject | i18nReplace:{start: startItemIndex, end: endItemIndex, total: totalDataLength } | async}}
			</span>
			<span *ngIf="pagesUnknown" class="cds--pagination__text cds--pagination__items-count" [ngStyle]="{'margin-left': showPageInput ? null : 0}">
				{{totalItemsUnknownText.subject | i18nReplace:{start: startItemIndex, end: endItemIndex } | async}}
			</span>
		</div>

		<!-- right skeleton div -->
		<div *ngIf="skeleton" class="cds--pagination__right">
			<p class="cds--skeleton__text" style="width: 70px"></p>
		</div>

		<div *ngIf="!skeleton" class="cds--pagination__right">
			<span *ngIf="pagesUnknown" class="cds--pagination__text cds--pagination__page-text">
				<ng-container *ngIf="!showPageInput">{{currentPage}}</ng-container>
				{{pageText.subject | async}}
			</span>
			<ng-container *ngIf="showPageInput">
				<div
					class="cds--select cds--select--inline cds--select__page-number"
					[class.cds--select--disabled]="pageInputDisabled">
					<label [for]="currentPageSelectId" class="cds--label cds--visually-hidden">{{pageText.subject | async}}</label>
					<input
						*ngIf="pageOptions.length > pageSelectThreshold"
						style="padding-right: 1rem; margin-right: 1rem;"
						[id]="currentPageSelectId"
						type="number"
						min="1"
						[max]="pageOptions.length"
						class="cds--select-input"
						[(ngModel)]="currentPage">
					<select
						*ngIf="pageOptions.length <= pageSelectThreshold"
						[id]="currentPageSelectId"
						class="cds--select-input"
						[disabled]="pageInputDisabled"
						[(ngModel)]="currentPage">
						<option *ngFor="let page of pageOptions; let i = index;" class="cds--select-option" [value]="i + 1">{{i + 1}}</option>
					</select>
					<svg
						*ngIf="pageOptions.length <= pageSelectThreshold"
						cdsIcon="chevron--down"
						size="16"
						style="display: inherit;"
						class="cds--select__arrow"
						[attr.ariaLabel]="optionsListText.subject | async">
					</svg>
				</div>
			</ng-container>

			<span *ngIf="!pagesUnknown && lastPage <= 1" class="cds--pagination__text">
				<ng-container *ngIf="!showPageInput">{{currentPage}}</ng-container>
				{{ofLastPageText.subject | i18nReplace: {last: lastPage} | async}}
			</span>
			<span *ngIf="!pagesUnknown && lastPage > 1" class="cds--pagination__text">
				<ng-container *ngIf="!showPageInput">{{currentPage}}</ng-container>
				{{ofLastPagesText.subject | i18nReplace: {last: lastPage} | async}}
			</span>
			<div class="cds--pagination__control-buttons">
				<button
					cdsButton="ghost"
					iconOnly="true"
					class="cds--pagination__button cds--pagination__button--backward"
					[ngClass]="{
						'cds--pagination__button--no-index': currentPage <= 1 || disabled
					}"
					tabindex="0"
					[attr.aria-label]="backwardText.subject | async"
					(click)="selectPage.emit(previousPage)"
					[disabled]="(currentPage <= 1 || disabled ? true : null)">
					<svg cdsIcon="caret--left" size="16" class="cds--btn__icon"></svg>
				</button>

				<button
					cdsButton="ghost"
					iconOnly="true"
					class="
						cds--pagination__button
						cds--pagination__button--forward"
					[ngClass]="{
						'cds--pagination__button--no-index': currentPage >= lastPage || disabled
					}"
					tabindex="0"
					[attr.aria-label]="forwardText.subject | async"
					(click)="selectPage.emit(nextPage)"
					[disabled]="(currentPage >= lastPage || disabled ? true : null)">
					<svg cdsIcon="caret--right" size="16" class="cds--btn__icon"></svg>
				</button>
			</div>
		</div>
	</div>
	`
    }]
  }], function() {
    return [{
      type: I18n
    }, {
      type: ExperimentalService
    }];
  }, {
    skeleton: [{
      type: Input
    }],
    model: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    pageInputDisabled: [{
      type: Input
    }],
    showPageInput: [{
      type: Input
    }],
    pagesUnknown: [{
      type: Input
    }],
    pageSelectThreshold: [{
      type: Input
    }],
    translations: [{
      type: Input
    }],
    itemsPerPageOptions: [{
      type: Input
    }],
    selectPage: [{
      type: Output
    }]
  });
})();
var PaginationNavItem = class {
  constructor() {
    this.page = 0;
    this.isActive = false;
    this.click = new EventEmitter();
  }
};
PaginationNavItem.ɵfac = function PaginationNavItem_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || PaginationNavItem)();
};
PaginationNavItem.ɵcmp = ɵɵdefineComponent({
  type: PaginationNavItem,
  selectors: [["cds-pagination-nav-item"], ["ibm-pagination-nav-item"]],
  inputs: {
    page: "page",
    isActive: "isActive"
  },
  outputs: {
    click: "click"
  },
  standalone: false,
  decls: 5,
  vars: 5,
  consts: [[1, "cds--pagination-nav__list-item"], ["type", "button", 1, "cds--pagination-nav__page", 3, "click", "ngClass"], [1, "cds--pagination-nav__accessibility-label"]],
  template: function PaginationNavItem_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "li", 0)(1, "button", 1);
      ɵɵlistener("click", function PaginationNavItem_Template_button_click_1_listener() {
        return ctx.click.emit(ctx.page);
      });
      ɵɵelementStart(2, "span", 2);
      ɵɵtext(3);
      ɵɵelementEnd();
      ɵɵtext(4);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngClass", ɵɵpureFunction1(3, _c65, ctx.isActive));
      ɵɵadvance(2);
      ɵɵtextInterpolate1(" ", ctx.page, " ");
      ɵɵadvance();
      ɵɵtextInterpolate1(" ", ctx.page, " ");
    }
  },
  dependencies: [NgClass],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PaginationNavItem, [{
    type: Component,
    args: [{
      selector: "cds-pagination-nav-item, ibm-pagination-nav-item",
      template: `
		<li class="cds--pagination-nav__list-item">
			<button
				type="button"
				class="cds--pagination-nav__page"
				[ngClass]="{ 'cds--pagination-nav__page--active': isActive }"
				(click)="click.emit(page)">
				<span class="cds--pagination-nav__accessibility-label">
					{{page}}
				</span>
				{{page}}
			</button>
		</li>
	`
    }]
  }], function() {
    return [];
  }, {
    page: [{
      type: Input
    }],
    isActive: [{
      type: Input
    }],
    click: [{
      type: Output
    }]
  });
})();
var PaginationOverflow = class {
  constructor(i18n) {
    this.i18n = i18n;
    this.ariaLabel = this.i18n.get().PAGINATION.SELECT_ARIA;
    this.change = new EventEmitter();
  }
  get countAsArray() {
    return [...Array(this.count)];
  }
  handleChange(event) {
    this.change.emit(+event.target.value);
    event.target.value = "";
  }
};
PaginationOverflow.ɵfac = function PaginationOverflow_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || PaginationOverflow)(ɵɵdirectiveInject(I18n));
};
PaginationOverflow.ɵcmp = ɵɵdefineComponent({
  type: PaginationOverflow,
  selectors: [["cds-pagination-overflow"], ["ibm-pagination-overflow"]],
  inputs: {
    fromIndex: "fromIndex",
    count: "count",
    ariaLabel: "ariaLabel"
  },
  outputs: {
    change: "change"
  },
  standalone: false,
  decls: 2,
  vars: 2,
  consts: [["class", "cds--pagination-nav__list-item", 4, "ngIf"], [3, "page", 4, "ngIf"], [1, "cds--pagination-nav__list-item"], [1, "cds--pagination-nav__select"], [1, "cds--pagination-nav__page", "cds--pagination-nav__page--select", 3, "change"], ["value", "", "hidden", ""], [4, "ngFor", "ngForOf"], [1, "cds--pagination-nav__select-icon-wrapper"], ["cdsIcon", "overflow-menu--horizontal", "size", "16", 1, "cds--pagination-nav__select-icon", 2, "display", "inherit"], [3, "page"]],
  template: function PaginationOverflow_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, PaginationOverflow_li_0_Template, 7, 2, "li", 0)(1, PaginationOverflow_cds_pagination_nav_item_1_Template, 1, 1, "cds-pagination-nav-item", 1);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.count > 1);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.count === 1);
    }
  },
  dependencies: [NgForOf, NgIf, NgSelectOption, ɵNgSelectMultipleOption, IconDirective, PaginationNavItem],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PaginationOverflow, [{
    type: Component,
    args: [{
      selector: "cds-pagination-overflow, ibm-pagination-overflow",
      template: `
		<li class="cds--pagination-nav__list-item" *ngIf="count > 1">
			<div class="cds--pagination-nav__select">
			<select
				[attr.aria-label]="ariaLabel"
				class="cds--pagination-nav__page cds--pagination-nav__page--select"
				(change)="handleChange($event)">
				<option value="" hidden></option>
				<option
				*ngFor="let item of countAsArray; let i = index">
					{{fromIndex + i + 1}}
				</option>
			</select>
			<div class="cds--pagination-nav__select-icon-wrapper">
				<svg
					cdsIcon="overflow-menu--horizontal"
					size="16"
					style="display: inherit"
					class="cds--pagination-nav__select-icon">
				</svg>
			</div>
			</div>
		</li>
		<cds-pagination-nav-item *ngIf="count === 1" [page]="fromIndex + 1"></cds-pagination-nav-item>
	`
    }]
  }], function() {
    return [{
      type: I18n
    }];
  }, {
    fromIndex: [{
      type: Input
    }],
    count: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    change: [{
      type: Output
    }]
  });
})();
var PaginationNav = class _PaginationNav {
  constructor(i18n, experimental) {
    this.i18n = i18n;
    this.experimental = experimental;
    this.disabled = false;
    this.numOfItemsToShow = 4;
    this.size = "lg";
    this.selectPage = new EventEmitter();
    this.nextItemText = this.i18n.getOverridable("PAGINATION.NEXT");
    this.previousItemText = this.i18n.getOverridable("PAGINATION.PREVIOUS");
    _PaginationNav.paginationCounter++;
  }
  /**
   * Expects an object that contains some or all of:
   * ```
   * {
   *		"NEXT": "Next",
   *		"PREVIOUS": "Previous",
   * }
   * ```
   */
  set translations(value) {
    const valueWithDefaults = merge2(this.i18n.getMultiple("PAGINATION"), value);
    this.nextItemText.override(valueWithDefaults.NEXT);
    this.previousItemText.override(valueWithDefaults.PREVIOUS);
  }
  // Size
  get smallLayoutSize() {
    return this.size === "sm";
  }
  get mediumLayoutSize() {
    return this.size === "md";
  }
  get largeLayoutSize() {
    return this.size === "lg";
  }
  get totalNumbersArray() {
    return range(this.totalDataLength + 1, 1);
  }
  get currentPage() {
    return this.model.currentPage;
  }
  set currentPage(value) {
    value = Number(value);
    this.selectPage.emit(value);
  }
  get totalDataLength() {
    return this.model.totalDataLength;
  }
  get startOffset() {
    return this.numOfItemsToShow <= 4 && this.currentPage > 1 ? 0 : 1;
  }
  get frontCuts() {
    const cuts = this.getCuts();
    return cuts.front;
  }
  get backCuts() {
    const cuts = this.getCuts();
    return cuts.back;
  }
  get leftArrowDisabled() {
    return this.disabled || this.currentPage === 1;
  }
  get rightArrowDisabled() {
    return this.disabled || this.currentPage === this.totalDataLength;
  }
  handleOverflowSelection(page) {
    if (typeof page === "number") {
      this.currentPage = page;
    }
  }
  jumpToNext() {
    this.currentPage = this.currentPage < this.totalDataLength ? this.currentPage + 1 : this.totalDataLength;
  }
  jumpToPrevious() {
    this.currentPage = this.currentPage > 1 ? this.currentPage - 1 : 1;
  }
  getPages() {
    if (this.totalDataLength <= 1) {
      return null;
    }
    const cuts = this.getCuts();
    return this.totalNumbersArray.slice(this.startOffset + cuts.front, (1 + cuts.back) * -1);
  }
  getCuts(splitPoint = null) {
    const page = this.currentPage - 1;
    const totalItems = this.totalDataLength;
    const itemsThatFit = this.numOfItemsToShow;
    if (itemsThatFit >= totalItems) {
      return {
        front: 0,
        back: 0
      };
    }
    const split = splitPoint || Math.ceil(itemsThatFit / 2) - 1;
    let frontHidden = page + 1 - split;
    let backHidden = totalItems - page - (itemsThatFit - split) + 1;
    if (frontHidden <= 1) {
      backHidden -= frontHidden <= 0 ? Math.abs(frontHidden) + 1 : 0;
      frontHidden = 0;
    }
    if (backHidden <= 1) {
      frontHidden -= backHidden <= 0 ? Math.abs(backHidden) + 1 : 0;
      backHidden = 0;
    }
    return {
      front: frontHidden,
      back: backHidden
    };
  }
};
PaginationNav.paginationCounter = 0;
PaginationNav.ɵfac = function PaginationNav_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || PaginationNav)(ɵɵdirectiveInject(I18n), ɵɵdirectiveInject(ExperimentalService));
};
PaginationNav.ɵcmp = ɵɵdefineComponent({
  type: PaginationNav,
  selectors: [["cds-pagination-nav"], ["ibm-pagination-navm"]],
  hostVars: 6,
  hostBindings: function PaginationNav_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--layout--size-sm", ctx.smallLayoutSize)("cds--layout--size-md", ctx.mediumLayoutSize)("cds--layout--size-lg", ctx.largeLayoutSize);
    }
  },
  inputs: {
    model: "model",
    disabled: "disabled",
    numOfItemsToShow: "numOfItemsToShow",
    translations: "translations",
    size: "size"
  },
  outputs: {
    selectPage: "selectPage"
  },
  standalone: false,
  decls: 16,
  vars: 15,
  consts: [[1, "cds--pagination-nav"], [1, "cds--pagination-nav__list"], [1, "cds--pagination-nav__list-item"], ["kind", "ghost", 3, "click", "size", "disabled", "description"], ["cdsIcon", "caret--left", "size", "16", 1, "cds--btn__icon"], ["page", "1", 3, "isActive", "click", 4, "ngIf"], [3, "count", "fromIndex", "change", 4, "ngIf"], [3, "page", "isActive", "click", 4, "ngFor", "ngForOf"], [3, "page", "isActive", "click", 4, "ngIf"], ["cdsIcon", "caret--right", "size", "16", 1, "cds--btn__icon"], ["page", "1", 3, "click", "isActive"], [3, "change", "count", "fromIndex"], [3, "click", "page", "isActive"]],
  template: function PaginationNav_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div")(1, "div", 0)(2, "ul", 1)(3, "li", 2)(4, "cds-icon-button", 3);
      ɵɵpipe(5, "async");
      ɵɵlistener("click", function PaginationNav_Template_cds_icon_button_click_4_listener() {
        return ctx.jumpToPrevious();
      });
      ɵɵnamespaceSVG();
      ɵɵelement(6, "svg", 4);
      ɵɵelementEnd()();
      ɵɵtemplate(7, PaginationNav_cds_pagination_nav_item_7_Template, 1, 1, "cds-pagination-nav-item", 5)(8, PaginationNav_cds_pagination_overflow_8_Template, 1, 2, "cds-pagination-overflow", 6)(9, PaginationNav_cds_pagination_nav_item_9_Template, 1, 2, "cds-pagination-nav-item", 7)(10, PaginationNav_cds_pagination_overflow_10_Template, 1, 2, "cds-pagination-overflow", 6)(11, PaginationNav_cds_pagination_nav_item_11_Template, 1, 2, "cds-pagination-nav-item", 8);
      ɵɵnamespaceHTML();
      ɵɵelementStart(12, "li", 2)(13, "cds-icon-button", 3);
      ɵɵpipe(14, "async");
      ɵɵlistener("click", function PaginationNav_Template_cds_icon_button_click_13_listener() {
        return ctx.jumpToNext();
      });
      ɵɵnamespaceSVG();
      ɵɵelement(15, "svg", 9);
      ɵɵelementEnd()()()()();
    }
    if (rf & 2) {
      ɵɵadvance(4);
      ɵɵproperty("size", ctx.size)("disabled", ctx.leftArrowDisabled)("description", ɵɵpipeBind1(5, 11, ctx.previousItemText.subject));
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.numOfItemsToShow >= 5 || ctx.numOfItemsToShow <= 4 && ctx.currentPage <= 1);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.frontCuts);
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.getPages());
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.backCuts);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.totalDataLength > 1);
      ɵɵadvance(2);
      ɵɵproperty("size", ctx.size)("disabled", ctx.rightArrowDisabled)("description", ɵɵpipeBind1(14, 13, ctx.nextItemText.subject));
    }
  },
  dependencies: [NgForOf, NgIf, IconDirective, IconButton, PaginationNavItem, PaginationOverflow, AsyncPipe],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PaginationNav, [{
    type: Component,
    args: [{
      selector: "cds-pagination-nav, ibm-pagination-navm",
      template: `
	<div>
		<div class="cds--pagination-nav">
			<ul class="cds--pagination-nav__list">
				<li class="cds--pagination-nav__list-item">
					<cds-icon-button
						kind="ghost"
						[size]="size"
						(click)="jumpToPrevious()"
						[disabled]="leftArrowDisabled"
						[description]="previousItemText.subject | async">
						<svg
							cdsIcon="caret--left"
							size="16"
							class="cds--btn__icon">
						</svg>
					</cds-icon-button>
				</li>
				<cds-pagination-nav-item
					*ngIf="this.numOfItemsToShow >= 5 || (this.numOfItemsToShow <= 4 && currentPage <= 1)"
					page="1"
					(click)="currentPage = 1"
					[isActive]="currentPage == 1">
				</cds-pagination-nav-item>
				<cds-pagination-overflow
					*ngIf="frontCuts"
					[count]="frontCuts"
					[fromIndex]="startOffset"
					(change)="handleOverflowSelection($event)">
				</cds-pagination-overflow>
				<cds-pagination-nav-item
					*ngFor="let page of getPages();"
					[page]="page"
					(click)="currentPage = page"
					[isActive]="currentPage == page">
				</cds-pagination-nav-item>
				<cds-pagination-overflow
					*ngIf="backCuts"
					[count]="backCuts"
					[fromIndex]="totalNumbersArray.length - backCuts - 1"
					(change)="handleOverflowSelection($event)">
				</cds-pagination-overflow>
				<cds-pagination-nav-item
					*ngIf="totalDataLength > 1"
					[page]="totalNumbersArray.length"
					(click)="currentPage = totalNumbersArray.length"
					[isActive]="currentPage == totalNumbersArray.length">
				</cds-pagination-nav-item>
				<li class="cds--pagination-nav__list-item">
					<cds-icon-button
						kind="ghost"
						[size]="size"
						(click)="jumpToNext()"
						[disabled]="rightArrowDisabled"
						[description]="nextItemText.subject | async">
						<svg
							cdsIcon="caret--right"
							size="16"
							class="cds--btn__icon">
						</svg>
					</cds-icon-button>
				</li>
			</ul>
		</div>
	</div>
	`
    }]
  }], function() {
    return [{
      type: I18n
    }, {
      type: ExperimentalService
    }];
  }, {
    model: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    numOfItemsToShow: [{
      type: Input
    }],
    translations: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    smallLayoutSize: [{
      type: HostBinding,
      args: ["class.cds--layout--size-sm"]
    }],
    mediumLayoutSize: [{
      type: HostBinding,
      args: ["class.cds--layout--size-md"]
    }],
    largeLayoutSize: [{
      type: HostBinding,
      args: ["class.cds--layout--size-lg"]
    }],
    selectPage: [{
      type: Output
    }]
  });
})();
var PaginationModule = class {
};
PaginationModule.ɵfac = function PaginationModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || PaginationModule)();
};
PaginationModule.ɵmod = ɵɵdefineNgModule({
  type: PaginationModule,
  declarations: [Pagination, PaginationNav, PaginationNavItem, PaginationOverflow],
  imports: [CommonModule, FormsModule, I18nModule, ExperimentalModule, IconModule, ButtonModule],
  exports: [Pagination, PaginationNav, PaginationNavItem, PaginationOverflow]
});
PaginationModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, FormsModule, I18nModule, ExperimentalModule, IconModule, ButtonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PaginationModule, [{
    type: NgModule,
    args: [{
      declarations: [Pagination, PaginationNav, PaginationNavItem, PaginationOverflow],
      exports: [Pagination, PaginationNav, PaginationNavItem, PaginationOverflow],
      imports: [CommonModule, FormsModule, I18nModule, ExperimentalModule, IconModule, ButtonModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-progress-bar.mjs
var _c028 = (a0) => ({
  "transform": a0
});
function ProgressBar_div_0_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.label);
  }
}
function ProgressBar_div_0_3_ng_template_0_Template(rf, ctx) {
}
function ProgressBar_div_0_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ProgressBar_div_0_3_ng_template_0_Template, 0, 0, "ng-template", 9);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.label);
  }
}
function ProgressBar_div_0__svg_svg_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 10);
  }
}
function ProgressBar_div_0__svg_svg_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 11);
  }
}
function ProgressBar_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 4)(1, "span", 5);
    ɵɵtemplate(2, ProgressBar_div_0_ng_container_2_Template, 2, 1, "ng-container", 6)(3, ProgressBar_div_0_3_Template, 1, 1, null, 6);
    ɵɵelementEnd();
    ɵɵtemplate(4, ProgressBar_div_0__svg_svg_4_Template, 1, 0, "svg", 7)(5, ProgressBar_div_0__svg_svg_5_Template, 1, 0, "svg", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("id", ctx_r0.id);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.label));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.label));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isFinished);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isError);
  }
}
function ProgressBar_div_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.helperText);
  }
}
function ProgressBar_div_3_2_ng_template_0_Template(rf, ctx) {
}
function ProgressBar_div_3_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ProgressBar_div_3_2_ng_template_0_Template, 0, 0, "ng-template", 9);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.helperText);
  }
}
function ProgressBar_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 12);
    ɵɵtemplate(1, ProgressBar_div_3_ng_container_1_Template, 2, 1, "ng-container", 6)(2, ProgressBar_div_3_2_Template, 1, 1, null, 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("id", ctx_r0.helperId);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.helperText));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.helperText));
  }
}
var ProgressBar = class _ProgressBar {
  constructor() {
    this.id = `progress-bar-${_ProgressBar.progressBarCounter++}`;
    this.helperId = `progress-bar-helper-${_ProgressBar.progressBarCounter}`;
    this.max = 100;
    this.type = "default";
    this.status = "active";
    this.size = "big";
    this.defaultClass = true;
    this._value = void 0;
  }
  /**
   * Current value
   */
  set value(num) {
    this._value = num;
    if (num > this.max) {
      this._value = this.max;
    }
    if (num < 0) {
      this._value = 0;
    }
    if (this.isError) {
      this._value = 0;
    } else if (this.isFinished) {
      this._value = this.max;
    }
  }
  get value() {
    return this._value;
  }
  get percentage() {
    return `scaleX(${this.value / this.max})`;
  }
  // Size
  get bigBar() {
    return this.size === "big";
  }
  get smallBar() {
    return this.size === "small";
  }
  // Type
  get defaultType() {
    return this.type === "default";
  }
  get indentedType() {
    return this.type === "indented";
  }
  get inlineType() {
    return this.type === "inline";
  }
  // Status
  get isFinished() {
    return this.status === "finished";
  }
  get isError() {
    return this.status === "error";
  }
  get indeterminate() {
    return this.value === void 0 && !this.isFinished && !this.isError;
  }
  isTemplate(value) {
    return value instanceof TemplateRef;
  }
};
ProgressBar.progressBarCounter = 0;
ProgressBar.ɵfac = function ProgressBar_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ProgressBar)();
};
ProgressBar.ɵcmp = ɵɵdefineComponent({
  type: ProgressBar,
  selectors: [["cds-progress-bar"], ["ibm-progress-bar"]],
  hostVars: 18,
  hostBindings: function ProgressBar_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--progress-bar--big", ctx.bigBar)("cds--progress-bar--small", ctx.smallBar)("cds--progress-bar--default", ctx.defaultType)("cds--progress-bar--indented", ctx.indentedType)("cds--progress-bar--inline", ctx.inlineType)("cds--progress-bar--finished", ctx.isFinished)("cds--progress-bar--error", ctx.isError)("cds--progress-bar--indeterminate", ctx.indeterminate)("cds--progress-bar", ctx.defaultClass);
    }
  },
  inputs: {
    value: "value",
    id: "id",
    label: "label",
    helperText: "helperText",
    max: "max",
    type: "type",
    status: "status",
    size: "size"
  },
  standalone: false,
  decls: 4,
  vars: 11,
  consts: [["class", "cds--progress-bar__label", 3, "id", 4, "ngIf"], ["role", "progressbar", 1, "cds--progress-bar__track"], [1, "cds--progress-bar__bar", 3, "ngStyle"], ["class", "cds--progress-bar__helper-text", 3, "id", 4, "ngIf"], [1, "cds--progress-bar__label", 3, "id"], [1, "cds--progress-bar__label-text"], [4, "ngIf"], ["fill", "currentColor", "cdsIcon", "checkmark--filled", "class", "cds--progress-bar__status-icon", 4, "ngIf"], ["fill", "currentColor", "cdsIcon", "error--filled", "class", "cds--progress-bar__status-icon", 4, "ngIf"], [3, "ngTemplateOutlet"], ["fill", "currentColor", "cdsIcon", "checkmark--filled", 1, "cds--progress-bar__status-icon"], ["fill", "currentColor", "cdsIcon", "error--filled", 1, "cds--progress-bar__status-icon"], [1, "cds--progress-bar__helper-text", 3, "id"]],
  template: function ProgressBar_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, ProgressBar_div_0_Template, 6, 5, "div", 0);
      ɵɵelementStart(1, "div", 1);
      ɵɵelement(2, "div", 2);
      ɵɵelementEnd();
      ɵɵtemplate(3, ProgressBar_div_3_Template, 3, 3, "div", 3);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.label);
      ɵɵadvance();
      ɵɵattribute("aria-invalid", ctx.isError)("aria-labelledby", ctx.id)("aria-describedby", ctx.helperText ? ctx.helperId : null)("aria-valuemin", !ctx.indeterminate ? 0 : null)("aria-valuemax", !ctx.indeterminate ? ctx.max : null)("aria-valuenow", !ctx.indeterminate ? ctx.value : null);
      ɵɵadvance();
      ɵɵproperty("ngStyle", ɵɵpureFunction1(9, _c028, !ctx.isFinished && !ctx.isError ? ctx.percentage : null));
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.helperText);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet, NgStyle, IconDirective],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProgressBar, [{
    type: Component,
    args: [{
      selector: "cds-progress-bar, ibm-progress-bar",
      template: `
		<div
			*ngIf="label"
			class="cds--progress-bar__label"
			[id]="id">
			<span class="cds--progress-bar__label-text">
				<ng-container *ngIf="!isTemplate(label)">{{label}}</ng-container>
				<ng-template *ngIf="isTemplate(label)" [ngTemplateOutlet]="label"></ng-template>
			</span>
			<svg
				*ngIf="isFinished"
				fill="currentColor"
				cdsIcon="checkmark--filled"
				class="cds--progress-bar__status-icon">
			</svg>
			<svg
				*ngIf="isError"
				fill="currentColor"
				cdsIcon="error--filled"
				class="cds--progress-bar__status-icon">
			</svg>
		</div>
		<div
			class="cds--progress-bar__track"
			role="progressbar"
			[attr.aria-invalid]="isError"
			[attr.aria-labelledby]="id"
			[attr.aria-describedby]="helperText ? helperId : null"
			[attr.aria-valuemin]="!indeterminate ? 0 : null"
			[attr.aria-valuemax]="!indeterminate ? max : null"
			[attr.aria-valuenow]="!indeterminate ? value : null">
			<div
				class="cds--progress-bar__bar"
				[ngStyle]="{
					'transform': !isFinished && !isError ? percentage : null
				}">
			</div>
		</div>
		<div
			[id]="helperId"
			*ngIf="helperText"
			class="cds--progress-bar__helper-text">
			<ng-container *ngIf="!isTemplate(helperText)">{{helperText}}</ng-container>
			<ng-template *ngIf="isTemplate(helperText)" [ngTemplateOutlet]="helperText"></ng-template>
		</div>
	`
    }]
  }], null, {
    value: [{
      type: Input
    }],
    bigBar: [{
      type: HostBinding,
      args: ["class.cds--progress-bar--big"]
    }],
    smallBar: [{
      type: HostBinding,
      args: ["class.cds--progress-bar--small"]
    }],
    defaultType: [{
      type: HostBinding,
      args: ["class.cds--progress-bar--default"]
    }],
    indentedType: [{
      type: HostBinding,
      args: ["class.cds--progress-bar--indented"]
    }],
    inlineType: [{
      type: HostBinding,
      args: ["class.cds--progress-bar--inline"]
    }],
    isFinished: [{
      type: HostBinding,
      args: ["class.cds--progress-bar--finished"]
    }],
    isError: [{
      type: HostBinding,
      args: ["class.cds--progress-bar--error"]
    }],
    indeterminate: [{
      type: HostBinding,
      args: ["class.cds--progress-bar--indeterminate"]
    }],
    id: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    helperText: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    defaultClass: [{
      type: HostBinding,
      args: ["class.cds--progress-bar"]
    }]
  });
})();
var ProgressBarModule = class {
};
ProgressBarModule.ɵfac = function ProgressBarModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ProgressBarModule)();
};
ProgressBarModule.ɵmod = ɵɵdefineNgModule({
  type: ProgressBarModule,
  declarations: [ProgressBar],
  imports: [CommonModule, IconModule],
  exports: [ProgressBar]
});
ProgressBarModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, IconModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProgressBarModule, [{
    type: NgModule,
    args: [{
      declarations: [ProgressBar],
      exports: [ProgressBar],
      imports: [CommonModule, IconModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-progress-indicator.mjs
var _c029 = (a0, a1, a2) => ({
  "cds--skeleton": a0,
  "cds--progress--vertical": a1,
  "cds--progress--space-equal": a2
});
var _c127 = (a0, a1, a2, a3) => ({
  "cds--progress-step--disabled": a0,
  "cds--progress-step--complete": a1,
  "cds--progress-step--incomplete": a2,
  "cds--progress-step--current": a3
});
var _c220 = (a0) => ({
  "cds--progress-step-button--unclickable": a0
});
var _c314 = (a0) => ({
  "cds--progress__warning": a0
});
function ProgressIndicator_li_1__svg_title_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "title");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const step_r4 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(step_r4.description);
  }
}
function ProgressIndicator_li_1_p_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "p", 11);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const step_r4 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(step_r4.secondaryLabel);
  }
}
function ProgressIndicator_li_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "li", 2)(1, "button", 3);
    ɵɵlistener("click", function ProgressIndicator_li_1_Template_button_click_1_listener() {
      const i_r2 = ɵɵrestoreView(_r1).index;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onClick(i_r2));
    });
    ɵɵelementStart(2, "span", 4);
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵnamespaceSVG();
    ɵɵelementStart(4, "svg", 5);
    ɵɵtemplate(5, ProgressIndicator_li_1__svg_title_5_Template, 2, 1, "title", 6);
    ɵɵelementEnd();
    ɵɵnamespaceHTML();
    ɵɵelementStart(6, "div", 7)(7, "p", 8);
    ɵɵtext(8);
    ɵɵelementEnd();
    ɵɵtemplate(9, ProgressIndicator_li_1_p_9_Template, 2, 1, "p", 9);
    ɵɵelementEnd();
    ɵɵelement(10, "span", 10);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    let tmp_9_0;
    const step_r4 = ctx.$implicit;
    const i_r2 = ctx.index;
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("ngClass", ɵɵpureFunction4(12, _c127, step_r4.disabled, step_r4.complete, !step_r4.complete && i_r2 !== ctx_r2.current, i_r2 === ctx_r2.current));
    ɵɵadvance();
    ɵɵproperty("ngClass", ɵɵpureFunction1(17, _c220, !step_r4.onClick || ctx_r2.current === i_r2))("disabled", step_r4.disabled)("tabindex", ctx_r2.current !== i_r2 && step_r4.onClick && !step_r4.disabled ? 0 : -1)("title", step_r4.label);
    ɵɵattribute("aria-disabled", step_r4.disabled);
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r2.translations[(tmp_9_0 = ctx_r2.getCurrentState(i_r2)) == null ? null : tmp_9_0.toUpperCase()], " ");
    ɵɵadvance();
    ɵɵproperty("cdsIcon", ctx_r2.statusIcons[ctx_r2.getCurrentState(i_r2)])("ngClass", ɵɵpureFunction1(19, _c314, step_r4.invalid && i_r2 !== ctx_r2.current));
    ɵɵadvance();
    ɵɵproperty("ngIf", step_r4.description);
    ɵɵadvance(3);
    ɵɵtextInterpolate(step_r4.label);
    ɵɵadvance();
    ɵɵproperty("ngIf", step_r4.secondaryLabel);
  }
}
var ProgressIndicator = class {
  constructor(i18n) {
    this.i18n = i18n;
    this.stepSelected = new EventEmitter();
    this.translations = this.i18n.get().PROGRESS_INDICATOR;
    this.orientation = "horizontal";
    this.skeleton = false;
    this.spacing = "default";
    this.statusIcons = {
      current: "incomplete",
      complete: "checkmark--outline",
      invalid: "warning",
      incomplete: "circle-dash"
    };
  }
  get current() {
    return this._current;
  }
  set current(current) {
    this._current = current;
    this.setProgressIndicatorStates();
  }
  static skeletonSteps(stepCount) {
    const steps = [];
    for (let i = 0; i < stepCount; i++) {
      steps.push({
        complete: false
      });
    }
    return steps;
  }
  /**
   * Executes click function if `onClick` exists for step
   * `Current` step functions will not be executed
   * @param index number
   */
  onClick(index) {
    if (index !== this.current && typeof this.steps[index].onClick === "function") {
      this.steps[index].onClick();
    }
    this.stepSelected.emit({
      step: this.steps[index],
      index
    });
  }
  /**
   * Gets current state based on weight of the state
   * Weight of state goes from error, incomplete, current, and complete
   *
   * This function is used to determine which icon & translation string to display
   * @param index number
   * @returns string
   */
  getCurrentState(index) {
    if (index === this.current) {
      return "current";
    } else if (this.steps[index].invalid) {
      return "invalid";
    } else if (this.steps[index].complete) {
      return "complete";
    }
    return "incomplete";
  }
  setProgressIndicatorStates() {
    if (this.steps === void 0) {
      return;
    }
    this.steps.forEach((step, index) => {
      if (index < this.current) {
        step.complete = true;
      } else {
        step.complete = false;
      }
    });
  }
};
ProgressIndicator.ɵfac = function ProgressIndicator_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ProgressIndicator)(ɵɵdirectiveInject(I18n));
};
ProgressIndicator.ɵcmp = ɵɵdefineComponent({
  type: ProgressIndicator,
  selectors: [["cds-progress-indicator"], ["ibm-progress-indicator"]],
  inputs: {
    current: "current",
    steps: "steps",
    translations: "translations",
    orientation: "orientation",
    skeleton: "skeleton",
    spacing: "spacing"
  },
  outputs: {
    stepSelected: "stepSelected"
  },
  standalone: false,
  decls: 2,
  vars: 6,
  consts: [["data-progress", "", "data-progress-current", "", 1, "cds--progress", 3, "ngClass"], ["class", "cds--progress-step", 3, "ngClass", 4, "ngFor", "ngForOf"], [1, "cds--progress-step", 3, "ngClass"], ["type", "button", 1, "cds--progress-step-button", 3, "click", "ngClass", "disabled", "tabindex", "title"], [1, "cds--assistive-text"], ["size", "16", 3, "cdsIcon", "ngClass"], [4, "ngIf"], [1, "cds--progress-text"], [1, "cds--progress-label"], ["class", "cds--progress-optional", 4, "ngIf"], [1, "cds--progress-line"], [1, "cds--progress-optional"]],
  template: function ProgressIndicator_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "ul", 0);
      ɵɵtemplate(1, ProgressIndicator_li_1_Template, 11, 21, "li", 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngClass", ɵɵpureFunction3(2, _c029, ctx.skeleton, ctx.orientation === "vertical", ctx.spacing === "equal" && ctx.orientation !== "vertical"));
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.steps);
    }
  },
  dependencies: [NgClass, NgForOf, NgIf, IconDirective],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProgressIndicator, [{
    type: Component,
    args: [{
      selector: "cds-progress-indicator, ibm-progress-indicator",
      template: `
	<ul
		data-progress
		data-progress-current
		class="cds--progress"
		[ngClass]="{
			'cds--skeleton': skeleton,
			'cds--progress--vertical': (orientation === 'vertical'),
			'cds--progress--space-equal': spacing === 'equal' && orientation !== 'vertical'
		}">
		<li
			class="cds--progress-step"
			*ngFor="let step of steps; let i = index"
			[ngClass]="{
				'cds--progress-step--disabled' : step.disabled,
				'cds--progress-step--complete' : step.complete,
				'cds--progress-step--incomplete' : !step.complete && i !== current,
				'cds--progress-step--current': i === current
			}">
			<button
				type="button"
				class="cds--progress-step-button"
				[ngClass]="{
					'cds--progress-step-button--unclickable': !step.onClick || current === i
				}"
				[disabled]="step.disabled"
				[attr.aria-disabled]="step.disabled"
				[tabindex]="(current !== i && step.onClick && !step.disabled) ? 0 : -1"
				[title]="step.label"
				(click)="onClick(i)">
				<span class="cds--assistive-text">
					{{this.translations[getCurrentState(i)?.toUpperCase()]}}
				</span>
				<svg
					[cdsIcon]="statusIcons[getCurrentState(i)]"
					size="16"
					[ngClass]="{
						'cds--progress__warning': step.invalid && i !== current
					}">
					<title *ngIf="step.description">{{step.description}}</title>
				</svg>
				<div class="cds--progress-text">
					<p class="cds--progress-label">{{step.label}}</p>
					<p *ngIf="step.secondaryLabel" class="cds--progress-optional">{{step.secondaryLabel}}</p>
				</div>
				<span class="cds--progress-line"></span>
			</button>
		</li>
	</ul>
	`
    }]
  }], function() {
    return [{
      type: I18n
    }];
  }, {
    current: [{
      type: Input
    }],
    steps: [{
      type: Input
    }],
    stepSelected: [{
      type: Output
    }],
    translations: [{
      type: Input
    }],
    orientation: [{
      type: Input
    }],
    skeleton: [{
      type: Input
    }],
    spacing: [{
      type: Input
    }]
  });
})();
var ProgressIndicatorModule = class {
};
ProgressIndicatorModule.ɵfac = function ProgressIndicatorModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ProgressIndicatorModule)();
};
ProgressIndicatorModule.ɵmod = ɵɵdefineNgModule({
  type: ProgressIndicatorModule,
  declarations: [ProgressIndicator],
  imports: [CommonModule, IconModule, I18nModule],
  exports: [ProgressIndicator]
});
ProgressIndicatorModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, IconModule, I18nModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ProgressIndicatorModule, [{
    type: NgModule,
    args: [{
      declarations: [ProgressIndicator],
      exports: [ProgressIndicator],
      imports: [CommonModule, IconModule, I18nModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-search.mjs
var _c030 = ["input"];
var _c128 = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) => ({
  "cds--search--sm": a0,
  "cds--search--md": a1,
  "cds--search--lg": a2,
  "cds--search--light": a3,
  "cds--skeleton": a4,
  "cds--search--expandable": a5,
  "cds--search--expanded": a6,
  "cds--toolbar-search": a7,
  "cds--toolbar-search--active": a8,
  "cds--toolbar-search-container-persistent": a9,
  "cds--toolbar-search-container-expandable": a10,
  "cds--toolbar-search-container-active": a11,
  "cds--search--fluid": a12,
  "cds--search--disabled": a13
});
var _c221 = (a0) => ({
  "cds--skeleton": a0
});
var _c315 = (a0) => ({
  "cds--search-close--hidden": a0
});
function Search_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 6);
  }
}
function Search_ng_template_4_button_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 10);
    ɵɵlistener("click", function Search_ng_template_4_button_2_Template_button_click_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.openSearch());
    });
    ɵɵnamespaceSVG();
    ɵɵelement(1, "svg", 11);
    ɵɵelementEnd();
  }
}
function Search_ng_template_4__svg_svg_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 11);
  }
}
function Search_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "input", 7, 1);
    ɵɵlistener("input", function Search_ng_template_4_Template_input_input_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onSearch($event.target.value));
    })("keyup.enter", function Search_ng_template_4_Template_input_keyup_enter_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onEnter());
    });
    ɵɵelementEnd();
    ɵɵtemplate(2, Search_ng_template_4_button_2_Template, 2, 0, "button", 8)(3, Search_ng_template_4__svg_svg_3_Template, 1, 0, "svg", 9);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("type", ctx_r2.tableSearch || !ctx_r2.toolbar ? "text" : "search")("id", ctx_r2.id)("value", ctx_r2.value)("autocomplete", ctx_r2.autocomplete)("placeholder", ctx_r2.placeholder)("disabled", ctx_r2.disabled)("required", ctx_r2.required);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", !ctx_r2.tableSearch && ctx_r2.toolbar);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.tableSearch || !ctx_r2.toolbar);
  }
}
function Search_button_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 12);
    ɵɵlistener("click", function Search_button_6_Template_button_click_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.clearSearch());
    });
    ɵɵelementStart(1, "span", 13);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵnamespaceSVG();
    ɵɵelement(3, "svg", 14);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("ngClass", ɵɵpureFunction1(3, _c315, !ctx_r2.value || ctx_r2.value.length === 0))("title", ctx_r2.clearButtonTitle);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r2.clearButtonTitle);
  }
}
var Search = class _Search {
  /**
   * Creates an instance of `Search`.
   * @param i18n The i18n translations.
   */
  constructor(elementRef, i18n) {
    this.elementRef = elementRef;
    this.i18n = i18n;
    this.theme = "dark";
    this.size = "md";
    this.disabled = false;
    this.toolbar = false;
    this.expandable = false;
    this.skeleton = false;
    this.active = false;
    this.tableSearch = false;
    this.id = `search-${_Search.searchCount}`;
    this.value = "";
    this.autocomplete = "on";
    this.label = this.i18n.get().SEARCH.LABEL;
    this.placeholder = this.i18n.get().SEARCH.PLACEHOLDER;
    this.clearButtonTitle = this.i18n.get().SEARCH.CLEAR_BUTTON;
    this.searchTitle = "";
    this.fluid = false;
    this.valueChange = new EventEmitter();
    this.open = new EventEmitter();
    this.clear = new EventEmitter();
    this.search = new EventEmitter();
    this.isComposing = false;
    this.onTouched = () => {
    };
    this.propagateChange = (_) => {
    };
    _Search.searchCount++;
  }
  get containerClass() {
    return !(this.toolbar || this.expandable);
  }
  get fluidSkeletonClass() {
    return this.skeleton && this.fluid;
  }
  /**
   * This is the initial value set to the component
   * @param value The input value.
   */
  writeValue(value) {
    this.value = value;
  }
  /**
   * Sets a method in order to propagate changes back to the form.
   */
  registerOnChange(fn) {
    this.propagateChange = fn;
  }
  /**
   * Registers a callback to be triggered when the control has been touched.
   * @param fn Callback to be triggered when the search input is touched.
   */
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  /**
   * Called when text is written in the input.
   * @param search The input text.
   */
  onSearch(search) {
    if (this.isComposing) {
      return;
    }
    this.value = search;
    this.doValueChange();
  }
  /**
   * Called on enter.
   */
  onEnter() {
    this.search.emit(this.value);
  }
  /**
   * Called when clear button is clicked.
   */
  clearSearch() {
    this.value = "";
    this.clear.emit();
    this.propagateChange(this.value);
  }
  doValueChange() {
    this.valueChange.emit(this.value);
    this.propagateChange(this.value);
  }
  openSearch() {
    this.active = true;
    this.open.emit(this.active);
    setTimeout(() => this.inputRef.nativeElement.focus());
  }
  keyDown(event) {
    if (this.toolbar || this.expandable) {
      if (event.key === "Escape") {
        if (this.value === "") {
          this.active = false;
          this.open.emit(this.active);
        }
      } else if (event.key === "Enter") {
        this.openSearch();
      }
    }
    if (event.key === "Escape") {
      if (this.value !== "") {
        this.clearSearch();
      }
    }
  }
  focusOut(event) {
    this.onTouched();
    if ((this.expandable || this.toolbar) && this.inputRef && this.inputRef.nativeElement.value === "" && !this.elementRef.nativeElement.contains(event.relatedTarget)) {
      this.active = false;
      this.open.emit(this.active);
    }
  }
  focusIn(event) {
    this.onTouched();
    if ((this.expandable || this.toolbar) && this.inputRef && !event.relatedTarget && !this.elementRef.nativeElement.contains(event.relatedTarget)) {
      this.openSearch();
    }
  }
  /**
   * Called when using IME composition.
   */
  compositionStart(event) {
    this.isComposing = true;
  }
  /**
   * Called when IME composition finishes.
   */
  compositionEnd(event) {
    this.isComposing = false;
    this.onSearch(this.value + event.data);
  }
};
Search.searchCount = 0;
Search.ɵfac = function Search_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Search)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(I18n));
};
Search.ɵcmp = ɵɵdefineComponent({
  type: Search,
  selectors: [["cds-search"], ["ibm-search"]],
  viewQuery: function Search_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c030, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inputRef = _t.first);
    }
  },
  hostVars: 4,
  hostBindings: function Search_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("keydown", function Search_keydown_HostBindingHandler($event) {
        return ctx.keyDown($event);
      })("focusout", function Search_focusout_HostBindingHandler($event) {
        return ctx.focusOut($event);
      })("focusin", function Search_focusin_HostBindingHandler($event) {
        return ctx.focusIn($event);
      })("compositionstart", function Search_compositionstart_HostBindingHandler($event) {
        return ctx.compositionStart($event);
      })("compositionend", function Search_compositionend_HostBindingHandler($event) {
        return ctx.compositionEnd($event);
      });
    }
    if (rf & 2) {
      ɵɵclassProp("cds--form-item", ctx.containerClass)("cds--text-input--fluid__skeleton", ctx.fluidSkeletonClass);
    }
  },
  inputs: {
    theme: "theme",
    size: "size",
    disabled: "disabled",
    toolbar: "toolbar",
    expandable: "expandable",
    skeleton: "skeleton",
    active: "active",
    tableSearch: "tableSearch",
    name: "name",
    id: "id",
    required: "required",
    value: "value",
    autocomplete: "autocomplete",
    label: "label",
    placeholder: "placeholder",
    clearButtonTitle: "clearButtonTitle",
    searchTitle: "searchTitle",
    ariaLabel: "ariaLabel",
    fluid: "fluid"
  },
  outputs: {
    valueChange: "valueChange",
    open: "open",
    clear: "clear",
    search: "search"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: Search,
    multi: true
  }])],
  decls: 7,
  vars: 25,
  consts: [["enableInput", ""], ["input", ""], ["role", "search", 1, "cds--search", 3, "click", "ngClass"], [1, "cds--label", 3, "for", "ngClass"], ["class", "cds--text-input cds--skeleton", 4, "ngIf", "ngIfElse"], ["class", "cds--search-close", 3, "ngClass", "title", "click", 4, "ngIf"], [1, "cds--text-input", "cds--skeleton"], [1, "cds--search-input", 3, "input", "keyup.enter", "type", "id", "value", "autocomplete", "placeholder", "disabled", "required"], ["class", "cds--toolbar-search__btn", "aria-label", "Open search", 3, "click", 4, "ngIf"], ["cdsIcon", "search", "class", "cds--search-magnifier-icon", "size", "16", 4, "ngIf"], ["aria-label", "Open search", 1, "cds--toolbar-search__btn", 3, "click"], ["cdsIcon", "search", "size", "16", 1, "cds--search-magnifier-icon"], [1, "cds--search-close", 3, "click", "ngClass", "title"], [1, "cds--visually-hidden"], ["cdsIcon", "close", "size", "16"]],
  template: function Search_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵelementStart(0, "div", 2);
      ɵɵlistener("click", function Search_Template_div_click_0_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.openSearch());
      });
      ɵɵelementStart(1, "label", 3);
      ɵɵtext(2);
      ɵɵelementEnd();
      ɵɵtemplate(3, Search_div_3_Template, 1, 0, "div", 4)(4, Search_ng_template_4_Template, 4, 9, "ng-template", null, 0, ɵɵtemplateRefExtractor)(6, Search_button_6_Template, 4, 5, "button", 5);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      const enableInput_r6 = ɵɵreference(5);
      ɵɵproperty("ngClass", ɵɵpureFunctionV(8, _c128, [ctx.size === "sm", ctx.size === "md", ctx.size === "lg", ctx.theme === "light", ctx.skeleton && !ctx.fluid, ctx.expandable && !ctx.tableSearch, ctx.expandable && !ctx.tableSearch && ctx.active, ctx.toolbar && !ctx.expandable, ctx.toolbar && !ctx.expandable && ctx.active, ctx.tableSearch && !ctx.expandable, ctx.tableSearch && ctx.expandable, ctx.tableSearch && ctx.expandable && ctx.active, ctx.fluid, ctx.disabled]));
      ɵɵattribute("aria-label", ctx.ariaLabel);
      ɵɵadvance();
      ɵɵproperty("for", ctx.id)("ngClass", ɵɵpureFunction1(23, _c221, ctx.skeleton && ctx.fluid));
      ɵɵadvance();
      ɵɵtextInterpolate1(" ", !ctx.skeleton ? ctx.label : "", " ");
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.skeleton)("ngIfElse", enableInput_r6);
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.tableSearch || !ctx.toolbar);
    }
  },
  dependencies: [NgClass, NgIf, IconDirective],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Search, [{
    type: Component,
    args: [{
      selector: "cds-search, ibm-search",
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: Search,
        multi: true
      }],
      template: `<div
	class="cds--search"
	[ngClass]="{
		'cds--search--sm': size === 'sm',
		'cds--search--md': size === 'md',
		'cds--search--lg': size === 'lg',
		'cds--search--light': theme === 'light',
		'cds--skeleton': skeleton && !fluid,
		'cds--search--expandable': expandable && !tableSearch,
		'cds--search--expanded': expandable && !tableSearch && active,
		'cds--toolbar-search': toolbar && !expandable,
		'cds--toolbar-search--active': toolbar && !expandable && active,
		'cds--toolbar-search-container-persistent': tableSearch && !expandable,
		'cds--toolbar-search-container-expandable': tableSearch && expandable,
		'cds--toolbar-search-container-active': tableSearch && expandable && active,
		'cds--search--fluid': fluid,
		'cds--search--disabled': disabled
	}"
	role="search"
	[attr.aria-label]="ariaLabel"
	(click)="openSearch()">
	<label
		class="cds--label"
		[for]="id"
		[ngClass]="{ 'cds--skeleton': skeleton && fluid }">
		{{ !skeleton ? label : ''}}
	</label>

	<div *ngIf="skeleton; else enableInput" class="cds--text-input cds--skeleton"></div>
	<ng-template #enableInput>
		<input
			#input
			class="cds--search-input"
			[type]="tableSearch || !toolbar ? 'text' : 'search'"
			[id]="id"
			[value]="value"
			[autocomplete]="autocomplete"
			[placeholder]="placeholder"
			[disabled]="disabled"
			[required]="required"
			(input)="onSearch($event.target.value)"
			(keyup.enter)="onEnter()"/>
		<button
			*ngIf="!tableSearch && toolbar"
			class="cds--toolbar-search__btn"
			(click)="openSearch()"
			aria-label="Open search">
			<svg cdsIcon="search" size="16" class="cds--search-magnifier-icon"></svg>
		</button>
		<svg
			cdsIcon="search"
			*ngIf="tableSearch || !toolbar"
			class="cds--search-magnifier-icon"
			size="16">
		</svg>
	</ng-template>

	<button
		*ngIf="tableSearch || !toolbar"
		class="cds--search-close"
		[ngClass]="{
			'cds--search-close--hidden': !value || value.length === 0
		}"
		[title]="clearButtonTitle"
		(click)="clearSearch()">
		<span class="cds--visually-hidden">{{ clearButtonTitle }}</span>
		<svg cdsIcon="close" size="16"></svg>
	</button>
</div>
`
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: I18n
    }];
  }, {
    containerClass: [{
      type: HostBinding,
      args: ["class.cds--form-item"]
    }],
    fluidSkeletonClass: [{
      type: HostBinding,
      args: ["class.cds--text-input--fluid__skeleton"]
    }],
    theme: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    toolbar: [{
      type: Input
    }],
    expandable: [{
      type: Input
    }],
    skeleton: [{
      type: Input
    }],
    active: [{
      type: Input
    }],
    tableSearch: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    required: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    autocomplete: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    clearButtonTitle: [{
      type: Input
    }],
    searchTitle: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    fluid: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    open: [{
      type: Output
    }],
    clear: [{
      type: Output
    }],
    search: [{
      type: Output
    }],
    inputRef: [{
      type: ViewChild,
      args: ["input"]
    }],
    keyDown: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }],
    focusOut: [{
      type: HostListener,
      args: ["focusout", ["$event"]]
    }],
    focusIn: [{
      type: HostListener,
      args: ["focusin", ["$event"]]
    }],
    compositionStart: [{
      type: HostListener,
      args: ["compositionstart", ["$event"]]
    }],
    compositionEnd: [{
      type: HostListener,
      args: ["compositionend", ["$event"]]
    }]
  });
})();
var SearchModule = class {
};
SearchModule.ɵfac = function SearchModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || SearchModule)();
};
SearchModule.ɵmod = ɵɵdefineNgModule({
  type: SearchModule,
  declarations: [Search],
  imports: [FormsModule, CommonModule, I18nModule, IconModule],
  exports: [Search]
});
SearchModule.ɵinj = ɵɵdefineInjector({
  imports: [FormsModule, CommonModule, I18nModule, IconModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SearchModule, [{
    type: NgModule,
    args: [{
      declarations: [Search],
      exports: [Search],
      imports: [FormsModule, CommonModule, I18nModule, IconModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-select.mjs
var _c031 = ["select"];
var _c129 = ["*"];
var _c222 = (a0, a1) => ({
  "cds--form-item": a0,
  "cds--select--fluid": a1
});
var _c316 = (a0, a1, a2, a3, a4, a5, a6, a7) => ({
  "cds--select--inline": a0,
  "cds--select--light": a1,
  "cds--select--invalid": a2,
  "cds--select--warning": a3,
  "cds--select--disabled": a4,
  "cds--select--readonly": a5,
  "cds--select--fluid--invalid": a6,
  "cds--select--fluid--focus": a7
});
var _c411 = (a0) => ({
  "cds--label--disabled": a0
});
var _c59 = (a0) => ({
  "cds--form__helper-text--disabled": a0
});
var _c66 = (a0, a1, a2) => ({
  "cds--select-input--sm": a0,
  "cds--select-input--md": a1,
  "cds--select-input--lg": a2
});
function Select_ng_container_1_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 7);
  }
}
function Select_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, Select_ng_container_1_div_1_Template, 1, 0, "div", 5);
    ɵɵelement(2, "div", 6);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.label);
  }
}
function Select_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 8)(2, "div", 9);
    ɵɵelement(3, "div", 10)(4, "div", 11);
    ɵɵelementEnd()();
    ɵɵelementContainerEnd();
  }
}
function Select_div_3_label_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.label);
  }
}
function Select_div_3_label_1_2_ng_template_0_Template(rf, ctx) {
}
function Select_div_3_label_1_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, Select_div_3_label_1_2_ng_template_0_Template, 0, 0, "ng-template", 17);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.label);
  }
}
function Select_div_3_label_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "label", 16);
    ɵɵtemplate(1, Select_div_3_label_1_ng_container_1_Template, 2, 1, "ng-container", 3)(2, Select_div_3_label_1_2_Template, 1, 1, null, 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("for", ctx_r0.id)("ngClass", ɵɵpureFunction1(4, _c411, ctx_r0.disabled));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.label));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.label));
  }
}
function Select_div_3_div_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function Select_div_3_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 18);
    ɵɵtemplate(1, Select_div_3_div_2_ng_container_1_Template, 1, 0, "ng-container", 19);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const noInline_r2 = ɵɵreference(5);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", noInline_r2);
  }
}
function Select_div_3_div_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.helperText);
  }
}
function Select_div_3_div_3_2_ng_template_0_Template(rf, ctx) {
}
function Select_div_3_div_3_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, Select_div_3_div_3_2_ng_template_0_Template, 0, 0, "ng-template", 17);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.helperText);
  }
}
function Select_div_3_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 20);
    ɵɵtemplate(1, Select_div_3_div_3_ng_container_1_Template, 2, 1, "ng-container", 3)(2, Select_div_3_div_3_2_Template, 1, 1, null, 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngClass", ɵɵpureFunction1(3, _c59, ctx_r0.disabled));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.helperText));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.helperText));
  }
}
function Select_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 12);
    ɵɵtemplate(1, Select_div_3_label_1_Template, 3, 6, "label", 13)(2, Select_div_3_div_2_Template, 2, 1, "div", 14)(3, Select_div_3_div_3_Template, 3, 5, "div", 15);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    const noInline_r2 = ɵɵreference(5);
    ɵɵproperty("ngClass", ɵɵpureFunction8(5, _c316, ctx_r0.display === "inline", ctx_r0.theme === "light", ctx_r0.invalid, ctx_r0.warn, ctx_r0.disabled, ctx_r0.readonly, ctx_r0.fluid && ctx_r0.invalid, ctx_r0.fluid && ctx_r0.focused));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.label);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.display === "inline")("ngIfElse", noInline_r2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.helperText && !ctx_r0.invalid && !ctx_r0.warn && !ctx_r0.skeleton && !ctx_r0.fluid);
  }
}
function Select_ng_template_4__svg_svg_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 27);
  }
}
function Select_ng_template_4__svg_svg_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 28);
  }
}
function Select_ng_template_4_ng_container_8_div_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.invalidText);
  }
}
function Select_ng_template_4_ng_container_8_div_2_2_ng_template_0_Template(rf, ctx) {
}
function Select_ng_template_4_ng_container_8_div_2_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, Select_ng_template_4_ng_container_8_div_2_2_ng_template_0_Template, 0, 0, "ng-template", 17);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.invalidText);
  }
}
function Select_ng_template_4_ng_container_8_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 32);
    ɵɵtemplate(1, Select_ng_template_4_ng_container_8_div_2_ng_container_1_Template, 2, 1, "ng-container", 3)(2, Select_ng_template_4_ng_container_8_div_2_2_Template, 1, 1, null, 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.invalidText));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.invalidText));
  }
}
function Select_ng_template_4_ng_container_8_div_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.warnText);
  }
}
function Select_ng_template_4_ng_container_8_div_3_2_ng_template_0_Template(rf, ctx) {
}
function Select_ng_template_4_ng_container_8_div_3_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, Select_ng_template_4_ng_container_8_div_3_2_ng_template_0_Template, 0, 0, "ng-template", 17);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.warnText);
  }
}
function Select_ng_template_4_ng_container_8_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 33);
    ɵɵtemplate(1, Select_ng_template_4_ng_container_8_div_3_ng_container_1_Template, 2, 1, "ng-container", 3)(2, Select_ng_template_4_ng_container_8_div_3_2_Template, 1, 1, null, 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.warnText));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.warnText));
  }
}
function Select_ng_template_4_ng_container_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "hr", 29);
    ɵɵtemplate(2, Select_ng_template_4_ng_container_8_div_2_Template, 3, 2, "div", 30)(3, Select_ng_template_4_ng_container_8_div_3_Template, 3, 2, "div", 31);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r0.invalid && ctx_r0.invalidText);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.invalid && ctx_r0.warn);
  }
}
function Select_ng_template_4_ng_container_9_div_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.invalidText);
  }
}
function Select_ng_template_4_ng_container_9_div_1_2_ng_template_0_Template(rf, ctx) {
}
function Select_ng_template_4_ng_container_9_div_1_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, Select_ng_template_4_ng_container_9_div_1_2_ng_template_0_Template, 0, 0, "ng-template", 17);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.invalidText);
  }
}
function Select_ng_template_4_ng_container_9_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 32);
    ɵɵtemplate(1, Select_ng_template_4_ng_container_9_div_1_ng_container_1_Template, 2, 1, "ng-container", 3)(2, Select_ng_template_4_ng_container_9_div_1_2_Template, 1, 1, null, 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.invalidText));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.invalidText));
  }
}
function Select_ng_template_4_ng_container_9_div_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.warnText);
  }
}
function Select_ng_template_4_ng_container_9_div_2_2_ng_template_0_Template(rf, ctx) {
}
function Select_ng_template_4_ng_container_9_div_2_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, Select_ng_template_4_ng_container_9_div_2_2_ng_template_0_Template, 0, 0, "ng-template", 17);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.warnText);
  }
}
function Select_ng_template_4_ng_container_9_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 33);
    ɵɵtemplate(1, Select_ng_template_4_ng_container_9_div_2_ng_container_1_Template, 2, 1, "ng-container", 3)(2, Select_ng_template_4_ng_container_9_div_2_2_Template, 1, 1, null, 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.warnText));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.warnText));
  }
}
function Select_ng_template_4_ng_container_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, Select_ng_template_4_ng_container_9_div_1_Template, 3, 2, "div", 30)(2, Select_ng_template_4_ng_container_9_div_2_Template, 3, 2, "div", 31);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.invalid && ctx_r0.invalidText);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.invalid && ctx_r0.warn);
  }
}
function Select_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 21)(1, "select", 22, 1);
    ɵɵlistener("change", function Select_ng_template_4_Template_select_change_1_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onChange($event));
    })("mousedown", function Select_ng_template_4_Template_select_mousedown_1_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onMouseDown($event));
    })("keydown", function Select_ng_template_4_Template_select_keydown_1_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onKeyDown($event));
    })("focus", function Select_ng_template_4_Template_select_focus_1_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.fluid ? ctx_r0.handleFocus($event) : null);
    })("blur", function Select_ng_template_4_Template_select_blur_1_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.fluid ? ctx_r0.handleFocus($event) : null);
    });
    ɵɵprojection(3);
    ɵɵelementEnd();
    ɵɵnamespaceSVG();
    ɵɵelementStart(4, "svg", 23);
    ɵɵelement(5, "path", 24);
    ɵɵelementEnd();
    ɵɵtemplate(6, Select_ng_template_4__svg_svg_6_Template, 1, 0, "svg", 25)(7, Select_ng_template_4__svg_svg_7_Template, 1, 0, "svg", 26)(8, Select_ng_template_4_ng_container_8_Template, 4, 2, "ng-container", 3);
    ɵɵelementEnd();
    ɵɵtemplate(9, Select_ng_template_4_ng_container_9_Template, 3, 2, "ng-container", 3);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵattribute("data-invalid", ctx_r0.invalid ? true : null);
    ɵɵadvance();
    ɵɵproperty("disabled", ctx_r0.disabled)("ngClass", ɵɵpureFunction3(11, _c66, ctx_r0.size === "sm", ctx_r0.size === "md", ctx_r0.size === "lg"));
    ɵɵattribute("id", ctx_r0.id)("aria-label", ctx_r0.ariaLabel)("aria-invalid", ctx_r0.invalid ? "true" : null)("aria-readonly", ctx_r0.readonly ? "true" : null);
    ɵɵadvance(5);
    ɵɵproperty("ngIf", ctx_r0.invalid);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.invalid && ctx_r0.warn);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.fluid);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.fluid);
  }
}
var OptGroup = class {
  constructor() {
    this.inputClass = "cds--select-optgroup";
  }
};
OptGroup.ɵfac = function OptGroup_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || OptGroup)();
};
OptGroup.ɵdir = ɵɵdefineDirective({
  type: OptGroup,
  selectors: [["optgroup"]],
  hostVars: 2,
  hostBindings: function OptGroup_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassMap(ctx.inputClass);
    }
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OptGroup, [{
    type: Directive,
    args: [{
      // tslint:disable-next-line
      selector: "optgroup"
    }]
  }], null, {
    inputClass: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var Option = class {
  constructor() {
    this.inputClass = "cds--select-option";
  }
};
Option.ɵfac = function Option_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Option)();
};
Option.ɵdir = ɵɵdefineDirective({
  type: Option,
  selectors: [["option"]],
  hostVars: 2,
  hostBindings: function Option_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassMap(ctx.inputClass);
    }
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Option, [{
    type: Directive,
    args: [{
      // tslint:disable-next-line
      selector: "option"
    }]
  }], null, {
    inputClass: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var Select = class _Select {
  constructor() {
    this.display = "default";
    this.warn = false;
    this.id = `select-${_Select.selectCount++}`;
    this.size = "md";
    this.disabled = false;
    this.skeleton = false;
    this.invalid = false;
    this.readonly = false;
    this.theme = "dark";
    this.fluid = false;
    this.valueChange = new EventEmitter();
    this.focused = false;
    this.onChangeHandler = (_) => {
    };
    this.onTouchedHandler = () => {
    };
  }
  set value(v) {
    this._value = v;
    if (this.select) {
      this.select.nativeElement.value = this._value;
    }
  }
  get value() {
    return this._value;
  }
  ngAfterViewInit() {
    if (this.value !== void 0 && this.value !== null && this.select && this.select.nativeElement.value !== this.value) {
      this.select.nativeElement.value = this.value;
    }
  }
  /**
   * Receives a value from the model.
   */
  writeValue(obj) {
    this.value = obj;
  }
  /**
   * Registers a listener that notifies the model when the control updates
   */
  registerOnChange(fn) {
    this.onChangeHandler = fn;
  }
  /**
   * Registers a listener that notifies the model when the control is blurred
   */
  registerOnTouched(fn) {
    this.onTouchedHandler = fn;
  }
  /**
   * Sets the disabled state through the model
   */
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  /**
   * Handles the change event from the `select`.
   * Sends events to the change handler and emits a `selected` event.
   */
  onChange(event) {
    this.value = event.target.value;
    this.onChangeHandler(event.target.value);
    this.valueChange.emit(event.target.value);
  }
  /**
   * Listens for the host blurring, and notifies the model
   */
  focusOut() {
    this.onTouchedHandler();
  }
  isTemplate(value) {
    return value instanceof TemplateRef;
  }
  onMouseDown(event) {
    if (this.readonly) {
      event.preventDefault();
      event.target.focus();
    }
  }
  onKeyDown(event) {
    const selectAccessKeys = ["ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight", " "];
    if (this.readonly && selectAccessKeys.includes(event.key)) {
      event.preventDefault();
    }
  }
  handleFocus(event) {
    this.focused = event.type === "focus";
  }
};
Select.selectCount = 0;
Select.ɵfac = function Select_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Select)();
};
Select.ɵcmp = ɵɵdefineComponent({
  type: Select,
  selectors: [["cds-select"], ["ibm-select"]],
  viewQuery: function Select_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c031, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.select = _t.first);
    }
  },
  hostBindings: function Select_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("focusout", function Select_focusout_HostBindingHandler() {
        return ctx.focusOut();
      });
    }
  },
  inputs: {
    value: "value",
    display: "display",
    label: "label",
    helperText: "helperText",
    invalidText: "invalidText",
    warn: "warn",
    warnText: "warnText",
    id: "id",
    size: "size",
    disabled: "disabled",
    skeleton: "skeleton",
    invalid: "invalid",
    readonly: "readonly",
    theme: "theme",
    ariaLabel: "ariaLabel",
    fluid: "fluid"
  },
  outputs: {
    valueChange: "valueChange"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: Select,
    multi: true
  }])],
  ngContentSelectors: _c129,
  decls: 6,
  vars: 7,
  consts: [["noInline", ""], ["select", ""], [3, "ngClass"], [4, "ngIf"], ["class", "cds--select", 3, "ngClass", 4, "ngIf"], ["class", "cds--label cds--skeleton", 4, "ngIf"], [1, "cds--select", "cds--skeleton"], [1, "cds--label", "cds--skeleton"], [1, "cds--list-box__wrapper--fluid"], [1, "cds--list-box", "cds--skeleton"], [1, "cds--list-box__label"], [1, "cds--list-box__field"], [1, "cds--select", 3, "ngClass"], ["class", "cds--label", 3, "for", "ngClass", 4, "ngIf"], ["class", "cds--select-input--inline__wrapper", 4, "ngIf", "ngIfElse"], ["class", "cds--form__helper-text", 3, "ngClass", 4, "ngIf"], [1, "cds--label", 3, "for", "ngClass"], [3, "ngTemplateOutlet"], [1, "cds--select-input--inline__wrapper"], [4, "ngTemplateOutlet"], [1, "cds--form__helper-text", 3, "ngClass"], [1, "cds--select-input__wrapper"], [1, "cds--select-input", 3, "change", "mousedown", "keydown", "focus", "blur", "disabled", "ngClass"], ["focusable", "false", "preserveAspectRatio", "xMidYMid meet", "xmlns", "http://www.w3.org/2000/svg", "width", "16", "height", "16", "viewBox", "0 0 16 16", "aria-hidden", "true", 1, "cds--select__arrow", 2, "will-change", "transform"], ["d", "M8 11L3 6 3.7 5.3 8 9.6 12.3 5.3 13 6z"], ["cdsIcon", "warning--filled", "size", "16", "class", "cds--select__invalid-icon", 4, "ngIf"], ["cdsIcon", "warning--alt--filled", "size", "16", "class", "cds--select__invalid-icon cds--select__invalid-icon--warning", 4, "ngIf"], ["cdsIcon", "warning--filled", "size", "16", 1, "cds--select__invalid-icon"], ["cdsIcon", "warning--alt--filled", "size", "16", 1, "cds--select__invalid-icon", "cds--select__invalid-icon--warning"], [1, "cds--select__divider"], ["role", "alert", "class", "cds--form-requirement", "aria-live", "polite", 4, "ngIf"], ["class", "cds--form-requirement", 4, "ngIf"], ["role", "alert", "aria-live", "polite", 1, "cds--form-requirement"], [1, "cds--form-requirement"]],
  template: function Select_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 2);
      ɵɵtemplate(1, Select_ng_container_1_Template, 3, 1, "ng-container", 3)(2, Select_ng_container_2_Template, 5, 0, "ng-container", 3)(3, Select_div_3_Template, 4, 14, "div", 4);
      ɵɵelementEnd();
      ɵɵtemplate(4, Select_ng_template_4_Template, 10, 15, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      ɵɵproperty("ngClass", ɵɵpureFunction2(4, _c222, !ctx.skeleton, ctx.fluid && !ctx.skeleton));
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.skeleton && !ctx.fluid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.skeleton && ctx.fluid);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.skeleton);
    }
  },
  dependencies: [NgClass, NgIf, NgTemplateOutlet, IconDirective],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Select, [{
    type: Component,
    args: [{
      selector: "cds-select, ibm-select",
      template: `
		<div
			[ngClass]="{
				'cds--form-item': !skeleton,
				'cds--select--fluid': fluid && !skeleton
			}">
			<ng-container *ngIf="skeleton && !fluid">
				<div *ngIf="label" class="cds--label cds--skeleton"></div>
				<div class="cds--select cds--skeleton"></div>
			</ng-container>
			<ng-container *ngIf="skeleton && fluid">
				<div class="cds--list-box__wrapper--fluid">
					<div class="cds--list-box cds--skeleton">
						<div class="cds--list-box__label"></div>
						<div class="cds--list-box__field"></div>
					</div>
				</div>
			</ng-container>
			<div
				*ngIf="!skeleton"
				class="cds--select"
				[ngClass]="{
					'cds--select--inline': display === 'inline',
					'cds--select--light': theme === 'light',
					'cds--select--invalid': invalid,
					'cds--select--warning': warn,
					'cds--select--disabled': disabled,
					'cds--select--readonly': readonly,
					'cds--select--fluid--invalid': fluid && invalid,
					'cds--select--fluid--focus': fluid && focused
				}">
				<label
					*ngIf="label"
					[for]="id"
					class="cds--label"
					[ngClass]="{'cds--label--disabled': disabled}">
					<ng-container *ngIf="!isTemplate(label)">{{label}}</ng-container>
					<ng-template *ngIf="isTemplate(label)" [ngTemplateOutlet]="label"></ng-template>
				</label>
				<div *ngIf="display === 'inline'; else noInline" class="cds--select-input--inline__wrapper">
					<ng-container *ngTemplateOutlet="noInline"></ng-container>
				</div>
				<div
					*ngIf="helperText && !invalid && !warn && !skeleton && !fluid"
					class="cds--form__helper-text"
					[ngClass]="{
						'cds--form__helper-text--disabled': disabled
					}">
					<ng-container *ngIf="!isTemplate(helperText)">{{helperText}}</ng-container>
					<ng-template *ngIf="isTemplate(helperText)" [ngTemplateOutlet]="helperText"></ng-template>
				</div>
			</div>
		</div>

		<!-- select element: dynamically projected based on 'display' variant -->
		<ng-template #noInline>
			<div class="cds--select-input__wrapper" [attr.data-invalid]="(invalid ? true : null)">
				<select
					#select
					[attr.id]="id"
					[attr.aria-label]="ariaLabel"
					[disabled]="disabled"
					(change)="onChange($event)"
					[attr.aria-invalid]="invalid ? 'true' : null"
					[attr.aria-readonly]="readonly ? 'true' : null"
					class="cds--select-input"
					[ngClass]="{
						'cds--select-input--sm': size === 'sm',
						'cds--select-input--md': size === 'md',
						'cds--select-input--lg': size === 'lg'
					}"
					(mousedown)="onMouseDown($event)"
					(keydown)="onKeyDown($event)"
					(focus)="fluid ? handleFocus($event) : null"
					(blur)="fluid ? handleFocus($event) : null">
					<ng-content></ng-content>
				</select>
				<svg
					focusable="false"
					preserveAspectRatio="xMidYMid meet"
					style="will-change: transform;"
					xmlns="http://www.w3.org/2000/svg"
					class="cds--select__arrow"
					width="16"
					height="16"
					viewBox="0 0 16 16"
					aria-hidden="true">
					<path d="M8 11L3 6 3.7 5.3 8 9.6 12.3 5.3 13 6z"></path>
				</svg>
				<svg
					*ngIf="invalid"
					cdsIcon="warning--filled"
					size="16"
					class="cds--select__invalid-icon">
				</svg>
				<svg
					*ngIf="!invalid && warn"
					cdsIcon="warning--alt--filled"
					size="16"
					class="cds--select__invalid-icon cds--select__invalid-icon--warning">
				</svg>
				<ng-container *ngIf="fluid">
					<hr class="cds--select__divider" />
					<div
						*ngIf="invalid && invalidText" role="alert" class="cds--form-requirement" aria-live="polite">
						<ng-container *ngIf="!isTemplate(invalidText)">{{invalidText}}</ng-container>
						<ng-template *ngIf="isTemplate(invalidText)" [ngTemplateOutlet]="invalidText"></ng-template>
					</div>
					<div *ngIf="!invalid && warn" class="cds--form-requirement">
						<ng-container *ngIf="!isTemplate(warnText)">{{warnText}}</ng-container>
						<ng-template *ngIf="isTemplate(warnText)" [ngTemplateOutlet]="warnText"></ng-template>
					</div>
				</ng-container>
			</div>
			<ng-container *ngIf="!fluid">
				<div
					*ngIf="invalid && invalidText" role="alert" class="cds--form-requirement" aria-live="polite">
					<ng-container *ngIf="!isTemplate(invalidText)">{{invalidText}}</ng-container>
					<ng-template *ngIf="isTemplate(invalidText)" [ngTemplateOutlet]="invalidText"></ng-template>
				</div>
				<div *ngIf="!invalid && warn" class="cds--form-requirement">
					<ng-container *ngIf="!isTemplate(warnText)">{{warnText}}</ng-container>
					<ng-template *ngIf="isTemplate(warnText)" [ngTemplateOutlet]="warnText"></ng-template>
				</div>
			</ng-container>
		</ng-template>
	`,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: Select,
        multi: true
      }]
    }]
  }], null, {
    value: [{
      type: Input
    }],
    display: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    helperText: [{
      type: Input
    }],
    invalidText: [{
      type: Input
    }],
    warn: [{
      type: Input
    }],
    warnText: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    skeleton: [{
      type: Input
    }],
    invalid: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }],
    theme: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    fluid: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    select: [{
      type: ViewChild,
      args: ["select"]
    }],
    focusOut: [{
      type: HostListener,
      args: ["focusout"]
    }]
  });
})();
var SelectModule = class {
};
SelectModule.ɵfac = function SelectModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || SelectModule)();
};
SelectModule.ɵmod = ɵɵdefineNgModule({
  type: SelectModule,
  declarations: [Select, Option, OptGroup],
  imports: [CommonModule, FormsModule, IconModule],
  exports: [Select, Option, OptGroup]
});
SelectModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, FormsModule, IconModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectModule, [{
    type: NgModule,
    args: [{
      declarations: [Select, Option, OptGroup],
      exports: [Select, Option, OptGroup],
      imports: [CommonModule, FormsModule, IconModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-skeleton.mjs
function SkeletonText_p_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "p", 1);
  }
  if (rf & 2) {
    const width_r1 = ctx.$implicit;
    ɵɵstyleProp("width", width_r1);
  }
}
var SkeletonPlaceholder = class {
};
SkeletonPlaceholder.ɵfac = function SkeletonPlaceholder_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || SkeletonPlaceholder)();
};
SkeletonPlaceholder.ɵcmp = ɵɵdefineComponent({
  type: SkeletonPlaceholder,
  selectors: [["cds-skeleton-placeholder"], ["ibm-skeleton-placeholder"]],
  standalone: false,
  decls: 1,
  vars: 0,
  consts: [[1, "cds--skeleton__placeholder"]],
  template: function SkeletonPlaceholder_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelement(0, "div", 0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SkeletonPlaceholder, [{
    type: Component,
    args: [{
      selector: "cds-skeleton-placeholder, ibm-skeleton-placeholder",
      template: `
		<div class="cds--skeleton__placeholder"></div>`
    }]
  }], null, null);
})();
var SkeletonText = class {
  constructor() {
    this.lines = 5;
    this.minLineWidth = 100;
    this.maxLineWidth = 300;
  }
  /**
   * Returns a random width in pixels based off a min width, and a max width.
   */
  getRandomInt(min2, max2) {
    return `${Math.floor(Math.random() * (max2 - min2 + 1) + min2) + "px"}`;
  }
  ngOnChanges() {
    this.lineWidths = Array.from(Array(this.lines).keys()).map((num) => this.getRandomInt(this.minLineWidth, this.maxLineWidth));
  }
};
SkeletonText.ɵfac = function SkeletonText_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || SkeletonText)();
};
SkeletonText.ɵcmp = ɵɵdefineComponent({
  type: SkeletonText,
  selectors: [["cds-skeleton-text"], ["ibm-skeleton-text"]],
  inputs: {
    lines: "lines",
    minLineWidth: "minLineWidth",
    maxLineWidth: "maxLineWidth"
  },
  standalone: false,
  features: [ɵɵNgOnChangesFeature],
  decls: 1,
  vars: 1,
  consts: [["class", "cds--skeleton__text", 3, "width", 4, "ngFor", "ngForOf"], [1, "cds--skeleton__text"]],
  template: function SkeletonText_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, SkeletonText_p_0_Template, 1, 2, "p", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngForOf", ctx.lineWidths);
    }
  },
  dependencies: [NgForOf],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SkeletonText, [{
    type: Component,
    args: [{
      selector: "cds-skeleton-text, ibm-skeleton-text",
      template: `
		<p
			*ngFor="let width of lineWidths"
			class="cds--skeleton__text"
			[style.width]="width">
		</p>
	`
    }]
  }], null, {
    lines: [{
      type: Input
    }],
    minLineWidth: [{
      type: Input
    }],
    maxLineWidth: [{
      type: Input
    }]
  });
})();
var SkeletonModule = class {
};
SkeletonModule.ɵfac = function SkeletonModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || SkeletonModule)();
};
SkeletonModule.ɵmod = ɵɵdefineNgModule({
  type: SkeletonModule,
  declarations: [SkeletonPlaceholder, SkeletonText],
  imports: [CommonModule],
  exports: [SkeletonPlaceholder, SkeletonText]
});
SkeletonModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SkeletonModule, [{
    type: NgModule,
    args: [{
      declarations: [SkeletonPlaceholder, SkeletonText],
      exports: [SkeletonPlaceholder, SkeletonText],
      imports: [CommonModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-slider.mjs
var _c032 = ["track"];
var _c130 = ["filledTrack"];
var _c223 = ["range"];
var _c317 = ["thumbs"];
var _c412 = [[["", "minLabel", ""]], [["", "maxLabel", ""]], [["input"]]];
var _c510 = ["[minLabel]", "[maxLabel]", "input"];
var _c67 = (a0) => ({
  "cds--slider-container--readonly": a0
});
var _c74 = (a0, a1) => ({
  "cds--slider--disabled": a0,
  "cds--slider--readonly": a1
});
var _c84 = (a0) => ({
  "cds--label--disabled": a0
});
var _c94 = (a0) => ({
  insetInlineStart: a0
});
function Slider_ng_container_0_label_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.label);
  }
}
function Slider_ng_container_0_label_1_2_ng_template_0_Template(rf, ctx) {
}
function Slider_ng_container_0_label_1_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, Slider_ng_container_0_label_1_2_ng_template_0_Template, 0, 0, "ng-template", 15);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.label);
  }
}
function Slider_ng_container_0_label_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "label", 14);
    ɵɵtemplate(1, Slider_ng_container_0_label_1_ng_container_1_Template, 2, 1, "ng-container", 10)(2, Slider_ng_container_0_label_1_2_Template, 1, 1, null, 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("for", ctx_r1.id)("id", ctx_r1.labelId)("ngClass", ɵɵpureFunction1(5, _c84, ctx_r1.disabled));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.isTemplate(ctx_r1.label));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.isTemplate(ctx_r1.label));
  }
}
function Slider_ng_container_0_ng_container_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 16)(2, "div", 17, 4);
    ɵɵlistener("mousedown", function Slider_ng_container_0_ng_container_6_Template_div_mousedown_2_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onMouseDown($event));
    })("keydown", function Slider_ng_container_0_ng_container_6_Template_div_keydown_2_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onKeyDown($event));
    });
    ɵɵelementEnd()();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngStyle", ɵɵpureFunction1(3, _c94, ctx_r1.getFractionComplete(ctx_r1.value) * 100 + "%"));
    ɵɵadvance();
    ɵɵproperty("id", ctx_r1.id);
    ɵɵattribute("aria-labelledby", ctx_r1.labelId);
  }
}
function Slider_ng_container_0_ng_container_7_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 16)(1, "div", 17, 4);
    ɵɵlistener("mousedown", function Slider_ng_container_0_ng_container_7_div_1_Template_div_mousedown_1_listener($event) {
      const i_r5 = ɵɵrestoreView(_r4).index;
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.onMouseDown($event, i_r5));
    })("keydown", function Slider_ng_container_0_ng_container_7_div_1_Template_div_keydown_1_listener($event) {
      const i_r5 = ɵɵrestoreView(_r4).index;
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.onKeyDown($event, i_r5));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const thumb_r6 = ctx.$implicit;
    const i_r5 = ctx.index;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("ngStyle", ɵɵpureFunction1(3, _c94, ctx_r1.getFractionComplete(thumb_r6) * 100 + "%"));
    ɵɵadvance();
    ɵɵproperty("id", ctx_r1.id + (i_r5 > 0 ? "-" + i_r5 : ""));
    ɵɵattribute("aria-labelledby", ctx_r1.labelId);
  }
}
function Slider_ng_container_0_ng_container_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, Slider_ng_container_0_ng_container_7_div_1_Template, 3, 5, "div", 18);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1.value)("ngForTrackBy", ctx_r1.trackThumbsBy);
  }
}
function Slider_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, Slider_ng_container_0_label_1_Template, 3, 7, "label", 6);
    ɵɵelementStart(2, "div", 7)(3, "label", 8);
    ɵɵprojection(4);
    ɵɵelementEnd();
    ɵɵelementStart(5, "div", 9);
    ɵɵlistener("click", function Slider_ng_container_0_Template_div_click_5_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onClick($event));
    });
    ɵɵtemplate(6, Slider_ng_container_0_ng_container_6_Template, 4, 5, "ng-container", 10)(7, Slider_ng_container_0_ng_container_7_Template, 2, 2, "ng-container", 10);
    ɵɵelement(8, "div", 11, 1)(10, "div", 12, 2)(12, "input", 13, 3);
    ɵɵelementEnd();
    ɵɵelementStart(14, "label", 8);
    ɵɵprojection(15, 1);
    ɵɵelementEnd();
    ɵɵprojection(16, 2);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.label);
    ɵɵadvance();
    ɵɵproperty("ngClass", ɵɵpureFunction1(11, _c67, ctx_r1.readonly));
    ɵɵadvance();
    ɵɵproperty("id", ctx_r1.bottomRangeId);
    ɵɵadvance(2);
    ɵɵproperty("ngClass", ɵɵpureFunction2(13, _c74, ctx_r1.disabled, ctx_r1.readonly));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.isRange());
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.isRange());
    ɵɵadvance(5);
    ɵɵproperty("step", ctx_r1.step)("min", ctx_r1.min)("max", ctx_r1.max)("value", ctx_r1.value.toString());
    ɵɵadvance(2);
    ɵɵproperty("id", ctx_r1.topRangeId);
  }
}
function Slider_ng_template_1_label_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "label", 24);
  }
}
function Slider_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, Slider_ng_template_1_label_0_Template, 1, 0, "label", 19);
    ɵɵelementStart(1, "div", 20);
    ɵɵelement(2, "span", 21);
    ɵɵelementStart(3, "div", 22);
    ɵɵelement(4, "div", 23)(5, "div", 11)(6, "div", 12);
    ɵɵelementEnd();
    ɵɵelement(7, "span", 21);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngIf", ctx_r1.label);
  }
}
var Slider = class _Slider {
  constructor(elementRef, eventService, changeDetection) {
    this.elementRef = elementRef;
    this.eventService = eventService;
    this.changeDetection = changeDetection;
    this.step = 1;
    this.id = `slider-${_Slider.count++}`;
    this.shiftMultiplier = 4;
    this.skeleton = false;
    this.disableArrowKeys = false;
    this.valueChange = new EventEmitter();
    this.hostClass = true;
    this.labelId = `${this.id}-label`;
    this.bottomRangeId = `${this.id}-bottom-range`;
    this.topRangeId = `${this.id}-top-range`;
    this.fractionComplete = 0;
    this.isMouseDown = false;
    this._min = 0;
    this._max = 100;
    this._value = [this.min];
    this._previousValue = [this.min];
    this._disabled = false;
    this._readonly = false;
    this._focusedThumbIndex = 0;
    this.propagateChange = (_) => {
    };
    this.onTouched = () => {
    };
  }
  /** The lower bound of our range */
  set min(v) {
    if (!v) {
      return;
    }
    this._min = v;
    this.value = this.value;
  }
  get min() {
    return this._min;
  }
  /** The upper bound of our range */
  set max(v) {
    if (!v) {
      return;
    }
    this._max = v;
    this.value = this.value;
  }
  get max() {
    return this._max;
  }
  /** Set the initial value. Available for two way binding */
  set value(v) {
    if (!v) {
      v = [this.min];
    }
    if (typeof v === "number" || typeof v === "string") {
      v = [Number(v)];
    }
    if (v[0] < this.min) {
      v[0] = this.min;
    }
    if (v[0] > this.max) {
      v[0] = this.max;
    }
    if (this.isRange()) {
      if (this._previousValue[0] !== v[0]) {
        if (v[0] > v[1] - this.step) {
          v[0] = v[1] - this.step;
        } else if (v[0] > this.max) {
          v[0] = this.max;
        } else if (v[0] < this.min) {
          v[0] = this.min;
        }
      }
      if (this._previousValue[1] !== v[1]) {
        if (v[1] > this.max) {
          v[1] = this.max;
        } else if (v[1] < this._value[0] + this.step) {
          v[1] = this._value[0] + this.step;
        } else if (v[1] < this.min) {
          v[1] = this.min;
        }
      }
    }
    this._previousValue = [...this._value];
    this._value = [...v];
    if (this.isRange() && this.filledTrack) {
      this.updateTrackRangeWidth();
    } else if (this.filledTrack) {
      this.filledTrack.nativeElement.style.transform = `translate(0%, -50%) ${this.scaleX(this.getFractionComplete(v[0]))}`;
    }
    if (this.inputs && this.inputs.length) {
      this.inputs.forEach((input, index) => {
        input.value = this._value[index].toString();
      });
    }
    const valueToEmit = this.isRange() ? v : v[0];
    this.propagateChange(valueToEmit);
    this.valueChange.emit(valueToEmit);
  }
  get value() {
    if (this.isRange()) {
      return this._value;
    }
    return this._value[0];
  }
  /** Disables the range visually and functionally */
  set disabled(v) {
    this._disabled = v;
    const inputs = this.getInputs();
    if (inputs && inputs.length > 0) {
      inputs.forEach((input) => input.disabled = v);
    }
  }
  get disabled() {
    return this._disabled;
  }
  /** Set to `true` for a readonly state. */
  set readonly(v) {
    this._readonly = v;
    const inputs = this.getInputs();
    if (inputs && inputs.length > 0) {
      inputs.forEach((input) => input.readOnly = v);
    }
  }
  get readonly() {
    return this._readonly;
  }
  ngAfterViewInit() {
    this.eventService.onDocument("mousemove", this.onMouseMove.bind(this));
    this.eventService.onDocument("mouseup", this.onMouseUp.bind(this));
    this.changeDetection.detectChanges();
    this.inputs = this.getInputs();
    if (this.inputs && this.inputs.length > 0) {
      this.inputs.forEach((input, index) => {
        input.type = "number";
        input.classList.add("cds--slider-text-input");
        input.classList.add("cds--text-input");
        input.setAttribute("aria-labelledby", `${this.bottomRangeId} ${this.topRangeId}`);
        input.value = index < this._value.length ? this._value[index].toString() : this.max.toString();
        this.eventService.on(input, "change", (event) => this.onChange(event, index));
        if (index === 0) {
          this.eventService.on(input, "focus", this.onFocus.bind(this));
        }
      });
    }
  }
  trackThumbsBy(index, item) {
    return index;
  }
  /** Register a change propagation function for `ControlValueAccessor` */
  registerOnChange(fn) {
    this.propagateChange = fn;
  }
  /** Register a callback to notify when our input has been touched */
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  /** Receives a value from the model */
  writeValue(v) {
    this.value = v;
  }
  /**
   * Returns the amount of "completeness" of a value as a fraction of the total track width
   */
  getFractionComplete(value) {
    if (!this.track) {
      return 0;
    }
    const trackWidth = this.track.nativeElement.getBoundingClientRect().width;
    return this.convertToPx(value) / trackWidth;
  }
  /** Helper function to return the CSS transform `scaleX` function */
  scaleX(complete) {
    return `scaleX(${complete})`;
  }
  /** Converts a given px value to a "real" value in our range */
  convertToValue(pxAmount) {
    const range2 = this.max - this.min;
    const trackWidth = this.track.nativeElement.getBoundingClientRect().width;
    const unrounded = pxAmount / trackWidth;
    const rounded = Math.round(range2 * unrounded / this.step) * this.step;
    return rounded + this.min;
  }
  /** Converts a given "real" value to a px value we can update the view with */
  convertToPx(value) {
    if (!this.track) {
      return 0;
    }
    const trackWidth = this.track.nativeElement.getBoundingClientRect().width;
    if (value >= this.max) {
      return trackWidth;
    }
    if (value <= this.min) {
      return 0;
    }
    return Math.round(trackWidth * ((value - this.min) / (this.max - this.min)));
  }
  /**
   * Increments the value by the step value, or the step value multiplied by the `multiplier` argument.
   *
   * @argument multiplier Defaults to `1`, multiplied with the step value.
   */
  incrementValue(multiplier = 1, index = 0) {
    this._value[index] = this._value[index] + this.step * multiplier;
    this.value = this.value;
  }
  /**
   * Decrements the value by the step value, or the step value multiplied by the `multiplier` argument.
   *
   * @argument multiplier Defaults to `1`, multiplied with the step value.
   */
  decrementValue(multiplier = 1, index = 0) {
    this._value[index] = this._value[index] - this.step * multiplier;
    this.value = this.value;
  }
  /**
   * Determines if the slider is in range mode.
   */
  isRange() {
    return this._value.length > 1;
  }
  /**
   * Range mode only.
   * Updates the track width to span from the low thumb to the high thumb
   */
  updateTrackRangeWidth() {
    const fraction = this.getFractionComplete(this._value[0]);
    const fraction2 = this.getFractionComplete(this._value[1]);
    this.filledTrack.nativeElement.style.transform = `translate(${fraction * 100}%, -50%) ${this.scaleX(fraction2 - fraction)}`;
  }
  /** Change handler for the optional input */
  onChange(event, index) {
    this._value[index] = Number(event.target.value);
    this.value = this.value;
  }
  /**
   * Handles clicks on the slider, and setting the value to it's "real" equivalent.
   * Will assign the value to the closest thumb if in range mode.
   * */
  onClick(event) {
    if (this.disabled || this.readonly) {
      return;
    }
    const trackLeft = this.track.nativeElement.getBoundingClientRect().left;
    const trackValue = this.convertToValue(event.clientX - trackLeft);
    if (this.isRange()) {
      if (Math.abs(this._value[0] - trackValue) < Math.abs(this._value[1] - trackValue)) {
        this._value[0] = trackValue;
      } else {
        this._value[1] = trackValue;
      }
    } else {
      this._value[0] = trackValue;
    }
    this.value = this.value;
  }
  /** Focus handler for the optional input */
  onFocus({
    target
  }) {
    target.select();
  }
  /** Mouse move handler. Responsible for updating the value and visual selection based on mouse movement */
  onMouseMove(event) {
    if (this.disabled || this.readonly || !this.isMouseDown) {
      return;
    }
    const track = this.track.nativeElement.getBoundingClientRect();
    let value;
    if (event.clientX - track.left <= track.width && event.clientX - track.left >= 0) {
      value = this.convertToValue(event.clientX - track.left);
    }
    if (event.clientX - track.left > track.width) {
      value = this.max;
    }
    if (event.clientX - track.left < 0) {
      value = this.min;
    }
    if (value !== void 0) {
      this._value[this._focusedThumbIndex] = value;
      this.value = this.value;
    }
  }
  /**
   * Enables the `onMouseMove` handler
   *
   * @param {boolean} thumb If true then `thumb` is clicked down, otherwise `thumb2` is clicked down.
   */
  onMouseDown(event, index = 0) {
    event.preventDefault();
    if (this.disabled || this.readonly) {
      return;
    }
    this._focusedThumbIndex = index;
    this.thumbs.toArray()[index].nativeElement.focus();
    this.isMouseDown = true;
  }
  /** Disables the `onMouseMove` handler */
  onMouseUp() {
    this.isMouseDown = false;
  }
  /**
   * Calls `incrementValue` for ArrowRight and ArrowUp, `decrementValue` for ArrowLeft and ArrowDown.
   *
   * @param {boolean} thumb If true then `thumb` is pressed down, otherwise `thumb2` is pressed down.
   */
  onKeyDown(event, index = 0) {
    if (this.disableArrowKeys || this.readonly) {
      return;
    }
    const multiplier = event.shiftKey ? this.shiftMultiplier : 1;
    if (event.key === "ArrowLeft" || event.key === "ArrowDown") {
      this.decrementValue(multiplier, index);
      this.thumbs.toArray()[index].nativeElement.focus();
      event.preventDefault();
    } else if (event.key === "ArrowRight" || event.key === "ArrowUp") {
      this.incrementValue(multiplier, index);
      this.thumbs.toArray()[index].nativeElement.focus();
      event.preventDefault();
    }
  }
  isTemplate(value) {
    return value instanceof TemplateRef;
  }
  /** Get optional input fields */
  getInputs() {
    return this.elementRef.nativeElement.querySelectorAll("input:not([type=range])");
  }
};
Slider.count = 0;
Slider.ɵfac = function Slider_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Slider)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(EventService), ɵɵdirectiveInject(ChangeDetectorRef));
};
Slider.ɵcmp = ɵɵdefineComponent({
  type: Slider,
  selectors: [["cds-slider"], ["ibm-slider"]],
  viewQuery: function Slider_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c032, 5);
      ɵɵviewQuery(_c130, 5);
      ɵɵviewQuery(_c223, 5);
      ɵɵviewQuery(_c317, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.track = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.filledTrack = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.range = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.thumbs = _t);
    }
  },
  hostVars: 2,
  hostBindings: function Slider_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--form-item", ctx.hostClass);
    }
  },
  inputs: {
    min: "min",
    max: "max",
    step: "step",
    value: "value",
    id: "id",
    shiftMultiplier: "shiftMultiplier",
    skeleton: "skeleton",
    label: "label",
    disableArrowKeys: "disableArrowKeys",
    disabled: "disabled",
    readonly: "readonly"
  },
  outputs: {
    valueChange: "valueChange"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: Slider,
    multi: true
  }])],
  ngContentSelectors: _c510,
  decls: 3,
  vars: 2,
  consts: [["skeletonTemplate", ""], ["track", ""], ["filledTrack", ""], ["range", ""], ["thumbs", ""], [4, "ngIf", "ngIfElse"], ["class", "cds--label", 3, "for", "id", "ngClass", 4, "ngIf"], [1, "cds--slider-container", 3, "ngClass"], [1, "cds--slider__range-label", 3, "id"], [1, "cds--slider", 3, "click", "ngClass"], [4, "ngIf"], [1, "cds--slider__track"], [1, "cds--slider__filled-track"], ["aria-label", "slider", "type", "range", 1, "cds--slider__input", 3, "step", "min", "max", "value"], [1, "cds--label", 3, "for", "id", "ngClass"], [3, "ngTemplateOutlet"], [1, "cds--slider__thumb-wrapper", 3, "ngStyle"], ["role", "slider", "tabindex", "0", 1, "cds--slider__thumb", 3, "mousedown", "keydown", "id"], ["class", "cds--slider__thumb-wrapper", 3, "ngStyle", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "cds--label cds--skeleton", 4, "ngIf"], [1, "cds--slider-container", "cds--skeleton"], [1, "cds--slider__range-label"], [1, "cds--slider"], [1, "cds--slider__thumb"], [1, "cds--label", "cds--skeleton"]],
  template: function Slider_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c412);
      ɵɵtemplate(0, Slider_ng_container_0_Template, 17, 16, "ng-container", 5)(1, Slider_ng_template_1_Template, 8, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      const skeletonTemplate_r7 = ɵɵreference(2);
      ɵɵproperty("ngIf", !ctx.skeleton)("ngIfElse", skeletonTemplate_r7);
    }
  },
  dependencies: [NgClass, NgForOf, NgIf, NgTemplateOutlet, NgStyle],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Slider, [{
    type: Component,
    args: [{
      selector: "cds-slider, ibm-slider",
      template: `
		<ng-container *ngIf="!skeleton; else skeletonTemplate">
			<label
				*ngIf="label"
				[for]="id"
				[id]="labelId"
				class="cds--label"
				[ngClass]="{'cds--label--disabled': disabled}">
				<ng-container *ngIf="!isTemplate(label)">{{label}}</ng-container>
				<ng-template *ngIf="isTemplate(label)" [ngTemplateOutlet]="label"></ng-template>
			</label>
			<div
				class="cds--slider-container"
				[ngClass]="{ 'cds--slider-container--readonly': readonly }">
				<label [id]="bottomRangeId" class="cds--slider__range-label">
					<ng-content select="[minLabel]"></ng-content>
				</label>
				<div
					class="cds--slider"
					(click)="onClick($event)"
					[ngClass]="{
						'cds--slider--disabled': disabled,
						'cds--slider--readonly': readonly
					}">
					<ng-container *ngIf="!isRange()">
						<div class="cds--slider__thumb-wrapper"
							[ngStyle]="{insetInlineStart: getFractionComplete(value) * 100 + '%'}">
							<div
								#thumbs
								role="slider"
								[id]="id"
								[attr.aria-labelledby]="labelId"
								class="cds--slider__thumb"
								tabindex="0"
								(mousedown)="onMouseDown($event)"
								(keydown)="onKeyDown($event)">
							</div>
						</div>
					</ng-container>
					<ng-container *ngIf="isRange()">
						<div class="cds--slider__thumb-wrapper"
						 [ngStyle]="{insetInlineStart: getFractionComplete(thumb) * 100 + '%'}"
						 *ngFor="let thumb of value; let i = index; trackBy: trackThumbsBy">
							<div
								#thumbs
								role="slider"
								[id]="id + (i > 0 ? '-' + i : '')"
								[attr.aria-labelledby]="labelId"
								class="cds--slider__thumb"
								tabindex="0"
								(mousedown)="onMouseDown($event, i)"
								(keydown)="onKeyDown($event, i)">
							</div>
						</div>
					</ng-container>
					<div
						#track
						class="cds--slider__track">
					</div>
					<div
						#filledTrack
						class="cds--slider__filled-track">
					</div>
					<input
						#range
						aria-label="slider"
						class="cds--slider__input"
						type="range"
						[step]="step"
						[min]="min"
						[max]="max"
						[value]="value.toString()">
				</div>
				<label [id]="topRangeId" class="cds--slider__range-label">
					<ng-content select="[maxLabel]"></ng-content>
				</label>
				<ng-content select="input"></ng-content>
			</div>
		</ng-container>

		<ng-template #skeletonTemplate>
			<label *ngIf="label" class="cds--label cds--skeleton"></label>
			<div class="cds--slider-container cds--skeleton">
				<span class="cds--slider__range-label"></span>
				<div class="cds--slider">
					<div class="cds--slider__thumb"></div>
					<div class="cds--slider__track"></div>
					<div class="cds--slider__filled-track"></div>
				</div>
				<span class="cds--slider__range-label"></span>
			</div>
		</ng-template>
	`,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: Slider,
        multi: true
      }]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: EventService
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    step: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    shiftMultiplier: [{
      type: Input
    }],
    skeleton: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    disableArrowKeys: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.cds--form-item"]
    }],
    thumbs: [{
      type: ViewChildren,
      args: ["thumbs"]
    }],
    track: [{
      type: ViewChild,
      args: ["track"]
    }],
    filledTrack: [{
      type: ViewChild,
      args: ["filledTrack"]
    }],
    range: [{
      type: ViewChild,
      args: ["range"]
    }]
  });
})();
var SliderModule = class {
};
SliderModule.ɵfac = function SliderModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || SliderModule)();
};
SliderModule.ɵmod = ɵɵdefineNgModule({
  type: SliderModule,
  declarations: [Slider],
  imports: [CommonModule, UtilsModule],
  exports: [Slider]
});
SliderModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, UtilsModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SliderModule, [{
    type: NgModule,
    args: [{
      declarations: [Slider],
      exports: [Slider],
      imports: [CommonModule, UtilsModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-structured-list.mjs
var _c033 = ["*"];
function ListColumn_span_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span");
  }
}
function ListHeader_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 2);
  }
}
var _c131 = ["input"];
function ListRow_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "input", 2, 0);
    ɵɵlistener("focus", function ListRow_ng_container_1_Template_input_focus_1_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleFocus(true));
    })("blur", function ListRow_ng_container_1_Template_input_blur_1_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleFocus(false));
    })("change", function ListRow_ng_container_1_Template_input_change_1_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onChange($event));
    });
    ɵɵelementEnd();
    ɵɵelementStart(3, "div", 3);
    ɵɵnamespaceSVG();
    ɵɵelement(4, "svg", 4);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("value", ctx_r1.value)("name", ctx_r1.name)("title", ctx_r1.label)("checked", ctx_r1.selected);
  }
}
var _c224 = [[["cds-list-header"], ["ibm-list-header"]], "*"];
var _c318 = ["cds-list-header,ibm-list-header", "*"];
var _c413 = (a0, a1, a2, a3) => ({
  "cds--structured-list--flush": a0,
  "cds--structured-list--selection": a1,
  "cds--structured-list--condensed": a2,
  "cds--skeleton": a3
});
var ListColumn = class {
  constructor() {
    this.skeleton = false;
    this.role = "cell";
    this.isHeaderColumn = true;
    this.isBodyColumn = true;
    this.nowrap = false;
  }
};
ListColumn.ɵfac = function ListColumn_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ListColumn)();
};
ListColumn.ɵcmp = ɵɵdefineComponent({
  type: ListColumn,
  selectors: [["cds-list-column"], ["ibm-list-column"]],
  hostVars: 7,
  hostBindings: function ListColumn_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", ctx.role);
      ɵɵclassProp("cds--structured-list-th", ctx.isHeaderColumn)("cds--structured-list-td", ctx.isBodyColumn)("cds--structured-list-content--nowrap", ctx.nowrap);
    }
  },
  inputs: {
    skeleton: "skeleton",
    nowrap: "nowrap"
  },
  standalone: false,
  ngContentSelectors: _c033,
  decls: 2,
  vars: 1,
  consts: [[4, "ngIf"]],
  template: function ListColumn_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, ListColumn_span_0_Template, 1, 0, "span", 0);
      ɵɵprojection(1);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.skeleton);
    }
  },
  dependencies: [NgIf],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ListColumn, [{
    type: Component,
    args: [{
      selector: "cds-list-column, ibm-list-column",
      template: `
		<span *ngIf="skeleton"></span>
		<ng-content></ng-content>
	`
    }]
  }], null, {
    skeleton: [{
      type: Input
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    isHeaderColumn: [{
      type: HostBinding,
      args: ["class.cds--structured-list-th"]
    }],
    isBodyColumn: [{
      type: HostBinding,
      args: ["class.cds--structured-list-td"]
    }],
    nowrap: [{
      type: HostBinding,
      args: ["class.cds--structured-list-content--nowrap"]
    }, {
      type: Input
    }]
  });
})();
var ListHeader = class {
  constructor() {
    this.wrapper = true;
    this.role = "rowgroup";
    this.selection = false;
    this._skeleton = false;
  }
  set skeleton(value) {
    this._skeleton = value;
    this.updateChildren();
  }
  get skeleton() {
    return this._skeleton;
  }
  ngAfterContentInit() {
    this.columns.forEach((column) => {
      column.isBodyColumn = false;
      column.isHeaderColumn = true;
    });
    this.updateChildren();
  }
  updateChildren() {
    if (this.columns) {
      this.columns.toArray().forEach((child) => child.skeleton = this.skeleton);
    }
  }
};
ListHeader.ɵfac = function ListHeader_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ListHeader)();
};
ListHeader.ɵcmp = ɵɵdefineComponent({
  type: ListHeader,
  selectors: [["cds-list-header"], ["ibm-list-header"]],
  contentQueries: function ListHeader_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ListColumn, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columns = _t);
    }
  },
  hostVars: 3,
  hostBindings: function ListHeader_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", ctx.role);
      ɵɵclassProp("cds--structured-list-thead", ctx.wrapper);
    }
  },
  inputs: {
    skeleton: "skeleton"
  },
  standalone: false,
  ngContentSelectors: _c033,
  decls: 3,
  vars: 1,
  consts: [["role", "row", 1, "cds--structured-list-row", "cds--structured-list-row--header-row"], ["class", "cds--structured-list-th", 4, "ngIf"], [1, "cds--structured-list-th"]],
  template: function ListHeader_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 0);
      ɵɵprojection(1);
      ɵɵtemplate(2, ListHeader_div_2_Template, 1, 0, "div", 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.selection);
    }
  },
  dependencies: [NgIf],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ListHeader, [{
    type: Component,
    args: [{
      selector: "cds-list-header, ibm-list-header",
      template: `
		<div class="cds--structured-list-row cds--structured-list-row--header-row" role="row">
			<ng-content></ng-content>
			<div *ngIf="selection" class="cds--structured-list-th"></div>
		</div>
	`
    }]
  }], null, {
    wrapper: [{
      type: HostBinding,
      args: ["class.cds--structured-list-thead"]
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    skeleton: [{
      type: Input
    }],
    columns: [{
      type: ContentChildren,
      args: [ListColumn]
    }]
  });
})();
var ListRow = class {
  constructor() {
    this.selected = false;
    this.change = new EventEmitter();
    this.selection = false;
    this.name = "list";
    this.wrapper = true;
    this.role = "row";
    this.isFocused = false;
  }
  get focusClass() {
    return this.isFocused;
  }
  ngAfterContentInit() {
    this.columns.forEach((column) => {
      column.isBodyColumn = true;
      column.isHeaderColumn = false;
    });
  }
  onclick() {
    if (this.selection) {
      this.input.nativeElement.click();
    }
  }
  onChange(event) {
    this.change.emit(event);
  }
  handleFocus(isFocused) {
    if (this.selection) {
      this.isFocused = isFocused;
      if (this.isFocused) {
        this.input.nativeElement.click();
      }
    }
  }
};
ListRow.ɵfac = function ListRow_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ListRow)();
};
ListRow.ɵcmp = ɵɵdefineComponent({
  type: ListRow,
  selectors: [["cds-list-row"], ["ibm-list-row"]],
  contentQueries: function ListRow_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ListColumn, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columns = _t);
    }
  },
  viewQuery: function ListRow_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c131, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.input = _t.first);
    }
  },
  hostVars: 8,
  hostBindings: function ListRow_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function ListRow_click_HostBindingHandler() {
        return ctx.onclick();
      });
    }
    if (rf & 2) {
      ɵɵattribute("aria-label", ctx.label)("role", ctx.role);
      ɵɵclassProp("cds--structured-list-row--focused-within", ctx.focusClass)("cds--structured-list-row--selected", ctx.selected)("cds--structured-list-row", ctx.wrapper);
    }
  },
  inputs: {
    selected: "selected",
    label: "label",
    value: "value"
  },
  outputs: {
    change: "change"
  },
  standalone: false,
  ngContentSelectors: _c033,
  decls: 2,
  vars: 1,
  consts: [["input", ""], [4, "ngIf"], ["type", "radio", 1, "cds--structured-list-input", "cds--visually-hidden", 3, "focus", "blur", "change", "value", "name", "title", "checked"], [1, "cds--structured-list-td"], ["cdsIcon", "checkmark--filled", "size", "16", 1, "cds--structured-list-svg"]],
  template: function ListRow_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
      ɵɵtemplate(1, ListRow_ng_container_1_Template, 5, 4, "ng-container", 1);
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.selection);
    }
  },
  dependencies: [NgIf, IconDirective],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ListRow, [{
    type: Component,
    args: [{
      selector: "cds-list-row, ibm-list-row",
      template: `
		<ng-content></ng-content>
		<ng-container *ngIf="selection">
			<input
				#input
				class="cds--structured-list-input cds--visually-hidden"
				type="radio"
				[value]="value"
				[name]="name"
				[title]="label"
				(focus)="handleFocus(true)"
				(blur)="handleFocus(false)"
				(change)="onChange($event)"
				[checked]="selected"/>
			<div class="cds--structured-list-td">
				<svg cdsIcon="checkmark--filled" size="16" class="cds--structured-list-svg"></svg>
			</div>
		</ng-container>
	`
    }]
  }], null, {
    focusClass: [{
      type: HostBinding,
      args: ["class.cds--structured-list-row--focused-within"]
    }],
    selected: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.cds--structured-list-row--selected"]
    }],
    label: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.aria-label"]
    }],
    value: [{
      type: Input
    }],
    change: [{
      type: Output
    }],
    wrapper: [{
      type: HostBinding,
      args: ["class.cds--structured-list-row"]
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    columns: [{
      type: ContentChildren,
      args: [ListColumn]
    }],
    input: [{
      type: ViewChild,
      args: ["input"]
    }],
    onclick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var StructuredList = class _StructuredList {
  constructor() {
    this.selection = false;
    this.flushed = false;
    this.condensed = false;
    this.name = `structured-list-${_StructuredList.listCount++}`;
    this.selected = new EventEmitter();
    this._skeleton = false;
    this.onChange = (_) => {
    };
    this.onTouched = () => {
    };
  }
  /**
   * Sets the skeleton value for all `ListHeader` to the skeleton value of `StructuredList`.
   */
  set skeleton(value) {
    this._skeleton = value;
    this.updateChildren();
  }
  /**
   * Returns the skeleton value in the `StructuredList` if there is one.
   */
  get skeleton() {
    return this._skeleton;
  }
  ngAfterContentInit() {
    const setSelection = (rowOrHeader) => {
      rowOrHeader.selection = this.selection;
    };
    this.headers.forEach(setSelection);
    this.rows.forEach((row) => {
      setSelection(row);
      row.name = this.name;
      row.change.subscribe(() => {
        this.selected.emit({
          value: row.value,
          selected: row.selected,
          name: this.name
        });
        this.onChange(row.value);
        this.writeValue(row.value);
      });
    });
    this.updateChildren();
  }
  writeValue(value) {
    if (!this.rows) {
      return;
    }
    this.rows.forEach((row) => {
      if (row.value === value) {
        row.selected = true;
      } else {
        row.selected = false;
      }
    });
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  updateChildren() {
    if (this.headers) {
      this.headers.toArray().forEach((child) => child.skeleton = this.skeleton);
    }
  }
};
StructuredList.listCount = 0;
StructuredList.ɵfac = function StructuredList_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || StructuredList)();
};
StructuredList.ɵcmp = ɵɵdefineComponent({
  type: StructuredList,
  selectors: [["cds-structured-list"], ["ibm-structured-list"]],
  contentQueries: function StructuredList_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ListRow, 4);
      ɵɵcontentQuery(dirIndex, ListHeader, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.rows = _t);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headers = _t);
    }
  },
  inputs: {
    selection: "selection",
    flushed: "flushed",
    condensed: "condensed",
    name: "name",
    skeleton: "skeleton"
  },
  outputs: {
    selected: "selected"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: StructuredList,
    multi: true
  }])],
  ngContentSelectors: _c318,
  decls: 4,
  vars: 6,
  consts: [["role", "table", 1, "cds--structured-list", 3, "ngClass"], ["role", "rowgroup", 1, "cds--structured-list-tbody"]],
  template: function StructuredList_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c224);
      ɵɵelementStart(0, "div", 0);
      ɵɵprojection(1);
      ɵɵelementStart(2, "div", 1);
      ɵɵprojection(3, 1);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵproperty("ngClass", ɵɵpureFunction4(1, _c413, ctx.flushed, ctx.selection, ctx.condensed, ctx.skeleton));
    }
  },
  dependencies: [NgClass],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StructuredList, [{
    type: Component,
    args: [{
      selector: "cds-structured-list, ibm-structured-list",
      template: `
		<div
			class="cds--structured-list"
			role="table"
			[ngClass]="{
				'cds--structured-list--flush': flushed,
				'cds--structured-list--selection': selection,
				'cds--structured-list--condensed': condensed,
				'cds--skeleton': skeleton
			}">
			<ng-content select="cds-list-header,ibm-list-header"></ng-content>
			<div class="cds--structured-list-tbody" role="rowgroup">
				<ng-content></ng-content>
			</div>
		</div>
	`,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: StructuredList,
        multi: true
      }]
    }]
  }], null, {
    selection: [{
      type: Input
    }],
    flushed: [{
      type: Input
    }],
    condensed: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    skeleton: [{
      type: Input
    }],
    selected: [{
      type: Output
    }],
    rows: [{
      type: ContentChildren,
      args: [ListRow]
    }],
    headers: [{
      type: ContentChildren,
      args: [ListHeader]
    }]
  });
})();
var StructuredListModule = class {
};
StructuredListModule.ɵfac = function StructuredListModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || StructuredListModule)();
};
StructuredListModule.ɵmod = ɵɵdefineNgModule({
  type: StructuredListModule,
  declarations: [StructuredList, ListRow, ListHeader, ListColumn],
  imports: [CommonModule, IconModule],
  exports: [StructuredList, ListRow, ListHeader, ListColumn]
});
StructuredListModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, IconModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StructuredListModule, [{
    type: NgModule,
    args: [{
      declarations: [StructuredList, ListRow, ListHeader, ListColumn],
      exports: [StructuredList, ListRow, ListHeader, ListColumn],
      imports: [CommonModule, IconModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-table.mjs
var _c034 = ["*", [["cds-table-toolbar-actions"], ["ibm-table-toolbar-actions"]]];
var _c133 = ["*", "cds-table-toolbar-actions,ibm-table-toolbar-actions"];
var _c225 = (a0) => ({
  "cds--table-toolbar--sm": a0
});
var _c319 = (a0) => ({
  "cds--batch-actions--active": a0
});
var _c414 = (a0) => ({
  count: a0
});
function TableToolbar_div_2_p_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "span");
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵtext(3);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const legacyText_r2 = ctx.ngIf;
    const n_r3 = ɵɵnextContext().ngIf;
    ɵɵadvance(2);
    ɵɵtextInterpolate(n_r3);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", legacyText_r2, " ");
  }
}
function TableToolbar_div_2_p_2_ng_template_3_span_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵpipe(2, "async");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵtextInterpolate(ɵɵpipeBind1(2, 1, ctx_r3._batchTextSingle.subject));
  }
}
function TableToolbar_div_2_p_2_ng_template_3_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵpipe(2, "i18nReplace");
    ɵɵpipe(3, "async");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const n_r3 = ɵɵnextContext(2).ngIf;
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ɵɵpipeBind1(3, 4, ɵɵpipeBind2(2, 1, ctx_r3._batchTextMultiple.subject, ɵɵpureFunction1(6, _c414, n_r3))));
  }
}
function TableToolbar_div_2_p_2_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TableToolbar_div_2_p_2_ng_template_3_span_0_Template, 3, 3, "span", 10)(1, TableToolbar_div_2_p_2_ng_template_3_span_1_Template, 4, 8, "span", 10);
  }
  if (rf & 2) {
    const n_r3 = ɵɵnextContext().ngIf;
    ɵɵproperty("ngIf", n_r3 === 1);
    ɵɵadvance();
    ɵɵproperty("ngIf", n_r3 !== 1);
  }
}
function TableToolbar_div_2_p_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "p", 8);
    ɵɵtemplate(1, TableToolbar_div_2_p_2_ng_container_1_Template, 4, 2, "ng-container", 9);
    ɵɵpipe(2, "async");
    ɵɵtemplate(3, TableToolbar_div_2_p_2_ng_template_3_Template, 2, 2, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const batchTextBlock_r5 = ɵɵreference(4);
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ɵɵpipeBind1(2, 2, ctx_r3._batchTextLegacy.subject))("ngIfElse", batchTextBlock_r5);
  }
}
function TableToolbar_div_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 3)(1, "div", 4);
    ɵɵtemplate(2, TableToolbar_div_2_p_2_Template, 5, 4, "p", 5);
    ɵɵelementEnd();
    ɵɵelementStart(3, "div", 6);
    ɵɵprojection(4, 1);
    ɵɵelementStart(5, "button", 7);
    ɵɵlistener("click", function TableToolbar_div_2_Template_button_click_5_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.onCancel());
    });
    ɵɵtext(6);
    ɵɵpipe(7, "async");
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵproperty("ngClass", ɵɵpureFunction1(6, _c319, ctx_r3.selected));
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r3.count);
    ɵɵadvance(3);
    ɵɵproperty("tabindex", ctx_r3.selected ? 0 : -1);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind1(7, 4, ctx_r3._cancelText.subject), " ");
  }
}
var _c511 = ["*"];
var _c68 = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) => ({
  "cds--search--sm": a0,
  "cds--search--md": a1,
  "cds--search--lg": a2,
  "cds--search--light": a3,
  "cds--skeleton": a4,
  "cds--search--expandable": a5,
  "cds--search--expanded": a6,
  "cds--toolbar-search": a7,
  "cds--toolbar-search--active": a8,
  "cds--toolbar-search-container-persistent": a9,
  "cds--toolbar-search-container-expandable": a10,
  "cds--toolbar-search-container-active": a11,
  "cds--search--fluid": a12,
  "cds--search--disabled": a13
});
var _c75 = (a0) => ({
  "cds--skeleton": a0
});
var _c85 = (a0) => ({
  "cds--search-close--hidden": a0
});
function TableToolbarSearch_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 6);
  }
}
function TableToolbarSearch_ng_template_4_button_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 10);
    ɵɵlistener("click", function TableToolbarSearch_ng_template_4_button_2_Template_button_click_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.openSearch());
    });
    ɵɵnamespaceSVG();
    ɵɵelement(1, "svg", 11);
    ɵɵelementEnd();
  }
}
function TableToolbarSearch_ng_template_4__svg_svg_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 11);
  }
}
function TableToolbarSearch_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "input", 7, 1);
    ɵɵlistener("input", function TableToolbarSearch_ng_template_4_Template_input_input_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onSearch($event.target.value));
    })("keyup.enter", function TableToolbarSearch_ng_template_4_Template_input_keyup_enter_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onEnter());
    });
    ɵɵelementEnd();
    ɵɵtemplate(2, TableToolbarSearch_ng_template_4_button_2_Template, 2, 0, "button", 8)(3, TableToolbarSearch_ng_template_4__svg_svg_3_Template, 1, 0, "svg", 9);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("type", ctx_r2.tableSearch || !ctx_r2.toolbar ? "text" : "search")("id", ctx_r2.id)("value", ctx_r2.value)("autocomplete", ctx_r2.autocomplete)("placeholder", ctx_r2.placeholder)("disabled", ctx_r2.disabled)("required", ctx_r2.required);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", !ctx_r2.tableSearch && ctx_r2.toolbar);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.tableSearch || !ctx_r2.toolbar);
  }
}
function TableToolbarSearch_button_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 12);
    ɵɵlistener("click", function TableToolbarSearch_button_6_Template_button_click_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.clearSearch());
    });
    ɵɵelementStart(1, "span", 13);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵnamespaceSVG();
    ɵɵelement(3, "svg", 14);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("ngClass", ɵɵpureFunction1(3, _c85, !ctx_r2.value || ctx_r2.value.length === 0))("title", ctx_r2.clearButtonTitle);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r2.clearButtonTitle);
  }
}
var _c95 = ["cdsTableHeadCell", ""];
var _c104 = (a0, a1) => ({
  "cds--table-sort--active": a0,
  "cds--table-sort--descending": a1
});
var _c1111 = (a0) => ({
  data: a0
});
function TableHeadCell_button_0_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 8);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.column.data, " ");
  }
}
function TableHeadCell_button_0_4_ng_template_0_Template(rf, ctx) {
}
function TableHeadCell_button_0_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TableHeadCell_button_0_4_ng_template_0_Template, 0, 0, "ng-template", 9);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.column.template)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c1111, ctx_r1.column.data));
  }
}
function TableHeadCell_button_0__svg_svg_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "svg", 10);
    ɵɵelement(1, "path", 11);
    ɵɵelementEnd();
  }
}
function TableHeadCell_button_0__svg_svg_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "svg", 12);
    ɵɵelement(1, "path", 13);
    ɵɵelementEnd();
  }
}
function TableHeadCell_button_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 2);
    ɵɵpipe(1, "async");
    ɵɵlistener("click", function TableHeadCell_button_0_Template_button_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onClick());
    });
    ɵɵelementStart(2, "span", 3);
    ɵɵtemplate(3, TableHeadCell_button_0_div_3_Template, 2, 1, "div", 4)(4, TableHeadCell_button_0_4_Template, 1, 4, null, 5)(5, TableHeadCell_button_0__svg_svg_5_Template, 2, 0, "svg", 6)(6, TableHeadCell_button_0__svg_svg_6_Template, 2, 0, "svg", 7);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngClass", ɵɵpureFunction2(9, _c104, ctx_r1.column.sorted, ctx_r1.column.ascending));
    ɵɵattribute("aria-label", ɵɵpipeBind1(1, 7, ctx_r1.column.sorted && ctx_r1.column.ascending ? ctx_r1.getSortDescendingLabel() : ctx_r1.getSortAscendingLabel()));
    ɵɵadvance(2);
    ɵɵproperty("title", ctx_r1.column.title);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.skeleton && !ctx_r1.column.template);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.skeleton && ctx_r1.column.template);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.skeleton);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.skeleton);
  }
}
function TableHeadCell_div_1_span_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.column.data, " ");
  }
}
function TableHeadCell_div_1_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 16);
    ɵɵtemplate(1, TableHeadCell_div_1_span_1_ng_container_1_Template, 2, 1, "ng-container", 5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("title", ctx_r1.column.data);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.skeleton);
  }
}
function TableHeadCell_div_1_ng_template_2_Template(rf, ctx) {
}
function TableHeadCell_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 14);
    ɵɵtemplate(1, TableHeadCell_div_1_span_1_Template, 2, 2, "span", 15)(2, TableHeadCell_div_1_ng_template_2_Template, 0, 0, "ng-template", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.column.template);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.column.template)("ngTemplateOutletContext", ɵɵpureFunction1(3, _c1111, ctx_r1.column.data));
  }
}
var _c1210 = ["cdsTableHeadCheckbox", ""];
function TableHeadCheckbox_cds_checkbox_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "cds-checkbox", 1);
    ɵɵlistener("checkedChange", function TableHeadCheckbox_cds_checkbox_0_Template_cds_checkbox_checkedChange_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.change.emit());
    });
    ɵɵtext(1);
    ɵɵpipe(2, "async");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r1.name)("checked", ctx_r1.checked)("indeterminate", ctx_r1.indeterminate)("hideLabel", true);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind1(2, 5, ctx_r1.getAriaLabel()), " ");
  }
}
var _c134 = ["cdsTableHeadExpand", ""];
function TableHeadExpand_button_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 2);
    ɵɵpipe(1, "async");
    ɵɵlistener("click", function TableHeadExpand_button_0_Template_button_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.expandedChange.emit(!ctx_r1.expanded));
    });
    ɵɵnamespaceSVG();
    ɵɵelement(2, "svg", 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵattribute("aria-label", ɵɵpipeBind1(1, 1, ctx_r1.getAriaLabel()));
  }
}
function TableHeadExpand_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵprojection(1);
    ɵɵelementContainerEnd();
  }
}
var _c142 = ["cdsTableHead", ""];
var _c152 = (a0) => ({
  "cds--table-expand-v2": a0
});
var _c162 = (a0) => ({
  "width": a0,
  "padding": 0,
  "border": 0
});
function TableHead_ng_container_0_th_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "th", 6);
    ɵɵlistener("expandedChange", function TableHead_ng_container_0_th_2_Template_th_expandedChange_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onExpandAllRowsChange($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("showExpandAllToggle", ctx_r1.showExpandAllToggle)("ngClass", ɵɵpureFunction1(4, _c152, ctx_r1.stickyHeader))("id", ctx_r1.model.getId("expand"))("expanded", ctx_r1.model.expandableRowsCount() === ctx_r1.model.expandedRowsCount());
  }
}
function TableHead_ng_container_0_th_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "th", 7);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("id", ctx_r1.model.getId("select"));
  }
}
function TableHead_ng_container_0_th_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "th", 8);
    ɵɵlistener("change", function TableHead_ng_container_0_th_4_Template_th_change_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onSelectAllCheckboxChange());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("checked", ctx_r1.selectAllCheckbox)("indeterminate", ctx_r1.selectAllCheckboxSomeSelected)("ariaLabel", ctx_r1.getCheckboxHeaderLabel())("skeleton", ctx_r1.skeleton)("name", ctx_r1.model.getHeaderId("select"))("id", ctx_r1.model.getId("select"));
  }
}
function TableHead_ng_container_0_ng_container_5_th_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "th", 10);
    ɵɵlistener("sort", function TableHead_ng_container_0_ng_container_5_th_1_Template_th_sort_0_listener() {
      ɵɵrestoreView(_r4);
      const i_r5 = ɵɵnextContext().index;
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.sort.emit(i_r5));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    const column_r7 = ctx_r5.$implicit;
    const i_r5 = ctx_r5.index;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassMap(column_r7.className);
    ɵɵproperty("ngStyle", column_r7.style)("sortable", ctx_r1.sortable)("skeleton", ctx_r1.skeleton)("id", ctx_r1.model.getId(i_r5))("column", column_r7)("filterTitle", ctx_r1.getFilterTitle());
    ɵɵattribute("colspan", column_r7.colSpan)("rowspan", column_r7.rowSpan);
  }
}
function TableHead_ng_container_0_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, TableHead_ng_container_0_ng_container_5_th_1_Template, 1, 10, "th", 9);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const column_r7 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", column_r7 && column_r7.visible);
  }
}
function TableHead_ng_container_0_th_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "th", 11);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngStyle", ɵɵpureFunction1(1, _c162, ctx_r1.scrollbarWidth + "px"));
  }
}
function TableHead_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "tr");
    ɵɵtemplate(2, TableHead_ng_container_0_th_2_Template, 1, 6, "th", 1)(3, TableHead_ng_container_0_th_3_Template, 1, 1, "th", 2)(4, TableHead_ng_container_0_th_4_Template, 1, 6, "th", 3)(5, TableHead_ng_container_0_ng_container_5_Template, 2, 1, "ng-container", 4)(6, TableHead_ng_container_0_th_6_Template, 1, 3, "th", 5);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r1.model.hasExpandableRows());
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.skeleton && ctx_r1.showSelectionColumn && ctx_r1.enableSingleSelect);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.skeleton && ctx_r1.showSelectionColumn && !ctx_r1.enableSingleSelect);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1.model.header);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.skeleton && ctx_r1.stickyHeader && ctx_r1.scrollbarWidth);
  }
}
var _c172 = ["cdsTableData", ""];
function TableData_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.item.data);
  }
}
function TableData_1_ng_template_0_Template(rf, ctx) {
}
function TableData_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TableData_1_ng_template_0_Template, 0, 0, "ng-template", 1);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.item.template)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c1111, ctx_r0.item.data));
  }
}
var _c182 = ["cdsTableCheckbox", ""];
function TableCheckbox_cds_checkbox_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "cds-checkbox", 1);
    ɵɵlistener("checkedChange", function TableCheckbox_cds_checkbox_0_Template_cds_checkbox_checkedChange_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.selectedChange.emit());
    });
    ɵɵtext(1);
    ɵɵpipe(2, "i18nReplace");
    ɵɵpipe(3, "async");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r1.name)("checked", ctx_r1.selected)("disabled", ctx_r1.disabled)("hideLabel", true);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind1(3, 8, ɵɵpipeBind2(2, 5, ctx_r1.getLabel(), ctx_r1.getSelectionLabelValue(ctx_r1.row))), " ");
  }
}
var _c192 = ["cdsTableRadio", ""];
function TableRadio_cds_radio_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "cds-radio", 1);
    ɵɵpipe(1, "i18nReplace");
    ɵɵpipe(2, "async");
    ɵɵpipe(3, "i18nReplace");
    ɵɵpipe(4, "async");
    ɵɵlistener("change", function TableRadio_cds_radio_0_Template_cds_radio_change_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.change.emit());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ariaLabel", ɵɵpipeBind1(2, 7, ɵɵpipeBind2(1, 4, ctx_r1.getLabel(), ctx_r1.getSelectionLabelValue(ctx_r1.row))))("checked", ctx_r1.selected)("disabled", ctx_r1.disabled);
    ɵɵattribute("aria-label", ɵɵpipeBind1(4, 12, ɵɵpipeBind2(3, 9, ctx_r1.getLabel(), ctx_r1.getSelectionLabelValue(ctx_r1.row))));
  }
}
var _c20 = ["cdsTableExpandButton", ""];
function TableExpandButton_button_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 1);
    ɵɵpipe(1, "async");
    ɵɵlistener("click", function TableExpandButton_button_0_Template_button_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.expandRow.emit());
    });
    ɵɵnamespaceSVG();
    ɵɵelement(2, "svg", 2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵattribute("aria-label", ɵɵpipeBind1(1, 1, ctx_r1.getAriaLabel()));
  }
}
var _c21 = ["cdsTableRow", ""];
function TableRowComponent_ng_container_0_td_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "td", 5);
    ɵɵlistener("expandRow", function TableRowComponent_ng_container_0_td_1_Template_td_expandRow_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.expandRow.emit());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("expanded", ctx_r1.expanded)("expandable", ctx_r1.expandable)("skeleton", ctx_r1.skeleton)("ariaLabel", ctx_r1.getExpandButtonAriaLabel())("headers", ctx_r1.model.getHeaderId("expand"));
  }
}
function TableRowComponent_ng_container_0_ng_container_2_td_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td");
  }
}
function TableRowComponent_ng_container_0_ng_container_2_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "td", 7);
    ɵɵlistener("selectedChange", function TableRowComponent_ng_container_0_ng_container_2_ng_template_2_Template_td_selectedChange_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.onSelectionChange());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("size", ctx_r1.size)("selected", ctx_r1.selected)("label", ctx_r1.getCheckboxLabel())("row", ctx_r1.row)("skeleton", ctx_r1.skeleton)("headers", ctx_r1.model.getHeaderId("select"));
  }
}
function TableRowComponent_ng_container_0_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, TableRowComponent_ng_container_0_ng_container_2_td_1_Template, 1, 0, "td", 6)(2, TableRowComponent_ng_container_0_ng_container_2_ng_template_2_Template, 1, 6, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const tableCheckboxTemplate_r4 = ɵɵreference(3);
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.showSelectionColumnCheckbox)("ngIfElse", tableCheckboxTemplate_r4);
  }
}
function TableRowComponent_ng_container_0_td_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "td", 8);
    ɵɵlistener("change", function TableRowComponent_ng_container_0_td_3_Template_td_change_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onSelectionChange());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("selected", ctx_r1.selected)("label", ctx_r1.getCheckboxLabel())("row", ctx_r1.row)("skeleton", ctx_r1.skeleton)("headers", ctx_r1.model.getHeaderId("select"));
  }
}
function TableRowComponent_ng_container_0_ng_container_4_td_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "td", 11);
    ɵɵlistener("click", function TableRowComponent_ng_container_0_ng_container_4_td_1_Template_td_click_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.onRowClick());
    })("keydown.enter", function TableRowComponent_ng_container_0_ng_container_4_td_1_Template_td_keydown_enter_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.onRowClick());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r6 = ɵɵnextContext();
    const item_r8 = ctx_r6.$implicit;
    const j_r9 = ctx_r6.index;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassMap(ctx_r1.model.getHeader(j_r9).className);
    ɵɵproperty("headers", ctx_r1.model.getHeaderId(j_r9, item_r8.colSpan))("item", item_r8)("title", item_r8.title)("ngStyle", ctx_r1.model.getHeader(j_r9).style)("skeleton", ctx_r1.skeleton);
    ɵɵattribute("colspan", item_r8.colSpan)("rowspan", item_r8.rowSpan);
  }
}
function TableRowComponent_ng_container_0_ng_container_4_td_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "td", 12);
    ɵɵlistener("click", function TableRowComponent_ng_container_0_ng_container_4_td_2_Template_td_click_0_listener() {
      ɵɵrestoreView(_r10);
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.onRowClick());
    })("keydown.enter", function TableRowComponent_ng_container_0_ng_container_4_td_2_Template_td_keydown_enter_0_listener() {
      ɵɵrestoreView(_r10);
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.onRowClick());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r6 = ɵɵnextContext();
    const item_r8 = ctx_r6.$implicit;
    const j_r9 = ctx_r6.index;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("headers", ctx_r1.model.getHeaderId(j_r9, item_r8.colSpan))("item", item_r8)("title", item_r8.title)("skeleton", ctx_r1.skeleton);
    ɵɵattribute("colspan", item_r8.colSpan)("rowspan", item_r8.rowSpan);
  }
}
function TableRowComponent_ng_container_0_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, TableRowComponent_ng_container_0_ng_container_4_td_1_Template, 1, 9, "td", 9)(2, TableRowComponent_ng_container_0_ng_container_4_td_2_Template, 1, 6, "td", 10);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r8 = ctx.$implicit;
    const j_r9 = ctx.index;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", item_r8 && ctx_r1.model.getHeader(j_r9) && ctx_r1.model.getHeader(j_r9).visible);
    ɵɵadvance();
    ɵɵproperty("ngIf", item_r8 && ctx_r1.model.getHeader(j_r9) == null);
  }
}
function TableRowComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, TableRowComponent_ng_container_0_td_1_Template, 1, 5, "td", 2)(2, TableRowComponent_ng_container_0_ng_container_2_Template, 4, 2, "ng-container", 1)(3, TableRowComponent_ng_container_0_td_3_Template, 1, 5, "td", 3)(4, TableRowComponent_ng_container_0_ng_container_4_Template, 3, 2, "ng-container", 4);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.model.hasExpandableRows());
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.skeleton && ctx_r1.showSelectionColumn && !ctx_r1.enableSingleSelect);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.skeleton && ctx_r1.showSelectionColumn && ctx_r1.enableSingleSelect);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1.row);
  }
}
var _c226 = ["cdsTableExpandedRow", ""];
function TableExpandedRow_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.firstExpandedDataInRow(ctx_r0.row), " ");
  }
}
function TableExpandedRow_ng_template_2_Template(rf, ctx) {
}
var _c232 = ["cdsTableBody", ""];
var _c242 = (a0, a1, a2, a3) => ({
  "tbody_row--success": a0,
  "tbody_row--warning": a1,
  "tbody_row--info": a2,
  "tbody_row--error": a3
});
function TableBody_ng_container_0_ng_container_1_tr_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "tr", 4);
    ɵɵlistener("selectRow", function TableBody_ng_container_0_ng_container_1_tr_1_Template_tr_selectRow_0_listener() {
      ɵɵrestoreView(_r1);
      const i_r2 = ɵɵnextContext().index;
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.onRowCheckboxChange(i_r2));
    })("deselectRow", function TableBody_ng_container_0_ng_container_1_tr_1_Template_tr_deselectRow_0_listener() {
      ɵɵrestoreView(_r1);
      const i_r2 = ɵɵnextContext().index;
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.onRowCheckboxChange(i_r2));
    })("expandRow", function TableBody_ng_container_0_ng_container_1_tr_1_Template_tr_expandRow_0_listener() {
      ɵɵrestoreView(_r1);
      const i_r2 = ɵɵnextContext().index;
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.model.expandRow(i_r2, !ctx_r2.model.isRowExpanded(i_r2)));
    })("rowClick", function TableBody_ng_container_0_ng_container_1_tr_1_Template_tr_rowClick_0_listener() {
      ɵɵrestoreView(_r1);
      const i_r2 = ɵɵnextContext().index;
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.onRowClick(i_r2));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    const row_r5 = ctx_r3.$implicit;
    const i_r2 = ctx_r3.index;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵclassMap(ctx_r2.model.rowsClass[i_r2] ? ctx_r2.model.rowsClass[i_r2] : null);
    ɵɵproperty("model", ctx_r2.model)("row", row_r5)("size", ctx_r2.size)("selected", ctx_r2.model.isRowSelected(i_r2))("expandable", ctx_r2.model.isRowExpandable(i_r2))("expanded", ctx_r2.model.isRowExpanded(i_r2))("checkboxLabel", ctx_r2.getCheckboxRowLabel())("expandButtonAriaLabel", ctx_r2.getExpandButtonAriaLabel())("showSelectionColumn", ctx_r2.showSelectionColumn)("enableSingleSelect", ctx_r2.enableSingleSelect)("skeleton", ctx_r2.skeleton)("ngClass", ɵɵpureFunction4(14, _c242, !ctx_r2.model.isRowSelected(i_r2) && ctx_r2.model.getRowContext(i_r2) === "success", !ctx_r2.model.isRowSelected(i_r2) && ctx_r2.model.getRowContext(i_r2) === "warning", !ctx_r2.model.isRowSelected(i_r2) && ctx_r2.model.getRowContext(i_r2) === "info", !ctx_r2.model.isRowSelected(i_r2) && ctx_r2.model.getRowContext(i_r2) === "error"));
  }
}
function TableBody_ng_container_0_ng_container_1_tr_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "tr", 5);
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    const row_r5 = ctx_r3.$implicit;
    const i_r2 = ctx_r3.index;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("row", row_r5)("expanded", ctx_r2.model.isRowExpanded(i_r2))("skeleton", ctx_r2.skeleton);
  }
}
function TableBody_ng_container_0_ng_container_1_ng_container_3_tr_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "tr", 7);
  }
  if (rf & 2) {
    const expandedDataRow_r6 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext(4);
    ɵɵproperty("model", ctx_r2.model)("showSelectionColumnCheckbox", false)("showSelectionColumn", ctx_r2.showSelectionColumn)("row", expandedDataRow_r6)("size", ctx_r2.size)("skeleton", ctx_r2.skeleton);
  }
}
function TableBody_ng_container_0_ng_container_1_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, TableBody_ng_container_0_ng_container_1_ng_container_3_tr_1_Template, 1, 6, "tr", 6);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const row_r5 = ɵɵnextContext().$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r2.firstExpandedDataInRow(row_r5));
  }
}
function TableBody_ng_container_0_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, TableBody_ng_container_0_ng_container_1_tr_1_Template, 1, 19, "tr", 2)(2, TableBody_ng_container_0_ng_container_1_tr_2_Template, 1, 3, "tr", 3)(3, TableBody_ng_container_0_ng_container_1_ng_container_3_Template, 2, 1, "ng-container", 0);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const row_r5 = ctx.$implicit;
    const i_r2 = ctx.index;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r2.model.isRowFiltered(i_r2));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.model.isRowExpandable(i_r2) && !ctx_r2.shouldExpandAsTable(row_r5) && !ctx_r2.model.isRowFiltered(i_r2));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.model.isRowExpandable(i_r2) && ctx_r2.shouldExpandAsTable(row_r5) && ctx_r2.model.isRowExpanded(i_r2) && !ctx_r2.model.isRowFiltered(i_r2));
  }
}
function TableBody_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, TableBody_ng_container_0_ng_container_1_Template, 4, 3, "ng-container", 1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r2.model.data);
  }
}
var _c252 = (a0) => ({
  "cds--data-table--sticky-header": a0
});
var _c262 = () => ({
  "overflow-y": "scroll"
});
function Table_tbody_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "tbody", 6);
    ɵɵlistener("deselectRow", function Table_tbody_2_Template_tbody_deselectRow_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onSelectRow($event));
    })("scroll", function Table_tbody_2_Template_tbody_scroll_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onScroll($event));
    })("selectRow", function Table_tbody_2_Template_tbody_selectRow_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onSelectRow($event));
    })("rowClick", function Table_tbody_2_Template_tbody_rowClick_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onRowClick($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("checkboxRowLabel", ctx_r2.getCheckboxRowLabel())("enableSingleSelect", ctx_r2.enableSingleSelect)("expandButtonAriaLabel", ctx_r2.expandButtonAriaLabel)("model", ctx_r2.model)("size", ctx_r2.size)("ngStyle", ɵɵpureFunction0(9, _c262))("selectionLabelColumn", ctx_r2.selectionLabelColumn)("showSelectionColumn", ctx_r2.showSelectionColumn)("skeleton", ctx_r2.skeleton);
  }
}
function Table_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
function Table_ng_template_6_Template(rf, ctx) {
}
function Table_tr_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr")(1, "td", 7)(2, "div", 8);
    ɵɵnamespaceSVG();
    ɵɵelementStart(3, "svg", 9);
    ɵɵelement(4, "circle", 10);
    ɵɵelementEnd()()()();
  }
}
function Table_tr_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "tr")(1, "td", 11)(2, "h5");
    ɵɵtext(3);
    ɵɵpipe(4, "async");
    ɵɵelementEnd();
    ɵɵelementStart(5, "button", 12);
    ɵɵlistener("click", function Table_tr_8_Template_button_click_5_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.scrollToTop($event));
    });
    ɵɵtext(6);
    ɵɵpipe(7, "async");
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance(3);
    ɵɵtextInterpolate(ɵɵpipeBind1(4, 2, ctx_r2.getEndOfDataText()));
    ɵɵadvance(3);
    ɵɵtextInterpolate1(" ", ɵɵpipeBind1(7, 4, ctx_r2.getScrollTopText()), " ");
  }
}
var TableToolbar = class {
  constructor(i18n) {
    this.i18n = i18n;
    this.size = "md";
    this.cancel = new EventEmitter();
    this.actionBarLabel = this.i18n.getOverridable("TABLE_TOOLBAR.ACTION_BAR");
    this._cancelText = this.i18n.getOverridable("TABLE_TOOLBAR.CANCEL");
    this._batchTextLegacy = this.i18n.getOverridable("TABLE_TOOLBAR.BATCH_TEXT");
    this._batchTextSingle = this.i18n.getOverridable("TABLE_TOOLBAR.BATCH_TEXT_SINGLE");
    this._batchTextMultiple = this.i18n.getOverridable("TABLE_TOOLBAR.BATCH_TEXT_MULTIPLE");
  }
  set batchText(value) {
    if (typeof value === "object") {
      this._batchTextSingle.override(value.SINGLE);
      this._batchTextMultiple.override(value.MULTIPLE);
    } else {
      this._batchTextLegacy.override(value);
    }
  }
  set ariaLabel(value) {
    this.actionBarLabel.override(value.ACTION_BAR);
  }
  set cancelText(value) {
    this._cancelText.override(value.CANCEL);
  }
  get cancelText() {
    return {
      CANCEL: this._cancelText.value
    };
  }
  get count() {
    return this.model.totalDataLength > 0 ? this.model.rowsSelected.reduce((previous, current) => previous + (current ? 1 : 0), 0) : 0;
  }
  get selected() {
    return this.model.totalDataLength > 0 ? this.model.rowsSelected.some((item) => item) : false;
  }
  onCancel() {
    this.model.selectAll(false);
    this.cancel.emit();
  }
};
TableToolbar.ɵfac = function TableToolbar_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TableToolbar)(ɵɵdirectiveInject(I18n));
};
TableToolbar.ɵcmp = ɵɵdefineComponent({
  type: TableToolbar,
  selectors: [["cds-table-toolbar"], ["ibm-table-toolbar"]],
  inputs: {
    model: "model",
    batchText: "batchText",
    ariaLabel: "ariaLabel",
    cancelText: "cancelText",
    size: "size"
  },
  outputs: {
    cancel: "cancel"
  },
  standalone: false,
  ngContentSelectors: _c133,
  decls: 4,
  vars: 7,
  consts: [["batchTextBlock", ""], [1, "cds--table-toolbar", 3, "ngClass"], ["class", "cds--batch-actions", 3, "ngClass", 4, "ngIf"], [1, "cds--batch-actions", 3, "ngClass"], [1, "cds--batch-summary"], ["class", "cds--batch-summary__para", 4, "ngIf"], [1, "cds--action-list"], ["cdsButton", "primary", 1, "cds--batch-summary__cancel", 3, "click", "tabindex"], [1, "cds--batch-summary__para"], [4, "ngIf", "ngIfElse"], [4, "ngIf"]],
  template: function TableToolbar_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c034);
      ɵɵelementStart(0, "section", 1);
      ɵɵpipe(1, "async");
      ɵɵtemplate(2, TableToolbar_div_2_Template, 8, 8, "div", 2);
      ɵɵprojection(3);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngClass", ɵɵpureFunction1(5, _c225, ctx.size === "sm"));
      ɵɵattribute("aria-label", ɵɵpipeBind1(1, 3, ctx.actionBarLabel.subject));
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.model);
    }
  },
  dependencies: [NgClass, NgIf, Button, AsyncPipe, ReplacePipe],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableToolbar, [{
    type: Component,
    args: [{
      selector: "cds-table-toolbar, ibm-table-toolbar",
      template: `
	<section
		class="cds--table-toolbar"
		[ngClass]="{'cds--table-toolbar--sm' : size === 'sm'}"
		[attr.aria-label]="actionBarLabel.subject | async">
		<div
			*ngIf="model"
			class="cds--batch-actions"
			[ngClass]="{
				'cds--batch-actions--active': selected
			}">
			<div class="cds--batch-summary">
				<p class="cds--batch-summary__para" *ngIf="count as n">
					<ng-container *ngIf="_batchTextLegacy.subject | async as legacyText; else batchTextBlock">
						<span>{{n}}</span> {{legacyText}}
					</ng-container>
					<ng-template #batchTextBlock>
						<span *ngIf="n === 1">{{_batchTextSingle.subject | async}}</span>
						<span *ngIf="n !== 1">{{_batchTextMultiple.subject | i18nReplace: {count: n} | async}}</span>
					</ng-template>
				</p>
			</div>
			<div class="cds--action-list">
				<ng-content select="cds-table-toolbar-actions,ibm-table-toolbar-actions"></ng-content>
				<button
					cdsButton="primary"
					class="cds--batch-summary__cancel"
					[tabindex]="selected ? 0 : -1"
					(click)="onCancel()">
					{{_cancelText.subject | async}}
				</button>
			</div>
		</div>
		<ng-content></ng-content>
	</section>
	`
    }]
  }], function() {
    return [{
      type: I18n
    }];
  }, {
    model: [{
      type: Input
    }],
    batchText: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    cancelText: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    cancel: [{
      type: Output
    }]
  });
})();
var TableToolbarActions = class {
};
TableToolbarActions.ɵfac = function TableToolbarActions_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TableToolbarActions)();
};
TableToolbarActions.ɵcmp = ɵɵdefineComponent({
  type: TableToolbarActions,
  selectors: [["cds-table-toolbar-actions"], ["ibm-table-toolbar-actions"]],
  standalone: false,
  ngContentSelectors: _c511,
  decls: 1,
  vars: 0,
  template: function TableToolbarActions_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableToolbarActions, [{
    type: Component,
    args: [{
      selector: "cds-table-toolbar-actions, ibm-table-toolbar-actions",
      template: `<ng-content></ng-content>`
    }]
  }], null, null);
})();
var TableToolbarSearch = class extends Search {
  constructor() {
    super(...arguments);
    this.tableSearch = true;
    this.size = "lg";
    this.hostClass = true;
  }
  ngAfterViewInit() {
    setTimeout(() => {
      if (this.value) {
        this.openSearch();
      }
    });
  }
};
TableToolbarSearch.ɵfac = /* @__PURE__ */ (() => {
  let ɵTableToolbarSearch_BaseFactory;
  return function TableToolbarSearch_Factory(__ngFactoryType__) {
    return (ɵTableToolbarSearch_BaseFactory || (ɵTableToolbarSearch_BaseFactory = ɵɵgetInheritedFactory(TableToolbarSearch)))(__ngFactoryType__ || TableToolbarSearch);
  };
})();
TableToolbarSearch.ɵcmp = ɵɵdefineComponent({
  type: TableToolbarSearch,
  selectors: [["cds-table-toolbar-search"], ["ibm-table-toolbar-search"]],
  hostVars: 2,
  hostBindings: function TableToolbarSearch_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--toolbar-content", ctx.hostClass);
    }
  },
  standalone: false,
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: TableToolbarSearch,
    multi: true
  }]), ɵɵInheritDefinitionFeature],
  decls: 7,
  vars: 25,
  consts: [["enableInput", ""], ["input", ""], ["role", "search", 1, "cds--search", 3, "click", "ngClass"], [1, "cds--label", 3, "for", "ngClass"], ["class", "cds--text-input cds--skeleton", 4, "ngIf", "ngIfElse"], ["class", "cds--search-close", 3, "ngClass", "title", "click", 4, "ngIf"], [1, "cds--text-input", "cds--skeleton"], [1, "cds--search-input", 3, "input", "keyup.enter", "type", "id", "value", "autocomplete", "placeholder", "disabled", "required"], ["class", "cds--toolbar-search__btn", "aria-label", "Open search", 3, "click", 4, "ngIf"], ["cdsIcon", "search", "class", "cds--search-magnifier-icon", "size", "16", 4, "ngIf"], ["aria-label", "Open search", 1, "cds--toolbar-search__btn", 3, "click"], ["cdsIcon", "search", "size", "16", 1, "cds--search-magnifier-icon"], [1, "cds--search-close", 3, "click", "ngClass", "title"], [1, "cds--visually-hidden"], ["cdsIcon", "close", "size", "16"]],
  template: function TableToolbarSearch_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵelementStart(0, "div", 2);
      ɵɵlistener("click", function TableToolbarSearch_Template_div_click_0_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.openSearch());
      });
      ɵɵelementStart(1, "label", 3);
      ɵɵtext(2);
      ɵɵelementEnd();
      ɵɵtemplate(3, TableToolbarSearch_div_3_Template, 1, 0, "div", 4)(4, TableToolbarSearch_ng_template_4_Template, 4, 9, "ng-template", null, 0, ɵɵtemplateRefExtractor)(6, TableToolbarSearch_button_6_Template, 4, 5, "button", 5);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      const enableInput_r6 = ɵɵreference(5);
      ɵɵproperty("ngClass", ɵɵpureFunctionV(8, _c68, [ctx.size === "sm", ctx.size === "md", ctx.size === "lg", ctx.theme === "light", ctx.skeleton && !ctx.fluid, ctx.expandable && !ctx.tableSearch, ctx.expandable && !ctx.tableSearch && ctx.active, ctx.toolbar && !ctx.expandable, ctx.toolbar && !ctx.expandable && ctx.active, ctx.tableSearch && !ctx.expandable, ctx.tableSearch && ctx.expandable, ctx.tableSearch && ctx.expandable && ctx.active, ctx.fluid, ctx.disabled]));
      ɵɵattribute("aria-label", ctx.ariaLabel);
      ɵɵadvance();
      ɵɵproperty("for", ctx.id)("ngClass", ɵɵpureFunction1(23, _c75, ctx.skeleton && ctx.fluid));
      ɵɵadvance();
      ɵɵtextInterpolate1(" ", !ctx.skeleton ? ctx.label : "", " ");
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.skeleton)("ngIfElse", enableInput_r6);
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.tableSearch || !ctx.toolbar);
    }
  },
  dependencies: [NgClass, NgIf, IconDirective],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableToolbarSearch, [{
    type: Component,
    args: [{
      selector: "cds-table-toolbar-search, ibm-table-toolbar-search",
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: TableToolbarSearch,
        multi: true
      }],
      template: `<div
	class="cds--search"
	[ngClass]="{
		'cds--search--sm': size === 'sm',
		'cds--search--md': size === 'md',
		'cds--search--lg': size === 'lg',
		'cds--search--light': theme === 'light',
		'cds--skeleton': skeleton && !fluid,
		'cds--search--expandable': expandable && !tableSearch,
		'cds--search--expanded': expandable && !tableSearch && active,
		'cds--toolbar-search': toolbar && !expandable,
		'cds--toolbar-search--active': toolbar && !expandable && active,
		'cds--toolbar-search-container-persistent': tableSearch && !expandable,
		'cds--toolbar-search-container-expandable': tableSearch && expandable,
		'cds--toolbar-search-container-active': tableSearch && expandable && active,
		'cds--search--fluid': fluid,
		'cds--search--disabled': disabled
	}"
	role="search"
	[attr.aria-label]="ariaLabel"
	(click)="openSearch()">
	<label
		class="cds--label"
		[for]="id"
		[ngClass]="{ 'cds--skeleton': skeleton && fluid }">
		{{ !skeleton ? label : ''}}
	</label>

	<div *ngIf="skeleton; else enableInput" class="cds--text-input cds--skeleton"></div>
	<ng-template #enableInput>
		<input
			#input
			class="cds--search-input"
			[type]="tableSearch || !toolbar ? 'text' : 'search'"
			[id]="id"
			[value]="value"
			[autocomplete]="autocomplete"
			[placeholder]="placeholder"
			[disabled]="disabled"
			[required]="required"
			(input)="onSearch($event.target.value)"
			(keyup.enter)="onEnter()"/>
		<button
			*ngIf="!tableSearch && toolbar"
			class="cds--toolbar-search__btn"
			(click)="openSearch()"
			aria-label="Open search">
			<svg cdsIcon="search" size="16" class="cds--search-magnifier-icon"></svg>
		</button>
		<svg
			cdsIcon="search"
			*ngIf="tableSearch || !toolbar"
			class="cds--search-magnifier-icon"
			size="16">
		</svg>
	</ng-template>

	<button
		*ngIf="tableSearch || !toolbar"
		class="cds--search-close"
		[ngClass]="{
			'cds--search-close--hidden': !value || value.length === 0
		}"
		[title]="clearButtonTitle"
		(click)="clearSearch()">
		<span class="cds--visually-hidden">{{ clearButtonTitle }}</span>
		<svg cdsIcon="close" size="16"></svg>
	</button>
</div>
`
    }]
  }], null, {
    hostClass: [{
      type: HostBinding,
      args: ["class.cds--toolbar-content"]
    }]
  });
})();
var TableToolbarContent = class {
  constructor() {
    this.class = true;
  }
};
TableToolbarContent.ɵfac = function TableToolbarContent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TableToolbarContent)();
};
TableToolbarContent.ɵcmp = ɵɵdefineComponent({
  type: TableToolbarContent,
  selectors: [["cds-table-toolbar-content"], ["ibm-table-toolbar-content"]],
  hostVars: 2,
  hostBindings: function TableToolbarContent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--toolbar-content", ctx.class);
    }
  },
  standalone: false,
  ngContentSelectors: _c511,
  decls: 1,
  vars: 0,
  template: function TableToolbarContent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableToolbarContent, [{
    type: Component,
    args: [{
      selector: "cds-table-toolbar-content, ibm-table-toolbar-content",
      template: `<ng-content></ng-content>`
    }]
  }], null, {
    class: [{
      type: HostBinding,
      args: ["class.cds--toolbar-content"]
    }]
  });
})();
var TableHeaderDescription = class _TableHeaderDescription {
  constructor() {
    this.id = `table-description-${_TableHeaderDescription.counter++}`;
    this.descriptionClass = true;
  }
};
TableHeaderDescription.counter = 0;
TableHeaderDescription.ɵfac = function TableHeaderDescription_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TableHeaderDescription)();
};
TableHeaderDescription.ɵdir = ɵɵdefineDirective({
  type: TableHeaderDescription,
  selectors: [["", "cdsTableHeaderDescription", ""], ["", "ibmTableHeaderDescription", ""]],
  hostVars: 3,
  hostBindings: function TableHeaderDescription_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("id", ctx.id);
      ɵɵclassProp("cds--data-table-header__description", ctx.descriptionClass);
    }
  },
  inputs: {
    id: "id"
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableHeaderDescription, [{
    type: Directive,
    args: [{
      selector: "[cdsTableHeaderDescription], [ibmTableHeaderDescription]"
    }]
  }], null, {
    id: [{
      type: HostBinding,
      args: ["attr.id"]
    }, {
      type: Input
    }],
    descriptionClass: [{
      type: HostBinding,
      args: ["class.cds--data-table-header__description"]
    }]
  });
})();
var TableHeaderTitle = class _TableHeaderTitle {
  constructor() {
    this.id = `table-title-${_TableHeaderTitle.counter++}`;
    this.titleClass = true;
  }
};
TableHeaderTitle.counter = 0;
TableHeaderTitle.ɵfac = function TableHeaderTitle_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TableHeaderTitle)();
};
TableHeaderTitle.ɵdir = ɵɵdefineDirective({
  type: TableHeaderTitle,
  selectors: [["", "cdsTableHeaderTitle", ""], ["", "ibmTableHeaderTitle", ""]],
  hostVars: 3,
  hostBindings: function TableHeaderTitle_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("id", ctx.id);
      ɵɵclassProp("cds--data-table-header__title", ctx.titleClass);
    }
  },
  inputs: {
    id: "id"
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableHeaderTitle, [{
    type: Directive,
    args: [{
      selector: "[cdsTableHeaderTitle], [ibmTableHeaderTitle]"
    }]
  }], null, {
    id: [{
      type: HostBinding,
      args: ["attr.id"]
    }, {
      type: Input
    }],
    titleClass: [{
      type: HostBinding,
      args: ["class.cds--data-table-header__title"]
    }]
  });
})();
var TableHeaderItem = class {
  /**
   * Creates an instance of TableHeaderItem.
   */
  constructor(rawData) {
    this.visible = true;
    this.sorted = false;
    this.sortable = true;
    this.filterCount = 0;
    this.rowSpan = 1;
    this.colSpan = 1;
    this.style = {};
    this.sortDirection = "NONE";
    const defaults2 = {
      data: "",
      visible: this.visible,
      style: this.style,
      filterCount: this.filterCount,
      filterData: {
        data: ""
      }
    };
    const data = Object.assign({}, defaults2, rawData);
    for (let property of Object.getOwnPropertyNames(data)) {
      if (data.hasOwnProperty(property)) {
        this[property] = data[property];
      }
    }
  }
  /**
   * If true, sort is set to ascending, if false descending will be true.
   *
   */
  set ascending(asc) {
    this.sortDirection = asc ? "ASCENDING" : "DESCENDING";
  }
  get ascending() {
    return this.sortDirection === "ASCENDING";
  }
  /**
   * If true, sort is set to descending, if false ascending will be true.
   *
   */
  set descending(desc) {
    this.sortDirection = desc ? "DESCENDING" : "ASCENDING";
  }
  get descending() {
    return this.sortDirection === "DESCENDING";
  }
  get title() {
    if (this._title) {
      return this._title;
    }
    if (!this.data) {
      return "";
    }
    if (typeof this.data === "string") {
      return this.data;
    }
    if (this.data.toString && this.data.constructor !== {}.constructor) {
      return this.data.toString();
    }
    return "";
  }
  set title(title) {
    this._title = title;
  }
  /**
   * Used for sorting rows of the table.
   *
   * Override to enable different sorting.
   *
   * < 0 if `one` should go before `two`
   * > 0 if `one` should go after `two`
   * 0 if it doesn't matter (they are the same)
   */
  compare(one, two) {
    if (!one || !two) {
      return 0;
    }
    if (typeof one.data === "string") {
      return one.data.localeCompare(two.data);
    }
    if (one.data < two.data) {
      return -1;
    } else if (one.data > two.data) {
      return 1;
    } else {
      return 0;
    }
  }
  /**
   * Used to filter rows in the table.
   *
   * Override to make a custom filter.
   *
   * Even though there is just one filter function, there can be multiple filters.
   * When implementing filter, set `filterCount` before returning.
   *
   * `true` to hide the row
   * `false` to show the row
   */
  filter(item) {
    this.filterCount = 0;
    return false;
  }
};
var TableItem = class {
  /**
   * Creates an instance of TableItem.
   */
  constructor(rawData) {
    this.rowSpan = 1;
    this.colSpan = 1;
    const defaults2 = {
      data: ""
    };
    const data = Object.assign({}, defaults2, rawData);
    for (const property of Object.getOwnPropertyNames(data)) {
      if (data.hasOwnProperty(property)) {
        this[property] = data[property];
      }
    }
  }
  get title() {
    if (typeof this._title === "string") {
      return this._title;
    }
    if (!this.data) {
      return "";
    }
    if (typeof this.data === "string") {
      return this.data;
    }
    if (this.data.toString && this.data.constructor !== {}.constructor) {
      return this.data.toString();
    }
    return "";
  }
  set title(title) {
    this._title = title;
  }
};
var TableModel = class _TableModel {
  constructor() {
    this.dataChange = new EventEmitter();
    this.rowsSelectedChange = new EventEmitter();
    this.rowsExpandedChange = new EventEmitter();
    this.rowsExpandedAllChange = new EventEmitter();
    this.rowsCollapsedAllChange = new EventEmitter();
    this.selectAllChange = new Subject();
    this.rowsSelected = [];
    this.rowsExpanded = [];
    this.rowsIndices = [];
    this.rowsContext = [];
    this.rowsClass = [];
    this.header = [];
    this.currentPage = 1;
    this.pageLength = 10;
    this.isEnd = false;
    this.isLoading = false;
    this._data = [[]];
    this.tableModelCount = 0;
    this.tableModelCount = _TableModel.COUNT++;
  }
  /**
   * Sets data of the table.
   *
   * Make sure all rows are the same length to keep the column count accurate.
   */
  set data(newData) {
    if (!newData || Array.isArray(newData) && newData.length === 0) {
      newData = [[]];
    }
    this._data = newData;
    this.rowsSelected = new Array(this._data.length).fill(false);
    this.rowsExpanded = new Array(this._data.length).fill(false);
    this.rowsIndices = [...Array(this._data.length).keys()];
    this.rowsContext = new Array(this._data.length);
    this.rowsClass = new Array(this._data.length);
    if (this.header == null || this.header.length !== this._data[0].length && this._data[0].length > 0) {
      let header = new Array();
      for (let i = 0; i < this._data[0].length; i++) {
        header.push(new TableHeaderItem());
      }
      this.header = header;
    }
    this.dataChange.emit();
  }
  /**
   * Gets the full data.
   *
   * You can use it to alter individual `TableItem`s but if you need to change
   * table structure, use `addRow()` and/or `addColumn()`
   */
  get data() {
    return this._data;
  }
  /**
   * Manually set data length in case the data in the table doesn't
   * correctly reflect all the data that table is to display.
   *
   * Example: if you have multiple pages of data that table will display
   * but you're loading one at a time.
   *
   * Set to `null` to reset to default behavior.
   */
  set totalDataLength(length) {
    this._totalDataLength = isNaN(length) ? null : length;
  }
  /**
   * Total length of data that table has access to, or the amount manually set
   */
  get totalDataLength() {
    if (this._totalDataLength !== null && this._totalDataLength >= 0) {
      return this._totalDataLength;
    }
    if (this.data && this.data.length === 1 && this.data[0].length === 0) {
      return 0;
    }
    return this.data.length;
  }
  /**
   * Returns an id for the given column
   *
   * @param column the column to generate an id for
   * @param row the row of the header to generate an id for
   */
  getId(column, row = 0) {
    return `table-header-${row}-${column}-${this.tableModelCount}`;
  }
  /**
   * Returns the id of the header. Used to link the cells with headers (or headers with headers)
   *
   * @param column the column to start getting headers for
   * @param colSpan the number of columns to get headers for (defaults to 1)
   */
  getHeaderId(column, colSpan = 1) {
    if (column === "select" || column === "expand") {
      return this.getId(column);
    }
    let ids = [];
    for (let i = column; i >= 0; i--) {
      if (this.header[i]) {
        for (let j = 0; j < colSpan; j++) {
          ids.push(this.getId(i + j));
        }
        break;
      }
    }
    return ids.join(" ");
  }
  /**
   * Finds closest header by trying the `column` and then working its way to the left
   *
   * @param column the target column
   */
  getHeader(column) {
    if (!this.header) {
      return null;
    }
    for (let i = column; i >= 0; i--) {
      const headerCell = this.header[i];
      if (headerCell) {
        return headerCell;
      }
    }
    return null;
  }
  /**
   * Returns how many rows is currently selected
   */
  selectedRowsCount() {
    let count = 0;
    if (this.rowsSelected) {
      this.rowsSelected.forEach((rowSelected) => {
        if (rowSelected) {
          count++;
        }
      });
    }
    return count;
  }
  /**
   * Returns how many rows is currently expanded
   */
  expandedRowsCount() {
    let count = 0;
    if (this.rowsExpanded) {
      this.rowsExpanded.forEach((rowExpanded) => {
        if (rowExpanded) {
          count++;
        }
      });
    }
    return count;
  }
  /**
   * Returns `index`th row of the table.
   *
   * Negative index starts from the end. -1 being the last element.
   *
   * @param index
   */
  row(index) {
    return this.data[this.realRowIndex(index)];
  }
  /**
   * Adds a row to the `index`th row or appends to table if index not provided.
   *
   * If row is shorter than other rows or not provided, it will be padded with
   * empty `TableItem` elements.
   *
   * If row is longer than other rows, others will be extended to match so no data is lost.
   *
   * If called on an empty table with no parameters, it creates a 1x1 table.
   *
   * Negative index starts from the end. -1 being the last element.
   *
   * @param [row]
   * @param [index]
   */
  addRow(row, index) {
    if (!this.data || this.data.length === 0 || this.data[0].length === 0) {
      let newData = new Array();
      newData.push(row ? row : [new TableItem()]);
      this.data = newData;
      return;
    }
    let realRow = row;
    const columnCount = this.data[0].length;
    if (row == null) {
      realRow = new Array();
      for (let i = 0; i < columnCount; i++) {
        realRow.push(new TableItem());
      }
    }
    if (realRow.length < columnCount) {
      const difference = columnCount - realRow.length;
      for (let i = 0; i < difference; i++) {
        realRow.push(new TableItem());
      }
    } else if (realRow.length > columnCount) {
      let difference = realRow.length - this.header.length;
      for (let j = 0; j < difference; j++) {
        this.header.push(new TableHeaderItem());
      }
      for (let i = 0; i < this.data.length; i++) {
        let currentRow = this.data[i];
        difference = realRow.length - currentRow.length;
        for (let j = 0; j < difference; j++) {
          currentRow.push(new TableItem());
        }
      }
    }
    if (index == null) {
      this.data.push(realRow);
      this.rowsSelected.push(false);
      this.rowsExpanded.push(false);
      this.rowsContext.push(void 0);
      this.rowsClass.push(void 0);
      this.rowsIndices.push(this.data.length - 1);
    } else {
      const ri = this.realRowIndex(index);
      this.data.splice(ri, 0, realRow);
      this.rowsSelected.splice(ri, 0, false);
      this.rowsExpanded.splice(ri, 0, false);
      this.rowsContext.splice(ri, 0, void 0);
      this.rowsClass.splice(ri, 0, void 0);
      this.rowsIndices.splice(ri, 0, this.data.length - 1);
    }
    this.dataChange.emit();
  }
  /**
   * Deletes `index`th row.
   *
   * Negative index starts from the end. -1 being the last element.
   *
   * @param index
   */
  deleteRow(index) {
    const rri = this.realRowIndex(index);
    this.data.splice(rri, 1);
    this.rowsSelected.splice(rri, 1);
    this.rowsExpanded.splice(rri, 1);
    this.rowsContext.splice(rri, 1);
    this.rowsClass.splice(rri, 1);
    const rowIndex = this.rowsIndices[rri];
    this.rowsIndices.splice(rri, 1);
    this.rowsIndices = this.rowsIndices.map((value) => value > rowIndex ? --value : value);
    this.dataChange.emit();
  }
  /**
   * Deletes all rows.
   */
  deleteAllRows() {
    this.data = [];
  }
  hasExpandableRows() {
    return this.data.some((data) => data.some((d) => d && d.expandedData));
  }
  /**
   * Number of rows that can be expanded.
   *
   * @returns number
   */
  expandableRowsCount() {
    return this.data.reduce((counter, _, index) => {
      counter = this.isRowExpandable(index) ? counter + 1 : counter;
      return counter;
    }, 0);
  }
  isRowExpandable(index) {
    return this.data[index].some((d) => d && d.expandedData);
  }
  isRowExpanded(index) {
    return this.rowsExpanded[index];
  }
  getRowContext(index) {
    return this.rowsContext[index];
  }
  /**
   * Returns `index`th column of the table.
   *
   * Negative index starts from the end. -1 being the last element.
   *
   * @param index
   */
  column(index) {
    let column = new Array();
    const ri = this.realColumnIndex(index);
    const rc = this.data.length;
    for (let i = 0; i < rc; i++) {
      const row = this.data[i];
      column.push(row[ri]);
    }
    return column;
  }
  /**
   * Adds a column to the `index`th column or appends to table if index not provided.
   *
   * If column is shorter than other columns or not provided, it will be padded with
   * empty `TableItem` elements.
   *
   * If column is longer than other columns, others will be extended to match so no data is lost.
   *
   * If called on an empty table with no parameters, it creates a 1x1 table.
   *
   * Negative index starts from the end. -1 being the last element.
   *
   * @param [column]
   * @param [index]
   */
  addColumn(column, index) {
    if (!this.data || this.data.length === 0 || this.data[0].length === 0) {
      let newData = new Array();
      if (column == null) {
        newData.push([new TableItem()]);
      } else {
        for (let i = 0; i < column.length; i++) {
          let item = column[i];
          newData.push([item]);
        }
      }
      this.data = newData;
      return;
    }
    let rc = this.data.length;
    let ci = this.realColumnIndex(index);
    for (let i = 0; column != null && i < column.length - rc; i++) {
      this.addRow();
    }
    rc = this.data.length;
    if (index == null) {
      for (let i = 0; i < rc; i++) {
        let row = this.data[i];
        row.push(column == null || column[i] == null ? new TableItem() : column[i]);
      }
      if (this.header.length < this.data[0].length) {
        this.header.push(new TableHeaderItem());
      }
    } else {
      if (index >= this.data[0].length) {
        ci++;
      }
      for (let i = 0; i < rc; i++) {
        let row = this.data[i];
        row.splice(ci, 0, column == null || column[i] == null ? new TableItem() : column[i]);
      }
      if (this.header.length < this.data[0].length) {
        this.header.splice(ci, 0, new TableHeaderItem());
      }
    }
    this.dataChange.emit();
  }
  /**
   * Deletes `index`th column.
   *
   * Negative index starts from the end. -1 being the last element.
   *
   * @param index
   */
  deleteColumn(index) {
    const rci = this.realColumnIndex(index);
    const rowCount = this.data.length;
    for (let i = 0; i < rowCount; i++) {
      this.data[i].splice(rci, 1);
    }
    if (this.header.length > this.data[0].length) {
      this.header.splice(rci, 1);
    }
    this.dataChange.emit();
  }
  moveColumn(indexFrom, indexTo) {
    const headerFrom = this.header[indexFrom];
    this.addColumn(this.column(indexFrom), indexTo);
    this.deleteColumn(indexFrom + (indexTo < indexFrom ? 1 : 0));
    this.header[indexTo + (indexTo > indexFrom ? -1 : 0)] = headerFrom;
  }
  /**
   * cycle through the three sort states
   * @param index
   */
  cycleSortState(index) {
    switch (this.header[index].sortDirection) {
      case "ASCENDING":
        this.header[index].sortDirection = "DESCENDING";
        break;
      case "DESCENDING":
        this.header[index].sortDirection = "NONE";
        break;
      default:
        this.header[index].sortDirection = "ASCENDING";
        break;
    }
  }
  /**
   * Sorts the data currently present in the model based on `compare()`
   *
   * Direction is set by `ascending` and `descending` properties of `TableHeaderItem`
   * in `index`th column.
   *
   * @param index The column based on which it's sorting
   */
  sort(index) {
    this.pushRowStateToModelData();
    const headerSorted = this.header[index].sorted;
    this.header.forEach((column) => column.sorted = false);
    if (this.header[index].sortDirection === "NONE" && headerSorted) {
      const oldData = this._data;
      this._data = [];
      for (let i = 0; i < this.rowsIndices.length; i++) {
        const ri = this.rowsIndices[i];
        this._data[ri] = oldData[i];
      }
    } else {
      const descending = this.header[index].sortDirection === "DESCENDING" ? -1 : 1;
      this.data.sort((a, b) => {
        return descending * this.header[index].compare(a[index], b[index]);
      });
      this.header[index].sorted = true;
    }
    this.popRowStateFromModelData();
  }
  /**
   * Appends `rowsSelected` and `rowsExpanded` info to model data.
   *
   * When sorting rows, do this first so information about row selection
   * gets sorted with the other row info.
   *
   * Call `popRowSelectionFromModelData()` after sorting to make everything
   * right with the world again.
   */
  pushRowStateToModelData() {
    for (let i = 0; i < this.data.length; i++) {
      const rowSelectedMark = new TableItem();
      rowSelectedMark.data = this.rowsSelected[i];
      this.data[i].push(rowSelectedMark);
      const rowExpandedMark = new TableItem();
      rowExpandedMark.data = this.rowsExpanded[i];
      this.data[i].push(rowExpandedMark);
      const rowContext = new TableItem();
      rowContext.data = this.rowsContext[i];
      this.data[i].push(rowContext);
      const rowClass = new TableItem();
      rowClass.data = this.rowsClass[i];
      this.data[i].push(rowClass);
      const rowIndex = new TableItem();
      rowIndex.data = this.rowsIndices[i];
      this.data[i].push(rowIndex);
    }
  }
  /**
   * Restores `rowsSelected` from data pushed by `pushRowSelectionToModelData()`
   *
   * Call after sorting data (if you previously pushed to maintain selection order)
   * to make everything right with the world again.
   */
  popRowStateFromModelData() {
    for (let i = 0; i < this.data.length; i++) {
      this.rowsIndices[i] = this.data[i].pop().data;
      this.rowsClass[i] = this.data[i].pop().data;
      this.rowsContext[i] = this.data[i].pop().data;
      this.rowsExpanded[i] = !!this.data[i].pop().data;
      this.rowsSelected[i] = !!this.data[i].pop().data;
    }
  }
  /**
   * Checks if row is filtered out.
   *
   * @param index
   * @returns true if any of the filters in header filters out the `index`th row
   */
  isRowFiltered(index) {
    const realIndex = this.realRowIndex(index);
    return this.header.some((item, i) => item && item.filter(this.row(realIndex)[i]));
  }
  /**
   * Select/deselect `index`th row based on value
   *
   * @param index index of the row to select
   * @param value state to set the row to. Defaults to `true`
   */
  selectRow(index, value = true) {
    if (this.isRowDisabled(index)) {
      return;
    }
    this.rowsSelected[index] = value;
    this.rowsSelectedChange.emit(index);
  }
  /**
   * Selects or deselects all rows in the model
   *
   * @param value state to set all rows to. Defaults to `true`
   */
  selectAll(value = true) {
    if (this.data.length >= 1 && this.data[0].length >= 1) {
      for (let i = 0; i < this.rowsSelected.length; i++) {
        this.selectRow(i, value);
      }
    }
    this.selectAllChange.next(value);
  }
  isRowSelected(index) {
    return this.rowsSelected[index];
  }
  /**
   * Checks if row is disabled or not.
   */
  isRowDisabled(index) {
    const row = this.data[index];
    return !!row.disabled;
  }
  /**
   * Expands/Collapses `index`th row based on value
   *
   * @param index index of the row to expand or collapse
   * @param value expanded state of the row. `true` is expanded and `false` is collapsed
   */
  expandRow(index, value = true) {
    this.rowsExpanded[index] = value;
    this.rowsExpandedChange.emit(index);
  }
  /**
   * Expands / collapses all rows
   *
   * @param value expanded state of the rows. `true` is expanded and `false` is collapsed
   */
  expandAllRows(value = true) {
    if (this.data.length > 0) {
      for (let i = 0; i < this.data.length; i++) {
        if (this.isRowExpandable(i)) {
          this.rowsExpanded[i] = value;
        }
      }
      if (value) {
        this.rowsExpandedAllChange.emit();
      } else {
        this.rowsCollapsedAllChange.emit();
      }
    }
  }
  /**
   * Gets the true index of a row based on it's relative position.
   * Like in Python, positive numbers start from the top and
   * negative numbers start from the bottom.
   *
   * @param index
   */
  realRowIndex(index) {
    return this.realIndex(index, this.data.length);
  }
  /**
   * Gets the true index of a column based on it's relative position.
   * Like in Python, positive numbers start from the top and
   * negative numbers start from the bottom.
   *
   * @param index
   */
  realColumnIndex(index) {
    return this.realIndex(index, this.data[0].length);
  }
  /**
   * Generic function to calculate the real index of something.
   * Used by `realRowIndex()` and `realColumnIndex()`
   *
   * @param index
   * @param length
   */
  realIndex(index, length) {
    if (index == null) {
      return length - 1;
    } else if (index >= 0) {
      return index >= length ? length - 1 : index;
    } else {
      return -index >= length ? 0 : length + index;
    }
  }
};
TableModel.COUNT = 0;
var DataGridInteractionModel = class {
  /**
   * `DataGridInteractionModel` requires knowledge of events, and a representation of your table/grid to be useful.
   *
   * @param keyboardEventStream an Observable of KeyboardEvents. Should be scoped to the table container.
   * @param clickEventStream an Observable of ClickEvents. should only include clicks that take action on items known by the TableAdapter
   * @param tableAdapter an instance of a concrete class that implements TableAdapter. The standard carbon table uses TableDomAdapter
   */
  constructor(keyboardEventStream, clickEventStream, tableAdapter) {
    this.keyboardEventStream = keyboardEventStream;
    this.clickEventStream = clickEventStream;
    this.tableAdapter = tableAdapter;
    this.rowSubject = new BehaviorSubject({
      current: 0,
      previous: -1
    });
    this.columnSubject = new BehaviorSubject({
      current: 0,
      previous: -1
    });
    this.rowIndex = this.rowSubject.asObservable();
    this.columnIndex = this.columnSubject.asObservable();
    this.position = combineLatest(this.rowIndex, this.columnIndex).pipe(map((positions) => {
      const [row, column] = positions;
      return {
        current: [row.current, column.current],
        previous: [row.previous, column.previous]
      };
    }));
    this.keyboardEventStream.subscribe(this.handleKeyboardEvent.bind(this));
    this.clickEventStream.subscribe(this.handleClickEvent.bind(this));
  }
  /**
   * The latest value emitted by the rowSubject
   */
  get currentRow() {
    return this.rowSubject.getValue().current;
  }
  /**
   * The latest value emitted by the columnSubject
   */
  get currentColumn() {
    return this.columnSubject.getValue().current;
  }
  /**
   * The last column as reported by the adapter
   */
  get lastColumn() {
    return this.tableAdapter.lastColumnIndex;
  }
  /**
   * The last row as reported by the adapter
   */
  get lastRow() {
    return this.tableAdapter.lastRowIndex;
  }
  /**
   * Handles moving the position according to the w3 datagrid navigation specs
   *
   * Refs:
   *  - https://www.w3.org/TR/wai-aria-practices/examples/grid/dataGrids.html
   *  - https://www.w3.org/TR/wai-aria-practices/#grid
   *
   * @param event the KeyboardEvent to handle
   */
  handleKeyboardEvent(event) {
    const currentCell = this.tableAdapter.getCell(this.currentRow, this.currentColumn);
    let currentColumn = this.tableAdapter.findColumnIndex(currentCell);
    let currentRow = this.tableAdapter.findRowIndex(currentCell);
    switch (event.key) {
      case "ArrowRight":
        event.preventDefault();
        this.goToColumn(currentColumn + currentCell.colSpan);
        break;
      case "ArrowLeft":
        event.preventDefault();
        this.goToColumn(currentColumn - 1);
        break;
      case "ArrowDown":
        event.preventDefault();
        this.goToRow(currentRow + currentCell.rowSpan);
        break;
      case "ArrowUp":
        event.preventDefault();
        this.goToRow(currentRow - 1);
        break;
      case "Home":
        event.preventDefault();
        if (event.ctrlKey) {
          this.goTo({
            row: 0,
            column: 0
          });
        } else {
          this.goToColumn(0);
        }
        break;
      case "End":
        event.preventDefault();
        if (event.ctrlKey) {
          this.goTo({
            row: this.lastRow,
            column: this.lastColumn
          });
        } else {
          this.goToColumn(this.lastColumn);
        }
        break;
    }
  }
  /**
   * Handles moving the position to the clicked cell
   *
   * @param event the MouseEvent to handle
   */
  handleClickEvent(event) {
    const cell = event.target.closest("td, th");
    const [rowIndex, cellIndex] = this.tableAdapter.findIndex(cell);
    this.goTo({
      row: rowIndex,
      column: cellIndex
    });
  }
  /**
   * Jump to a specific column without changing the row
   *
   * @param index column to jump to
   */
  goToColumn(index) {
    if (index > this.lastColumn || index < 0) {
      return;
    }
    this.goTo({
      row: this.currentRow,
      column: index
    });
  }
  /**
   * Jump to a specific row without changing the column
   *
   * @param index row to jump to
   */
  goToRow(index) {
    if (index > this.lastRow || index < 0) {
      return;
    }
    this.goTo({
      row: index,
      column: this.currentColumn
    });
  }
  /**
   * Jump to the specified row and column
   *
   * @param param0 an object that contains `row` and `column` properties
   */
  goTo({
    row,
    column
  }) {
    this.rowSubject.next({
      current: row,
      previous: this.currentRow
    });
    this.columnSubject.next({
      current: column,
      previous: this.currentColumn
    });
  }
  /**
   * Convenience method to reset the tab indexes on a standard carbon table.
   * For custom tables you may want to reset the indexes manually and simply call `.reset()`
   */
  resetTabIndexes(newTabIndex = -1) {
    for (let i = 0; i < this.tableAdapter.lastRowIndex; i++) {
      const row = this.tableAdapter.getRow(i);
      for (const cell of Array.from(row.cells)) {
        const tabbableElements = getFocusElementList(cell, tabbableSelectorIgnoreTabIndex);
        tabbableElements.forEach((node) => node.tabIndex = newTabIndex);
        cell.tabIndex = newTabIndex;
      }
    }
    this.reset();
  }
  /**
   * Resets the models focus position
   */
  reset() {
    this.rowSubject.next({
      current: 0,
      previous: -1
    });
    this.columnSubject.next({
      current: 0,
      previous: -1
    });
  }
};
var TableCellAdapter = class {
};
var TableRowAdapter = class {
};
var TableAdapter = class {
  /**
   * The last accessible column in the table
   */
  get lastColumnIndex() {
    return;
  }
  /**
   * The last accessible row in the table
   */
  get lastRowIndex() {
    return;
  }
  /**
   * Returns a cell from the table
   *
   * @param row index of the row
   * @param column index of the column
   */
  getCell(row, column) {
    return;
  }
  /**
   * Returns a row from the table
   *
   * @param column index of the column
   */
  getColumn(column) {
    return;
  }
  /**
   * Returns a row from the table
   *
   * @param row index of the row
   */
  getRow(row) {
    return;
  }
  /**
   * Finds the column index of a given cell
   *
   * @param cell the cell to search for
   */
  findColumnIndex(cell) {
    return;
  }
  /**
   * Finds the row index of a given cell
   *
   * @param cell the cell to search for
   */
  findRowIndex(cell) {
    return;
  }
  /**
   * Finds the row and column index of a given cell
   *
   * @param cell the cell to search for
   * @returns a tuple that follows the `[row, column]` convention
   */
  findIndex(cell) {
    return;
  }
};
var TableDomSpanDirection;
(function(TableDomSpanDirection2) {
  TableDomSpanDirection2["colSpan"] = "colSpan";
  TableDomSpanDirection2["rowSpan"] = "rowSpan";
})(TableDomSpanDirection || (TableDomSpanDirection = {}));
var TableDomAdapter = class {
  /**
   * `TableDomAdapter` works on a normal HTML table structure.
   * Custom tables that don't follow the standard structure should use a custom implementation of `TableAdapter`.
   *
   * The standard structure allows us to directly query rows for cells and indexes - though we do have to handle colspans specially.
   *
   * @param tableElement the root HTML table element.
   */
  constructor(tableElement) {
    this.tableElement = tableElement;
  }
  /**
   * The last accessible column in the table
   */
  get lastColumnIndex() {
    return this.getRealRowLength(this.tableElement.rows[0]);
  }
  /**
   * The last accessible row in the table
   */
  get lastRowIndex() {
    return this.tableElement.rows.length - 1;
  }
  /**
   * Returns a cell from the table taking colspans in to account.
   *
   * @param row index of the row
   * @param column index of the column
   */
  getCell(row, column) {
    const col = this.getColumn(column);
    return this.findCellInColumn(col, row).cell;
  }
  /**
   * Returns a column from the table, using the `id` and `headers` attributes
   *
   * See here for more detail these attributes: https://www.w3.org/TR/WCAG20-TECHS/H43.html
   *
   * @param column the index of the column
   */
  getColumn(column) {
    const firstHeader = Array.from(this.tableElement.rows[0].cells);
    const {
      cell: header,
      realIndex: realColumnIndex
    } = this.findCellInRow(firstHeader, column);
    const linkedCells = [];
    for (let i = 1; i < this.tableElement.rows.length; i++) {
      const row = this.tableElement.rows[i];
      const linkedRowCells = row.querySelectorAll(`[headers~='${header.id}']`);
      if (linkedRowCells.length > 1) {
        const {
          cell
        } = this.findCellInRow(Array.from(linkedRowCells), column - realColumnIndex);
        linkedCells.push(cell);
      } else if (linkedRowCells[0]) {
        linkedCells.push(linkedRowCells[0]);
      }
    }
    if (!linkedCells) {
      return [];
    }
    return [header, ...linkedCells];
  }
  /**
   * Returns a row from the table
   *
   * @param row index of the row
   */
  getRow(row) {
    return this.tableElement.rows[row];
  }
  /**
   * Finds the column index of a given cell
   *
   * @param cell the cell to search for
   */
  findColumnIndex(cell) {
    const row = this.getRow(this.findRowIndex(cell));
    if (!row) {
      return;
    }
    if (cell && cell.headers) {
      const ids = cell.headers.split(" ");
      const headerRows = Array.from(this.tableElement.tHead.rows);
      const indexes = [];
      for (const headerRow of headerRows.reverse()) {
        const headerCells = Array.from(headerRow.cells);
        const header = headerCells.find((headerCell) => ids.includes(headerCell.id));
        if (header) {
          let cellIndex2 = 0;
          for (const c of headerCells) {
            if (c === header) {
              break;
            }
            cellIndex2 += c.colSpan;
          }
          indexes.push(cellIndex2);
        }
      }
      const firstIndex = indexes.sort((a, b) => b - a)[0];
      let similarCells = [];
      for (const id of ids) {
        const rowCells = Array.from(row.querySelectorAll(`[headers~='${id}']`));
        for (const rowCell of rowCells) {
          if (!similarCells.includes(rowCell)) {
            similarCells.push(rowCell);
          }
        }
      }
      similarCells = similarCells.sort((a, b) => a.cellIndex - b.cellIndex);
      return firstIndex + similarCells.indexOf(cell);
    }
    let cellIndex = 0;
    for (const c of Array.from(row.cells)) {
      if (c === cell) {
        break;
      }
      cellIndex += c.colSpan;
    }
    return cellIndex;
  }
  /**
   * Finds the row index of a given cell
   *
   * @param cell the cell to search for
   */
  findRowIndex(cell) {
    for (const row of Array.from(this.tableElement.rows)) {
      if (row.contains(cell)) {
        return row.rowIndex;
      }
    }
  }
  /**
   * Finds the row and column index of a given cell
   *
   * @param cell the cell to search for
   * @returns a tuple that follows the `[row, column]` convention
   */
  findIndex(cell) {
    return [this.findRowIndex(cell), this.findColumnIndex(cell)];
  }
  /**
   * Helper function that returns the "real" length of a row.
   * Only accurate with regard to colspans (though that's sufficient for it's uses here)
   *
   * TODO: Take rowSpan into account
   *
   * @param row the row to get the length of
   */
  getRealRowLength(row) {
    return Array.from(row.cells).reduce((count, cell) => count + cell.colSpan, -1);
  }
  /**
   * Finds a cell and it's real index given an array of cells, a target index, and the spanning direction
   *
   * @param cells An array of cells to search
   * @param targetIndex The index we think the cell is located at
   * @param spanDirection The direction of the cell spans. Should be `"colSpan"` for a row and `"rowSpan"` for a column
   */
  findCell(cells, targetIndex, spanDirection) {
    let realIndex = 0;
    for (let i = 0; i < targetIndex; ) {
      i += cells[realIndex][spanDirection];
      if (i > targetIndex) {
        break;
      }
      realIndex++;
    }
    return {
      cell: cells[realIndex],
      realIndex
    };
  }
  /**
   * Helper method around `findCell`, searches based on a row of cells
   *
   * @param row the row of elements to search
   * @param index the index of the element
   */
  findCellInRow(row, index) {
    return this.findCell(row, index, TableDomSpanDirection.colSpan);
  }
  /**
   * Helper method around `findCell`, searches based on a column of cells
   *
   * @param col the column of elements to search
   * @param index the index of the element
   */
  findCellInColumn(col, index) {
    return this.findCell(col, index, TableDomSpanDirection.rowSpan);
  }
};
var TableDirective = class {
  constructor() {
    this.sortable = true;
    this.noBorder = true;
    this.striped = false;
    this.skeleton = false;
    this.size = "md";
    this.tableClass = true;
  }
  // Bind table size class
  get extraSmallSize() {
    return this.size === "xs";
  }
  get smallSize() {
    return this.size === "sm";
  }
  get mediumSize() {
    return this.size === "md";
  }
  get LargeSize() {
    return this.size === "lg";
  }
  get extraLargeSize() {
    return this.size === "xl";
  }
};
TableDirective.ɵfac = function TableDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TableDirective)();
};
TableDirective.ɵdir = ɵɵdefineDirective({
  type: TableDirective,
  selectors: [["", "cdsTable", ""], ["", "ibmTable", ""]],
  hostVars: 20,
  hostBindings: function TableDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--data-table--sort", ctx.sortable)("cds--data-table--no-border", ctx.noBorder)("cds--data-table--zebra", ctx.striped)("cds--skeleton", ctx.skeleton)("cds--data-table", ctx.tableClass)("cds--data-table--xs", ctx.extraSmallSize)("cds--data-table--sm", ctx.smallSize)("cds--data-table--md", ctx.mediumSize)("cds--data-table--lg", ctx.LargeSize)("cds--data-table--xl", ctx.extraLargeSize);
    }
  },
  inputs: {
    sortable: "sortable",
    noBorder: "noBorder",
    striped: "striped",
    skeleton: "skeleton",
    size: "size"
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableDirective, [{
    type: Directive,
    args: [{
      selector: "[cdsTable], [ibmTable]"
    }]
  }], null, {
    sortable: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.cds--data-table--sort"]
    }],
    noBorder: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.cds--data-table--no-border"]
    }],
    striped: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.cds--data-table--zebra"]
    }],
    skeleton: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.cds--skeleton"]
    }],
    size: [{
      type: Input
    }],
    tableClass: [{
      type: HostBinding,
      args: ["class.cds--data-table"]
    }],
    extraSmallSize: [{
      type: HostBinding,
      args: ["class.cds--data-table--xs"]
    }],
    smallSize: [{
      type: HostBinding,
      args: ["class.cds--data-table--sm"]
    }],
    mediumSize: [{
      type: HostBinding,
      args: ["class.cds--data-table--md"]
    }],
    LargeSize: [{
      type: HostBinding,
      args: ["class.cds--data-table--lg"]
    }],
    extraLargeSize: [{
      type: HostBinding,
      args: ["class.cds--data-table--xl"]
    }]
  });
})();
var TableHeadCellLabel = class {
  constructor() {
    this.baseClass = true;
  }
};
TableHeadCellLabel.ɵfac = function TableHeadCellLabel_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TableHeadCellLabel)();
};
TableHeadCellLabel.ɵdir = ɵɵdefineDirective({
  type: TableHeadCellLabel,
  selectors: [["", "cdsTableHeadCellLabel", ""], ["", "ibmTableHeadCellLabel", ""]],
  hostVars: 2,
  hostBindings: function TableHeadCellLabel_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--table-header-label", ctx.baseClass);
    }
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableHeadCellLabel, [{
    type: Directive,
    args: [{
      selector: "[cdsTableHeadCellLabel], [ibmTableHeadCellLabel]"
    }]
  }], null, {
    baseClass: [{
      type: HostBinding,
      args: ["class.cds--table-header-label"]
    }]
  });
})();
var TableHeadCell = class {
  constructor(i18n) {
    this.i18n = i18n;
    this.skeleton = false;
    this.sortable = true;
    this.sort = new EventEmitter();
    this.theadAction = false;
    this._sortDescendingLabel = this.i18n.getOverridable("TABLE.SORT_DESCENDING");
    this._sortAscendingLabel = this.i18n.getOverridable("TABLE.SORT_ASCENDING");
    this._filterTitle = this.i18n.getOverridable("TABLE.FILTER");
  }
  set sortDescendingLabel(value) {
    this._sortDescendingLabel.override(value);
  }
  get sortDescendingLabel() {
    return this._sortDescendingLabel.value;
  }
  set sortAscendingLabel(value) {
    this._sortAscendingLabel.override(value);
  }
  get sortAscendingLabel() {
    return this._sortAscendingLabel.value;
  }
  set filterTitle(value) {
    this._filterTitle.override(value);
  }
  get filterTitle() {
    return this._filterTitle.value;
  }
  ngOnChanges() {
    this.theadAction = !!this.column.filterTemplate || this.sort.observers.length > 0;
  }
  getSortDescendingLabel() {
    return this._sortDescendingLabel.subject.pipe(this.sortLabelMap());
  }
  getSortAscendingLabel() {
    return this._sortAscendingLabel.subject.pipe(this.sortLabelMap());
  }
  onClick() {
    if (!this.skeleton) {
      this.sort.emit();
    }
  }
  sortLabelMap() {
    return map((str) => {
      if (this.column.ariaSortLabel) {
        return this.column.ariaSortLabel;
      }
      if (this.column.formatSortLabel) {
        return this.column.formatSortLabel(str, this.column.ariaSortLabel);
      }
      return `${this.column.data} - ${str}`;
    });
  }
};
TableHeadCell.ɵfac = function TableHeadCell_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TableHeadCell)(ɵɵdirectiveInject(I18n));
};
TableHeadCell.ɵcmp = ɵɵdefineComponent({
  type: TableHeadCell,
  selectors: [["", "cdsTableHeadCell", ""], ["", "ibmTableHeadCell", ""]],
  hostVars: 2,
  hostBindings: function TableHeadCell_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("thead_action", ctx.theadAction);
    }
  },
  inputs: {
    column: "column",
    skeleton: "skeleton",
    sortable: "sortable",
    sortDescendingLabel: "sortDescendingLabel",
    sortAscendingLabel: "sortAscendingLabel",
    filterTitle: "filterTitle"
  },
  outputs: {
    sort: "sort"
  },
  standalone: false,
  features: [ɵɵNgOnChangesFeature],
  attrs: _c95,
  decls: 2,
  vars: 2,
  consts: [["class", "cds--table-sort", "aria-live", "polite", 3, "ngClass", "click", 4, "ngIf"], ["class", "cds--table-header-label", 4, "ngIf"], ["aria-live", "polite", 1, "cds--table-sort", 3, "click", "ngClass"], ["tabindex", "-1", 1, "cds--table-sort__flex", 3, "title"], ["cdsTableHeadCellLabel", "", 4, "ngIf"], [4, "ngIf"], ["focusable", "false", "preserveAspectRatio", "xMidYMid meet", "style", "will-change: transform;", "xmlns", "http://www.w3.org/2000/svg", "class", "cds--table-sort__icon", "width", "16", "height", "16", "viewBox", "0 0 16 16", "aria-hidden", "true", 4, "ngIf"], ["focusable", "false", "preserveAspectRatio", "xMidYMid meet", "style", "will-change: transform;", "xmlns", "http://www.w3.org/2000/svg", "class", "cds--table-sort__icon-unsorted", "width", "16", "height", "16", "viewBox", "0 0 16 16", "aria-hidden", "true", 4, "ngIf"], ["cdsTableHeadCellLabel", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["focusable", "false", "preserveAspectRatio", "xMidYMid meet", "xmlns", "http://www.w3.org/2000/svg", "width", "16", "height", "16", "viewBox", "0 0 16 16", "aria-hidden", "true", 1, "cds--table-sort__icon", 2, "will-change", "transform"], ["d", "M12.3 9.3l-3.8 3.8V1h-1v12.1L3.7 9.3 3 10l5 5 5-5z"], ["focusable", "false", "preserveAspectRatio", "xMidYMid meet", "xmlns", "http://www.w3.org/2000/svg", "width", "16", "height", "16", "viewBox", "0 0 16 16", "aria-hidden", "true", 1, "cds--table-sort__icon-unsorted", 2, "will-change", "transform"], ["d", "M13.8 10.3L12 12.1V2h-1v10.1l-1.8-1.8-.7.7 3 3 3-3zM4.5 2l-3 3 .7.7L4 3.9V14h1V3.9l1.8 1.8.7-.7z"], [1, "cds--table-header-label"], [3, "title", 4, "ngIf"], [3, "title"]],
  template: function TableHeadCell_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, TableHeadCell_button_0_Template, 7, 12, "button", 0)(1, TableHeadCell_div_1_Template, 3, 5, "div", 1);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.sortable && ctx.sort.observers.length > 0 && ctx.column.sortable);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.skeleton && ctx.sort.observers.length === 0 || ctx.sort.observers.length > 0 && !ctx.column.sortable || !ctx.sortable);
    }
  },
  dependencies: [NgClass, NgIf, NgTemplateOutlet, TableHeadCellLabel, AsyncPipe],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableHeadCell, [{
    type: Component,
    args: [{
      // tslint:disable-next-line: component-selector
      selector: "[cdsTableHeadCell], [ibmTableHeadCell]",
      template: `
		<button
			class="cds--table-sort"
			*ngIf="sortable && this.sort.observers.length > 0 && column.sortable"
			[attr.aria-label]="(column.sorted && column.ascending ? getSortDescendingLabel() : getSortAscendingLabel()) | async"
			aria-live="polite"
			[ngClass]="{
				'cds--table-sort--active': column.sorted,
				'cds--table-sort--descending': column.ascending
			}"
			(click)="onClick()">
			<span
				class="cds--table-sort__flex"
				[title]="column.title"
				tabindex="-1">
				<div *ngIf="!skeleton && !column.template" cdsTableHeadCellLabel>
					{{column.data}}
				</div>
				<ng-template
					*ngIf="!skeleton && column.template"
					[ngTemplateOutlet]="column.template"
					[ngTemplateOutletContext]="{data: column.data}">
				</ng-template>
				<svg
					*ngIf="!skeleton"
					focusable="false"
					preserveAspectRatio="xMidYMid meet"
					style="will-change: transform;"
					xmlns="http://www.w3.org/2000/svg"
					class="cds--table-sort__icon"
					width="16"
					height="16"
					viewBox="0 0 16 16"
					aria-hidden="true">
					<path d="M12.3 9.3l-3.8 3.8V1h-1v12.1L3.7 9.3 3 10l5 5 5-5z"></path>
				</svg>
				<svg
					*ngIf="!skeleton"
					focusable="false"
					preserveAspectRatio="xMidYMid meet"
					style="will-change: transform;"
					xmlns="http://www.w3.org/2000/svg"
					class="cds--table-sort__icon-unsorted"
					width="16"
					height="16"
					viewBox="0 0 16 16"
					aria-hidden="true">
					<path d="M13.8 10.3L12 12.1V2h-1v10.1l-1.8-1.8-.7.7 3 3 3-3zM4.5 2l-3 3 .7.7L4 3.9V14h1V3.9l1.8 1.8.7-.7z"></path>
				</svg>
			</span>
		</button>
		<div
			class="cds--table-header-label"
			*ngIf="!skeleton && this.sort.observers.length === 0 || (this.sort.observers.length > 0 && !column.sortable) || !sortable">
			<span *ngIf="!column.template" [title]="column.data">
				<ng-container *ngIf="!skeleton">
					{{column.data}}
				</ng-container>
			</span>
			<ng-template
				[ngTemplateOutlet]="column.template" [ngTemplateOutletContext]="{data: column.data}">
			</ng-template>
		</div>
	`
    }]
  }], function() {
    return [{
      type: I18n
    }];
  }, {
    column: [{
      type: Input
    }],
    skeleton: [{
      type: Input
    }],
    sortable: [{
      type: Input
    }],
    sortDescendingLabel: [{
      type: Input
    }],
    sortAscendingLabel: [{
      type: Input
    }],
    filterTitle: [{
      type: Input
    }],
    sort: [{
      type: Output
    }],
    theadAction: [{
      type: HostBinding,
      args: ["class.thead_action"]
    }]
  });
})();
var TableHeadCheckbox = class _TableHeadCheckbox {
  constructor(i18n) {
    this.i18n = i18n;
    this.checked = false;
    this.indeterminate = false;
    this.skeleton = false;
    this.name = `select-all-${_TableHeadCheckbox.tableSelectAllCount++}`;
    this.change = new EventEmitter();
    this.hostClass = true;
    this._ariaLabel = this.i18n.getOverridable("TABLE.CHECKBOX_HEADER");
  }
  set ariaLabel(value) {
    this._ariaLabel.override(value);
  }
  get ariaLabel() {
    return this._ariaLabel.value;
  }
  getAriaLabel() {
    return this._ariaLabel.subject;
  }
};
TableHeadCheckbox.tableSelectAllCount = 0;
TableHeadCheckbox.ɵfac = function TableHeadCheckbox_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TableHeadCheckbox)(ɵɵdirectiveInject(I18n));
};
TableHeadCheckbox.ɵcmp = ɵɵdefineComponent({
  type: TableHeadCheckbox,
  selectors: [["", "cdsTableHeadCheckbox", ""], ["", "ibmTableHeadCheckbox", ""]],
  hostVars: 2,
  hostBindings: function TableHeadCheckbox_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--table-column-checkbox", ctx.hostClass);
    }
  },
  inputs: {
    checked: "checked",
    indeterminate: "indeterminate",
    skeleton: "skeleton",
    name: "name",
    ariaLabel: "ariaLabel"
  },
  outputs: {
    change: "change"
  },
  standalone: false,
  attrs: _c1210,
  decls: 1,
  vars: 1,
  consts: [["inline", "true", 3, "name", "checked", "indeterminate", "hideLabel", "checkedChange", 4, "ngIf"], ["inline", "true", 3, "checkedChange", "name", "checked", "indeterminate", "hideLabel"]],
  template: function TableHeadCheckbox_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, TableHeadCheckbox_cds_checkbox_0_Template, 3, 7, "cds-checkbox", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", !ctx.skeleton);
    }
  },
  dependencies: [NgIf, Checkbox, AsyncPipe],
  styles: ["[_nghost-%COMP%]{width:10px}"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableHeadCheckbox, [{
    type: Component,
    args: [{
      selector: "[cdsTableHeadCheckbox], [ibmTableHeadCheckbox]",
      template: `
		<cds-checkbox
			*ngIf="!skeleton"
			inline="true"
			[name]="name"
			[checked]="checked"
			[indeterminate]="indeterminate"
			(checkedChange)="change.emit()"
			[hideLabel]="true">
				{{getAriaLabel() | async}}
		</cds-checkbox>
	`,
      styles: [":host{width:10px}\n"]
    }]
  }], function() {
    return [{
      type: I18n
    }];
  }, {
    checked: [{
      type: Input
    }],
    indeterminate: [{
      type: Input
    }],
    skeleton: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    change: [{
      type: Output
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.cds--table-column-checkbox"]
    }]
  });
})();
var TableHeadExpand = class {
  constructor(i18n) {
    this.i18n = i18n;
    this.hostClass = true;
    this.showExpandAllToggle = false;
    this.expanded = false;
    this.expandedChange = new EventEmitter();
    this._ariaLabel = this.i18n.getOverridable("TABLE.EXPAND_ALL_BUTTON");
  }
  get previousValue() {
    return this.expanded ? "collapsed" : null;
  }
  getAriaLabel() {
    return this._ariaLabel.subject;
  }
};
TableHeadExpand.ɵfac = function TableHeadExpand_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TableHeadExpand)(ɵɵdirectiveInject(I18n));
};
TableHeadExpand.ɵcmp = ɵɵdefineComponent({
  type: TableHeadExpand,
  selectors: [["", "cdsTableHeadExpand", ""], ["", "ibmTableHeadExpand", ""]],
  hostVars: 3,
  hostBindings: function TableHeadExpand_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("data-previous-value", ctx.previousValue);
      ɵɵclassProp("cds--table-expand", ctx.hostClass);
    }
  },
  inputs: {
    showExpandAllToggle: "showExpandAllToggle",
    expanded: "expanded"
  },
  outputs: {
    expandedChange: "expandedChange"
  },
  standalone: false,
  attrs: _c134,
  ngContentSelectors: _c511,
  decls: 2,
  vars: 2,
  consts: [["class", "cds--table-expand__button", 3, "click", 4, "ngIf"], [4, "ngIf"], [1, "cds--table-expand__button", 3, "click"], ["cdsIcon", "chevron--right", "size", "16", 1, "cds--table-expand__svg"]],
  template: function TableHeadExpand_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, TableHeadExpand_button_0_Template, 3, 3, "button", 0)(1, TableHeadExpand_ng_container_1_Template, 2, 0, "ng-container", 1);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.showExpandAllToggle);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.showExpandAllToggle);
    }
  },
  dependencies: [NgIf, IconDirective, AsyncPipe],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableHeadExpand, [{
    type: Component,
    args: [{
      // tslint:disable-next-line: component-selector
      selector: "[cdsTableHeadExpand], [ibmTableHeadExpand]",
      template: `
		<button
			*ngIf="showExpandAllToggle"
			class="cds--table-expand__button"
			[attr.aria-label]="getAriaLabel() | async"
			(click)="expandedChange.emit(!expanded)">
			<svg cdsIcon="chevron--right" size="16" class="cds--table-expand__svg"></svg>
		</button>
		<ng-container *ngIf="!showExpandAllToggle">
			<ng-content></ng-content>
		</ng-container>
	`
    }]
  }], function() {
    return [{
      type: I18n
    }];
  }, {
    hostClass: [{
      type: HostBinding,
      args: ["class.cds--table-expand"]
    }],
    showExpandAllToggle: [{
      type: Input
    }],
    expanded: [{
      type: Input
    }],
    expandedChange: [{
      type: Output
    }],
    previousValue: [{
      type: HostBinding,
      args: ["attr.data-previous-value"]
    }]
  });
})();
var TableHead = class {
  constructor(i18n) {
    this.i18n = i18n;
    this.showSelectionColumn = true;
    this.enableSingleSelect = false;
    this.selectAllCheckboxSomeSelected = false;
    this.selectAllCheckbox = false;
    this.skeleton = false;
    this.stickyHeader = false;
    this.showExpandAllToggle = false;
    this.sortable = true;
    this.sort = new EventEmitter();
    this.selectAll = new EventEmitter();
    this.deselectAll = new EventEmitter();
    this.expandAllRows = new EventEmitter();
    this.collapseAllRows = new EventEmitter();
    this.scrollbarWidth = 0;
    this._checkboxHeaderLabel = this.i18n.getOverridable("TABLE.CHECKBOX_HEADER");
    this._sortDescendingLabel = this.i18n.getOverridable("TABLE.SORT_DESCENDING");
    this._sortAscendingLabel = this.i18n.getOverridable("TABLE.SORT_ASCENDING");
    this._filterTitle = this.i18n.getOverridable("TABLE.FILTER");
  }
  set checkboxHeaderLabel(value) {
    this._checkboxHeaderLabel.override(value);
  }
  get checkboxHeaderLabel() {
    return this._checkboxHeaderLabel.value;
  }
  set sortDescendingLabel(value) {
    this._sortDescendingLabel.override(value);
  }
  get sortDescendingLabel() {
    return this._sortDescendingLabel.value;
  }
  set sortAscendingLabel(value) {
    this._sortAscendingLabel.override(value);
  }
  get sortAscendingLabel() {
    return this._sortAscendingLabel.value;
  }
  set filterTitle(value) {
    this._filterTitle.override(value);
  }
  get filterTitle() {
    return this._filterTitle.value;
  }
  ngAfterViewInit() {
    setTimeout(() => {
      this.scrollbarWidth = getScrollbarWidth();
    });
  }
  onSelectAllCheckboxChange() {
    if (!this.selectAllCheckbox && !this.selectAllCheckboxSomeSelected) {
      this.selectAll.emit(this.model);
    } else {
      this.deselectAll.emit(this.model);
    }
  }
  onExpandAllRowsChange(expand) {
    if (expand) {
      this.expandAllRows.emit(this.model);
    } else {
      this.collapseAllRows.emit(this.model);
    }
  }
  getCheckboxHeaderLabel() {
    return this._checkboxHeaderLabel.subject;
  }
  getSortDescendingLabel() {
    return this._sortDescendingLabel.subject;
  }
  getSortAscendingLabel() {
    return this._sortAscendingLabel.subject;
  }
  getFilterTitle() {
    return this._filterTitle.subject;
  }
};
TableHead.ɵfac = function TableHead_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TableHead)(ɵɵdirectiveInject(I18n));
};
TableHead.ɵcmp = ɵɵdefineComponent({
  type: TableHead,
  selectors: [["", "cdsTableHead", ""], ["", "ibmTableHead", ""]],
  inputs: {
    model: "model",
    showSelectionColumn: "showSelectionColumn",
    enableSingleSelect: "enableSingleSelect",
    selectAllCheckboxSomeSelected: "selectAllCheckboxSomeSelected",
    selectAllCheckbox: "selectAllCheckbox",
    skeleton: "skeleton",
    stickyHeader: "stickyHeader",
    showExpandAllToggle: "showExpandAllToggle",
    sortable: "sortable",
    checkboxHeaderLabel: "checkboxHeaderLabel",
    sortDescendingLabel: "sortDescendingLabel",
    sortAscendingLabel: "sortAscendingLabel",
    filterTitle: "filterTitle"
  },
  outputs: {
    sort: "sort",
    selectAll: "selectAll",
    deselectAll: "deselectAll",
    expandAllRows: "expandAllRows",
    collapseAllRows: "collapseAllRows"
  },
  standalone: false,
  attrs: _c142,
  ngContentSelectors: _c511,
  decls: 2,
  vars: 1,
  consts: [[4, "ngIf"], ["cdsTableHeadExpand", "", "scope", "col", 3, "showExpandAllToggle", "ngClass", "id", "expanded", "expandedChange", 4, "ngIf"], ["scope", "col", 3, "id", 4, "ngIf"], ["cdsTableHeadCheckbox", "", "scope", "col", 3, "checked", "indeterminate", "ariaLabel", "skeleton", "name", "id", "change", 4, "ngIf"], [4, "ngFor", "ngForOf"], ["scope", "col", 3, "ngStyle", 4, "ngIf"], ["cdsTableHeadExpand", "", "scope", "col", 3, "expandedChange", "showExpandAllToggle", "ngClass", "id", "expanded"], ["scope", "col", 3, "id"], ["cdsTableHeadCheckbox", "", "scope", "col", 3, "change", "checked", "indeterminate", "ariaLabel", "skeleton", "name", "id"], ["cdsTableHeadCell", "", "scope", "col", 3, "ngStyle", "class", "sortable", "skeleton", "id", "column", "filterTitle", "sort", 4, "ngIf"], ["cdsTableHeadCell", "", "scope", "col", 3, "sort", "ngStyle", "sortable", "skeleton", "id", "column", "filterTitle"], ["scope", "col", 3, "ngStyle"]],
  template: function TableHead_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, TableHead_ng_container_0_Template, 7, 5, "ng-container", 0);
      ɵɵprojection(1);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.model);
    }
  },
  dependencies: [NgClass, NgForOf, NgIf, NgStyle, TableHeadCell, TableHeadCheckbox, TableHeadExpand],
  styles: [".cds--table-expand-v2[_ngcontent-%COMP%]{padding-left:2.5rem}"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableHead, [{
    type: Component,
    args: [{
      selector: "[cdsTableHead], [ibmTableHead]",
      template: `
	<ng-container *ngIf="model">
		<tr>
			<th
				cdsTableHeadExpand
				*ngIf="model.hasExpandableRows()"
				scope="col"
				[showExpandAllToggle]="showExpandAllToggle"
				[ngClass]="{'cds--table-expand-v2': stickyHeader}"
				[id]="model.getId('expand')"
				[expanded]="model.expandableRowsCount() === model.expandedRowsCount()"
				(expandedChange)="onExpandAllRowsChange($event)">
			</th>
			<th
				*ngIf="!skeleton && showSelectionColumn && enableSingleSelect"
				scope="col"
				[id]="model.getId('select')">
				<!-- add width 0; since the carbon styles don't seem to constrain this headers width -->
			</th>
			<th
				cdsTableHeadCheckbox
				*ngIf="!skeleton && showSelectionColumn && !enableSingleSelect"
				scope="col"
				[checked]="selectAllCheckbox"
				[indeterminate]="selectAllCheckboxSomeSelected"
				[ariaLabel]="getCheckboxHeaderLabel()"
				[skeleton]="skeleton"
				[name]="model.getHeaderId('select')"
				(change)="onSelectAllCheckboxChange()"
				[id]="model.getId('select')">
			</th>
			<ng-container *ngFor="let column of model.header; let i = index">
				<th
					*ngIf="column && column.visible"
					[ngStyle]="column.style"
					cdsTableHeadCell
					scope="col"
					[class]="column.className"
					[sortable]="sortable"
					[skeleton]="skeleton"
					[id]="model.getId(i)"
					[column]="column"
					[filterTitle]="getFilterTitle()"
					[attr.colspan]="column.colSpan"
					[attr.rowspan]="column.rowSpan"
					(sort)="sort.emit(i)">
				</th>
			</ng-container>
			<th *ngIf="!skeleton && stickyHeader && scrollbarWidth"
				scope="col"
				[ngStyle]="{'width': scrollbarWidth + 'px', 'padding': 0, 'border': 0}">
				<!--
					Scrollbar pushes body to the left so this header column is added to push
					the title bar the same amount and keep the header and body columns aligned.
				-->
			</th>
		</tr>
	</ng-container>
	<ng-content></ng-content>
	`,
      styles: [".cds--table-expand-v2{padding-left:2.5rem}\n"]
    }]
  }], function() {
    return [{
      type: I18n
    }];
  }, {
    model: [{
      type: Input
    }],
    showSelectionColumn: [{
      type: Input
    }],
    enableSingleSelect: [{
      type: Input
    }],
    selectAllCheckboxSomeSelected: [{
      type: Input
    }],
    selectAllCheckbox: [{
      type: Input
    }],
    skeleton: [{
      type: Input
    }],
    stickyHeader: [{
      type: Input
    }],
    showExpandAllToggle: [{
      type: Input
    }],
    sortable: [{
      type: Input
    }],
    checkboxHeaderLabel: [{
      type: Input
    }],
    sortDescendingLabel: [{
      type: Input
    }],
    sortAscendingLabel: [{
      type: Input
    }],
    filterTitle: [{
      type: Input
    }],
    sort: [{
      type: Output
    }],
    selectAll: [{
      type: Output
    }],
    deselectAll: [{
      type: Output
    }],
    expandAllRows: [{
      type: Output
    }],
    collapseAllRows: [{
      type: Output
    }]
  });
})();
var ExpandedRowHover = class {
  addHoverClass(event) {
    event.target.previousElementSibling.classList.add("cds--expandable-row--hover");
  }
  removeHoverClass(event) {
    event.target.previousElementSibling.classList.remove("cds--expandable-row--hover");
  }
};
ExpandedRowHover.ɵfac = function ExpandedRowHover_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ExpandedRowHover)();
};
ExpandedRowHover.ɵdir = ɵɵdefineDirective({
  type: ExpandedRowHover,
  selectors: [["", "cdsExpandedRowHover", ""], ["", "ibmExpandedRowHover", ""]],
  hostBindings: function ExpandedRowHover_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("mouseenter", function ExpandedRowHover_mouseenter_HostBindingHandler($event) {
        return ctx.addHoverClass($event);
      })("mouseleave", function ExpandedRowHover_mouseleave_HostBindingHandler($event) {
        return ctx.removeHoverClass($event);
      });
    }
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExpandedRowHover, [{
    type: Directive,
    args: [{
      selector: "[cdsExpandedRowHover], [ibmExpandedRowHover]"
    }]
  }], null, {
    addHoverClass: [{
      type: HostListener,
      args: ["mouseenter", ["$event"]]
    }],
    removeHoverClass: [{
      type: HostListener,
      args: ["mouseleave", ["$event"]]
    }]
  });
})();
var TableData = class {
  constructor() {
    this.skeleton = false;
  }
};
TableData.ɵfac = function TableData_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TableData)();
};
TableData.ɵcmp = ɵɵdefineComponent({
  type: TableData,
  selectors: [["", "cdsTableData", ""], ["", "ibmTableData", ""]],
  inputs: {
    item: "item",
    skeleton: "skeleton"
  },
  standalone: false,
  attrs: _c172,
  decls: 2,
  vars: 2,
  consts: [[4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
  template: function TableData_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, TableData_ng_container_0_Template, 2, 1, "ng-container", 0)(1, TableData_1_Template, 1, 4, null, 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", !ctx.skeleton && !ctx.item.template);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.skeleton);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableData, [{
    type: Component,
    args: [{
      // tslint:disable-next-line: component-selector
      selector: "[cdsTableData], [ibmTableData]",
      template: `
		<ng-container *ngIf="!skeleton && !item.template">{{item.data}}</ng-container>
		<ng-template
			*ngIf="!skeleton"
			[ngTemplateOutlet]="item.template"
			[ngTemplateOutletContext]="{data: item.data}">
		</ng-template>
	`
    }]
  }], null, {
    item: [{
      type: Input
    }],
    skeleton: [{
      type: Input
    }]
  });
})();
var TableCheckbox = class {
  constructor(i18n) {
    this.i18n = i18n;
    this.selected = false;
    this.name = "";
    this.size = "md";
    this.skeleton = false;
    this.selectedChange = new EventEmitter();
    this._label = this.i18n.getOverridable("TABLE.CHECKBOX_ROW");
  }
  get disabled() {
    return this.row ? !!this.row.disabled : false;
  }
  set label(value) {
    this._label.override(value);
  }
  get label() {
    return this._label.value;
  }
  getSelectionLabelValue(row) {
    if (!this.selectionLabelColumn) {
      return {
        value: this.i18n.get().TABLE.ROW
      };
    }
    return {
      value: row[this.selectionLabelColumn].data
    };
  }
  getLabel() {
    return this._label.subject;
  }
};
TableCheckbox.ɵfac = function TableCheckbox_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TableCheckbox)(ɵɵdirectiveInject(I18n));
};
TableCheckbox.ɵcmp = ɵɵdefineComponent({
  type: TableCheckbox,
  selectors: [["", "cdsTableCheckbox", ""], ["", "ibmTableCheckbox", ""]],
  inputs: {
    row: "row",
    selected: "selected",
    name: "name",
    size: "size",
    label: "label",
    selectionLabelColumn: "selectionLabelColumn",
    skeleton: "skeleton"
  },
  outputs: {
    selectedChange: "selectedChange"
  },
  standalone: false,
  attrs: _c182,
  decls: 1,
  vars: 1,
  consts: [["inline", "true", 3, "name", "checked", "disabled", "hideLabel", "checkedChange", 4, "ngIf"], ["inline", "true", 3, "checkedChange", "name", "checked", "disabled", "hideLabel"]],
  template: function TableCheckbox_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, TableCheckbox_cds_checkbox_0_Template, 4, 10, "cds-checkbox", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", !ctx.skeleton);
    }
  },
  dependencies: [NgIf, Checkbox, AsyncPipe, ReplacePipe],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableCheckbox, [{
    type: Component,
    args: [{
      // tslint:disable-next-line: component-selector
      selector: "[cdsTableCheckbox], [ibmTableCheckbox]",
      template: `
		<cds-checkbox
			*ngIf="!skeleton"
			inline="true"
			[name]="name"
			[checked]="selected"
			[disabled]="disabled"
			(checkedChange)="selectedChange.emit()"
			[hideLabel]="true">
				{{getLabel() | i18nReplace:getSelectionLabelValue(row) | async}}
		</cds-checkbox>
	`
    }]
  }], function() {
    return [{
      type: I18n
    }];
  }, {
    row: [{
      type: Input
    }],
    selected: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    selectionLabelColumn: [{
      type: Input
    }],
    skeleton: [{
      type: Input
    }],
    selectedChange: [{
      type: Output
    }]
  });
})();
var TableRadio = class {
  constructor(i18n) {
    this.i18n = i18n;
    this.selected = false;
    this.radioColumn = true;
    this.selectableColumn = true;
    this.skeleton = false;
    this.change = new EventEmitter();
    this._label = this.i18n.getOverridable("TABLE.CHECKBOX_ROW");
  }
  set label(value) {
    this._label.override(value);
  }
  get label() {
    return this._label.value;
  }
  get disabled() {
    return this.row ? !!this.row.disabled : false;
  }
  getSelectionLabelValue(row) {
    if (!this.selectionLabelColumn) {
      return {
        value: this.i18n.get().TABLE.ROW
      };
    }
    return {
      value: row[this.selectionLabelColumn].data
    };
  }
  getLabel() {
    return this._label.subject;
  }
};
TableRadio.ɵfac = function TableRadio_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TableRadio)(ɵɵdirectiveInject(I18n));
};
TableRadio.ɵcmp = ɵɵdefineComponent({
  type: TableRadio,
  selectors: [["", "cdsTableRadio", ""], ["", "ibmTableRadio", ""]],
  hostVars: 4,
  hostBindings: function TableRadio_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--table-column-radio", ctx.radioColumn)("cds--table-column-checkbox", ctx.selectableColumn);
    }
  },
  inputs: {
    row: "row",
    selected: "selected",
    label: "label",
    selectionLabelColumn: "selectionLabelColumn",
    skeleton: "skeleton"
  },
  outputs: {
    change: "change"
  },
  standalone: false,
  attrs: _c192,
  decls: 1,
  vars: 1,
  consts: [[3, "ariaLabel", "checked", "disabled", "change", 4, "ngIf"], [3, "change", "ariaLabel", "checked", "disabled"]],
  template: function TableRadio_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, TableRadio_cds_radio_0_Template, 5, 14, "cds-radio", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", !ctx.skeleton);
    }
  },
  dependencies: [NgIf, Radio, AsyncPipe, ReplacePipe],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableRadio, [{
    type: Component,
    args: [{
      // tslint:disable-next-line: component-selector
      selector: "[cdsTableRadio], [ibmTableRadio]",
      template: `
		<cds-radio
			*ngIf="!skeleton"
			[attr.aria-label]="getLabel() | i18nReplace:getSelectionLabelValue(row) | async"
			[ariaLabel]="getLabel() | i18nReplace:getSelectionLabelValue(row) | async"
			[checked]="selected"
			[disabled]="disabled"
			(change)="change.emit()">
		</cds-radio>
	`
    }]
  }], function() {
    return [{
      type: I18n
    }];
  }, {
    row: [{
      type: Input
    }],
    selected: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    radioColumn: [{
      type: HostBinding,
      args: ["class.cds--table-column-radio"]
    }],
    selectableColumn: [{
      type: HostBinding,
      args: ["class.cds--table-column-checkbox"]
    }],
    selectionLabelColumn: [{
      type: Input
    }],
    skeleton: [{
      type: Input
    }],
    change: [{
      type: Output
    }]
  });
})();
var TableExpandButton = class {
  constructor(i18n) {
    this.i18n = i18n;
    this.expanded = false;
    this.expandable = false;
    this.skeleton = false;
    this.expandClass = true;
    this.expandRow = new EventEmitter();
    this._ariaLabel = this.i18n.getOverridable("TABLE.EXPAND_BUTTON");
  }
  set ariaLabel(value) {
    this._ariaLabel.override(value);
  }
  get ariaLabel() {
    return this._ariaLabel.value;
  }
  get previousValue() {
    return this.expanded ? "collapsed" : null;
  }
  getAriaLabel() {
    return this._ariaLabel.subject;
  }
};
TableExpandButton.ɵfac = function TableExpandButton_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TableExpandButton)(ɵɵdirectiveInject(I18n));
};
TableExpandButton.ɵcmp = ɵɵdefineComponent({
  type: TableExpandButton,
  selectors: [["", "cdsTableExpandButton", ""], ["", "ibmTableExpandButton", ""]],
  hostVars: 3,
  hostBindings: function TableExpandButton_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("data-previous-value", ctx.previousValue);
      ɵɵclassProp("cds--table-expand", ctx.expandClass);
    }
  },
  inputs: {
    expanded: "expanded",
    expandable: "expandable",
    ariaLabel: "ariaLabel",
    skeleton: "skeleton"
  },
  outputs: {
    expandRow: "expandRow"
  },
  standalone: false,
  attrs: _c20,
  decls: 1,
  vars: 1,
  consts: [["class", "cds--table-expand__button", 3, "click", 4, "ngIf"], [1, "cds--table-expand__button", 3, "click"], ["cdsIcon", "chevron--right", "size", "16", 1, "cds--table-expand__svg"]],
  template: function TableExpandButton_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, TableExpandButton_button_0_Template, 3, 3, "button", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.expandable);
    }
  },
  dependencies: [NgIf, IconDirective, AsyncPipe],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableExpandButton, [{
    type: Component,
    args: [{
      // tslint:disable-next-line: component-selector
      selector: "[cdsTableExpandButton], [ibmTableExpandButton]",
      template: `
		<button
			*ngIf="expandable"
			class="cds--table-expand__button"
			[attr.aria-label]="getAriaLabel() | async"
			(click)="expandRow.emit()">
			<svg cdsIcon="chevron--right" size="16" class="cds--table-expand__svg"></svg>
		</button>
	`
    }]
  }], function() {
    return [{
      type: I18n
    }];
  }, {
    expanded: [{
      type: Input
    }],
    expandable: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    skeleton: [{
      type: Input
    }],
    expandClass: [{
      type: HostBinding,
      args: ["class.cds--table-expand"]
    }],
    previousValue: [{
      type: HostBinding,
      args: ["attr.data-previous-value"]
    }],
    expandRow: [{
      type: Output
    }]
  });
})();
var TableRowComponent = class {
  constructor(i18n) {
    this.i18n = i18n;
    this.expanded = false;
    this.expandable = false;
    this.selected = false;
    this.size = "md";
    this.enableSingleSelect = false;
    this.showSelectionColumn = true;
    this.showSelectionColumnCheckbox = true;
    this.skeleton = false;
    this.selectRow = new EventEmitter();
    this.deselectRow = new EventEmitter();
    this.expandRow = new EventEmitter();
    this.rowClick = new EventEmitter();
    this._checkboxLabel = this.i18n.getOverridable("TABLE.CHECKBOX_ROW");
    this._expandButtonAriaLabel = this.i18n.getOverridable("TABLE.EXPAND_BUTTON");
  }
  set expandButtonAriaLabel(value) {
    this._expandButtonAriaLabel.override(value);
  }
  get expandButtonAriaLabel() {
    return this._expandButtonAriaLabel.value;
  }
  set checkboxLabel(value) {
    this._checkboxLabel.override(value);
  }
  get checkboxLabel() {
    return this._checkboxLabel.value;
  }
  get selectedClass() {
    return this.selected;
  }
  get parentRowClass() {
    return this.expandable;
  }
  get expandableRowClass() {
    return this.expanded;
  }
  get selectableClass() {
    return false;
  }
  get isParentRow() {
    return this.expandable ? true : null;
  }
  get isAccessible() {
    return this.enableSingleSelect && !this.showSelectionColumn ? 0 : null;
  }
  onHostClick() {
    if (this.enableSingleSelect && !this.showSelectionColumn) {
      this.onSelectionChange();
    }
  }
  onRowClick() {
    this.rowClick.emit();
  }
  onSelectionChange() {
    if (this.selected) {
      this.deselectRow.emit();
    } else {
      this.selectRow.emit();
    }
  }
  getCheckboxLabel() {
    return this._checkboxLabel.subject;
  }
  getExpandButtonAriaLabel() {
    return this._expandButtonAriaLabel.subject;
  }
};
TableRowComponent.ɵfac = function TableRowComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TableRowComponent)(ɵɵdirectiveInject(I18n));
};
TableRowComponent.ɵcmp = ɵɵdefineComponent({
  type: TableRowComponent,
  selectors: [["", "cdsTableRow", ""], ["", "ibmTableRow", ""]],
  hostVars: 10,
  hostBindings: function TableRowComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function TableRowComponent_click_HostBindingHandler() {
        return ctx.onHostClick();
      });
    }
    if (rf & 2) {
      ɵɵattribute("data-parent-row", ctx.isParentRow)("tabindex", ctx.isAccessible);
      ɵɵclassProp("cds--data-table--selected", ctx.selectedClass)("cds--parent-row", ctx.parentRowClass)("cds--expandable-row", ctx.expandableRowClass)("tbody_row--selectable", ctx.selectableClass);
    }
  },
  inputs: {
    model: "model",
    row: "row",
    expanded: "expanded",
    expandable: "expandable",
    selected: "selected",
    size: "size",
    enableSingleSelect: "enableSingleSelect",
    expandButtonAriaLabel: "expandButtonAriaLabel",
    checkboxLabel: "checkboxLabel",
    showSelectionColumn: "showSelectionColumn",
    showSelectionColumnCheckbox: "showSelectionColumnCheckbox",
    selectionLabelColumn: "selectionLabelColumn",
    skeleton: "skeleton"
  },
  outputs: {
    selectRow: "selectRow",
    deselectRow: "deselectRow",
    expandRow: "expandRow",
    rowClick: "rowClick"
  },
  standalone: false,
  attrs: _c21,
  ngContentSelectors: _c511,
  decls: 2,
  vars: 1,
  consts: [["tableCheckboxTemplate", ""], [4, "ngIf"], ["cdsTableExpandButton", "", "class", "cds--table-expand-v2", 3, "expanded", "expandable", "skeleton", "ariaLabel", "headers", "expandRow", 4, "ngIf"], ["cdsTableRadio", "", 3, "selected", "label", "row", "skeleton", "headers", "change", 4, "ngIf"], [4, "ngFor", "ngForOf"], ["cdsTableExpandButton", "", 1, "cds--table-expand-v2", 3, "expandRow", "expanded", "expandable", "skeleton", "ariaLabel", "headers"], [4, "ngIf", "ngIfElse"], ["cdsTableCheckbox", "", 1, "cds--table-column-checkbox", 3, "selectedChange", "size", "selected", "label", "row", "skeleton", "headers"], ["cdsTableRadio", "", 3, "change", "selected", "label", "row", "skeleton", "headers"], ["cdsTableData", "", 3, "headers", "item", "title", "class", "ngStyle", "skeleton", "click", "keydown.enter", 4, "ngIf"], ["cdsTableData", "", 3, "headers", "item", "title", "skeleton", "click", "keydown.enter", 4, "ngIf"], ["cdsTableData", "", 3, "click", "keydown.enter", "headers", "item", "title", "ngStyle", "skeleton"], ["cdsTableData", "", 3, "click", "keydown.enter", "headers", "item", "title", "skeleton"]],
  template: function TableRowComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, TableRowComponent_ng_container_0_Template, 5, 4, "ng-container", 1);
      ɵɵprojection(1);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.model);
    }
  },
  dependencies: [NgForOf, NgIf, NgStyle, TableData, TableCheckbox, TableRadio, TableExpandButton],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableRowComponent, [{
    type: Component,
    args: [{
      // tslint:disable-next-line: component-selector
      selector: "[cdsTableRow], [ibmTableRow]",
      template: `
		<ng-container *ngIf="model">
			<td
				*ngIf="model.hasExpandableRows()"
				cdsTableExpandButton
				class="cds--table-expand-v2"
				[expanded]="expanded"
				[expandable]="expandable"
				[skeleton]="skeleton"
				[ariaLabel]="getExpandButtonAriaLabel()"
				[headers]="model.getHeaderId('expand')"
				(expandRow)="expandRow.emit()">
			</td>
			<ng-container *ngIf="!skeleton && showSelectionColumn && !enableSingleSelect">
				<td
					*ngIf="!showSelectionColumnCheckbox; else tableCheckboxTemplate">
				</td>
				<ng-template #tableCheckboxTemplate>
					<td
						cdsTableCheckbox
						class="cds--table-column-checkbox"
						[size]="size"
						[selected]="selected"
						[label]="getCheckboxLabel()"
						[row]="row"
						[skeleton]="skeleton"
						[headers]="model.getHeaderId('select')"
						(selectedChange)="onSelectionChange()">
					</td>
				</ng-template>
			</ng-container>
			<td
				*ngIf="!skeleton && showSelectionColumn && enableSingleSelect"
				cdsTableRadio
				[selected]="selected"
				[label]="getCheckboxLabel()"
				[row]="row"
				[skeleton]="skeleton"
				[headers]="model.getHeaderId('select')"
				(change)="onSelectionChange()">
			</td>
			<ng-container *ngFor="let item of row; let j = index">
				<td
					*ngIf="item && model.getHeader(j) && model.getHeader(j).visible"
					cdsTableData
					[headers]="model.getHeaderId(j, item.colSpan)"
					[item]="item"
					[title]="item.title"
					[class]="model.getHeader(j).className"
					[ngStyle]="model.getHeader(j).style"
					[skeleton]="skeleton"
					[attr.colspan]="item.colSpan"
					[attr.rowspan]="item.rowSpan"
					(click)="onRowClick()"
					(keydown.enter)="onRowClick()">
				</td>
				<td
					*ngIf="item && model.getHeader(j) == null"
					cdsTableData
					[headers]="model.getHeaderId(j, item.colSpan)"
					[item]="item"
					[title]="item.title"
					[skeleton]="skeleton"
					[attr.colspan]="item.colSpan"
					[attr.rowspan]="item.rowSpan"
					(click)="onRowClick()"
					(keydown.enter)="onRowClick()">
				</td>
			</ng-container>
		</ng-container>
		<ng-content></ng-content>
	`
    }]
  }], function() {
    return [{
      type: I18n
    }];
  }, {
    model: [{
      type: Input
    }],
    row: [{
      type: Input
    }],
    expanded: [{
      type: Input
    }],
    expandable: [{
      type: Input
    }],
    selected: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    enableSingleSelect: [{
      type: Input
    }],
    expandButtonAriaLabel: [{
      type: Input
    }],
    checkboxLabel: [{
      type: Input
    }],
    showSelectionColumn: [{
      type: Input
    }],
    showSelectionColumnCheckbox: [{
      type: Input
    }],
    selectionLabelColumn: [{
      type: Input
    }],
    skeleton: [{
      type: Input
    }],
    selectRow: [{
      type: Output
    }],
    deselectRow: [{
      type: Output
    }],
    expandRow: [{
      type: Output
    }],
    rowClick: [{
      type: Output
    }],
    selectedClass: [{
      type: HostBinding,
      args: ["class.cds--data-table--selected"]
    }],
    parentRowClass: [{
      type: HostBinding,
      args: ["class.cds--parent-row"]
    }],
    expandableRowClass: [{
      type: HostBinding,
      args: ["class.cds--expandable-row"]
    }],
    selectableClass: [{
      type: HostBinding,
      args: ["class.tbody_row--selectable"]
    }],
    isParentRow: [{
      type: HostBinding,
      args: ["attr.data-parent-row"]
    }],
    isAccessible: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    onHostClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var TableExpandedRow = class {
  constructor() {
    this.skeleton = false;
    this.expandableRowClass = true;
    this.dataChildRow = true;
    this.expanded = false;
  }
  get displayStyle() {
    return this.expanded ? null : "none";
  }
  firstExpandedTemplateInRow(row) {
    const found = row.find((d) => d.expandedTemplate);
    if (found) {
      return found.expandedTemplate;
    }
    return found;
  }
  firstExpandedDataInRow(row) {
    const found = row.find((d) => d.expandedData);
    if (found) {
      return found.expandedData;
    }
    return found;
  }
};
TableExpandedRow.ɵfac = function TableExpandedRow_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TableExpandedRow)();
};
TableExpandedRow.ɵcmp = ɵɵdefineComponent({
  type: TableExpandedRow,
  selectors: [["", "cdsTableExpandedRow", ""], ["", "ibmTableExpandedRow", ""]],
  hostVars: 5,
  hostBindings: function TableExpandedRow_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("data-child-row", ctx.dataChildRow);
      ɵɵstyleProp("display", ctx.displayStyle);
      ɵɵclassProp("cds--expandable-row", ctx.expandableRowClass);
    }
  },
  inputs: {
    row: "row",
    skeleton: "skeleton",
    expanded: "expanded"
  },
  standalone: false,
  attrs: _c226,
  decls: 3,
  vars: 6,
  consts: [[4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
  template: function TableExpandedRow_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "td");
      ɵɵtemplate(1, TableExpandedRow_ng_container_1_Template, 2, 1, "ng-container", 0)(2, TableExpandedRow_ng_template_2_Template, 0, 0, "ng-template", 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵattribute("colspan", ctx.row.length + 2);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.firstExpandedTemplateInRow(ctx.row));
      ɵɵadvance();
      ɵɵproperty("ngTemplateOutlet", ctx.firstExpandedTemplateInRow(ctx.row))("ngTemplateOutletContext", ɵɵpureFunction1(4, _c1111, ctx.firstExpandedDataInRow(ctx.row)));
    }
  },
  dependencies: [NgIf, NgTemplateOutlet],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableExpandedRow, [{
    type: Component,
    args: [{
      // tslint:disable-next-line: component-selector
      selector: "[cdsTableExpandedRow], [ibmTableExpandedRow]",
      template: `
		<td [attr.colspan]="row.length + 2">
			<ng-container *ngIf="!firstExpandedTemplateInRow(row)">
				{{firstExpandedDataInRow(row)}}
			</ng-container>
			<ng-template
				[ngTemplateOutlet]="firstExpandedTemplateInRow(row)"
				[ngTemplateOutletContext]="{data: firstExpandedDataInRow(row)}">
			</ng-template>
		</td>
	`
    }]
  }], null, {
    row: [{
      type: Input
    }],
    skeleton: [{
      type: Input
    }],
    expandableRowClass: [{
      type: HostBinding,
      args: ["class.cds--expandable-row"]
    }],
    dataChildRow: [{
      type: HostBinding,
      args: ["attr.data-child-row"]
    }],
    expanded: [{
      type: Input
    }],
    displayStyle: [{
      type: HostBinding,
      args: ["style.display"]
    }]
  });
})();
var TableBody = class {
  constructor(i18n) {
    this.i18n = i18n;
    this.enableSingleSelect = false;
    this.showSelectionColumn = true;
    this.size = "md";
    this.skeleton = false;
    this.selectRow = new EventEmitter();
    this.deselectRow = new EventEmitter();
    this.rowClick = new EventEmitter();
    this._checkboxRowLabel = this.i18n.getOverridable("TABLE.CHECKBOX_ROW");
    this._expandButtonAriaLabel = this.i18n.getOverridable("TABLE.EXPAND_BUTTON");
  }
  set expandButtonAriaLabel(value) {
    this._expandButtonAriaLabel.override(value);
  }
  get expandButtonAriaLabel() {
    return this._expandButtonAriaLabel.value;
  }
  set checkboxRowLabel(value) {
    this._checkboxRowLabel.override(value);
  }
  get checkboxRowLabel() {
    return this._checkboxRowLabel.value;
  }
  /**
   * Triggered when a single row is clicked.
   * Updates the header checkbox state.
   * Emits the `selectRow` or `deselectRow` event.
   */
  onRowCheckboxChange(index) {
    if (this.model.isRowSelected(index)) {
      this.deselectRow.emit({
        model: this.model,
        deselectedRowIndex: index
      });
    } else {
      this.selectRow.emit({
        model: this.model,
        selectedRowIndex: index
      });
    }
  }
  onRowClick(index) {
    this.rowClick.emit(index);
  }
  getCheckboxRowLabel() {
    return this._checkboxRowLabel.subject;
  }
  getExpandButtonAriaLabel() {
    return this._expandButtonAriaLabel.subject;
  }
  firstExpandedDataInRow(row) {
    const found = row.find((d) => d.expandedData);
    if (found) {
      return found.expandedData;
    }
    return found;
  }
  shouldExpandAsTable(row) {
    return row.some((d) => d.expandAsTable);
  }
};
TableBody.ɵfac = function TableBody_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TableBody)(ɵɵdirectiveInject(I18n));
};
TableBody.ɵcmp = ɵɵdefineComponent({
  type: TableBody,
  selectors: [["", "cdsTableBody", ""], ["", "ibmTableBody", ""]],
  inputs: {
    model: "model",
    enableSingleSelect: "enableSingleSelect",
    expandButtonAriaLabel: "expandButtonAriaLabel",
    checkboxRowLabel: "checkboxRowLabel",
    showSelectionColumn: "showSelectionColumn",
    size: "size",
    selectionLabelColumn: "selectionLabelColumn",
    skeleton: "skeleton"
  },
  outputs: {
    selectRow: "selectRow",
    deselectRow: "deselectRow",
    rowClick: "rowClick"
  },
  standalone: false,
  attrs: _c232,
  ngContentSelectors: _c511,
  decls: 2,
  vars: 1,
  consts: [[4, "ngIf"], [4, "ngFor", "ngForOf"], ["cdsTableRow", "", 3, "model", "row", "size", "selected", "expandable", "expanded", "checkboxLabel", "expandButtonAriaLabel", "showSelectionColumn", "enableSingleSelect", "skeleton", "class", "ngClass", "selectRow", "deselectRow", "expandRow", "rowClick", 4, "ngIf"], ["cdsTableExpandedRow", "", "cdsExpandedRowHover", "", 3, "row", "expanded", "skeleton", 4, "ngIf"], ["cdsTableRow", "", 3, "selectRow", "deselectRow", "expandRow", "rowClick", "model", "row", "size", "selected", "expandable", "expanded", "checkboxLabel", "expandButtonAriaLabel", "showSelectionColumn", "enableSingleSelect", "skeleton", "ngClass"], ["cdsTableExpandedRow", "", "cdsExpandedRowHover", "", 3, "row", "expanded", "skeleton"], ["cdsTableRow", "", 3, "model", "showSelectionColumnCheckbox", "showSelectionColumn", "row", "size", "skeleton", 4, "ngFor", "ngForOf"], ["cdsTableRow", "", 3, "model", "showSelectionColumnCheckbox", "showSelectionColumn", "row", "size", "skeleton"]],
  template: function TableBody_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, TableBody_ng_container_0_Template, 2, 1, "ng-container", 0);
      ɵɵprojection(1);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.model);
    }
  },
  dependencies: [NgClass, NgForOf, NgIf, ExpandedRowHover, TableRowComponent, TableExpandedRow],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableBody, [{
    type: Component,
    args: [{
      // tslint:disable-next-line: component-selector
      selector: "[cdsTableBody], [ibmTableBody]",
      template: `
		<ng-container *ngIf="model">
			<ng-container *ngFor="let row of model.data; let i = index">
				<tr
					cdsTableRow
					[model]="model"
					[row]="row"
					[size]="size"
					[selected]="model.isRowSelected(i)"
					[expandable]="model.isRowExpandable(i)"
					[expanded]="model.isRowExpanded(i)"
					[checkboxLabel]="getCheckboxRowLabel()"
					[expandButtonAriaLabel]="getExpandButtonAriaLabel()"
					[showSelectionColumn]="showSelectionColumn"
					[enableSingleSelect]="enableSingleSelect"
					[skeleton]="skeleton"
					(selectRow)="onRowCheckboxChange(i)"
					(deselectRow)="onRowCheckboxChange(i)"
					(expandRow)="model.expandRow(i, !model.isRowExpanded(i))"
					(rowClick)="onRowClick(i)"
					*ngIf="!model.isRowFiltered(i)"
					[class]="(model.rowsClass[i] ? model.rowsClass[i] : null)"
					[ngClass]="{
						'tbody_row--success': !model.isRowSelected(i) && model.getRowContext(i) === 'success',
						'tbody_row--warning': !model.isRowSelected(i) && model.getRowContext(i) === 'warning',
						'tbody_row--info': !model.isRowSelected(i) && model.getRowContext(i) === 'info',
						'tbody_row--error': !model.isRowSelected(i) && model.getRowContext(i) === 'error'
					}">
				</tr>
				<tr
					*ngIf="model.isRowExpandable(i) && !shouldExpandAsTable(row) && !model.isRowFiltered(i)"
					cdsTableExpandedRow
					cdsExpandedRowHover
					[row]="row"
					[expanded]="model.isRowExpanded(i)"
					[skeleton]="skeleton">
				</tr>
				<ng-container
					*ngIf="model.isRowExpandable(i) && shouldExpandAsTable(row) && model.isRowExpanded(i) && !model.isRowFiltered(i)">
					<tr
						*ngFor="let expandedDataRow of firstExpandedDataInRow(row)"
						cdsTableRow
						[model]="model"
						[showSelectionColumnCheckbox]="false"
						[showSelectionColumn]="showSelectionColumn"
						[row]="expandedDataRow"
						[size]="size"
						[skeleton]="skeleton">
					</tr>
				</ng-container>
			</ng-container>
		</ng-container>
		<ng-content></ng-content>
	`
    }]
  }], function() {
    return [{
      type: I18n
    }];
  }, {
    model: [{
      type: Input
    }],
    enableSingleSelect: [{
      type: Input
    }],
    expandButtonAriaLabel: [{
      type: Input
    }],
    checkboxRowLabel: [{
      type: Input
    }],
    showSelectionColumn: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    selectionLabelColumn: [{
      type: Input
    }],
    skeleton: [{
      type: Input
    }],
    selectRow: [{
      type: Output
    }],
    deselectRow: [{
      type: Output
    }],
    rowClick: [{
      type: Output
    }]
  });
})();
var Table = class _Table {
  /**
   * Creates an instance of Table.
   */
  constructor(elementRef, applicationRef, i18n) {
    this.elementRef = elementRef;
    this.applicationRef = applicationRef;
    this.i18n = i18n;
    this.size = "md";
    this.skeleton = false;
    this.sortable = true;
    this.noBorder = true;
    this.showExpandAllToggle = false;
    this.showSelectionColumn = true;
    this.enableSingleSelect = false;
    this.scrollLoadDistance = 0;
    this.striped = true;
    this.tableContent = true;
    this.stickyHeader = false;
    this.sort = new EventEmitter();
    this.selectAll = new EventEmitter();
    this.deselectAll = new EventEmitter();
    this.selectRow = new EventEmitter();
    this.deselectRow = new EventEmitter();
    this.rowClick = new EventEmitter();
    this.scrollLoad = new EventEmitter();
    this.selectAllCheckbox = false;
    this.selectAllCheckboxSomeSelected = false;
    this.isColumnDragging = false;
    this.columnDraggedHoverIndex = -1;
    this.columnDraggedPosition = "";
    this._isDataGrid = false;
    this.isViewReady = false;
    this.subscriptions = new Subscription();
    this._expandButtonAriaLabel = this.i18n.getOverridable("TABLE.EXPAND_BUTTON");
    this._sortDescendingLabel = this.i18n.getOverridable("TABLE.SORT_DESCENDING");
    this._sortAscendingLabel = this.i18n.getOverridable("TABLE.SORT_ASCENDING");
    this._checkboxHeaderLabel = this.i18n.getOverridable("TABLE.CHECKBOX_HEADER");
    this._checkboxRowLabel = this.i18n.getOverridable("TABLE.CHECKBOX_ROW");
    this._endOfDataText = this.i18n.getOverridable("TABLE.END_OF_DATA");
    this._scrollTopText = this.i18n.getOverridable("TABLE.SCROLL_TOP");
    this._filterTitle = this.i18n.getOverridable("TABLE.FILTER");
  }
  /**
   * Creates a skeleton model with a row and column count specified by the user
   *
   * Example:
   *
   * ```typescript
   * this.model = Table.skeletonModel(5, 5);
   * ```
   */
  static skeletonModel(rowCount, columnCount) {
    const model = new TableModel();
    let header = new Array();
    let data = new Array();
    let row = new Array();
    for (let i = 0; i < columnCount; i++) {
      header.push(new TableHeaderItem());
      row.push(new TableItem());
    }
    for (let i = 0; i < rowCount - 1; i++) {
      data.push(row);
    }
    model.header = header;
    model.data = data;
    return model;
  }
  static setTabIndex(element, index) {
    const focusElementList = getFocusElementList(element, tabbableSelectorIgnoreTabIndex);
    if (element.firstElementChild && element.firstElementChild.classList.contains("cds--table-sort") && focusElementList.length > 1) {
      focusElementList[1].tabIndex = index;
    } else if (focusElementList.length > 0) {
      focusElementList[0].tabIndex = index;
    } else {
      element.tabIndex = index;
    }
  }
  static focus(element) {
    const focusElementList = getFocusElementList(element, tabbableSelectorIgnoreTabIndex);
    if (element.firstElementChild?.classList.contains("cds--table-sort") && focusElementList.length > 1 || focusElementList.length > 0) {
      focusElementList[0].focus();
    } else {
      element.focus();
    }
  }
  /**
   * `TableModel` with data the table is to display.
   */
  set model(m) {
    if (this._model) {
      this.subscriptions.unsubscribe();
      this.subscriptions = new Subscription();
    }
    this._model = m;
    const rowsChange = this._model.rowsSelectedChange.subscribe(() => this.updateSelectAllCheckbox());
    const dataChange = this._model.dataChange.subscribe(() => {
      if (this.isDataGrid) {
        this.resetTabIndex();
      }
      this.updateSelectAllCheckbox();
    });
    this.subscriptions.add(rowsChange);
    this.subscriptions.add(dataChange);
    if (this.isDataGrid) {
      const expandedChange = this._model.rowsExpandedChange.subscribe(() => {
        setTimeout(() => {
          const expandedRows = this.elementRef.nativeElement.querySelectorAll(".cds--expandable-row:not(.cds--parent-row)");
          Array.from(expandedRows).forEach((row) => {
            if (row.firstElementChild.tabIndex === void 0 || row.firstElementChild.tabIndex !== -1) {
              row.firstElementChild.tabIndex = -1;
            }
          });
        });
      });
      this.subscriptions.add(expandedChange);
    }
  }
  get model() {
    return this._model;
  }
  /**
   * Set to `true` for a data grid with keyboard interactions.
   */
  set isDataGrid(value) {
    this._isDataGrid = value;
    if (this.isViewReady) {
      if (value) {
        this.enableDataGridInteractions();
      } else {
        this.disableDataGridInteractions();
      }
    }
  }
  get isDataGrid() {
    return this._isDataGrid;
  }
  /**
   * @todo - Enable column resize when Carbon officially supports feature
   * Set to `true` to enable users to resize columns.
   *
   * Works for columns with width set in pixels.
   *
   */
  // @Input() columnsResizable = false;
  /**
   * @todo - Enable columns drag & drop when Carbon officially supports feature
   * Set to `true` to enable users to drag and drop columns.
   *
   * Changing the column order in table changes table model. Be aware of it when you add additional data
   * to the model.
   *
   */
  // @Input() columnsDraggable = false;
  set expandButtonAriaLabel(value) {
    this._expandButtonAriaLabel.override(value);
  }
  get expandButtonAriaLabel() {
    return this._expandButtonAriaLabel.value;
  }
  set sortDescendingLabel(value) {
    this._sortDescendingLabel.override(value);
  }
  get sortDescendingLabel() {
    return this._sortDescendingLabel.value;
  }
  set sortAscendingLabel(value) {
    this._sortAscendingLabel.override(value);
  }
  get sortAscendingLabel() {
    return this._sortAscendingLabel.value;
  }
  /**
   * Expects an object that contains some or all of:
   * ```
   * {
   *		"FILTER": "Filter",
   *		"END_OF_DATA": "You've reached the end of your content",
   *		"SCROLL_TOP": "Scroll to top",
   *		"CHECKBOX_HEADER": "Select all rows",
   *		"CHECKBOX_ROW": "Select row"
   * }
   * ```
   */
  set translations(value) {
    const valueWithDefaults = merge2(this.i18n.getMultiple("TABLE"), value);
    this._filterTitle.override(valueWithDefaults.FILTER);
    this._endOfDataText.override(valueWithDefaults.END_OF_DATA);
    this._scrollTopText.override(valueWithDefaults.SCROLL_TOP);
    this._checkboxHeaderLabel.override(valueWithDefaults.CHECKBOX_HEADER);
    this._checkboxRowLabel.override(valueWithDefaults.CHECKBOX_ROW);
  }
  get noData() {
    return !this.model.data || this.model.data.length === 0 || this.model.data.length === 1 && this.model.data[0].length === 0;
  }
  ngOnInit() {
    this.updateSelectAllCheckbox();
  }
  ngAfterViewInit() {
    this.isViewReady = true;
    if (this.isDataGrid) {
      this.enableDataGridInteractions();
    }
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
    if (this.positionSubscription) {
      this.positionSubscription.unsubscribe();
    }
  }
  enableDataGridInteractions() {
    if (this.interactionModel) {
      return;
    }
    const table = this.elementRef.nativeElement.querySelector("table");
    const tableAdapter = new TableDomAdapter(table);
    const keydownEventStream = fromEvent(table, "keydown");
    const clickEventStream = fromEvent(table, "click");
    this.interactionModel = new DataGridInteractionModel(keydownEventStream, clickEventStream, tableAdapter);
    this.positionSubscription = this.interactionModel.position.subscribe((event) => {
      const [currentRow, currentColumn] = event.current;
      const [previousRow, previousColumn] = event.previous;
      const currentElement = tableAdapter.getCell(currentRow, currentColumn);
      _Table.setTabIndex(currentElement, 0);
      if (previousRow === -1 || previousColumn === -1) {
        return;
      }
      if (previousRow !== currentRow || previousColumn !== currentColumn) {
        const previousElement = tableAdapter.getCell(previousRow, previousColumn);
        _Table.setTabIndex(previousElement, -1);
      }
      _Table.focus(currentElement);
    });
    this.resetTabIndex();
  }
  disableDataGridInteractions() {
    if (this.positionSubscription) {
      this.positionSubscription.unsubscribe();
    }
    this.resetTabIndex(0);
    this.interactionModel = null;
  }
  onSelectAll() {
    this.model.selectAll(true);
    this.selectAll.emit(this.model);
  }
  onDeselectAll() {
    this.model.selectAll(false);
    this.deselectAll.emit(this.model);
  }
  onSelectRow(event) {
    if (Object.keys(event).includes("selectedRowIndex")) {
      if (this.enableSingleSelect) {
        this.model.selectAll(false);
      }
      this.model.selectRow(event.selectedRowIndex, true);
      this.selectRow.emit(event);
    } else {
      this.model.selectRow(event.deselectedRowIndex, false);
      this.deselectRow.emit(event);
    }
  }
  onRowClick(index) {
    this.rowClick.emit(index);
  }
  updateSelectAllCheckbox() {
    const selectedRowsCount = this.model.selectedRowsCount();
    if (selectedRowsCount <= 0) {
      this.selectAllCheckbox = false;
      this.selectAllCheckboxSomeSelected = false;
    } else if (selectedRowsCount < this.model.data.length) {
      this.selectAllCheckbox = true;
      this.selectAllCheckboxSomeSelected = true;
    } else {
      this.selectAllCheckbox = true;
      this.selectAllCheckboxSomeSelected = false;
    }
  }
  resetTabIndex(newTabIndex = -1) {
    setTimeout(() => {
      const focusElementList = getFocusElementList(this.elementRef.nativeElement, tabbableSelectorIgnoreTabIndex);
      if (focusElementList) {
        focusElementList.forEach((tabbable) => {
          tabbable.tabIndex = newTabIndex;
        });
      }
      if (this.interactionModel) {
        this.interactionModel.resetTabIndexes(newTabIndex);
      }
    });
  }
  columnResizeStart(event, column) {
    this.columnResizeWidth = parseInt(column.style.width, 10);
    this.columnResizeMouseX = event.clientX;
    event.preventDefault();
    this.mouseMoveSubscription = fromEvent(document.body, "mousemove").subscribe((event2) => {
      this.columnResizeProgress(event2, column);
    });
    this.mouseUpSubscription = fromEvent(document.body, "mouseup").subscribe((event2) => {
      this.columnResizeEnd(event2, column);
    });
  }
  columnResizeProgress(event, column) {
    const move = event.clientX - this.columnResizeMouseX;
    column.style.width = `${this.columnResizeWidth + move}px`;
  }
  columnResizeEnd(event, column) {
    this.mouseMoveSubscription.unsubscribe();
    this.mouseUpSubscription.unsubscribe();
  }
  /**
   * Triggered when the user scrolls on the `<tbody>` element.
   * Emits the `scrollLoad` event.
   */
  onScroll(event) {
    const distanceFromBottom = event.target.scrollHeight - event.target.clientHeight - event.target.scrollTop;
    if (distanceFromBottom <= this.scrollLoadDistance) {
      this.scrollLoad.emit(this.model);
    } else {
      this.model.isEnd = false;
    }
  }
  columnDragStart(event, columnIndex) {
    this.isColumnDragging = true;
    this.columnDraggedHoverIndex = columnIndex;
    event.dataTransfer.setData("columnIndex", JSON.stringify(columnIndex));
  }
  columnDragEnd(event, columnIndex) {
    this.isColumnDragging = false;
    this.columnDraggedHoverIndex = -1;
  }
  columnDragEnter(event, position2, columnIndex) {
    this.columnDraggedPosition = position2;
    this.columnDraggedHoverIndex = columnIndex;
  }
  columnDragLeave(event, position2, columnIndex) {
    this.columnDraggedPosition = "";
  }
  columnDragover(event, position2, columnIndex) {
    this.columnDraggedHoverIndex = columnIndex;
    this.columnDraggedPosition = position2;
    event.preventDefault();
  }
  columnDrop(event, position2, columnIndex) {
    this.isColumnDragging = false;
    this.columnDraggedHoverIndex = -1;
    this.columnDraggedPosition = "";
    this.model.moveColumn(parseInt(event.dataTransfer.getData("columnIndex"), 10), columnIndex + (position2 === "right" ? 1 : 0));
  }
  doSort(index) {
    if (this.sort.observers.length === 0) {
      this.model.cycleSortState(index);
      this.model.sort(index);
    }
    this.sort.emit(index);
  }
  /**
   * Triggered when the user scrolls on the `<tbody>` element.
   * Emits the `scrollLoad` event.
   */
  scrollToTop(event) {
    event.target.parentElement.parentElement.parentElement.parentElement.children[1].scrollTop = 0;
    this.model.isEnd = false;
  }
  getSelectionLabelValue(row) {
    if (!this.selectionLabelColumn) {
      return {
        value: this.i18n.get().TABLE.ROW
      };
    }
    return {
      value: row[this.selectionLabelColumn].data
    };
  }
  getExpandButtonAriaLabel() {
    return this._expandButtonAriaLabel.subject;
  }
  getSortDescendingLabel() {
    return this._sortDescendingLabel.subject;
  }
  getSortAscendingLabel() {
    return this._sortAscendingLabel.subject;
  }
  getCheckboxHeaderLabel() {
    return this._checkboxHeaderLabel.subject;
  }
  getCheckboxRowLabel() {
    return this._checkboxRowLabel.subject;
  }
  getEndOfDataText() {
    return this._endOfDataText.subject;
  }
  getScrollTopText() {
    return this._scrollTopText.subject;
  }
  getFilterTitle() {
    return this._filterTitle.subject;
  }
};
Table.ɵfac = function Table_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Table)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ApplicationRef), ɵɵdirectiveInject(I18n));
};
Table.ɵcmp = ɵɵdefineComponent({
  type: Table,
  selectors: [["cds-table"], ["ibm-table"]],
  hostVars: 4,
  hostBindings: function Table_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--data-table-content", ctx.tableContent)("cds--data-table_inner-container", ctx.stickyHeader);
    }
  },
  inputs: {
    ariaLabelledby: "ariaLabelledby",
    ariaDescribedby: "ariaDescribedby",
    model: "model",
    size: "size",
    skeleton: "skeleton",
    isDataGrid: "isDataGrid",
    sortable: "sortable",
    noBorder: "noBorder",
    showExpandAllToggle: "showExpandAllToggle",
    showSelectionColumn: "showSelectionColumn",
    enableSingleSelect: "enableSingleSelect",
    scrollLoadDistance: "scrollLoadDistance",
    expandButtonAriaLabel: "expandButtonAriaLabel",
    sortDescendingLabel: "sortDescendingLabel",
    sortAscendingLabel: "sortAscendingLabel",
    translations: "translations",
    striped: "striped",
    stickyHeader: "stickyHeader",
    footerTemplate: "footerTemplate",
    selectionLabelColumn: "selectionLabelColumn"
  },
  outputs: {
    sort: "sort",
    selectAll: "selectAll",
    deselectAll: "deselectAll",
    selectRow: "selectRow",
    deselectRow: "deselectRow",
    rowClick: "rowClick",
    scrollLoad: "scrollLoad"
  },
  standalone: false,
  ngContentSelectors: _c511,
  decls: 9,
  vars: 28,
  consts: [["noDataTemplate", ""], ["cdsTable", "", 3, "sortable", "noBorder", "ngClass", "size", "striped", "skeleton"], ["cdsTableHead", "", 3, "deselectAll", "selectAll", "expandAllRows", "collapseAllRows", "sort", "sortable", "checkboxHeaderLabel", "filterTitle", "model", "selectAllCheckbox", "selectAllCheckboxSomeSelected", "showSelectionColumn", "enableSingleSelect", "showExpandAllToggle", "skeleton", "sortAscendingLabel", "sortDescendingLabel", "stickyHeader"], ["cdsTableBody", "", 3, "checkboxRowLabel", "enableSingleSelect", "expandButtonAriaLabel", "model", "size", "ngStyle", "selectionLabelColumn", "showSelectionColumn", "skeleton", "deselectRow", "scroll", "selectRow", "rowClick", 4, "ngIf", "ngIfElse"], [3, "ngTemplateOutlet"], [4, "ngIf"], ["cdsTableBody", "", 3, "deselectRow", "scroll", "selectRow", "rowClick", "checkboxRowLabel", "enableSingleSelect", "expandButtonAriaLabel", "model", "size", "ngStyle", "selectionLabelColumn", "showSelectionColumn", "skeleton"], [1, "table_loading-indicator"], [1, "cds--loading", "cds--loading--small"], ["viewBox", "-75 -75 150 150", 1, "cds--loading__svg"], ["cx", "0", "cy", "0", "r", "37.5", 1, "cds--loading__stroke"], [1, "table_end-indicator"], [1, "btn--secondary-sm", 3, "click"]],
  template: function Table_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵprojectionDef();
      ɵɵelementStart(0, "table", 1)(1, "thead", 2);
      ɵɵlistener("deselectAll", function Table_Template_thead_deselectAll_1_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onDeselectAll());
      })("selectAll", function Table_Template_thead_selectAll_1_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onSelectAll());
      })("expandAllRows", function Table_Template_thead_expandAllRows_1_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.model.expandAllRows(true));
      })("collapseAllRows", function Table_Template_thead_collapseAllRows_1_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.model.expandAllRows(false));
      })("sort", function Table_Template_thead_sort_1_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.doSort($event));
      });
      ɵɵelementEnd();
      ɵɵtemplate(2, Table_tbody_2_Template, 1, 10, "tbody", 3)(3, Table_ng_template_3_Template, 1, 0, "ng-template", null, 0, ɵɵtemplateRefExtractor);
      ɵɵelementStart(5, "tfoot");
      ɵɵtemplate(6, Table_ng_template_6_Template, 0, 0, "ng-template", 4)(7, Table_tr_7_Template, 5, 0, "tr", 5)(8, Table_tr_8_Template, 8, 6, "tr", 5);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      const noDataTemplate_r5 = ɵɵreference(4);
      ɵɵproperty("sortable", ctx.sortable)("noBorder", ctx.noBorder)("ngClass", ɵɵpureFunction1(26, _c252, ctx.stickyHeader))("size", ctx.size)("striped", ctx.striped)("skeleton", ctx.skeleton);
      ɵɵattribute("aria-labelledby", ctx.ariaLabelledby)("aria-describedby", ctx.ariaDescribedby);
      ɵɵadvance();
      ɵɵproperty("sortable", ctx.sortable)("checkboxHeaderLabel", ctx.getCheckboxHeaderLabel())("filterTitle", ctx.getFilterTitle())("model", ctx.model)("selectAllCheckbox", ctx.selectAllCheckbox)("selectAllCheckboxSomeSelected", ctx.selectAllCheckboxSomeSelected)("showSelectionColumn", ctx.showSelectionColumn)("enableSingleSelect", ctx.enableSingleSelect)("showExpandAllToggle", ctx.showExpandAllToggle)("skeleton", ctx.skeleton)("sortAscendingLabel", ctx.sortAscendingLabel)("sortDescendingLabel", ctx.sortDescendingLabel)("stickyHeader", ctx.stickyHeader);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.noData)("ngIfElse", noDataTemplate_r5);
      ɵɵadvance(4);
      ɵɵproperty("ngTemplateOutlet", ctx.footerTemplate);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.model.isLoading);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.model.isEnd);
    }
  },
  dependencies: [NgClass, NgIf, NgTemplateOutlet, NgStyle, TableDirective, TableHead, TableBody, AsyncPipe],
  styles: ["[_nghost-%COMP%]{display:block}"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Table, [{
    type: Component,
    args: [{
      selector: "cds-table, ibm-table",
      template: `
	<table
		cdsTable
		[sortable]="sortable"
		[noBorder]="noBorder"
		[ngClass]="{'cds--data-table--sticky-header': stickyHeader}"
		[size]="size"
		[striped]="striped"
		[skeleton]="skeleton"
		[attr.aria-labelledby]="ariaLabelledby"
		[attr.aria-describedby]="ariaDescribedby">
		<thead
			cdsTableHead
			[sortable]="sortable"
			(deselectAll)="onDeselectAll()"
			(selectAll)="onSelectAll()"
			(expandAllRows)="model.expandAllRows(true)"
			(collapseAllRows)="model.expandAllRows(false)"
			(sort)="doSort($event)"
			[checkboxHeaderLabel]="getCheckboxHeaderLabel()"
			[filterTitle]="getFilterTitle()"
			[model]="model"
			[selectAllCheckbox]="selectAllCheckbox"
			[selectAllCheckboxSomeSelected]="selectAllCheckboxSomeSelected"
			[showSelectionColumn]="showSelectionColumn"
			[enableSingleSelect]="enableSingleSelect"
			[showExpandAllToggle]="showExpandAllToggle"
			[skeleton]="skeleton"
			[sortAscendingLabel]="sortAscendingLabel"
			[sortDescendingLabel]="sortDescendingLabel"
			[stickyHeader]="stickyHeader">
		</thead>
		<tbody
			cdsTableBody
			(deselectRow)="onSelectRow($event)"
			(scroll)="onScroll($event)"
			(selectRow)="onSelectRow($event)"
			[checkboxRowLabel]="getCheckboxRowLabel()"
			[enableSingleSelect]="enableSingleSelect"
			(rowClick)="onRowClick($event)"
			[expandButtonAriaLabel]="expandButtonAriaLabel"
			[model]="model"
			[size]="size"
			[ngStyle]="{'overflow-y': 'scroll'}"
			[selectionLabelColumn]="selectionLabelColumn"
			[showSelectionColumn]="showSelectionColumn"
			[skeleton]="skeleton"
			*ngIf="!noData; else noDataTemplate">
		</tbody>
		<ng-template #noDataTemplate><ng-content></ng-content></ng-template>
		<tfoot>
			<ng-template
				[ngTemplateOutlet]="footerTemplate">
			</ng-template>
			<tr *ngIf="this.model.isLoading">
				<td class="table_loading-indicator">
					<div class="cds--loading cds--loading--small">
						<svg class="cds--loading__svg" viewBox="-75 -75 150 150">
							<circle class="cds--loading__stroke" cx="0" cy="0" r="37.5" />
						</svg>
					</div>
				</td>
			</tr>
			<tr *ngIf="this.model.isEnd">
				<td class="table_end-indicator">
					<h5>{{getEndOfDataText() | async}}</h5>
					<button (click)="scrollToTop($event)" class="btn--secondary-sm">
						{{getScrollTopText() | async}}
					</button>
				</td>
			</tr>
		</tfoot>
	</table>
	`,
      styles: [":host{display:block}\n"]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: ApplicationRef
    }, {
      type: I18n
    }];
  }, {
    ariaLabelledby: [{
      type: Input
    }],
    ariaDescribedby: [{
      type: Input
    }],
    model: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    skeleton: [{
      type: Input
    }],
    isDataGrid: [{
      type: Input
    }],
    sortable: [{
      type: Input
    }],
    noBorder: [{
      type: Input
    }],
    showExpandAllToggle: [{
      type: Input
    }],
    showSelectionColumn: [{
      type: Input
    }],
    enableSingleSelect: [{
      type: Input
    }],
    scrollLoadDistance: [{
      type: Input
    }],
    expandButtonAriaLabel: [{
      type: Input
    }],
    sortDescendingLabel: [{
      type: Input
    }],
    sortAscendingLabel: [{
      type: Input
    }],
    translations: [{
      type: Input
    }],
    striped: [{
      type: Input
    }],
    tableContent: [{
      type: HostBinding,
      args: ["class.cds--data-table-content"]
    }],
    stickyHeader: [{
      type: HostBinding,
      args: ["class.cds--data-table_inner-container"]
    }, {
      type: Input
    }],
    footerTemplate: [{
      type: Input
    }],
    selectionLabelColumn: [{
      type: Input
    }],
    sort: [{
      type: Output
    }],
    selectAll: [{
      type: Output
    }],
    deselectAll: [{
      type: Output
    }],
    selectRow: [{
      type: Output
    }],
    deselectRow: [{
      type: Output
    }],
    rowClick: [{
      type: Output
    }],
    scrollLoad: [{
      type: Output
    }]
  });
})();
var TableContainer = class {
  constructor() {
    this.containerClass = true;
  }
  ngAfterContentInit() {
    if (this.table) {
      this.table.ariaLabelledby = this.headerTitle?.id;
      this.table.ariaDescribedby = this.headerDescription?.id;
    }
  }
};
TableContainer.ɵfac = function TableContainer_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TableContainer)();
};
TableContainer.ɵcmp = ɵɵdefineComponent({
  type: TableContainer,
  selectors: [["cds-table-container"], ["ibm-table-container"]],
  contentQueries: function TableContainer_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, TableHeaderTitle, 5);
      ɵɵcontentQuery(dirIndex, TableHeaderDescription, 5);
      ɵɵcontentQuery(dirIndex, Table, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTitle = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerDescription = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.table = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function TableContainer_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--data-table-container", ctx.containerClass);
    }
  },
  standalone: false,
  ngContentSelectors: _c511,
  decls: 1,
  vars: 0,
  template: function TableContainer_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  styles: ["[_nghost-%COMP%]{display:block}"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableContainer, [{
    type: Component,
    args: [{
      selector: "cds-table-container, ibm-table-container",
      template: `<ng-content></ng-content>`,
      styles: [":host{display:block}\n"]
    }]
  }], null, {
    containerClass: [{
      type: HostBinding,
      args: ["class.cds--data-table-container"]
    }],
    headerTitle: [{
      type: ContentChild,
      args: [TableHeaderTitle]
    }],
    headerDescription: [{
      type: ContentChild,
      args: [TableHeaderDescription]
    }],
    table: [{
      type: ContentChild,
      args: [Table]
    }]
  });
})();
var TableHeader = class {
  constructor() {
    this.headerClass = true;
    this.displayStyle = "block";
  }
};
TableHeader.ɵfac = function TableHeader_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TableHeader)();
};
TableHeader.ɵcmp = ɵɵdefineComponent({
  type: TableHeader,
  selectors: [["cds-table-header"], ["ibm-table-header"]],
  hostVars: 4,
  hostBindings: function TableHeader_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵstyleProp("display", ctx.displayStyle);
      ɵɵclassProp("cds--data-table-header", ctx.headerClass);
    }
  },
  standalone: false,
  ngContentSelectors: _c511,
  decls: 1,
  vars: 0,
  template: function TableHeader_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableHeader, [{
    type: Component,
    args: [{
      selector: "cds-table-header, ibm-table-header",
      template: `
		<ng-content></ng-content>
	`
    }]
  }], null, {
    headerClass: [{
      type: HostBinding,
      args: ["class.cds--data-table-header"]
    }],
    displayStyle: [{
      type: HostBinding,
      args: ["style.display"]
    }]
  });
})();
var TableRow = class extends Array {
  constructor() {
    super(...arguments);
    this.disabled = false;
  }
};
var TableModule = class {
};
TableModule.ɵfac = function TableModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TableModule)();
};
TableModule.ɵmod = ɵɵdefineNgModule({
  type: TableModule,
  declarations: [
    // toolbar and utility components
    TableToolbar,
    TableContainer,
    TableHeader,
    TableHeaderTitle,
    TableHeaderDescription,
    TableHeadCellLabel,
    TableToolbarActions,
    TableToolbarSearch,
    TableToolbarContent,
    ExpandedRowHover,
    // core table components
    Table,
    TableDirective,
    TableHead,
    TableHeadCell,
    TableHeadCheckbox,
    TableHeadExpand,
    TableBody,
    TableRowComponent,
    TableExpandedRow,
    TableData,
    TableCheckbox,
    TableRadio,
    TableExpandButton
  ],
  imports: [CommonModule, NFormsModule, FormsModule, DialogModule, ButtonModule, SearchModule, I18nModule, IconModule],
  exports: [
    // toolbar and utility components
    TableToolbar,
    TableContainer,
    TableHeader,
    TableHeaderTitle,
    TableHeaderDescription,
    TableHeadCellLabel,
    TableToolbarActions,
    TableToolbarSearch,
    TableToolbarContent,
    ExpandedRowHover,
    // core table components
    Table,
    TableDirective,
    TableHead,
    TableHeadCell,
    TableHeadCheckbox,
    TableHeadExpand,
    TableBody,
    TableRowComponent,
    TableExpandedRow,
    TableData,
    TableCheckbox,
    TableRadio,
    TableExpandButton
  ]
});
TableModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, NFormsModule, FormsModule, DialogModule, ButtonModule, SearchModule, I18nModule, IconModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableModule, [{
    type: NgModule,
    args: [{
      declarations: [
        // toolbar and utility components
        TableToolbar,
        TableContainer,
        TableHeader,
        TableHeaderTitle,
        TableHeaderDescription,
        TableHeadCellLabel,
        TableToolbarActions,
        TableToolbarSearch,
        TableToolbarContent,
        ExpandedRowHover,
        // core table components
        Table,
        TableDirective,
        TableHead,
        TableHeadCell,
        TableHeadCheckbox,
        TableHeadExpand,
        TableBody,
        TableRowComponent,
        TableExpandedRow,
        TableData,
        TableCheckbox,
        TableRadio,
        TableExpandButton
      ],
      exports: [
        // toolbar and utility components
        TableToolbar,
        TableContainer,
        TableHeader,
        TableHeaderTitle,
        TableHeaderDescription,
        TableHeadCellLabel,
        TableToolbarActions,
        TableToolbarSearch,
        TableToolbarContent,
        ExpandedRowHover,
        // core table components
        Table,
        TableDirective,
        TableHead,
        TableHeadCell,
        TableHeadCheckbox,
        TableHeadExpand,
        TableBody,
        TableRowComponent,
        TableExpandedRow,
        TableData,
        TableCheckbox,
        TableRadio,
        TableExpandButton
      ],
      imports: [CommonModule, NFormsModule, FormsModule, DialogModule, ButtonModule, SearchModule, I18nModule, IconModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-tabs.mjs
var _c035 = ["tabList"];
var _c135 = ["*"];
var _c227 = (a0) => ({
  "cds--tab--overflow-nav-button--hidden": a0
});
var _c320 = (a0) => ({
  "display": a0
});
var _c415 = (a0) => ({
  $implicit: a0
});
function Tab_div_0_1_ng_template_0_Template(rf, ctx) {
}
function Tab_div_0_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, Tab_div_0_1_ng_template_0_Template, 0, 0, "ng-template", 3);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.tabContent)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c415, ctx_r0.templateContext));
  }
}
function Tab_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 1);
    ɵɵtemplate(1, Tab_div_0_1_Template, 1, 4, null, 2);
    ɵɵprojection(2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngStyle", ɵɵpureFunction1(4, _c320, ctx_r0.active ? null : "none"));
    ɵɵattribute("tabindex", ctx_r0.tabIndex)("aria-labelledby", ctx_r0.id + "-header");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.tabContent));
  }
}
var _c512 = ["tabItem"];
var _c69 = (a0, a1) => ({
  "cds--tabs__nav-item--selected": a0,
  "cds--tabs__nav-item--disabled": a1
});
function TabHeaders_button_6_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const tab_r7 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", tab_r7.heading, " ");
  }
}
function TabHeaders_button_6_3_ng_template_0_Template(rf, ctx) {
}
function TabHeaders_button_6_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TabHeaders_button_6_3_ng_template_0_Template, 0, 0, "ng-template", 12);
  }
  if (rf & 2) {
    const tab_r7 = ɵɵnextContext().$implicit;
    ɵɵproperty("ngTemplateOutlet", tab_r7.heading)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c415, tab_r7.context));
  }
}
function TabHeaders_button_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 10, 1);
    ɵɵlistener("focus", function TabHeaders_button_6_Template_button_focus_0_listener() {
      const i_r3 = ɵɵrestoreView(_r2).index;
      const tabItem_r4 = ɵɵreference(1);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.onTabFocus(tabItem_r4, i_r3));
    })("click", function TabHeaders_button_6_Template_button_click_0_listener() {
      const ctx_r5 = ɵɵrestoreView(_r2);
      const tab_r7 = ctx_r5.$implicit;
      const i_r3 = ctx_r5.index;
      const tabItem_r4 = ɵɵreference(1);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.selectTab(tabItem_r4, tab_r7, i_r3));
    });
    ɵɵtemplate(2, TabHeaders_button_6_ng_container_2_Template, 2, 1, "ng-container", 11)(3, TabHeaders_button_6_3_Template, 1, 4, null, 11);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const tab_r7 = ctx.$implicit;
    ɵɵpropertyInterpolate1("id", "", tab_r7.id, "-header");
    ɵɵproperty("ngClass", ɵɵpureFunction2(9, _c69, tab_r7.active, tab_r7.disabled));
    ɵɵattribute("aria-selected", tab_r7.active)("tabindex", tab_r7.active ? 0 : -1)("aria-controls", tab_r7.id)("aria-disabled", tab_r7.disabled);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", !tab_r7.headingIsTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", tab_r7.headingIsTemplate);
  }
}
function TabSkeleton_li_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "li", 2)(1, "div", 3);
    ɵɵelement(2, "span");
    ɵɵelementEnd()();
  }
}
var _c76 = ["*", [["", "before", ""]], [["", "after", ""]]];
var _c86 = ["*", "[before]", "[after]"];
function Tabs_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "cds-tabs-skeleton");
    ɵɵelementContainerEnd();
  }
}
function Tabs_ng_container_1_cds_tab_headers_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-tab-headers", 5);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const before_r1 = ɵɵreference(4);
    const after_r2 = ɵɵreference(6);
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("theme", ctx_r2.theme)("tabs", ctx_r2.tabs)("followFocus", ctx_r2.followFocus)("cacheActive", ctx_r2.cacheActive)("contentBefore", before_r1)("contentAfter", after_r2)("ariaLabel", ctx_r2.ariaLabel)("ariaLabelledby", ctx_r2.ariaLabelledby)("type", ctx_r2.type);
  }
}
function Tabs_ng_container_1_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 1);
  }
}
function Tabs_ng_container_1_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 2);
  }
}
function Tabs_ng_container_1_cds_tab_headers_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-tab-headers", 6);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("tabs", ctx_r2.tabs)("cacheActive", ctx_r2.cacheActive)("type", ctx_r2.type);
  }
}
function Tabs_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, Tabs_ng_container_1_cds_tab_headers_1_Template, 1, 9, "cds-tab-headers", 3);
    ɵɵprojection(2);
    ɵɵtemplate(3, Tabs_ng_container_1_ng_template_3_Template, 1, 0, "ng-template", null, 0, ɵɵtemplateRefExtractor)(5, Tabs_ng_container_1_ng_template_5_Template, 1, 0, "ng-template", null, 1, ɵɵtemplateRefExtractor)(7, Tabs_ng_container_1_cds_tab_headers_7_Template, 1, 3, "cds-tab-headers", 4);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.hasTabHeaders() && ctx_r2.position === "top");
    ɵɵadvance(6);
    ɵɵproperty("ngIf", ctx_r2.hasTabHeaders() && ctx_r2.position === "bottom");
  }
}
var BaseTabHeader = class {
  constructor(elementRef, changeDetectorRef, eventService, renderer) {
    this.elementRef = elementRef;
    this.changeDetectorRef = changeDetectorRef;
    this.eventService = eventService;
    this.renderer = renderer;
    this.cacheActive = false;
    this.type = "line";
    this.theme = "dark";
    this.tabsClass = true;
    this.OVERFLOW_BUTTON_OFFSET = 44;
    this.longPressMultiplier = 3;
    this.clickMultiplier = 1.5;
    this.longPressInterval = null;
    this.tickInterval = null;
  }
  get containedClass() {
    return this.type === "contained";
  }
  get themeClass() {
    return this.theme === "light";
  }
  get hasHorizontalOverflow() {
    const tabList = this.headerContainer.nativeElement;
    return tabList.scrollWidth > tabList.clientWidth;
  }
  get leftOverflowNavButtonHidden() {
    const tabList = this.headerContainer.nativeElement;
    return !this.hasHorizontalOverflow || !tabList.scrollLeft;
  }
  get rightOverflowNavButtonHidden() {
    const tabList = this.headerContainer.nativeElement;
    return !this.hasHorizontalOverflow || tabList.scrollLeft + tabList.clientWidth === tabList.scrollWidth;
  }
  handleScroll() {
    this.changeDetectorRef.markForCheck();
  }
  handleOverflowNavClick(direction, numOftabs = 0) {
    const tabList = this.headerContainer.nativeElement;
    const {
      clientWidth,
      scrollLeft,
      scrollWidth
    } = tabList;
    if (direction > 0) {
      tabList.scrollLeft = Math.min(scrollLeft + scrollWidth / numOftabs * this.clickMultiplier, scrollWidth - clientWidth);
    } else if (direction < 0) {
      tabList.scrollLeft = Math.max(scrollLeft - scrollWidth / numOftabs * this.clickMultiplier, 0);
    }
  }
  handleOverflowNavMouseDown(direction) {
    const tabList = this.headerContainer.nativeElement;
    this.longPressInterval = setTimeout(() => {
      this.renderer.setStyle(tabList, "scroll-behavior", "auto");
      this.tickInterval = setInterval(() => {
        tabList.scrollLeft += direction * this.longPressMultiplier;
        if (this.leftOverflowNavButtonHidden || this.rightOverflowNavButtonHidden) {
          return () => {
            clearInterval(this.tickInterval);
            this.handleOverflowNavMouseUp();
          };
        }
      });
      return () => clearInterval(this.longPressInterval);
    }, 500);
  }
  /**
   * Clear intervals/Timeout & reset scroll behavior
   */
  handleOverflowNavMouseUp() {
    clearInterval(this.tickInterval);
    clearTimeout(this.longPressInterval);
    this.renderer.setStyle(this.headerContainer.nativeElement, "scroll-behavior", "smooth");
  }
};
BaseTabHeader.ɵfac = function BaseTabHeader_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || BaseTabHeader)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(EventService), ɵɵdirectiveInject(Renderer2));
};
BaseTabHeader.ɵcmp = ɵɵdefineComponent({
  type: BaseTabHeader,
  selectors: [["ng-component"]],
  viewQuery: function BaseTabHeader_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c035, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerContainer = _t.first);
    }
  },
  hostVars: 6,
  hostBindings: function BaseTabHeader_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--tabs", ctx.tabsClass)("cds--tabs--contained", ctx.containedClass)("cds--tabs--light", ctx.themeClass);
    }
  },
  inputs: {
    cacheActive: "cacheActive",
    followFocus: "followFocus",
    ariaLabel: "ariaLabel",
    ariaLabelledby: "ariaLabelledby",
    contentBefore: "contentBefore",
    contentAfter: "contentAfter",
    type: "type",
    theme: "theme"
  },
  standalone: false,
  decls: 0,
  vars: 0,
  template: function BaseTabHeader_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseTabHeader, [{
    type: Component,
    args: [{
      template: ""
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: ChangeDetectorRef
    }, {
      type: EventService
    }, {
      type: Renderer2
    }];
  }, {
    cacheActive: [{
      type: Input
    }],
    followFocus: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    ariaLabelledby: [{
      type: Input
    }],
    contentBefore: [{
      type: Input
    }],
    contentAfter: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    theme: [{
      type: Input
    }],
    tabsClass: [{
      type: HostBinding,
      args: ["class.cds--tabs"]
    }],
    containedClass: [{
      type: HostBinding,
      args: ["class.cds--tabs--contained"]
    }],
    themeClass: [{
      type: HostBinding,
      args: ["class.cds--tabs--light"]
    }],
    headerContainer: [{
      type: ViewChild,
      args: ["tabList", {
        static: true
      }]
    }]
  });
})();
var TabHeader = class {
  constructor(host) {
    this.host = host;
    this.active = false;
    this.disabled = false;
    this.type = "button";
    this.ariaSelected = this.active;
    this.ariaDisabled = this.disabled;
    this.navItem = true;
    this.navLink = true;
    this.selected = new EventEmitter();
    this._cacheActive = false;
  }
  get tabIndex() {
    return this.active ? 0 : -1;
  }
  get isSelected() {
    return this.active;
  }
  get isDisabled() {
    return this.disabled;
  }
  /**
   * Set to 'true' to have pane reference cached and not reloaded on tab switching.
   */
  set cacheActive(shouldCache) {
    this._cacheActive = shouldCache;
    if (this.paneReference) {
      this.paneReference.cacheActive = this.cacheActive;
    }
  }
  set paneTabIndex(tabIndex) {
    if (this.paneReference) {
      this.paneReference.tabIndex = tabIndex;
    }
  }
  get cacheActive() {
    return this._cacheActive;
  }
  onClick() {
    this.selectTab();
  }
  ngAfterViewInit() {
    setTimeout(() => {
      this.title = this.title ? this.title : this.host.nativeElement.textContent;
    });
  }
  selectTab() {
    this.focus();
    if (!this.disabled) {
      this.selected.emit();
      this.active = true;
      if (this.paneReference) {
        this.paneReference.active = true;
      }
    }
  }
  focus() {
    this.host.nativeElement.focus();
  }
};
TabHeader.ɵfac = function TabHeader_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TabHeader)(ɵɵdirectiveInject(ElementRef));
};
TabHeader.ɵdir = ɵɵdefineDirective({
  type: TabHeader,
  selectors: [["", "cdsTabHeader", ""], ["", "ibmTabHeader", ""]],
  hostVars: 13,
  hostBindings: function TabHeader_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function TabHeader_click_HostBindingHandler() {
        return ctx.onClick();
      });
    }
    if (rf & 2) {
      ɵɵattribute("tabIndex", ctx.tabIndex)("type", ctx.type)("aria-selected", ctx.ariaSelected)("aria-disabled", ctx.ariaDisabled)("title", ctx.title);
      ɵɵclassProp("cds--tabs__nav-item--selected", ctx.isSelected)("cds--tabs__nav-item--disabled", ctx.isDisabled)("cds--tabs__nav-item", ctx.navItem)("cds--tabs__nav-link", ctx.navLink);
    }
  },
  inputs: {
    cacheActive: "cacheActive",
    paneTabIndex: "paneTabIndex",
    active: "active",
    disabled: "disabled",
    paneReference: "paneReference",
    title: "title"
  },
  outputs: {
    selected: "selected"
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TabHeader, [{
    type: Directive,
    args: [{
      selector: "[cdsTabHeader], [ibmTabHeader]"
    }]
  }], function() {
    return [{
      type: ElementRef
    }];
  }, {
    tabIndex: [{
      type: HostBinding,
      args: ["attr.tabIndex"]
    }],
    isSelected: [{
      type: HostBinding,
      args: ["class.cds--tabs__nav-item--selected"]
    }],
    isDisabled: [{
      type: HostBinding,
      args: ["class.cds--tabs__nav-item--disabled"]
    }],
    cacheActive: [{
      type: Input
    }],
    paneTabIndex: [{
      type: Input
    }],
    active: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    type: [{
      type: HostBinding,
      args: ["attr.type"]
    }],
    ariaSelected: [{
      type: HostBinding,
      args: ["attr.aria-selected"]
    }],
    ariaDisabled: [{
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }],
    navItem: [{
      type: HostBinding,
      args: ["class.cds--tabs__nav-item"]
    }],
    navLink: [{
      type: HostBinding,
      args: ["class.cds--tabs__nav-link"]
    }],
    paneReference: [{
      type: Input
    }],
    title: [{
      type: HostBinding,
      args: ["attr.title"]
    }, {
      type: Input
    }],
    selected: [{
      type: Output
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var TabHeaderGroup = class extends BaseTabHeader {
  constructor(elementRef, changeDetectorRef, eventService, renderer) {
    super(elementRef, changeDetectorRef, eventService, renderer);
    this.elementRef = elementRef;
    this.changeDetectorRef = changeDetectorRef;
    this.eventService = eventService;
    this.renderer = renderer;
    this.isNavigation = false;
    this.selectedSubscriptionTracker = new Subscription();
    this.currentSelectedTab = 0;
  }
  // keyboard accessibility
  /**
   * Controls the keydown events used for tabbing through the headings.
   */
  keyboardInput(event) {
    let tabHeadersArray = this.tabHeaderQuery.toArray();
    if (event.key === "ArrowRight") {
      if (this.currentSelectedTab < tabHeadersArray.length - 1) {
        event.preventDefault();
        if (this.followFocus && !tabHeadersArray[this.currentSelectedTab + 1].disabled) {
          tabHeadersArray[this.currentSelectedTab + 1].selectTab();
        } else {
          tabHeadersArray[this.currentSelectedTab + 1].focus();
          this.currentSelectedTab++;
        }
      } else {
        event.preventDefault();
        if (this.followFocus && !tabHeadersArray[0].disabled) {
          tabHeadersArray[0].selectTab();
        } else {
          tabHeadersArray[0].focus();
          this.currentSelectedTab = 0;
        }
      }
    }
    if (event.key === "ArrowLeft") {
      if (this.currentSelectedTab > 0) {
        event.preventDefault();
        if (this.followFocus && !tabHeadersArray[this.currentSelectedTab - 1].disabled) {
          tabHeadersArray[this.currentSelectedTab - 1].selectTab();
        } else {
          tabHeadersArray[this.currentSelectedTab - 1].focus();
          this.currentSelectedTab--;
        }
      } else {
        event.preventDefault();
        if (this.followFocus && !tabHeadersArray[tabHeadersArray.length - 1].disabled) {
          tabHeadersArray[tabHeadersArray.length - 1].selectTab();
        } else {
          tabHeadersArray[tabHeadersArray.length - 1].focus();
          this.currentSelectedTab = tabHeadersArray.length - 1;
        }
      }
    }
    if (event.key === "Home") {
      event.preventDefault();
      if (this.followFocus && !tabHeadersArray[0].disabled) {
        tabHeadersArray[0].selectTab();
      } else {
        tabHeadersArray[0].focus();
        this.currentSelectedTab = 0;
      }
    }
    if (event.key === "End") {
      event.preventDefault();
      if (this.followFocus && !tabHeadersArray[tabHeadersArray.length - 1].disabled) {
        tabHeadersArray[tabHeadersArray.length - 1].selectTab();
      } else {
        tabHeadersArray[tabHeadersArray.length - 1].focus();
        this.currentSelectedTab = tabHeadersArray.length - 1;
      }
    }
    if (event.key === " " && !this.followFocus) {
      tabHeadersArray[this.currentSelectedTab].selectTab();
    }
  }
  ngOnInit() {
    this.eventService.on(window, "resize", () => this.handleScroll());
  }
  ngAfterContentInit() {
    this.selectedSubscriptionTracker.unsubscribe();
    if (this.tabHeaderQuery) {
      this.tabHeaderQuery.toArray().forEach((tabHeader) => {
        tabHeader.cacheActive = this.cacheActive;
        tabHeader.paneTabIndex = this.isNavigation ? null : 0;
      });
    }
    const selectedSubscriptions = this.tabHeaderQuery.toArray().forEach((tabHeader) => {
      tabHeader.selected.subscribe(() => {
        this.currentSelectedTab = this.tabHeaderQuery.toArray().indexOf(tabHeader);
        this.tabHeaderQuery.toArray().filter((header) => header !== tabHeader).forEach((filteredHeader) => {
          filteredHeader.active = false;
          if (filteredHeader.paneReference) {
            filteredHeader.paneReference.active = false;
          }
        });
      });
    });
    this.selectedSubscriptionTracker.add(selectedSubscriptions);
    setTimeout(() => this.tabHeaderQuery.toArray()[this.currentSelectedTab].selectTab());
  }
  ngOnChanges(changes) {
    if (this.tabHeaderQuery) {
      if (changes.cacheActive) {
        this.tabHeaderQuery.toArray().forEach((tabHeader) => tabHeader.cacheActive = this.cacheActive);
      }
      if (changes.isNavigation) {
        this.tabHeaderQuery.toArray().forEach((tabHeader) => tabHeader.paneTabIndex = this.isNavigation ? null : 0);
      }
    }
  }
  getSelectedTab() {
    const selected = this.tabHeaderQuery.toArray()[this.currentSelectedTab];
    if (selected) {
      return selected;
    }
    return {
      headingIsTemplate: false,
      heading: ""
    };
  }
};
TabHeaderGroup.ɵfac = function TabHeaderGroup_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TabHeaderGroup)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(EventService), ɵɵdirectiveInject(Renderer2));
};
TabHeaderGroup.ɵcmp = ɵɵdefineComponent({
  type: TabHeaderGroup,
  selectors: [["cds-tab-header-group"], ["ibm-tab-header-group"]],
  contentQueries: function TabHeaderGroup_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, TabHeader, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tabHeaderQuery = _t);
    }
  },
  viewQuery: function TabHeaderGroup_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c035, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerContainer = _t.first);
    }
  },
  hostBindings: function TabHeaderGroup_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("keydown", function TabHeaderGroup_keydown_HostBindingHandler($event) {
        return ctx.keyboardInput($event);
      });
    }
  },
  inputs: {
    isNavigation: "isNavigation"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
  ngContentSelectors: _c135,
  decls: 11,
  vars: 9,
  consts: [["tabList", ""], ["type", "button", 1, "cds--tab--overflow-nav-button", "cds--tab--overflow-nav-button--previous", 3, "click", "pointerdown", "pointerup", "pointerleave", "pointerout", "pointercancel", "ngClass"], ["focusable", "false", "preserveAspectRatio", "xMidYMid meet", "xmlns", "http://www.w3.org/2000/svg", "fill", "currentColor", "width", "16", "height", "16", "viewBox", "0 0 16 16", "aria-hidden", "true"], ["d", "M5 8L10 3 10.7 3.7 6.4 8 10.7 12.3 10 13z"], ["role", "tablist", 1, "cds--tab--list", 3, "scroll"], [3, "ngTemplateOutlet"], ["type", "button", 1, "cds--tab--overflow-nav-button", "cds--tab--overflow-nav-button--next", 3, "click", "pointerdown", "pointerup", "pointerleave", "pointerout", "pointercancel", "ngClass"], ["d", "M11 8L6 13 5.3 12.3 9.6 8 5.3 3.7 6 3z"]],
  template: function TabHeaderGroup_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵprojectionDef();
      ɵɵelementStart(0, "button", 1);
      ɵɵlistener("click", function TabHeaderGroup_Template_button_click_0_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.handleOverflowNavClick(-1, ctx.tabHeaderQuery.length));
      })("pointerdown", function TabHeaderGroup_Template_button_pointerdown_0_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.handleOverflowNavMouseDown(-1));
      })("pointerup", function TabHeaderGroup_Template_button_pointerup_0_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.handleOverflowNavMouseUp());
      })("pointerleave", function TabHeaderGroup_Template_button_pointerleave_0_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.handleOverflowNavMouseUp());
      })("pointerout", function TabHeaderGroup_Template_button_pointerout_0_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.handleOverflowNavMouseUp());
      })("pointercancel", function TabHeaderGroup_Template_button_pointercancel_0_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.handleOverflowNavMouseUp());
      });
      ɵɵnamespaceSVG();
      ɵɵelementStart(1, "svg", 2);
      ɵɵelement(2, "path", 3);
      ɵɵelementEnd()();
      ɵɵnamespaceHTML();
      ɵɵelementStart(3, "div", 4, 0);
      ɵɵlistener("scroll", function TabHeaderGroup_Template_div_scroll_3_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.handleScroll());
      });
      ɵɵelementContainer(5, 5);
      ɵɵprojection(6);
      ɵɵelementContainer(7, 5);
      ɵɵelementEnd();
      ɵɵelementStart(8, "button", 6);
      ɵɵlistener("click", function TabHeaderGroup_Template_button_click_8_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.handleOverflowNavClick(1, ctx.tabHeaderQuery.length));
      })("pointerdown", function TabHeaderGroup_Template_button_pointerdown_8_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.handleOverflowNavMouseDown(1));
      })("pointerup", function TabHeaderGroup_Template_button_pointerup_8_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.handleOverflowNavMouseUp());
      })("pointerleave", function TabHeaderGroup_Template_button_pointerleave_8_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.handleOverflowNavMouseUp());
      })("pointerout", function TabHeaderGroup_Template_button_pointerout_8_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.handleOverflowNavMouseUp());
      })("pointercancel", function TabHeaderGroup_Template_button_pointercancel_8_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.handleOverflowNavMouseUp());
      });
      ɵɵnamespaceSVG();
      ɵɵelementStart(9, "svg", 2);
      ɵɵelement(10, "path", 7);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵproperty("ngClass", ɵɵpureFunction1(5, _c227, ctx.leftOverflowNavButtonHidden));
      ɵɵadvance(3);
      ɵɵattribute("aria-label", ctx.ariaLabel);
      ɵɵadvance(2);
      ɵɵproperty("ngTemplateOutlet", ctx.contentBefore);
      ɵɵadvance(2);
      ɵɵproperty("ngTemplateOutlet", ctx.contentAfter);
      ɵɵadvance();
      ɵɵproperty("ngClass", ɵɵpureFunction1(7, _c227, ctx.rightOverflowNavButtonHidden));
    }
  },
  dependencies: [NgClass, NgTemplateOutlet],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TabHeaderGroup, [{
    type: Component,
    args: [{
      selector: "cds-tab-header-group, ibm-tab-header-group",
      template: `
		<button
			type="button"
			class="cds--tab--overflow-nav-button cds--tab--overflow-nav-button--previous"
			[ngClass]="{
				'cds--tab--overflow-nav-button--hidden': leftOverflowNavButtonHidden
			}"
			(click)="handleOverflowNavClick(-1, tabHeaderQuery.length)"
			(pointerdown)="handleOverflowNavMouseDown(-1)"
			(pointerup)="handleOverflowNavMouseUp()"
			(pointerleave)="handleOverflowNavMouseUp()"
			(pointerout)="handleOverflowNavMouseUp()"
			(pointercancel)="handleOverflowNavMouseUp()">
			<svg
				focusable="false"
				preserveAspectRatio="xMidYMid meet"
				xmlns="http://www.w3.org/2000/svg"
				fill="currentColor"
				width="16"
				height="16"
				viewBox="0 0 16 16"
				aria-hidden="true">
				<path d="M5 8L10 3 10.7 3.7 6.4 8 10.7 12.3 10 13z"></path>
			</svg>
		</button>
		<div
			class="cds--tab--list"
			role="tablist"
			[attr.aria-label]="ariaLabel"
			(scroll)="handleScroll()"
			#tabList>
			<ng-container [ngTemplateOutlet]="contentBefore"></ng-container>
			<ng-content></ng-content>
			<ng-container [ngTemplateOutlet]="contentAfter"></ng-container>
		</div>
		<button
			type="button"
			class="cds--tab--overflow-nav-button cds--tab--overflow-nav-button--next"
			[ngClass]="{
				'cds--tab--overflow-nav-button--hidden': rightOverflowNavButtonHidden
			}"
			(click)="handleOverflowNavClick(1, tabHeaderQuery.length)"
			(pointerdown)="handleOverflowNavMouseDown(1)"
			(pointerup)="handleOverflowNavMouseUp()"
			(pointerleave)="handleOverflowNavMouseUp()"
			(pointerout)="handleOverflowNavMouseUp()"
			(pointercancel)="handleOverflowNavMouseUp()">
			<svg
				focusable="false"
				preserveAspectRatio="xMidYMid meet"
				xmlns="http://www.w3.org/2000/svg"
				fill="currentColor"
				width="16"
				height="16"
				viewBox="0 0 16 16"
				aria-hidden="true">
				<path d="M11 8L6 13 5.3 12.3 9.6 8 5.3 3.7 6 3z"></path>
			</svg>
		</button>
	`
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: ChangeDetectorRef
    }, {
      type: EventService
    }, {
      type: Renderer2
    }];
  }, {
    isNavigation: [{
      type: Input
    }],
    tabHeaderQuery: [{
      type: ContentChildren,
      args: [TabHeader]
    }],
    headerContainer: [{
      type: ViewChild,
      args: ["tabList", {
        static: true
      }]
    }],
    keyboardInput: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }]
  });
})();
var Tab = class _Tab {
  constructor() {
    this.headingIsTemplate = false;
    this.active = false;
    this.disabled = false;
    this.tabIndex = 0;
    this.id = `n-tab-${_Tab.counter++}`;
    this.selected = new EventEmitter();
    this.attrClass = this.id;
    this._cacheActive = false;
  }
  /**
   * Set to true to have Tab items cached and not reloaded on tab switching.
   */
  set cacheActive(shouldCache) {
    this._cacheActive = shouldCache;
  }
  get cacheActive() {
    return this._cacheActive;
  }
  /**
   * Checks for custom heading template on initialization and updates the value
   * of the boolean 'headingIsTemplate'.
   */
  ngOnInit() {
    if (this.heading instanceof TemplateRef) {
      this.headingIsTemplate = true;
    }
  }
  /**
   * Emit the status of the `Tab`, specifically 'select' and 'selected' properties.
   */
  doSelect() {
    this.selected.emit();
  }
  /**
  * Returns value indicating whether this `Tab` should be rendered in a `TabPanel`.
  */
  shouldRender() {
    return this.active || this.cacheActive;
  }
  isTemplate(value) {
    return value instanceof TemplateRef;
  }
};
Tab.counter = 0;
Tab.ɵfac = function Tab_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Tab)();
};
Tab.ɵcmp = ɵɵdefineComponent({
  type: Tab,
  selectors: [["cds-tab"], ["ibm-tab"]],
  hostVars: 1,
  hostBindings: function Tab_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("id", ctx.attrClass);
    }
  },
  inputs: {
    heading: "heading",
    title: "title",
    context: "context",
    active: "active",
    disabled: "disabled",
    tabIndex: "tabIndex",
    id: "id",
    cacheActive: "cacheActive",
    tabContent: "tabContent",
    templateContext: "templateContext"
  },
  outputs: {
    selected: "selected"
  },
  standalone: false,
  ngContentSelectors: _c135,
  decls: 1,
  vars: 1,
  consts: [["role", "tabpanel", "class", "cds--tab-content", "aria-live", "polite", 3, "ngStyle", 4, "ngIf"], ["role", "tabpanel", "aria-live", "polite", 1, "cds--tab-content", 3, "ngStyle"], [4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
  template: function Tab_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, Tab_div_0_Template, 3, 6, "div", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.shouldRender());
    }
  },
  dependencies: [NgIf, NgTemplateOutlet, NgStyle],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Tab, [{
    type: Component,
    args: [{
      selector: "cds-tab, ibm-tab",
      template: `
		<div
			[attr.tabindex]="tabIndex"
			role="tabpanel"
			*ngIf="shouldRender()"
			class="cds--tab-content"
			[ngStyle]="{'display': active ? null : 'none'}"
			[attr.aria-labelledby]="id + '-header'"
			aria-live="polite">
			<ng-template
				*ngIf="isTemplate(tabContent)"
				[ngTemplateOutlet]="tabContent"
				[ngTemplateOutletContext]="{ $implicit: templateContext }">
			</ng-template>
			<ng-content></ng-content>
		</div>
	`
    }]
  }], null, {
    heading: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    context: [{
      type: Input
    }],
    active: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    cacheActive: [{
      type: Input
    }],
    tabContent: [{
      type: Input
    }],
    templateContext: [{
      type: Input
    }],
    selected: [{
      type: Output
    }],
    attrClass: [{
      type: HostBinding,
      args: ["attr.id"]
    }]
  });
})();
var TabHeaders = class extends BaseTabHeader {
  constructor(elementRef, changeDetectorRef, eventService, renderer, i18n) {
    super(elementRef, changeDetectorRef, eventService, renderer);
    this.elementRef = elementRef;
    this.changeDetectorRef = changeDetectorRef;
    this.eventService = eventService;
    this.renderer = renderer;
    this.i18n = i18n;
    this.translations = this.i18n.get().TABS;
    this.firstVisibleTab = 0;
  }
  // keyboard accessibility
  /**
   * Controls the keydown events used for tabbing through the headings.
   */
  keyboardInput(event) {
    let tabsArray = this.tabs.toArray();
    if (event.key === "ArrowRight") {
      if (this.currentSelectedTab < this.allTabHeaders.length - 1) {
        event.preventDefault();
        if (this.followFocus) {
          this.selectTab(event.target, tabsArray[this.currentSelectedTab + 1], this.currentSelectedTab);
        }
        this.allTabHeaders.toArray()[this.currentSelectedTab + 1].nativeElement.focus();
      } else {
        event.preventDefault();
        if (this.followFocus) {
          this.selectTab(event.target, tabsArray[0], 0);
        }
        this.allTabHeaders.first.nativeElement.focus();
      }
    }
    if (event.key === "ArrowLeft") {
      if (this.currentSelectedTab > 0) {
        event.preventDefault();
        if (this.followFocus) {
          this.selectTab(event.target, tabsArray[this.currentSelectedTab - 1], this.currentSelectedTab);
        }
        this.allTabHeaders.toArray()[this.currentSelectedTab - 1].nativeElement.focus();
      } else {
        event.preventDefault();
        if (this.followFocus) {
          this.selectTab(event.target, tabsArray[this.allTabHeaders.length - 1], this.allTabHeaders.length);
        }
        this.allTabHeaders.toArray()[this.allTabHeaders.length - 1].nativeElement.focus();
      }
    }
    if (event.key === "Home") {
      event.preventDefault();
      if (this.followFocus) {
        this.selectTab(event.target, tabsArray[0], 0);
      }
      this.allTabHeaders.toArray()[0].nativeElement.focus();
    }
    if (event.key === "End") {
      event.preventDefault();
      if (this.followFocus) {
        this.selectTab(event.target, tabsArray[this.allTabHeaders.length - 1], this.allTabHeaders.length);
      }
      this.allTabHeaders.toArray()[this.allTabHeaders.length - 1].nativeElement.focus();
    }
    if ((event.key === " " || event.key === "Spacebar") && !this.followFocus) {
      this.selectTab(event.target, tabsArray[this.currentSelectedTab], this.currentSelectedTab);
    }
  }
  ngOnInit() {
    this.resizeObserver = new ResizeObserver(() => {
      this.changeDetectorRef.detectChanges();
    });
    this.resizeObserver.observe(this.headerContainer.nativeElement);
  }
  ngOnDestroy() {
    this.resizeObserver.unobserve(this.headerContainer.nativeElement);
  }
  ngAfterContentInit() {
    if (!this.tabInput) {
      this.tabs = this.tabQuery;
    } else {
      this.tabs = this.tabInput;
    }
    this.tabs.forEach((tab) => tab.cacheActive = this.cacheActive);
    this.tabs.changes.subscribe(() => {
      this.setFirstTab();
    });
    this.setFirstTab();
  }
  ngOnChanges(changes) {
    if (this.tabs && changes.cacheActive) {
      this.tabs.forEach((tab) => tab.cacheActive = this.cacheActive);
    }
  }
  /**
   * Controls manually focusing tabs.
   */
  onTabFocus(ref, index) {
    this.currentSelectedTab = index;
    this.headerContainer.nativeElement.parentElement.scrollLeft = 0;
  }
  getSelectedTab() {
    const selected = this.tabs.find((tab) => tab.active);
    if (selected) {
      return selected;
    }
    return {
      headingIsTemplate: false,
      heading: ""
    };
  }
  /**
   * Selects `Tab` 'tab' and moves it into view on the view DOM if it is not already.
   */
  selectTab(ref, tab, tabIndex) {
    if (tab.disabled) {
      return;
    }
    this.currentSelectedTab = tabIndex;
    this.tabs.forEach((_tab) => _tab.active = false);
    tab.active = true;
    tab.doSelect();
  }
  /**
   * Determines which `Tab` is initially selected.
   */
  setFirstTab() {
    setTimeout(() => {
      let firstTab = this.tabs.find((tab) => tab.active);
      if (!firstTab && this.tabs.first) {
        firstTab = this.tabs.first;
        firstTab.active = true;
      }
      if (firstTab) {
        firstTab.doSelect();
      }
    });
  }
};
TabHeaders.ɵfac = function TabHeaders_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TabHeaders)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(EventService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(I18n));
};
TabHeaders.ɵcmp = ɵɵdefineComponent({
  type: TabHeaders,
  selectors: [["cds-tab-headers"], ["ibm-tab-headers"]],
  contentQueries: function TabHeaders_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, Tab, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tabQuery = _t);
    }
  },
  viewQuery: function TabHeaders_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c035, 7);
      ɵɵviewQuery(_c512, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerContainer = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.allTabHeaders = _t);
    }
  },
  hostBindings: function TabHeaders_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("keydown", function TabHeaders_keydown_HostBindingHandler($event) {
        return ctx.keyboardInput($event);
      });
    }
  },
  inputs: {
    tabInput: [0, "tabs", "tabInput"],
    translations: "translations"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
  decls: 11,
  vars: 12,
  consts: [["tabList", ""], ["tabItem", ""], ["type", "button", 1, "cds--tab--overflow-nav-button", "cds--tab--overflow-nav-button--previous", 3, "click", "pointerdown", "pointerup", "pointerleave", "pointerout", "ngClass", "title"], ["focusable", "false", "preserveAspectRatio", "xMidYMid meet", "xmlns", "http://www.w3.org/2000/svg", "fill", "currentColor", "width", "16", "height", "16", "viewBox", "0 0 16 16", "aria-hidden", "true"], ["d", "M5 8L10 3 10.7 3.7 6.4 8 10.7 12.3 10 13z"], ["role", "tablist", 1, "cds--tab--list", 3, "scroll"], [3, "ngTemplateOutlet"], ["role", "tab", "class", "cds--tabs__nav-item cds--tabs__nav-link", "type", "button", "draggable", "false", 3, "ngClass", "id", "focus", "click", 4, "ngFor", "ngForOf"], ["type", "button", 1, "cds--tab--overflow-nav-button", "cds--tab--overflow-nav-button--next", 3, "click", "pointerdown", "pointerup", "pointerleave", "pointerout", "ngClass", "title"], ["d", "M11 8L6 13 5.3 12.3 9.6 8 5.3 3.7 6 3z"], ["role", "tab", "type", "button", "draggable", "false", 1, "cds--tabs__nav-item", "cds--tabs__nav-link", 3, "focus", "click", "ngClass", "id"], [4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
  template: function TabHeaders_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵelementStart(0, "button", 2);
      ɵɵlistener("click", function TabHeaders_Template_button_click_0_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.handleOverflowNavClick(-1, ctx.tabs.length));
      })("pointerdown", function TabHeaders_Template_button_pointerdown_0_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.handleOverflowNavMouseDown(-1));
      })("pointerup", function TabHeaders_Template_button_pointerup_0_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.handleOverflowNavMouseUp());
      })("pointerleave", function TabHeaders_Template_button_pointerleave_0_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.handleOverflowNavMouseUp());
      })("pointerout", function TabHeaders_Template_button_pointerout_0_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.handleOverflowNavMouseUp());
      });
      ɵɵnamespaceSVG();
      ɵɵelementStart(1, "svg", 3);
      ɵɵelement(2, "path", 4);
      ɵɵelementEnd()();
      ɵɵnamespaceHTML();
      ɵɵelementStart(3, "div", 5, 0);
      ɵɵlistener("scroll", function TabHeaders_Template_div_scroll_3_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.handleScroll());
      });
      ɵɵelementContainer(5, 6);
      ɵɵtemplate(6, TabHeaders_button_6_Template, 4, 12, "button", 7);
      ɵɵelementContainer(7, 6);
      ɵɵelementEnd();
      ɵɵelementStart(8, "button", 8);
      ɵɵlistener("click", function TabHeaders_Template_button_click_8_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.handleOverflowNavClick(1, ctx.tabs.length));
      })("pointerdown", function TabHeaders_Template_button_pointerdown_8_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.handleOverflowNavMouseDown(1));
      })("pointerup", function TabHeaders_Template_button_pointerup_8_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.handleOverflowNavMouseUp());
      })("pointerleave", function TabHeaders_Template_button_pointerleave_8_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.handleOverflowNavMouseUp());
      })("pointerout", function TabHeaders_Template_button_pointerout_8_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.handleOverflowNavMouseUp());
      });
      ɵɵnamespaceSVG();
      ɵɵelementStart(9, "svg", 3);
      ɵɵelement(10, "path", 9);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵproperty("ngClass", ɵɵpureFunction1(8, _c227, ctx.leftOverflowNavButtonHidden))("title", ctx.translations.BUTTON_ARIA_LEFT);
      ɵɵadvance(3);
      ɵɵattribute("aria-label", ctx.ariaLabel || ctx.translations.HEADER_ARIA_LABEL);
      ɵɵadvance(2);
      ɵɵproperty("ngTemplateOutlet", ctx.contentBefore);
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.tabs);
      ɵɵadvance();
      ɵɵproperty("ngTemplateOutlet", ctx.contentAfter);
      ɵɵadvance();
      ɵɵproperty("ngClass", ɵɵpureFunction1(10, _c227, ctx.rightOverflowNavButtonHidden))("title", ctx.translations.BUTTON_ARIA_RIGHT);
    }
  },
  dependencies: [NgClass, NgForOf, NgIf, NgTemplateOutlet],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TabHeaders, [{
    type: Component,
    args: [{
      selector: "cds-tab-headers, ibm-tab-headers",
      template: `
		<button
			type="button"
			(click)="handleOverflowNavClick(-1, tabs.length)"
			(pointerdown)="handleOverflowNavMouseDown(-1)"
			(pointerup)="handleOverflowNavMouseUp()"
			(pointerleave)="handleOverflowNavMouseUp()"
			(pointerout)="handleOverflowNavMouseUp()"
			class="cds--tab--overflow-nav-button cds--tab--overflow-nav-button--previous"
			[ngClass]="{
				'cds--tab--overflow-nav-button--hidden': leftOverflowNavButtonHidden
			}"
			[title]="translations.BUTTON_ARIA_LEFT">
			<svg
				focusable="false"
				preserveAspectRatio="xMidYMid meet"
				xmlns="http://www.w3.org/2000/svg"
				fill="currentColor"
				width="16"
				height="16"
				viewBox="0 0 16 16"
				aria-hidden="true">
				<path d="M5 8L10 3 10.7 3.7 6.4 8 10.7 12.3 10 13z"></path>
			</svg>
		</button>
		<div
			#tabList
			class="cds--tab--list"
			role="tablist"
			[attr.aria-label]="ariaLabel || translations.HEADER_ARIA_LABEL"
			(scroll)="handleScroll()">
			<ng-container [ngTemplateOutlet]="contentBefore"></ng-container>
			<button
				*ngFor="let tab of tabs; let i = index;"
				#tabItem
				role="tab"
				[attr.aria-selected]="tab.active"
				[attr.tabindex]="(tab.active?0:-1)"
				[attr.aria-controls]="tab.id"
				[attr.aria-disabled]="tab.disabled"
				[ngClass]="{
					'cds--tabs__nav-item--selected': tab.active,
					'cds--tabs__nav-item--disabled': tab.disabled
				}"
				class="cds--tabs__nav-item cds--tabs__nav-link"
				type="button"
				draggable="false"
				id="{{tab.id}}-header"
				(focus)="onTabFocus(tabItem, i)"
				(click)="selectTab(tabItem, tab, i)">
				<ng-container *ngIf="!tab.headingIsTemplate">
					{{ tab.heading }}
				</ng-container>
				<ng-template
					*ngIf="tab.headingIsTemplate"
					[ngTemplateOutlet]="tab.heading"
					[ngTemplateOutletContext]="{$implicit: tab.context}">
				</ng-template>
			</button>
			<ng-container [ngTemplateOutlet]="contentAfter"></ng-container>
		</div>
		<button
			type="button"
			(click)="handleOverflowNavClick(1, tabs.length)"
			(pointerdown)="handleOverflowNavMouseDown(1)"
			(pointerup)="handleOverflowNavMouseUp()"
			(pointerleave)="handleOverflowNavMouseUp()"
			(pointerout)="handleOverflowNavMouseUp()"
			class="cds--tab--overflow-nav-button cds--tab--overflow-nav-button--next"
			[ngClass]="{
				'cds--tab--overflow-nav-button--hidden': rightOverflowNavButtonHidden
			}"
			[title]="translations.BUTTON_ARIA_RIGHT">
			<svg
				focusable="false"
				preserveAspectRatio="xMidYMid meet"
				xmlns="http://www.w3.org/2000/svg"
				fill="currentColor"
				width="16"
				height="16"
				viewBox="0 0 16 16"
				aria-hidden="true">
				<path d="M11 8L6 13 5.3 12.3 9.6 8 5.3 3.7 6 3z"></path>
			</svg>
		</button>
	`
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: ChangeDetectorRef
    }, {
      type: EventService
    }, {
      type: Renderer2
    }, {
      type: I18n
    }];
  }, {
    tabInput: [{
      type: Input,
      args: ["tabs"]
    }],
    translations: [{
      type: Input
    }],
    headerContainer: [{
      type: ViewChild,
      args: ["tabList", {
        static: true
      }]
    }],
    tabQuery: [{
      type: ContentChildren,
      args: [Tab]
    }],
    allTabHeaders: [{
      type: ViewChildren,
      args: ["tabItem"]
    }],
    keyboardInput: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }]
  });
})();
var TabSkeleton = class {
  constructor() {
    this.skeleton = true;
    this.tabs = true;
    this.numOfSkeletonTabs = new Array(5);
  }
  /**
   * Set number of skeleton tabs to render, default is 5
   */
  set numOftabs(num) {
    this.numOfSkeletonTabs = new Array(num);
  }
};
TabSkeleton.ɵfac = function TabSkeleton_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TabSkeleton)();
};
TabSkeleton.ɵcmp = ɵɵdefineComponent({
  type: TabSkeleton,
  selectors: [["cds-tabs-skeleton"], ["ibm-tabs-skeleton"]],
  hostVars: 4,
  hostBindings: function TabSkeleton_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--skeleton", ctx.skeleton)("cds--tabs", ctx.tabs);
    }
  },
  inputs: {
    numOftabs: "numOftabs"
  },
  standalone: false,
  decls: 2,
  vars: 1,
  consts: [[1, "cds--tabs__nav"], ["class", "cds--tabs__nav-item", 4, "ngFor", "ngForOf"], [1, "cds--tabs__nav-item"], [1, "cds--tabs__nav-link"]],
  template: function TabSkeleton_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "ul", 0);
      ɵɵtemplate(1, TabSkeleton_li_1_Template, 3, 0, "li", 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.numOfSkeletonTabs);
    }
  },
  dependencies: [NgForOf],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TabSkeleton, [{
    type: Component,
    args: [{
      selector: "cds-tabs-skeleton, ibm-tabs-skeleton",
      template: `
		<ul class="cds--tabs__nav">
			<li
				*ngFor="let i of numOfSkeletonTabs"
				class="cds--tabs__nav-item">
				<div class="cds--tabs__nav-link">
					<span></span>
				</div>
			</li>
		</ul>
	`
    }]
  }], null, {
    numOftabs: [{
      type: Input
    }],
    skeleton: [{
      type: HostBinding,
      args: ["class.cds--skeleton"]
    }],
    tabs: [{
      type: HostBinding,
      args: ["class.cds--tabs"]
    }]
  });
})();
var Tabs = class {
  constructor() {
    this.position = "top";
    this.cacheActive = false;
    this.followFocus = true;
    this.isNavigation = false;
    this.type = "line";
    this.theme = "dark";
    this.skeleton = false;
  }
  /**
   * After content is initialized update `Tab`s to cache (if turned on) and set the initial
   * selected Tab item.
   */
  ngAfterContentInit() {
    if (this.tabHeaders) {
      this.tabHeaders.cacheActive = this.cacheActive;
    }
    this.tabs.forEach((tab) => {
      tab.tabIndex = this.isNavigation ? null : 0;
    });
  }
  ngOnChanges(changes) {
    if (this.tabHeaders && changes.cacheActive) {
      this.tabHeaders.cacheActive = this.cacheActive;
    }
    if (this.tabs && changes.isNavigation) {
      this.tabs.forEach((tab) => {
        tab.tabIndex = this.isNavigation ? null : 0;
      });
    }
  }
  /**
   * true if the n-tab's are passed directly to the component as children
   */
  hasTabHeaders() {
    return this.tabs.length > 0;
  }
};
Tabs.ɵfac = function Tabs_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Tabs)();
};
Tabs.ɵcmp = ɵɵdefineComponent({
  type: Tabs,
  selectors: [["cds-tabs"], ["ibm-tabs"]],
  contentQueries: function Tabs_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, TabHeaders, 5);
      ɵɵcontentQuery(dirIndex, Tab, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tabHeaders = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tabs = _t);
    }
  },
  inputs: {
    position: "position",
    cacheActive: "cacheActive",
    followFocus: "followFocus",
    isNavigation: "isNavigation",
    ariaLabel: "ariaLabel",
    ariaLabelledby: "ariaLabelledby",
    type: "type",
    theme: "theme",
    skeleton: "skeleton"
  },
  standalone: false,
  features: [ɵɵNgOnChangesFeature],
  ngContentSelectors: _c86,
  decls: 2,
  vars: 2,
  consts: [["before", ""], ["after", ""], [4, "ngIf"], [3, "theme", "tabs", "followFocus", "cacheActive", "contentBefore", "contentAfter", "ariaLabel", "ariaLabelledby", "type", 4, "ngIf"], [3, "tabs", "cacheActive", "type", 4, "ngIf"], [3, "theme", "tabs", "followFocus", "cacheActive", "contentBefore", "contentAfter", "ariaLabel", "ariaLabelledby", "type"], [3, "tabs", "cacheActive", "type"]],
  template: function Tabs_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c76);
      ɵɵtemplate(0, Tabs_ng_container_0_Template, 2, 0, "ng-container", 2)(1, Tabs_ng_container_1_Template, 8, 2, "ng-container", 2);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.skeleton);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.skeleton);
    }
  },
  dependencies: [NgIf, TabHeaders, TabSkeleton],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Tabs, [{
    type: Component,
    args: [{
      selector: "cds-tabs, ibm-tabs",
      template: `
		<ng-container *ngIf="skeleton">
			<cds-tabs-skeleton></cds-tabs-skeleton>
		</ng-container>
		<ng-container *ngIf="!skeleton">
			<cds-tab-headers
				*ngIf="hasTabHeaders() && position === 'top'"
				[theme]="theme"
				[tabs]="tabs"
				[followFocus]="followFocus"
				[cacheActive]="cacheActive"
				[contentBefore]="before"
				[contentAfter]="after"
				[ariaLabel]="ariaLabel"
				[ariaLabelledby]="ariaLabelledby"
				[type]="type">
			</cds-tab-headers>
			<ng-content></ng-content>
			<ng-template #before>
				<ng-content select="[before]"></ng-content>
			</ng-template>
			<ng-template #after>
				<ng-content select="[after]"></ng-content>
			</ng-template>
			<cds-tab-headers
				*ngIf="hasTabHeaders() && position === 'bottom'"
				[tabs]="tabs"
				[cacheActive]="cacheActive"
				[type]="type">
			</cds-tab-headers>
		</ng-container>
	`
    }]
  }], null, {
    position: [{
      type: Input
    }],
    cacheActive: [{
      type: Input
    }],
    followFocus: [{
      type: Input
    }],
    isNavigation: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    ariaLabelledby: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    theme: [{
      type: Input
    }],
    skeleton: [{
      type: Input
    }],
    tabs: [{
      type: ContentChildren,
      args: [Tab, {
        descendants: false
      }]
    }],
    tabHeaders: [{
      type: ContentChild,
      args: [TabHeaders]
    }]
  });
})();
var TabsModule = class {
};
TabsModule.ɵfac = function TabsModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TabsModule)();
};
TabsModule.ɵmod = ɵɵdefineNgModule({
  type: TabsModule,
  declarations: [BaseTabHeader, Tabs, Tab, TabHeader, TabHeaders, TabHeaderGroup, TabSkeleton],
  imports: [CommonModule, UtilsModule, I18nModule],
  exports: [Tabs, Tab, TabHeader, TabHeaders, TabHeaderGroup, TabSkeleton]
});
TabsModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, UtilsModule, I18nModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TabsModule, [{
    type: NgModule,
    args: [{
      declarations: [BaseTabHeader, Tabs, Tab, TabHeader, TabHeaders, TabHeaderGroup, TabSkeleton],
      exports: [Tabs, Tab, TabHeader, TabHeaders, TabHeaderGroup, TabSkeleton],
      imports: [CommonModule, UtilsModule, I18nModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-tag.mjs
var _c036 = [[["", "cdsTagIcon", ""], ["", "ibmTagIcon", ""]], "*"];
var _c136 = ["[cdsTagIcon],[ibmTagIcon]", "*"];
function Tag_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵprojection(1);
    ɵɵelementStart(2, "span", 1);
    ɵɵprojection(3, 1);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
}
function TagFilter_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵprojection(1);
    ɵɵelementStart(2, "span", 1);
    ɵɵlistener("click", function TagFilter_ng_container_0_Template_span_click_2_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onClick($event));
    });
    ɵɵprojection(3, 1);
    ɵɵelementEnd();
    ɵɵelementStart(4, "button", 2);
    ɵɵlistener("click", function TagFilter_ng_container_0_Template_button_click_4_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onClose($event));
    });
    ɵɵelementStart(5, "span", 3);
    ɵɵtext(6);
    ɵɵelementEnd();
    ɵɵnamespaceSVG();
    ɵɵelement(7, "svg", 4);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵattribute("title", ctx_r1.title ? ctx_r1.title : null);
    ɵɵadvance(2);
    ɵɵproperty("disabled", ctx_r1.disabled)("title", ctx_r1.closeButtonLabel);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r1.closeButtonLabel);
  }
}
function TagSelectableComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵprojection(1);
    ɵɵelementStart(2, "span", 1);
    ɵɵprojection(3, 1);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
}
function TagOperationalComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵprojection(1);
    ɵɵelementStart(2, "span", 1);
    ɵɵprojection(3, 1);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
}
var Tag = class {
  constructor() {
    this.type = "gray";
    this.size = "md";
    this.class = "";
    this.skeleton = false;
  }
  /**
   * @todo
   * Remove `cds--tag--${this.size}` in v7
   */
  get attrClass() {
    const skeletonClass = this.skeleton ? "cds--skeleton" : "";
    const sizeClass = `cds--tag--${this.size} cds--layout--size-${this.size}`;
    return `cds--tag cds--tag--${this.type} ${sizeClass} ${skeletonClass} ${this.class}`;
  }
};
Tag.ɵfac = function Tag_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Tag)();
};
Tag.ɵcmp = ɵɵdefineComponent({
  type: Tag,
  selectors: [["cds-tag"], ["ibm-tag"]],
  hostVars: 1,
  hostBindings: function Tag_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("class", ctx.attrClass);
    }
  },
  inputs: {
    type: "type",
    size: "size",
    class: "class",
    skeleton: "skeleton"
  },
  standalone: false,
  ngContentSelectors: _c136,
  decls: 1,
  vars: 1,
  consts: [[4, "ngIf"], [1, "cds--tag__label"]],
  template: function Tag_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c036);
      ɵɵtemplate(0, Tag_ng_container_0_Template, 4, 0, "ng-container", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", !ctx.skeleton);
    }
  },
  dependencies: [NgIf],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Tag, [{
    type: Component,
    args: [{
      selector: "cds-tag, ibm-tag",
      template: `
		<ng-container *ngIf="!skeleton">
			<ng-content select="[cdsTagIcon],[ibmTagIcon]"></ng-content>
			<span class="cds--tag__label">
				<ng-content></ng-content>
			</span>
		</ng-container>
	`
    }]
  }], null, {
    type: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    class: [{
      type: Input
    }],
    skeleton: [{
      type: Input
    }],
    attrClass: [{
      type: HostBinding,
      args: ["attr.class"]
    }]
  });
})();
var TagFilter = class extends Tag {
  constructor() {
    super(...arguments);
    this.closeButtonLabel = "Clear Filter";
    this.disabled = false;
    this.close = new EventEmitter();
    this.click = new EventEmitter();
  }
  onClick(event) {
    event.stopImmediatePropagation();
    if (!this.disabled) {
      this.click.emit({
        action: "click"
      });
    }
  }
  onClose(event) {
    event.stopImmediatePropagation();
    this.click.emit({
      action: "close"
    });
    this.close.emit();
  }
  /**
   * @todo
   * Remove `cds--tag--${this.size}` in v7
   */
  get attrClass() {
    const disabledClass = this.disabled ? "cds--tag--disabled" : "";
    const sizeClass = `cds--tag--${this.size} cds--layout--size-${this.size}`;
    const skeletonClass = this.skeleton ? "cds--skeleton" : "";
    return `cds--tag cds--tag--filter cds--tag--${this.type} ${disabledClass} ${sizeClass} ${skeletonClass} ${this.class}`;
  }
  get attrAriaLabel() {
    return `${this.title || ""} ${this.closeButtonLabel}`.trim();
  }
};
TagFilter.ɵfac = /* @__PURE__ */ (() => {
  let ɵTagFilter_BaseFactory;
  return function TagFilter_Factory(__ngFactoryType__) {
    return (ɵTagFilter_BaseFactory || (ɵTagFilter_BaseFactory = ɵɵgetInheritedFactory(TagFilter)))(__ngFactoryType__ || TagFilter);
  };
})();
TagFilter.ɵcmp = ɵɵdefineComponent({
  type: TagFilter,
  selectors: [["cds-tag-filter"], ["ibm-tag-filter"]],
  hostVars: 2,
  hostBindings: function TagFilter_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("class", ctx.attrClass)("aria-label", ctx.attrAriaLabel);
    }
  },
  inputs: {
    closeButtonLabel: "closeButtonLabel",
    disabled: "disabled",
    title: "title"
  },
  outputs: {
    close: "close",
    click: "click"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c136,
  decls: 1,
  vars: 1,
  consts: [[4, "ngIf"], [1, "cds--tag__label", 3, "click"], [1, "cds--tag__close-icon", 3, "click", "disabled", "title"], [1, "cds--visually-hidden"], ["cdsIcon", "close", "size", "16"]],
  template: function TagFilter_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c036);
      ɵɵtemplate(0, TagFilter_ng_container_0_Template, 8, 4, "ng-container", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", !ctx.skeleton);
    }
  },
  dependencies: [NgIf, IconDirective],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TagFilter, [{
    type: Component,
    args: [{
      selector: "cds-tag-filter, ibm-tag-filter",
      template: `
		<ng-container *ngIf="!skeleton">
			<ng-content select="[cdsTagIcon],[ibmTagIcon]"></ng-content>
			<span
				class="cds--tag__label"
				[attr.title]="title ? title : null"
				(click)="onClick($event)">
				<ng-content></ng-content>
			</span>
			<button
				class="cds--tag__close-icon"
				(click)="onClose($event)"
				[disabled]="disabled"
				[title]="closeButtonLabel">
				<span class="cds--visually-hidden">{{closeButtonLabel}}</span>
				<svg cdsIcon="close" size="16"></svg>
			</button>
		</ng-container>
	`
    }]
  }], null, {
    closeButtonLabel: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    close: [{
      type: Output
    }],
    click: [{
      type: Output
    }],
    attrClass: [{
      type: HostBinding,
      args: ["attr.class"]
    }],
    attrAriaLabel: [{
      type: HostBinding,
      args: ["attr.aria-label"]
    }]
  });
})();
var TagIconDirective = class {
  constructor() {
    this.tagIcon = true;
  }
};
TagIconDirective.ɵfac = function TagIconDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TagIconDirective)();
};
TagIconDirective.ɵdir = ɵɵdefineDirective({
  type: TagIconDirective,
  selectors: [["", "cdsTagIcon", ""], ["", "ibmTagIcon", ""]],
  hostVars: 2,
  hostBindings: function TagIconDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--tag__custom-icon", ctx.tagIcon);
    }
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TagIconDirective, [{
    type: Directive,
    args: [{
      selector: "[cdsTagIcon], [ibmTagIcon]"
    }]
  }], null, {
    tagIcon: [{
      type: HostBinding,
      args: ["class.cds--tag__custom-icon"]
    }]
  });
})();
var TagSelectableComponent = class {
  constructor() {
    this.role = "button";
    this.buttonType = "button";
    this.tabIndex = 0;
    this.size = "md";
    this.skeleton = false;
    this.disabled = false;
    this.class = "";
    this.selected = false;
    this.selectedChange = new EventEmitter();
  }
  get ariaPressed() {
    return this.selected;
  }
  onClick() {
    this.selected = !this.selected;
    this.selectedChange.emit(this.selected);
  }
  /**
   * @todo
   * Remove `cds--tag--${this.size}` in v7
   */
  get attrClass() {
    const disabledClass = this.disabled ? "cds--tag--disabled" : "";
    const sizeClass = `cds--tag--${this.size} cds--layout--size-${this.size}`;
    const skeletonClass = this.skeleton ? "cds--skeleton" : "";
    const selectedClass = this.selected ? "cds--tag--selectable-selected" : "";
    return `cds--tag cds--tag--selectable ${selectedClass} ${disabledClass} ${sizeClass} ${skeletonClass} ${this.class}`;
  }
};
TagSelectableComponent.ɵfac = function TagSelectableComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TagSelectableComponent)();
};
TagSelectableComponent.ɵcmp = ɵɵdefineComponent({
  type: TagSelectableComponent,
  selectors: [["cds-tag-selectable"], ["ibm-tag-selectable"]],
  hostVars: 5,
  hostBindings: function TagSelectableComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function TagSelectableComponent_click_HostBindingHandler() {
        return ctx.onClick();
      });
    }
    if (rf & 2) {
      ɵɵattribute("role", ctx.role)("type", ctx.buttonType)("tabindex", ctx.tabIndex)("aria-pressed", ctx.ariaPressed)("class", ctx.attrClass);
    }
  },
  inputs: {
    size: "size",
    skeleton: "skeleton",
    disabled: "disabled",
    class: "class",
    selected: "selected"
  },
  outputs: {
    selectedChange: "selectedChange"
  },
  standalone: false,
  ngContentSelectors: _c136,
  decls: 1,
  vars: 1,
  consts: [[4, "ngIf"], [1, "cds--tag__label"]],
  template: function TagSelectableComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c036);
      ɵɵtemplate(0, TagSelectableComponent_ng_container_0_Template, 4, 0, "ng-container", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", !ctx.skeleton);
    }
  },
  dependencies: [NgIf],
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TagSelectableComponent, [{
    type: Component,
    args: [{
      selector: "cds-tag-selectable, ibm-tag-selectable",
      template: `
		<ng-container *ngIf="!skeleton">
			<ng-content select="[cdsTagIcon],[ibmTagIcon]"></ng-content>
			<span class="cds--tag__label">
				<ng-content></ng-content>
			</span>
		</ng-container>
	`,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    buttonType: [{
      type: HostBinding,
      args: ["attr.type"]
    }],
    tabIndex: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    ariaPressed: [{
      type: HostBinding,
      args: ["attr.aria-pressed"]
    }],
    size: [{
      type: Input
    }],
    skeleton: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    class: [{
      type: Input
    }],
    selected: [{
      type: Input
    }],
    selectedChange: [{
      type: Output
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }],
    attrClass: [{
      type: HostBinding,
      args: ["attr.class"]
    }]
  });
})();
var TagOperationalComponent = class extends Tag {
  constructor() {
    super(...arguments);
    this.role = "button";
    this.buttonType = "button";
    this.tabIndex = 0;
    this.disabled = false;
  }
  /**
   * @todo
   * Remove `cds--tag--${this.size}` in v7
   */
  get attrClass() {
    const disabledClass = this.disabled ? "cds--tag--disabled" : "";
    const sizeClass = `cds--tag--${this.size} cds--layout--size-${this.size}`;
    const skeletonClass = this.skeleton ? "cds--skeleton" : "";
    return `cds--tag cds--tag--operational cds--tag--${this.type} ${disabledClass} ${sizeClass} ${skeletonClass} ${this.class}`;
  }
};
TagOperationalComponent.ɵfac = /* @__PURE__ */ (() => {
  let ɵTagOperationalComponent_BaseFactory;
  return function TagOperationalComponent_Factory(__ngFactoryType__) {
    return (ɵTagOperationalComponent_BaseFactory || (ɵTagOperationalComponent_BaseFactory = ɵɵgetInheritedFactory(TagOperationalComponent)))(__ngFactoryType__ || TagOperationalComponent);
  };
})();
TagOperationalComponent.ɵcmp = ɵɵdefineComponent({
  type: TagOperationalComponent,
  selectors: [["cds-tag-operational"], ["ibm-tag-operational"]],
  hostVars: 4,
  hostBindings: function TagOperationalComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", ctx.role)("type", ctx.buttonType)("tabindex", ctx.tabIndex)("class", ctx.attrClass);
    }
  },
  inputs: {
    disabled: "disabled"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c136,
  decls: 1,
  vars: 1,
  consts: [[4, "ngIf"], [1, "cds--tag__label"]],
  template: function TagOperationalComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c036);
      ɵɵtemplate(0, TagOperationalComponent_ng_container_0_Template, 4, 0, "ng-container", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", !ctx.skeleton);
    }
  },
  dependencies: [NgIf],
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TagOperationalComponent, [{
    type: Component,
    args: [{
      selector: "cds-tag-operational, ibm-tag-operational",
      template: `
		<ng-container *ngIf="!skeleton">
			<ng-content select="[cdsTagIcon],[ibmTagIcon]"></ng-content>
			<span class="cds--tag__label">
				<ng-content></ng-content>
			</span>
		</ng-container>
	`,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    buttonType: [{
      type: HostBinding,
      args: ["attr.type"]
    }],
    tabIndex: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    disabled: [{
      type: Input
    }],
    attrClass: [{
      type: HostBinding,
      args: ["attr.class"]
    }]
  });
})();
var TagModule = class {
};
TagModule.ɵfac = function TagModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TagModule)();
};
TagModule.ɵmod = ɵɵdefineNgModule({
  type: TagModule,
  declarations: [Tag, TagFilter, TagIconDirective, TagSelectableComponent, TagOperationalComponent],
  imports: [CommonModule, IconModule],
  exports: [Tag, TagFilter, TagIconDirective, TagSelectableComponent, TagOperationalComponent]
});
TagModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, IconModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TagModule, [{
    type: NgModule,
    args: [{
      declarations: [Tag, TagFilter, TagIconDirective, TagSelectableComponent, TagOperationalComponent],
      exports: [Tag, TagFilter, TagIconDirective, TagSelectableComponent, TagOperationalComponent],
      imports: [CommonModule, IconModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-theme.mjs
var ThemeDirective = class {
  constructor() {
    this.cdsTheme = "white";
    this.layerClass = true;
  }
  /**
   * @deprecated as of v5 - Use `cdsTheme` input property instead
   */
  set ibmTheme(type) {
    this.cdsTheme = type;
  }
  /**
   * Using host bindings with classes to ensure we do not
   * overwrite user added classes
   */
  get whiteThemeClass() {
    return this.cdsTheme === "white" || !this.cdsTheme;
  }
  get g10ThemeClass() {
    return this.cdsTheme === "g10";
  }
  get g90ThemeClass() {
    return this.cdsTheme === "g90";
  }
  get g100ThemeClass() {
    return this.cdsTheme === "g100";
  }
  ngAfterContentChecked() {
    this.layerChildren.toArray().forEach((layer) => {
      if (typeof layer.cdsLayer !== "number") {
        layer.cdsLayer = 1;
      }
    });
  }
};
ThemeDirective.ɵfac = function ThemeDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ThemeDirective)();
};
ThemeDirective.ɵdir = ɵɵdefineDirective({
  type: ThemeDirective,
  selectors: [["", "cdsTheme", ""], ["", "ibmTheme", ""]],
  contentQueries: function ThemeDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, LayerDirective, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.layerChildren = _t);
    }
  },
  hostVars: 10,
  hostBindings: function ThemeDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--white", ctx.whiteThemeClass)("cds--g10", ctx.g10ThemeClass)("cds--g90", ctx.g90ThemeClass)("cds--g100", ctx.g100ThemeClass)("cds--layer-one", ctx.layerClass);
    }
  },
  inputs: {
    ibmTheme: "ibmTheme",
    cdsTheme: "cdsTheme"
  },
  exportAs: ["theme"],
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThemeDirective, [{
    type: Directive,
    args: [{
      selector: "[cdsTheme], [ibmTheme]",
      exportAs: "theme"
    }]
  }], null, {
    ibmTheme: [{
      type: Input
    }],
    cdsTheme: [{
      type: Input
    }],
    layerChildren: [{
      type: ContentChildren,
      args: [LayerDirective, {
        descendants: false
      }]
    }],
    whiteThemeClass: [{
      type: HostBinding,
      args: ["class.cds--white"]
    }],
    g10ThemeClass: [{
      type: HostBinding,
      args: ["class.cds--g10"]
    }],
    g90ThemeClass: [{
      type: HostBinding,
      args: ["class.cds--g90"]
    }],
    g100ThemeClass: [{
      type: HostBinding,
      args: ["class.cds--g100"]
    }],
    layerClass: [{
      type: HostBinding,
      args: ["class.cds--layer-one"]
    }]
  });
})();
var ThemeModule = class {
};
ThemeModule.ɵfac = function ThemeModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ThemeModule)();
};
ThemeModule.ɵmod = ɵɵdefineNgModule({
  type: ThemeModule,
  declarations: [ThemeDirective],
  imports: [CommonModule, LayerModule],
  exports: [ThemeDirective]
});
ThemeModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, LayerModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThemeModule, [{
    type: NgModule,
    args: [{
      declarations: [ThemeDirective],
      exports: [ThemeDirective],
      imports: [CommonModule, LayerModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-toggletip.mjs
var _c037 = [[["", "cdsToggletipButton", ""]], [["", "cdsToggletipContent", ""]]];
var _c137 = ["[cdsToggletipButton]", "[cdsToggletipContent]"];
var ToggletipAction = class {
  constructor() {
    this.toggleTipActions = true;
  }
};
ToggletipAction.ɵfac = function ToggletipAction_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ToggletipAction)();
};
ToggletipAction.ɵdir = ɵɵdefineDirective({
  type: ToggletipAction,
  selectors: [["", "cdsToggletipAction", ""], ["", "ibmToggletipAction", ""]],
  hostVars: 2,
  hostBindings: function ToggletipAction_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--toggletip-actions", ctx.toggleTipActions);
    }
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ToggletipAction, [{
    type: Directive,
    args: [{
      selector: "[cdsToggletipAction], [ibmToggletipAction]"
    }]
  }], null, {
    toggleTipActions: [{
      type: HostBinding,
      args: ["class.cds--toggletip-actions"]
    }]
  });
})();
var ToggletipButton = class {
  constructor() {
    this.toggletipButton = true;
    this.toggletipButtonType = "button";
    this.ariaLabel = "Show information";
  }
};
ToggletipButton.ɵfac = function ToggletipButton_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ToggletipButton)();
};
ToggletipButton.ɵdir = ɵɵdefineDirective({
  type: ToggletipButton,
  selectors: [["", "cdsToggletipButton", ""], ["", "ibmToggletipButton", ""]],
  hostVars: 4,
  hostBindings: function ToggletipButton_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("type", ctx.toggletipButtonType)("aria-label", ctx.ariaLabel);
      ɵɵclassProp("cds--toggletip-button", ctx.toggletipButton);
    }
  },
  inputs: {
    ariaLabel: "ariaLabel"
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ToggletipButton, [{
    type: Directive,
    args: [{
      selector: "[cdsToggletipButton], [ibmToggletipButton]"
    }]
  }], null, {
    toggletipButton: [{
      type: HostBinding,
      args: ["class.cds--toggletip-button"]
    }],
    toggletipButtonType: [{
      type: HostBinding,
      args: ["attr.type"]
    }],
    ariaLabel: [{
      type: HostBinding,
      args: ["attr.aria-label"]
    }, {
      type: Input
    }]
  });
})();
var ToggletipContent = class {
  constructor() {
    this.toggletipContent = true;
  }
};
ToggletipContent.ɵfac = function ToggletipContent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ToggletipContent)();
};
ToggletipContent.ɵdir = ɵɵdefineDirective({
  type: ToggletipContent,
  selectors: [["", "cdsToggletipContent", ""], ["", "ibmToggletipContent", ""]],
  hostVars: 2,
  hostBindings: function ToggletipContent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--toggletip-content", ctx.toggletipContent);
    }
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ToggletipContent, [{
    type: Directive,
    args: [{
      selector: "[cdsToggletipContent], [ibmToggletipContent]"
    }]
  }], null, {
    toggletipContent: [{
      type: HostBinding,
      args: ["class.cds--toggletip-content"]
    }]
  });
})();
var ToggletipLabel = class {
  constructor() {
    this.toggleTipLabel = true;
  }
};
ToggletipLabel.ɵfac = function ToggletipLabel_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ToggletipLabel)();
};
ToggletipLabel.ɵdir = ɵɵdefineDirective({
  type: ToggletipLabel,
  selectors: [["", "cdsToggletipLabel", ""], ["", "ibmToggletipLabel", ""]],
  hostVars: 2,
  hostBindings: function ToggletipLabel_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--toggletip-label", ctx.toggleTipLabel);
    }
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ToggletipLabel, [{
    type: Directive,
    args: [{
      selector: "[cdsToggletipLabel], [ibmToggletipLabel]"
    }]
  }], null, {
    toggleTipLabel: [{
      type: HostBinding,
      args: ["class.cds--toggletip-label"]
    }]
  });
})();
var Toggletip = class _Toggletip extends PopoverContainer {
  constructor(hostElement, ngZone, renderer, changeDetectorRef) {
    super(hostElement, ngZone, renderer, changeDetectorRef);
    this.hostElement = hostElement;
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.changeDetectorRef = changeDetectorRef;
    this.id = `tooltip-${_Toggletip.toggletipCounter++}`;
    this.toggletipClass = true;
    this.isOpen = false;
    this.documentClick = this.handleFocusOut.bind(this);
    this.highContrast = true;
    this.dropShadow = false;
  }
  ngAfterViewInit() {
    this.initializeReferences();
    this.subscription = fromEvent(this.btn.nativeElement, "click").subscribe((event) => {
      if (this.isOpen) {
        document.removeEventListener("click", this.documentClick);
      } else {
        document.addEventListener("click", this.documentClick);
      }
      this.handleExpansion(!this.isOpen, event);
    });
    if (this.isOpen) {
      document.addEventListener("click", this.documentClick);
    }
    if (this.btn) {
      this.renderer.setAttribute(this.btn.nativeElement, "aria-controls", this.id);
    }
  }
  hostkeys(event) {
    if (open && event.key === "Escape") {
      event.stopPropagation();
      this.handleExpansion(false, event);
    }
  }
  handleFocusOut(event) {
    if (!this.hostElement.nativeElement.contains(event.target)) {
      this.handleExpansion(false, event);
    }
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
  handleExpansion(state = false, event) {
    this.handleChange(state, event);
    if (this.btn) {
      this.renderer.setAttribute(this.btn.nativeElement, "aria-expanded", this.isOpen.toString());
    }
  }
};
Toggletip.toggletipCounter = 0;
Toggletip.ɵfac = function Toggletip_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Toggletip)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef));
};
Toggletip.ɵcmp = ɵɵdefineComponent({
  type: Toggletip,
  selectors: [["cds-toggletip"], ["ibm-toggletip"]],
  contentQueries: function Toggletip_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ToggletipButton, 5, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.btn = _t.first);
    }
  },
  hostVars: 4,
  hostBindings: function Toggletip_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("keyup", function Toggletip_keyup_HostBindingHandler($event) {
        return ctx.hostkeys($event);
      });
    }
    if (rf & 2) {
      ɵɵclassProp("cds--toggletip", ctx.toggletipClass)("cds--toggletip--open", ctx.isOpen);
    }
  },
  inputs: {
    id: "id",
    isOpen: "isOpen"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c137,
  decls: 3,
  vars: 1,
  consts: [["aria-live", "polite"]],
  template: function Toggletip_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c037);
      ɵɵprojection(0);
      ɵɵelementStart(1, "cds-popover-content", 0);
      ɵɵprojection(2, 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵattribute("id", ctx.id);
    }
  },
  dependencies: [PopoverContent],
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Toggletip, [{
    type: Component,
    args: [{
      selector: "cds-toggletip, ibm-toggletip",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
		<ng-content select="[cdsToggletipButton]"></ng-content>
		<cds-popover-content [attr.id]="id" aria-live="polite">
			<ng-content select="[cdsToggletipContent]"></ng-content>
		</cds-popover-content>
	`
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    id: [{
      type: Input
    }],
    toggletipClass: [{
      type: HostBinding,
      args: ["class.cds--toggletip"]
    }],
    isOpen: [{
      type: HostBinding,
      args: ["class.cds--toggletip--open"]
    }, {
      type: Input
    }],
    btn: [{
      type: ContentChild,
      args: [ToggletipButton, {
        read: ElementRef
      }]
    }],
    hostkeys: [{
      type: HostListener,
      args: ["keyup", ["$event"]]
    }]
  });
})();
var ToggletipModule = class {
};
ToggletipModule.ɵfac = function ToggletipModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ToggletipModule)();
};
ToggletipModule.ɵmod = ɵɵdefineNgModule({
  type: ToggletipModule,
  declarations: [Toggletip, ToggletipLabel, ToggletipAction, ToggletipButton, ToggletipContent],
  imports: [CommonModule, PopoverModule],
  exports: [Toggletip, ToggletipLabel, ToggletipAction, ToggletipButton, ToggletipContent]
});
ToggletipModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, PopoverModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ToggletipModule, [{
    type: NgModule,
    args: [{
      declarations: [Toggletip, ToggletipLabel, ToggletipAction, ToggletipButton, ToggletipContent],
      exports: [Toggletip, ToggletipLabel, ToggletipAction, ToggletipButton, ToggletipContent],
      imports: [CommonModule, PopoverModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-tiles.mjs
var _c038 = ["*"];
var _c138 = (a0, a1) => ({
  "cds--tile--light": a0,
  "cds--tile--disabled cds--link--disabled": a1
});
var _c228 = ["container"];
var _c321 = [[["", "cdsAboveFold", ""], ["", "ibmAboveFold", ""], ["", 8, "cds--tile-content__above-the-fold"]], [["", "cdsBelowFold", ""], ["", "ibmBelowFold", ""], ["", 8, "cds--tile-content__below-the-fold"]]];
var _c416 = ["[cdsAboveFold],[ibmAboveFold],.cds--tile-content__above-the-fold", "[cdsBelowFold],[ibmBelowFold],.cds--tile-content__below-the-fold"];
var _c513 = (a0, a1) => ({
  "cds--tile--is-expanded": a0,
  "cds--tile--light": a1
});
var _c610 = (a0) => ({
  "max-height": a0
});
function ExpandableTile_button_0_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function ExpandableTile_button_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 5);
    ɵɵpipe(1, "async");
    ɵɵlistener("click", function ExpandableTile_button_0_Template_button_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onClick());
    });
    ɵɵtemplate(2, ExpandableTile_button_0_ng_container_2_Template, 1, 0, "ng-container", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const expandableTileContent_r3 = ɵɵreference(5);
    ɵɵproperty("ngClass", ɵɵpureFunction2(7, _c513, ctx_r1.expanded, ctx_r1.theme === "light"))("ngStyle", ɵɵpureFunction1(10, _c610, ctx_r1.expandedHeight + "px"));
    ɵɵattribute("aria-expanded", ctx_r1.expanded)("title", ɵɵpipeBind1(1, 5, ctx_r1.expanded ? ctx_r1.collapse.subject : ctx_r1.expand.subject));
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", expandableTileContent_r3);
  }
}
function ExpandableTile_div_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function ExpandableTile_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 7);
    ɵɵpipe(1, "async");
    ɵɵtemplate(2, ExpandableTile_div_1_ng_container_2_Template, 1, 0, "ng-container", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const expandableTileContent_r3 = ɵɵreference(5);
    ɵɵproperty("ngClass", ɵɵpureFunction2(6, _c513, ctx_r1.expanded, ctx_r1.theme === "light"))("ngStyle", ɵɵpureFunction1(9, _c610, ctx_r1.expandedHeight + "px"));
    ɵɵattribute("title", ɵɵpipeBind1(1, 4, ctx_r1.expanded ? ctx_r1.collapse.subject : ctx_r1.expand.subject));
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", expandableTileContent_r3);
  }
}
function ExpandableTile_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 8);
  }
}
function ExpandableTile_ng_template_4_div_4_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function ExpandableTile_ng_template_4_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 12);
    ɵɵtemplate(1, ExpandableTile_ng_template_4_div_4_ng_container_1_Template, 1, 0, "ng-container", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const chevronIcon_r4 = ɵɵreference(3);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", chevronIcon_r4);
  }
}
function ExpandableTile_ng_template_4_button_5_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function ExpandableTile_ng_template_4_button_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 13);
    ɵɵpipe(1, "async");
    ɵɵlistener("click", function ExpandableTile_ng_template_4_button_5_Template_button_click_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onClick());
    });
    ɵɵtemplate(2, ExpandableTile_ng_template_4_button_5_ng_container_2_Template, 1, 0, "ng-container", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    const chevronIcon_r4 = ɵɵreference(3);
    ɵɵattribute("aria-expanded", ctx_r1.expanded)("aria-label", ɵɵpipeBind1(1, 3, ctx_r1.expanded ? ctx_r1.collapse.subject : ctx_r1.expand.subject));
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", chevronIcon_r4);
  }
}
function ExpandableTile_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", null, 2)(2, "div", 9);
    ɵɵprojection(3);
    ɵɵelementEnd();
    ɵɵtemplate(4, ExpandableTile_ng_template_4_div_4_Template, 2, 1, "div", 10)(5, ExpandableTile_ng_template_4_button_5_Template, 3, 5, "button", 11);
    ɵɵelementStart(6, "div", 9);
    ɵɵprojection(7, 1);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(4);
    ɵɵproperty("ngIf", !ctx_r1.interactive);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.interactive);
  }
}
var _c77 = ["input"];
var _c87 = (a0, a1, a2) => ({
  "cds--tile--is-selected": a0,
  "cds--tile--light": a1,
  "cds--tile--disabled": a2
});
function SelectionTile__svg_svg_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 7);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("cdsIcon", ctx_r1.multiple ? "checkbox" : "checkmark");
  }
}
function SelectionTile_ng_template_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 7);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("cdsIcon", ctx_r1.multiple ? "checkbox--checked--filled" : "checkmark--filled");
  }
}
var _c96 = [[["ibm-selection-tile"], ["cds-selection-tile"]]];
var _c105 = ["ibm-selection-tile,cds-selection-tile"];
function TileGroup_legend_1_1_ng_template_0_Template(rf, ctx) {
}
function TileGroup_legend_1_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TileGroup_legend_1_1_ng_template_0_Template, 0, 0, "ng-template", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.legend);
  }
}
function TileGroup_legend_1_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵtextInterpolate(ctx_r0.legend);
  }
}
function TileGroup_legend_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "legend", 2);
    ɵɵtemplate(1, TileGroup_legend_1_1_Template, 1, 1, null, 3)(2, TileGroup_legend_1_ng_template_2_Template, 1, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const legendLabel_r2 = ɵɵreference(3);
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.legend))("ngIfElse", legendLabel_r2);
  }
}
var ClickableTileIconDirective = class {
  constructor() {
    this.icon = true;
  }
};
ClickableTileIconDirective.ɵfac = function ClickableTileIconDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClickableTileIconDirective)();
};
ClickableTileIconDirective.ɵdir = ɵɵdefineDirective({
  type: ClickableTileIconDirective,
  selectors: [["", "cdsClickableTileIcon", ""], ["", "ibmClickableTileIcon", ""]],
  hostVars: 2,
  hostBindings: function ClickableTileIconDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--tile--icon", ctx.icon);
    }
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClickableTileIconDirective, [{
    type: Directive,
    args: [{
      selector: "[cdsClickableTileIcon], [ibmClickableTileIcon]"
    }]
  }], null, {
    icon: [{
      type: HostBinding,
      args: ["class.cds--tile--icon"]
    }]
  });
})();
var ClickableTile = class {
  constructor(router) {
    this.router = router;
    this.theme = "dark";
    this.href = "#";
    this.disabled = false;
    this.navigation = new EventEmitter();
  }
  navigate(event) {
    if (this.router && this.route && !this.disabled) {
      event.preventDefault();
      const status = this.router.navigate(this.route, this.routeExtras);
      this.navigation.emit(status);
    }
  }
};
ClickableTile.ɵfac = function ClickableTile_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClickableTile)(ɵɵdirectiveInject(Router, 8));
};
ClickableTile.ɵcmp = ɵɵdefineComponent({
  type: ClickableTile,
  selectors: [["cds-clickable-tile"], ["ibm-clickable-tile"]],
  inputs: {
    theme: "theme",
    href: "href",
    target: "target",
    rel: "rel",
    disabled: "disabled",
    route: "route",
    routeExtras: "routeExtras"
  },
  outputs: {
    navigation: "navigation"
  },
  standalone: false,
  ngContentSelectors: _c038,
  decls: 2,
  vars: 8,
  consts: [["cdsLink", "", "tabindex", "0", 1, "cds--tile", "cds--tile--clickable", 3, "click", "ngClass"]],
  template: function ClickableTile_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "a", 0);
      ɵɵlistener("click", function ClickableTile_Template_a_click_0_listener($event) {
        return ctx.navigate($event);
      });
      ɵɵprojection(1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngClass", ɵɵpureFunction2(5, _c138, ctx.theme === "light", ctx.disabled));
      ɵɵattribute("href", ctx.disabled ? null : ctx.href, ɵɵsanitizeUrl)("target", ctx.target)("rel", ctx.rel ? ctx.rel : null)("aria-disabled", ctx.disabled);
    }
  },
  dependencies: [NgClass, Link],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClickableTile, [{
    type: Component,
    args: [{
      selector: "cds-clickable-tile, ibm-clickable-tile",
      template: `
	<a
		cdsLink
		class="cds--tile cds--tile--clickable"
		[ngClass]="{
			'cds--tile--light': theme === 'light',
			'cds--tile--disabled cds--link--disabled' : disabled
		}"
		tabindex="0"
		(click)="navigate($event)"
		[attr.href]="disabled ? null : href"
		[attr.target]="target"
		[attr.rel]="rel ? rel : null"
		[attr.aria-disabled]="disabled">
		<ng-content></ng-content>
	</a>`
    }]
  }], function() {
    return [{
      type: Router,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    theme: [{
      type: Input
    }],
    href: [{
      type: Input
    }],
    target: [{
      type: Input
    }],
    rel: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    route: [{
      type: Input
    }],
    routeExtras: [{
      type: Input
    }],
    navigation: [{
      type: Output
    }]
  });
})();
var ExpandableTile = class {
  constructor(i18n, element) {
    this.i18n = i18n;
    this.element = element;
    this.theme = "dark";
    this.expanded = false;
    this.interactive = false;
    this.tileMaxHeight = 0;
    this.currentExpandedHeight = 0;
    this.expand = this.i18n.getOverridable("TILES.EXPAND");
    this.collapse = this.i18n.getOverridable("TILES.COLLAPSE");
  }
  /**
   * Expects an object that contains some or all of:
   * ```
   * {
   *		"EXPAND": "Expand",
   *		"COLLAPSE": "Collapse",
   * }
   * ```
   */
  set translations(value) {
    const valueWithDefaults = merge2(this.i18n.getMultiple("TILES"), value);
    this.expand.override(valueWithDefaults.EXPAND);
    this.collapse.override(valueWithDefaults.COLLAPSE);
  }
  ngAfterViewInit() {
    this.updateMaxHeight();
  }
  get expandedHeight() {
    const tile = this.element.nativeElement.querySelector(".cds--tile");
    const tilePadding = parseInt(getComputedStyle(tile).paddingBottom, 10) + parseInt(getComputedStyle(tile).paddingTop, 10);
    const expandedHeight = this.tileMaxHeight + tilePadding;
    if (!isNaN(expandedHeight)) {
      this.currentExpandedHeight = expandedHeight;
    }
    return this.currentExpandedHeight;
  }
  updateMaxHeight() {
    if (this.expanded) {
      this.tileMaxHeight = this.tileContainer.nativeElement.getBoundingClientRect().height;
    } else {
      this.tileMaxHeight = this.element.nativeElement.querySelector(".cds--tile-content__above-the-fold").getBoundingClientRect().height;
    }
  }
  onClick() {
    this.expanded = !this.expanded;
    this.updateMaxHeight();
  }
};
ExpandableTile.ɵfac = function ExpandableTile_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ExpandableTile)(ɵɵdirectiveInject(I18n), ɵɵdirectiveInject(ElementRef));
};
ExpandableTile.ɵcmp = ɵɵdefineComponent({
  type: ExpandableTile,
  selectors: [["cds-expandable-tile"], ["ibm-expandable-tile"]],
  viewQuery: function ExpandableTile_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c228, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tileContainer = _t.first);
    }
  },
  inputs: {
    theme: "theme",
    expanded: "expanded",
    interactive: "interactive",
    translations: "translations"
  },
  standalone: false,
  ngContentSelectors: _c416,
  decls: 6,
  vars: 2,
  consts: [["chevronIcon", ""], ["expandableTileContent", ""], ["container", ""], ["class", "cds--tile cds--tile--expandable", "type", "button", 3, "ngClass", "ngStyle", "click", 4, "ngIf"], ["class", "cds--tile cds--tile--expandable cds--tile--expandable--interactive", 3, "ngClass", "ngStyle", 4, "ngIf"], ["type", "button", 1, "cds--tile", "cds--tile--expandable", 3, "click", "ngClass", "ngStyle"], [4, "ngTemplateOutlet"], [1, "cds--tile", "cds--tile--expandable", "cds--tile--expandable--interactive", 3, "ngClass", "ngStyle"], ["cdsIcon", "chevron--down", "size", "16"], [1, "cds--tile-content"], ["class", "cds--tile__chevron", 4, "ngIf"], ["class", "cds--tile__chevron cds--tile__chevron--interactive", "type", "button", 3, "click", 4, "ngIf"], [1, "cds--tile__chevron"], ["type", "button", 1, "cds--tile__chevron", "cds--tile__chevron--interactive", 3, "click"]],
  template: function ExpandableTile_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c321);
      ɵɵtemplate(0, ExpandableTile_button_0_Template, 3, 12, "button", 3)(1, ExpandableTile_div_1_Template, 3, 11, "div", 4)(2, ExpandableTile_ng_template_2_Template, 1, 0, "ng-template", null, 0, ɵɵtemplateRefExtractor)(4, ExpandableTile_ng_template_4_Template, 8, 2, "ng-template", null, 1, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", !ctx.interactive);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.interactive);
    }
  },
  dependencies: [NgClass, NgIf, NgTemplateOutlet, NgStyle, IconDirective, AsyncPipe],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExpandableTile, [{
    type: Component,
    args: [{
      selector: "cds-expandable-tile, ibm-expandable-tile",
      template: `
		<button
			*ngIf="!interactive"
			class="cds--tile cds--tile--expandable"
			[ngClass]="{
				'cds--tile--is-expanded' : expanded,
				'cds--tile--light': theme === 'light'
			}"
			[ngStyle]="{'max-height': expandedHeight + 'px'}"
			type="button"
			(click)="onClick()"
			[attr.aria-expanded]="expanded"
			[attr.title]="(expanded ? collapse.subject : expand.subject) | async">
				<ng-container *ngTemplateOutlet="expandableTileContent"></ng-container>
		</button>

		<div
			*ngIf="interactive"
			class="cds--tile cds--tile--expandable cds--tile--expandable--interactive"
			[ngClass]="{
				'cds--tile--is-expanded' : expanded,
				'cds--tile--light': theme === 'light'
			}"
			[ngStyle]="{'max-height': expandedHeight + 'px'}"
			[attr.title]="(expanded ? collapse.subject : expand.subject) | async">
			<ng-container *ngTemplateOutlet="expandableTileContent"></ng-container>
		</div>

		<ng-template #chevronIcon>
			<svg cdsIcon="chevron--down" size="16"></svg>
		</ng-template>

		<ng-template #expandableTileContent>
			<div #container>
				<div class="cds--tile-content">
					<ng-content select="[cdsAboveFold],[ibmAboveFold],.cds--tile-content__above-the-fold"></ng-content>
				</div>
				<div *ngIf="!interactive" class="cds--tile__chevron">
					<ng-container *ngTemplateOutlet="chevronIcon"></ng-container>
				</div>
				<button
					*ngIf="interactive"
					class="cds--tile__chevron cds--tile__chevron--interactive"
					type="button"
					(click)="onClick()"
					[attr.aria-expanded]="expanded"
					[attr.aria-label]="(expanded ? collapse.subject : expand.subject) | async">
					<ng-container *ngTemplateOutlet="chevronIcon"></ng-container>
				</button>
				<div class="cds--tile-content">
					<ng-content select="[cdsBelowFold],[ibmBelowFold],.cds--tile-content__below-the-fold"></ng-content>
				</div>
			</div>
		</ng-template>
	`
    }]
  }], function() {
    return [{
      type: I18n
    }, {
      type: ElementRef
    }];
  }, {
    theme: [{
      type: Input
    }],
    expanded: [{
      type: Input
    }],
    interactive: [{
      type: Input
    }],
    translations: [{
      type: Input
    }],
    tileContainer: [{
      type: ViewChild,
      args: ["container"]
    }]
  });
})();
var ExpandableTileAboveFoldDirective = class {
  constructor() {
    this.aboveFold = true;
  }
};
ExpandableTileAboveFoldDirective.ɵfac = function ExpandableTileAboveFoldDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ExpandableTileAboveFoldDirective)();
};
ExpandableTileAboveFoldDirective.ɵdir = ɵɵdefineDirective({
  type: ExpandableTileAboveFoldDirective,
  selectors: [["", "cdsAboveFold", ""], ["", "ibmAboveFold", ""]],
  hostVars: 2,
  hostBindings: function ExpandableTileAboveFoldDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--tile-content__above-the-fold", ctx.aboveFold);
    }
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExpandableTileAboveFoldDirective, [{
    type: Directive,
    args: [{
      selector: "[cdsAboveFold], [ibmAboveFold]"
    }]
  }], null, {
    aboveFold: [{
      type: HostBinding,
      args: ["class.cds--tile-content__above-the-fold"]
    }]
  });
})();
var ExpandableTileBelowFoldDirective = class {
  constructor() {
    this.belowFold = true;
  }
};
ExpandableTileBelowFoldDirective.ɵfac = function ExpandableTileBelowFoldDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ExpandableTileBelowFoldDirective)();
};
ExpandableTileBelowFoldDirective.ɵdir = ɵɵdefineDirective({
  type: ExpandableTileBelowFoldDirective,
  selectors: [["", "cdsBelowFold", ""], ["", "ibmBelowFold", ""]],
  hostVars: 2,
  hostBindings: function ExpandableTileBelowFoldDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--tile-content__below-the-fold", ctx.belowFold);
    }
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExpandableTileBelowFoldDirective, [{
    type: Directive,
    args: [{
      selector: "[cdsBelowFold], [ibmBelowFold]"
    }]
  }], null, {
    belowFold: [{
      type: HostBinding,
      args: ["class.cds--tile-content__below-the-fold"]
    }]
  });
})();
var SelectionTile = class _SelectionTile {
  constructor(i18n) {
    this.i18n = i18n;
    this.theme = "dark";
    this.id = `tile-${_SelectionTile.tileCount}`;
    this.change = new EventEmitter();
    this.disabled = false;
    this.name = "tile-group-unbound";
    this.multiple = true;
    this._selected = null;
    _SelectionTile.tileCount++;
  }
  /**
   * Updating the state of the input to match the state of the parameter passed in.
   * Set to `true` if this tile should be selected.
   */
  set selected(value) {
    this._selected = value ? true : null;
    if (this.input) {
      this.input.nativeElement.checked = this._selected;
    }
  }
  get selected() {
    return this.input ? this.input.nativeElement.checked : false;
  }
  ngAfterViewInit() {
    if (this.input) {
      setTimeout(() => {
        this.input.nativeElement.checked = this._selected;
      });
    }
  }
  keyboardInput(event) {
    if (event.key === "Enter" || event.key === "Spacebar" || event.key === " ") {
      this.selected = !this.selected;
      this.change.emit(event);
    }
  }
  onChange(event) {
    this.change.emit(event);
  }
};
SelectionTile.tileCount = 0;
SelectionTile.ɵfac = function SelectionTile_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || SelectionTile)(ɵɵdirectiveInject(I18n));
};
SelectionTile.ɵcmp = ɵɵdefineComponent({
  type: SelectionTile,
  selectors: [["cds-selection-tile"], ["ibm-selection-tile"]],
  viewQuery: function SelectionTile_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c77, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.input = _t.first);
    }
  },
  hostBindings: function SelectionTile_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("keydown", function SelectionTile_keydown_HostBindingHandler($event) {
        return ctx.keyboardInput($event);
      });
    }
  },
  inputs: {
    theme: "theme",
    id: "id",
    selected: "selected",
    value: "value",
    disabled: "disabled"
  },
  outputs: {
    change: "change"
  },
  standalone: false,
  ngContentSelectors: _c038,
  decls: 10,
  vars: 19,
  consts: [["input", ""], ["selectedIcon", ""], [1, "cds--tile-input", 3, "change", "id", "disabled", "type", "value", "name"], [1, "cds--tile", "cds--tile--selectable", 3, "for", "ngClass"], [1, "cds--tile__checkmark"], ["size", "16", 3, "cdsIcon", 4, "ngIf", "ngIfElse"], [1, "cds--tile-content"], ["size", "16", 3, "cdsIcon"]],
  template: function SelectionTile_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵprojectionDef();
      ɵɵelementStart(0, "input", 2, 0);
      ɵɵlistener("change", function SelectionTile_Template_input_change_0_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onChange($event));
      });
      ɵɵelementEnd();
      ɵɵelementStart(2, "label", 3);
      ɵɵpipe(3, "async");
      ɵɵelementStart(4, "div", 4);
      ɵɵtemplate(5, SelectionTile__svg_svg_5_Template, 1, 1, "svg", 5)(6, SelectionTile_ng_template_6_Template, 1, 1, "ng-template", null, 1, ɵɵtemplateRefExtractor);
      ɵɵelementEnd();
      ɵɵelementStart(8, "div", 6);
      ɵɵprojection(9);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      const selectedIcon_r3 = ɵɵreference(7);
      ɵɵproperty("id", ctx.id)("disabled", ctx.disabled)("type", ctx.multiple ? "checkbox" : "radio")("value", ctx.value)("name", ctx.name);
      ɵɵattribute("tabindex", ctx.disabled ? null : 0);
      ɵɵadvance(2);
      ɵɵproperty("for", ctx.id)("ngClass", ɵɵpureFunction3(15, _c87, ctx.selected, ctx.theme === "light", ctx.disabled));
      ɵɵattribute("aria-label", ɵɵpipeBind1(3, 13, ctx.i18n.get("TILES.TILE")));
      ɵɵadvance(2);
      ɵɵclassProp("cds--tile__checkmark--persistent", ctx.multiple);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.selected)("ngIfElse", selectedIcon_r3);
    }
  },
  dependencies: [NgClass, NgIf, IconDirective, AsyncPipe],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectionTile, [{
    type: Component,
    args: [{
      selector: "cds-selection-tile, ibm-selection-tile",
      template: `
		<input
			#input
			[attr.tabindex]="disabled ? null : 0"
			class="cds--tile-input"
			[id]="id"
			[disabled]="disabled"
			[type]="(multiple ? 'checkbox': 'radio')"
			[value]="value"
			[name]="name"
			(change)="onChange($event)"/>
		<label
			class="cds--tile cds--tile--selectable"
			[for]="id"
			[ngClass]="{
				'cds--tile--is-selected' : selected,
				'cds--tile--light': theme === 'light',
				'cds--tile--disabled' : disabled
			}"
			[attr.aria-label]="i18n.get('TILES.TILE') | async">
			<div class="cds--tile__checkmark"
				[class.cds--tile__checkmark--persistent]="multiple">
				<svg *ngIf="!selected; else selectedIcon"
					[cdsIcon]="multiple ? 'checkbox' : 'checkmark'"
					size="16">
				</svg>
				<ng-template #selectedIcon>
					<svg [cdsIcon]="multiple ? 'checkbox--checked--filled' : 'checkmark--filled'" size="16"></svg>
				</ng-template>
			</div>
			<div class="cds--tile-content">
				<ng-content></ng-content>
			</div>
		</label>
	`
    }]
  }], function() {
    return [{
      type: I18n
    }];
  }, {
    theme: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    selected: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    change: [{
      type: Output
    }],
    disabled: [{
      type: Input
    }],
    input: [{
      type: ViewChild,
      args: ["input", {
        static: true
      }]
    }],
    keyboardInput: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }]
  });
})();
var TileGroup = class _TileGroup {
  constructor() {
    this.name = `tile-group-${_TileGroup.tileGroupCount}`;
    this.multiple = false;
    this.selected = new EventEmitter();
    this.tileGroupClass = true;
    this.unsubscribe$ = new Subject();
    this.unsubscribeTiles$ = new Subject();
    this.onChange = (_) => {
    };
    this.onTouched = () => {
    };
    _TileGroup.tileGroupCount++;
  }
  ngAfterContentInit() {
    const updateTiles = () => {
      this.unsubscribeTiles$.next();
      setTimeout(() => {
        this.selectionTiles.forEach((tile) => {
          tile.name = this.name;
          tile.change.pipe(takeUntil(this.unsubscribeTiles$)).subscribe(() => {
            this.selected.emit({
              value: tile.value,
              selected: tile.selected,
              name: this.name
            });
            this.onChange(tile.value);
          });
          tile.multiple = this.multiple;
        });
      });
    };
    updateTiles();
    this.selectionTiles.changes.pipe(takeUntil(this.unsubscribe$)).subscribe((_) => updateTiles());
  }
  ngOnDestroy() {
    this.unsubscribe$.next();
    this.unsubscribe$.complete();
    this.unsubscribeTiles$.next();
    this.unsubscribeTiles$.complete();
  }
  writeValue(value) {
    if (!this.selectionTiles) {
      return;
    }
    this.selectionTiles.forEach((tile) => {
      if (tile.value === value) {
        tile.selected = true;
      } else {
        tile.selected = false;
      }
    });
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  isTemplate(value) {
    return value instanceof TemplateRef;
  }
};
TileGroup.tileGroupCount = 0;
TileGroup.ɵfac = function TileGroup_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TileGroup)();
};
TileGroup.ɵcmp = ɵɵdefineComponent({
  type: TileGroup,
  selectors: [["cds-tile-group"], ["ibm-tile-group"]],
  contentQueries: function TileGroup_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, SelectionTile, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.selectionTiles = _t);
    }
  },
  hostVars: 2,
  hostBindings: function TileGroup_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--tile-group", ctx.tileGroupClass);
    }
  },
  inputs: {
    name: "name",
    multiple: "multiple",
    legend: "legend"
  },
  outputs: {
    selected: "selected"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: TileGroup,
    multi: true
  }])],
  ngContentSelectors: _c105,
  decls: 3,
  vars: 1,
  consts: [["legendLabel", ""], ["class", "cds--label", 4, "ngIf"], [1, "cds--label"], [4, "ngIf", "ngIfElse"], [3, "ngTemplateOutlet"]],
  template: function TileGroup_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c96);
      ɵɵelementStart(0, "fieldset");
      ɵɵtemplate(1, TileGroup_legend_1_Template, 4, 2, "legend", 1);
      ɵɵprojection(2);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.legend);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TileGroup, [{
    type: Component,
    args: [{
      selector: "cds-tile-group, ibm-tile-group",
      template: `
		<fieldset>
			<legend *ngIf="legend" class="cds--label">
				<ng-template *ngIf="isTemplate(legend); else legendLabel;" [ngTemplateOutlet]="legend"></ng-template>
				<ng-template #legendLabel>{{legend}}</ng-template>
			</legend>
			<ng-content select="ibm-selection-tile,cds-selection-tile"></ng-content>
		</fieldset>`,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: TileGroup,
        multi: true
      }]
    }]
  }], function() {
    return [];
  }, {
    name: [{
      type: Input
    }],
    multiple: [{
      type: Input
    }],
    legend: [{
      type: Input
    }],
    selected: [{
      type: Output
    }],
    tileGroupClass: [{
      type: HostBinding,
      args: ["class.cds--tile-group"]
    }],
    selectionTiles: [{
      type: ContentChildren,
      args: [SelectionTile]
    }]
  });
})();
var Tile = class {
  constructor() {
    this.tileClass = true;
    this.theme = "dark";
  }
  get lightThemeEnabled() {
    return this.theme === "light";
  }
};
Tile.ɵfac = function Tile_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Tile)();
};
Tile.ɵcmp = ɵɵdefineComponent({
  type: Tile,
  selectors: [["cds-tile"], ["ibm-tile"]],
  hostVars: 4,
  hostBindings: function Tile_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--tile", ctx.tileClass)("cds--tile--light", ctx.lightThemeEnabled);
    }
  },
  inputs: {
    theme: "theme"
  },
  standalone: false,
  ngContentSelectors: _c038,
  decls: 1,
  vars: 0,
  template: function Tile_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Tile, [{
    type: Component,
    args: [{
      selector: "cds-tile, ibm-tile",
      template: `<ng-content></ng-content>`
    }]
  }], null, {
    tileClass: [{
      type: HostBinding,
      args: ["class.cds--tile"]
    }],
    lightThemeEnabled: [{
      type: HostBinding,
      args: ["class.cds--tile--light"]
    }],
    theme: [{
      type: Input
    }]
  });
})();
var TilesModule = class {
};
TilesModule.ɵfac = function TilesModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TilesModule)();
};
TilesModule.ɵmod = ɵɵdefineNgModule({
  type: TilesModule,
  declarations: [Tile, ClickableTile, ClickableTileIconDirective, ExpandableTileAboveFoldDirective, ExpandableTileBelowFoldDirective, ExpandableTile, SelectionTile, TileGroup],
  imports: [CommonModule, I18nModule, IconModule, LinkModule],
  exports: [Tile, ClickableTile, ClickableTileIconDirective, ExpandableTileAboveFoldDirective, ExpandableTileBelowFoldDirective, ExpandableTile, SelectionTile, TileGroup]
});
TilesModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, I18nModule, IconModule, LinkModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TilesModule, [{
    type: NgModule,
    args: [{
      declarations: [Tile, ClickableTile, ClickableTileIconDirective, ExpandableTileAboveFoldDirective, ExpandableTileBelowFoldDirective, ExpandableTile, SelectionTile, TileGroup],
      exports: [Tile, ClickableTile, ClickableTileIconDirective, ExpandableTileAboveFoldDirective, ExpandableTileBelowFoldDirective, ExpandableTile, SelectionTile, TileGroup],
      imports: [CommonModule, I18nModule, IconModule, LinkModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-timepicker-select.mjs
var _c039 = ["*"];
function TimePickerSelect_label_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "label", 5);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵattribute("for", ctx_r1.id);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.label);
  }
}
function TimePickerSelect__svg_svg_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 6);
  }
}
var TimePickerSelect = class _TimePickerSelect extends Select {
  constructor() {
    super(...arguments);
    this.timeSelect = true;
    this.timePickerSelect = true;
    this.id = `timepicker-select-${_TimePickerSelect.selectCount++}`;
    this.skeleton = false;
    this.theme = "dark";
    this.timePickerSelectSkeleton = this.skeleton;
  }
  get timePickerSelectLight() {
    return this.theme === "light";
  }
};
TimePickerSelect.ɵfac = /* @__PURE__ */ (() => {
  let ɵTimePickerSelect_BaseFactory;
  return function TimePickerSelect_Factory(__ngFactoryType__) {
    return (ɵTimePickerSelect_BaseFactory || (ɵTimePickerSelect_BaseFactory = ɵɵgetInheritedFactory(TimePickerSelect)))(__ngFactoryType__ || TimePickerSelect);
  };
})();
TimePickerSelect.ɵcmp = ɵɵdefineComponent({
  type: TimePickerSelect,
  selectors: [["cds-timepicker-select"], ["ibm-timepicker-select"]],
  hostVars: 8,
  hostBindings: function TimePickerSelect_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--select", ctx.timeSelect)("cds--time-picker__select", ctx.timePickerSelect)("cds--skeleton", ctx.timePickerSelectSkeleton)("cds--select--light", ctx.timePickerSelectLight);
    }
  },
  inputs: {
    id: "id",
    ariaLabel: "ariaLabel",
    skeleton: "skeleton",
    theme: "theme",
    label: "label"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: TimePickerSelect,
    multi: true
  }]), ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c039,
  decls: 6,
  vars: 5,
  consts: [["select", ""], ["class", "cds--label cds--visually-hidden", 4, "ngIf"], [1, "cds--select-input__wrapper"], [1, "cds--select-input", 3, "change", "disabled"], ["cdsIcon", "chevron--down", "size", "16", "class", "cds--select__arrow", 4, "ngIf"], [1, "cds--label", "cds--visually-hidden"], ["cdsIcon", "chevron--down", "size", "16", 1, "cds--select__arrow"]],
  template: function TimePickerSelect_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵprojectionDef();
      ɵɵtemplate(0, TimePickerSelect_label_0_Template, 2, 2, "label", 1);
      ɵɵelementStart(1, "div", 2)(2, "select", 3, 0);
      ɵɵlistener("change", function TimePickerSelect_Template_select_change_2_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onChange($event));
      });
      ɵɵprojection(4);
      ɵɵelementEnd();
      ɵɵtemplate(5, TimePickerSelect__svg_svg_5_Template, 1, 0, "svg", 4);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", !ctx.skeleton && ctx.label);
      ɵɵadvance(2);
      ɵɵproperty("disabled", ctx.disabled);
      ɵɵattribute("id", ctx.id)("aria-label", ctx.ariaLabel);
      ɵɵadvance(3);
      ɵɵproperty("ngIf", !ctx.skeleton);
    }
  },
  dependencies: [NgIf, IconDirective],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimePickerSelect, [{
    type: Component,
    args: [{
      selector: "cds-timepicker-select, ibm-timepicker-select",
      template: `
		<label *ngIf="!skeleton && label" [attr.for]="id" class="cds--label cds--visually-hidden">{{label}}</label>
		<div class="cds--select-input__wrapper">
			<select
				#select
				[attr.id]="id"
				[attr.aria-label]="ariaLabel"
				[disabled]="disabled"
				(change)="onChange($event)"
				class="cds--select-input">
				<ng-content></ng-content>
			</select>
			<svg cdsIcon="chevron--down" size="16" *ngIf="!skeleton" class="cds--select__arrow"></svg>
		</div>
	`,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: TimePickerSelect,
        multi: true
      }]
    }]
  }], null, {
    timeSelect: [{
      type: HostBinding,
      args: ["class.cds--select"]
    }],
    timePickerSelect: [{
      type: HostBinding,
      args: ["class.cds--time-picker__select"]
    }],
    id: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    skeleton: [{
      type: Input
    }],
    theme: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    timePickerSelectSkeleton: [{
      type: HostBinding,
      args: ["class.cds--skeleton"]
    }],
    timePickerSelectLight: [{
      type: HostBinding,
      args: ["class.cds--select--light"]
    }]
  });
})();
var TimePickerSelectModule = class {
};
TimePickerSelectModule.ɵfac = function TimePickerSelectModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TimePickerSelectModule)();
};
TimePickerSelectModule.ɵmod = ɵɵdefineNgModule({
  type: TimePickerSelectModule,
  declarations: [TimePickerSelect],
  imports: [SelectModule, CommonModule, IconModule],
  exports: [TimePickerSelect]
});
TimePickerSelectModule.ɵinj = ɵɵdefineInjector({
  imports: [SelectModule, CommonModule, IconModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimePickerSelectModule, [{
    type: NgModule,
    args: [{
      declarations: [TimePickerSelect],
      exports: [TimePickerSelect],
      imports: [SelectModule, CommonModule, IconModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-timepicker.mjs
var _c040 = ["*"];
var _c139 = (a0, a1, a2, a3, a4) => ({
  "cds--time-picker--invalid": a0,
  "cds--time-picker--sm": a1,
  "cds--time-picker--md": a2,
  "cds--time-picker--lg": a3,
  "cds--time-picker--light": a4
});
var _c229 = (a0, a1) => ({
  "cds--text-input--light": a0,
  "cds--skeleton": a1
});
var _c322 = (a0, a1) => ({
  "cds--label--disabled": a0,
  "cds--visually-hidden": a1
});
function TimePicker_label_0_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.label);
  }
}
function TimePicker_label_0_2_ng_template_0_Template(rf, ctx) {
}
function TimePicker_label_0_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TimePicker_label_0_2_ng_template_0_Template, 0, 0, "ng-template", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.label);
  }
}
function TimePicker_label_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "label", 5);
    ɵɵtemplate(1, TimePicker_label_0_ng_container_1_Template, 2, 1, "ng-container", 6)(2, TimePicker_label_0_2_Template, 1, 1, null, 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("for", ctx_r0.id)("ngClass", ɵɵpureFunction2(4, _c322, ctx_r0.disabled, ctx_r0.hideLabel));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.label));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.label));
  }
}
function TimePicker_div_5_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.invalidText);
  }
}
function TimePicker_div_5_2_ng_template_0_Template(rf, ctx) {
}
function TimePicker_div_5_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TimePicker_div_5_2_ng_template_0_Template, 0, 0, "ng-template", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.invalidText);
  }
}
function TimePicker_div_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 8);
    ɵɵtemplate(1, TimePicker_div_5_ng_container_1_Template, 2, 1, "ng-container", 6)(2, TimePicker_div_5_2_Template, 1, 1, null, 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.isTemplate(ctx_r0.invalidText));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isTemplate(ctx_r0.invalidText));
  }
}
var TimePicker = class _TimePicker {
  constructor() {
    this.invalid = false;
    this.hideLabel = false;
    this.placeholder = "hh:mm";
    this.pattern = "(1[012]|[0-9]):[0-5][0-9]";
    this.id = `timepicker-${_TimePicker.timePickerCount++}`;
    this.disabled = false;
    this.maxLength = 5;
    this.skeleton = false;
    this.theme = "dark";
    this.size = "md";
    this.valueChange = new EventEmitter();
    this.timepickerClass = true;
    this.onChangeHandler = (_) => {
    };
    this.onTouchedHandler = () => {
    };
  }
  writeValue(value) {
    this.value = value;
  }
  registerOnChange(callback) {
    this.onChangeHandler = callback;
  }
  registerOnTouched(callback) {
    this.onTouchedHandler = callback;
  }
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  onChange(event) {
    this.onChangeHandler(event.target.value);
    this.valueChange.emit(event.target.value);
  }
  focusOut() {
    this.onTouchedHandler();
  }
  isTemplate(value) {
    return value instanceof TemplateRef;
  }
};
TimePicker.timePickerCount = 0;
TimePicker.ɵfac = function TimePicker_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TimePicker)();
};
TimePicker.ɵcmp = ɵɵdefineComponent({
  type: TimePicker,
  selectors: [["cds-timepicker"], ["ibm-timepicker"]],
  hostVars: 2,
  hostBindings: function TimePicker_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("focusout", function TimePicker_focusout_HostBindingHandler() {
        return ctx.focusOut();
      });
    }
    if (rf & 2) {
      ɵɵclassProp("cds--form-item", ctx.timepickerClass);
    }
  },
  inputs: {
    invalid: "invalid",
    invalidText: "invalidText",
    label: "label",
    hideLabel: "hideLabel",
    placeholder: "placeholder",
    pattern: "pattern",
    id: "id",
    disabled: "disabled",
    value: "value",
    maxLength: "maxLength",
    skeleton: "skeleton",
    theme: "theme",
    size: "size"
  },
  outputs: {
    valueChange: "valueChange"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: TimePicker,
    multi: true
  }])],
  ngContentSelectors: _c040,
  decls: 6,
  vars: 20,
  consts: [["class", "cds--label", 3, "for", "ngClass", 4, "ngIf"], [1, "cds--time-picker", 3, "ngClass"], [1, "cds--time-picker__input"], ["type", "text", 1, "cds--time-picker__input-field", "cds--text-input", 3, "change", "ngClass", "value", "placeholder", "pattern", "disabled"], ["class", "cds--form-requirement", 4, "ngIf"], [1, "cds--label", 3, "for", "ngClass"], [4, "ngIf"], [3, "ngTemplateOutlet"], [1, "cds--form-requirement"]],
  template: function TimePicker_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, TimePicker_label_0_Template, 3, 7, "label", 0);
      ɵɵelementStart(1, "div", 1)(2, "div", 2)(3, "input", 3);
      ɵɵlistener("change", function TimePicker_Template_input_change_3_listener($event) {
        return ctx.onChange($event);
      });
      ɵɵelementEnd()();
      ɵɵprojection(4);
      ɵɵelementEnd();
      ɵɵtemplate(5, TimePicker_div_5_Template, 3, 2, "div", 4);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", !ctx.skeleton && ctx.label);
      ɵɵadvance();
      ɵɵproperty("ngClass", ɵɵpureFunction5(11, _c139, ctx.invalid, ctx.size === "sm", ctx.size === "md", ctx.size === "lg", ctx.theme === "light"));
      ɵɵadvance(2);
      ɵɵproperty("ngClass", ɵɵpureFunction2(17, _c229, ctx.theme === "light", ctx.skeleton))("value", ctx.value)("placeholder", ctx.placeholder)("pattern", ctx.pattern)("disabled", ctx.disabled);
      ɵɵattribute("data-invalid", ctx.invalid ? true : void 0)("id", ctx.id)("maxlength", ctx.maxLength);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.invalid);
    }
  },
  dependencies: [NgClass, NgIf, NgTemplateOutlet],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimePicker, [{
    type: Component,
    args: [{
      selector: "cds-timepicker, ibm-timepicker",
      template: `
		<label
		*ngIf="!skeleton && label"
		[for]="id"
		class="cds--label"
		[ngClass]="{
			'cds--label--disabled': disabled,
			'cds--visually-hidden': hideLabel
		}">
			<ng-container *ngIf="!isTemplate(label)">{{label}}</ng-container>
			<ng-template *ngIf="isTemplate(label)" [ngTemplateOutlet]="label"></ng-template>
		</label>
		<div
			class="cds--time-picker"
			[ngClass]="{
				'cds--time-picker--invalid' : invalid,
				'cds--time-picker--sm': size === 'sm',
				'cds--time-picker--md': size === 'md',
				'cds--time-picker--lg': size === 'lg',
				'cds--time-picker--light': theme === 'light'
			}">
			<div class="cds--time-picker__input">
				<input
					[ngClass]="{
						'cds--text-input--light': theme === 'light',
						'cds--skeleton': skeleton
					}"
					[value]="value"
					[placeholder]="placeholder"
					[attr.data-invalid]="invalid ? true : undefined"
					[pattern]="pattern"
					[attr.id]="id"
					[disabled]="disabled"
					[attr.maxlength]="maxLength"
					(change)="onChange($event)"
					type="text"
					class="cds--time-picker__input-field cds--text-input">
			</div>
			<ng-content></ng-content>
		</div>
		<div *ngIf="invalid" class="cds--form-requirement">
			<ng-container *ngIf="!isTemplate(invalidText)">{{invalidText}}</ng-container>
			<ng-template *ngIf="isTemplate(invalidText)" [ngTemplateOutlet]="invalidText"></ng-template>
		</div>
	`,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: TimePicker,
        multi: true
      }]
    }]
  }], null, {
    invalid: [{
      type: Input
    }],
    invalidText: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    hideLabel: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    pattern: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    maxLength: [{
      type: Input
    }],
    skeleton: [{
      type: Input
    }],
    theme: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    timepickerClass: [{
      type: HostBinding,
      args: ["class.cds--form-item"]
    }],
    focusOut: [{
      type: HostListener,
      args: ["focusout"]
    }]
  });
})();
var TimePickerModule = class {
};
TimePickerModule.ɵfac = function TimePickerModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TimePickerModule)();
};
TimePickerModule.ɵmod = ɵɵdefineNgModule({
  type: TimePickerModule,
  declarations: [TimePicker],
  imports: [TimePickerSelectModule, CommonModule],
  exports: [TimePicker]
});
TimePickerModule.ɵinj = ɵɵdefineInjector({
  imports: [TimePickerSelectModule, CommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimePickerModule, [{
    type: NgModule,
    args: [{
      declarations: [TimePicker],
      exports: [TimePicker],
      imports: [TimePickerSelectModule, CommonModule]
    }]
  }], null, null);
})();

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-treeview.mjs
var _c041 = ["*"];
var _c140 = (a0, a1, a2, a3, a4, a5) => ({
  "cds--tree-node--active": a0,
  "cds--tree-node--disabled": a1,
  "cds--tree-node--selected": a2,
  "cds--tree-leaf-node": a3,
  "cds--tree-parent-node": a4,
  "cds--tree-node--with-icon": a5
});
var _c230 = (a0) => ({
  $implicit: a0
});
var _c323 = (a0) => ({
  "cds--tree-parent-node__toggle-icon--expanded": a0
});
function TreeNodeComponent_div_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵnamespaceSVG();
    ɵɵelement(1, "svg", 7);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("cdsIcon", ctx_r1.icon);
  }
}
function TreeNodeComponent_div_1_2_ng_template_0_Template(rf, ctx) {
}
function TreeNodeComponent_div_1_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TreeNodeComponent_div_1_2_ng_template_0_Template, 0, 0, "ng-template", 8);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.icon);
  }
}
function TreeNodeComponent_div_1_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.label);
  }
}
function TreeNodeComponent_div_1_4_ng_template_0_Template(rf, ctx) {
}
function TreeNodeComponent_div_1_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TreeNodeComponent_div_1_4_ng_template_0_Template, 0, 0, "ng-template", 9);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.label)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c230, ctx_r1.labelContext));
  }
}
function TreeNodeComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 5);
    ɵɵlistener("click", function TreeNodeComponent_div_1_Template_div_click_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.nodeClick($event));
    });
    ɵɵtemplate(1, TreeNodeComponent_div_1_ng_container_1_Template, 2, 1, "ng-container", 6)(2, TreeNodeComponent_div_1_2_Template, 1, 1, null, 6)(3, TreeNodeComponent_div_1_ng_container_3_Template, 2, 1, "ng-container", 6)(4, TreeNodeComponent_div_1_4_Template, 1, 4, null, 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵstyleProp("padding-inline-start", ctx_r1.offset, "rem")("margin-inline-start", -ctx_r1.offset, "rem");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.icon && !ctx_r1.isTemplate(ctx_r1.icon));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.isTemplate(ctx_r1.icon));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.isTemplate(ctx_r1.label));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.isTemplate(ctx_r1.label));
  }
}
function TreeNodeComponent_div_2_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵnamespaceSVG();
    ɵɵelement(1, "svg", 7);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("cdsIcon", ctx_r1.icon);
  }
}
function TreeNodeComponent_div_2_5_ng_template_0_Template(rf, ctx) {
}
function TreeNodeComponent_div_2_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TreeNodeComponent_div_2_5_ng_template_0_Template, 0, 0, "ng-template", 9);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.icon)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c230, ctx_r1.iconContext));
  }
}
function TreeNodeComponent_div_2_ng_container_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.label);
  }
}
function TreeNodeComponent_div_2_7_ng_template_0_Template(rf, ctx) {
}
function TreeNodeComponent_div_2_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TreeNodeComponent_div_2_7_ng_template_0_Template, 0, 0, "ng-template", 9);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.label)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c230, ctx_r1.labelContext));
  }
}
function TreeNodeComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 10);
    ɵɵlistener("click", function TreeNodeComponent_div_2_Template_div_click_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.nodeClick($event));
    });
    ɵɵelementStart(1, "span", 11);
    ɵɵlistener("click", function TreeNodeComponent_div_2_Template_span_click_1_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.toggleExpanded($event));
    });
    ɵɵnamespaceSVG();
    ɵɵelement(2, "svg", 12);
    ɵɵelementEnd();
    ɵɵnamespaceHTML();
    ɵɵelementStart(3, "span", 13);
    ɵɵtemplate(4, TreeNodeComponent_div_2_ng_container_4_Template, 2, 1, "ng-container", 6)(5, TreeNodeComponent_div_2_5_Template, 1, 4, null, 6)(6, TreeNodeComponent_div_2_ng_container_6_Template, 2, 1, "ng-container", 6)(7, TreeNodeComponent_div_2_7_Template, 1, 4, null, 6);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵstyleProp("padding-inline-start", ctx_r1.offset, "rem")("margin-inline-start", -ctx_r1.offset, "rem");
    ɵɵadvance();
    ɵɵattribute("disabled", ctx_r1.disabled || null);
    ɵɵadvance();
    ɵɵproperty("ngClass", ɵɵpureFunction1(10, _c323, ctx_r1.expanded));
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r1.icon && !ctx_r1.isTemplate(ctx_r1.icon));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.isTemplate(ctx_r1.icon));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.isTemplate(ctx_r1.label));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.isTemplate(ctx_r1.label));
  }
}
function TreeNodeComponent_div_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵprojection(1);
    ɵɵelementContainerEnd();
  }
}
function TreeNodeComponent_div_3_ng_template_2_cds_tree_node_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "cds-tree-node", 17);
    ɵɵlistener("nodetoggle", function TreeNodeComponent_div_3_ng_template_2_cds_tree_node_0_Template_cds_tree_node_nodetoggle_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.nodetoggle.emit($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const childNode_r5 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("node", childNode_r5)("depth", ctx_r1.depth + 1)("disabled", ctx_r1.disabled);
  }
}
function TreeNodeComponent_div_3_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TreeNodeComponent_div_3_ng_template_2_cds_tree_node_0_Template, 1, 3, "cds-tree-node", 16);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngForOf", ctx_r1.children);
  }
}
function TreeNodeComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 14);
    ɵɵtemplate(1, TreeNodeComponent_div_3_ng_container_1_Template, 2, 0, "ng-container", 15)(2, TreeNodeComponent_div_3_ng_template_2_Template, 1, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const notProjected_r6 = ɵɵreference(3);
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.isProjected())("ngIfElse", notProjected_r6);
  }
}
var _c417 = ["treeWrapper"];
var _c514 = (a0, a1) => ({
  "cds--tree--sm": a0,
  "cds--tree--xs": a1
});
function TreeViewComponent_label_0_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.label);
  }
}
function TreeViewComponent_label_0_2_ng_template_0_Template(rf, ctx) {
}
function TreeViewComponent_label_0_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TreeViewComponent_label_0_2_ng_template_0_Template, 0, 0, "ng-template", 7);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.label)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c230, ctx_r1.labelContext));
  }
}
function TreeViewComponent_label_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "label", 5);
    ɵɵtemplate(1, TreeViewComponent_label_0_ng_container_1_Template, 2, 1, "ng-container", 6)(2, TreeViewComponent_label_0_2_Template, 1, 4, null, 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("id", ctx_r1.id);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.isTemplate(ctx_r1.label));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.isTemplate(ctx_r1.label));
  }
}
function TreeViewComponent_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵprojection(1);
    ɵɵelementContainerEnd();
  }
}
function TreeViewComponent_ng_template_4_cds_tree_node_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "cds-tree-node", 9);
    ɵɵlistener("nodetoggle", function TreeViewComponent_ng_template_4_cds_tree_node_0_Template_cds_tree_node_nodetoggle_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onNodeToggle($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const node_r4 = ctx.$implicit;
    ɵɵproperty("node", node_r4);
  }
}
function TreeViewComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TreeViewComponent_ng_template_4_cds_tree_node_0_Template, 1, 1, "cds-tree-node", 8);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngForOf", ctx_r1.tree);
  }
}
var TreeViewService = class {
  constructor() {
    this.contentProjected = true;
    this.isMultiSelect = false;
    this.selectionSubject = new ReplaySubject(1);
    this.focusNodeSubject = new ReplaySubject(1);
    this.value = /* @__PURE__ */ new Map();
    this.selectionObservable = this.selectionSubject.asObservable();
    this.focusNodeObservable = this.focusNodeSubject.asObservable();
  }
  /**
   * Emits the focused node
   * @param node: Node
   */
  focusNode(node) {
    this.focusNodeSubject.next(node);
  }
  /**
   * Store selected node in map
   * @param node: Node
   */
  selectNode(node) {
    if (!node) {
      return;
    }
    if (!this.isMultiSelect) {
      this.value.clear();
    }
    this.value.set(node.id, node);
    this.selectionSubject.next(this.value);
  }
  /**
   * Removes selected node from the map
   * @param node: Node
   */
  deselectNode(node) {
    if (!node) {
      return;
    }
    this.value.delete(node.id);
    this.selectionSubject.next(this.value);
  }
  /**
   * Removes all selected nodes from the map
   */
  deselectAllNodes() {
    this.value.clear();
    this.selectionSubject.next(this.value);
  }
};
TreeViewService.ɵfac = function TreeViewService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TreeViewService)();
};
TreeViewService.ɵprov = ɵɵdefineInjectable({
  token: TreeViewService,
  factory: TreeViewService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TreeViewService, [{
    type: Injectable
  }], function() {
    return [];
  }, null);
})();
var TreeNodeComponent = class _TreeNodeComponent {
  constructor(treeViewService) {
    this.treeViewService = treeViewService;
    this.id = `tree-node-${_TreeNodeComponent.treeNodeCount++}`;
    this.active = false;
    this.disabled = false;
    this.selectable = true;
    this.expanded = false;
    this.selected = false;
    this.gap = 0;
    this.children = [];
    this.depth = 0;
    this.nodeFocus = new EventEmitter();
    this.nodeBlur = new EventEmitter();
    this.nodeSelect = new EventEmitter();
    this.nodetoggle = new EventEmitter();
  }
  /**
   * Simple way to set all attributes of Node component via node object
   * Would simplify setting component attributes when dynamically rendering node.
   */
  set node(node) {
    this._node = node;
    this.id = node.id ?? this.id;
    this.active = node.active ?? this.active;
    this.disabled = node.disabled ?? this.disabled;
    this.selectable = node.selectable ?? this.selectable;
    this.expanded = node.expanded ?? this.expanded;
    this.label = node.label ?? this.label;
    this.labelContext = node.labelContext ?? this.labelContext;
    this.value = node.value ?? this.value;
    this.icon = node.icon ?? this.icon;
    this.selected = node.selected ?? this.selected;
    this.depth = node.depth ?? this.depth;
    this.gap = node.gap ?? this.gap;
    this.children = node.children ?? this.children;
    this.iconContext = node.iconText ?? this.iconContext;
  }
  get node() {
    return this._node;
  }
  /**
   * Caclulate offset for margin/padding
   */
  ngAfterContentChecked() {
    this.offset = this.calculateOffset();
  }
  /**
   * Highlight the node
   */
  ngOnInit() {
    this.subscription = this.treeViewService.selectionObservable.subscribe((value) => {
      this.selected = this.selectable && value.has(this.id);
      this.active = this.selectable && this.selected;
    });
  }
  /**
   * Unsubscribe from subscriptions
   */
  ngOnDestroy() {
    this.subscription?.unsubscribe();
  }
  /**
   * Selects the node and emits the event from the tree view component
   * @param event
   */
  nodeClick(event) {
    if (!this.disabled) {
      event.target.parentElement.focus();
      if (this.selectable || this.children.length === 0) {
        this.selected = true;
        this.active = true;
        const node = {
          id: this.id,
          label: this.label,
          value: this.value
        };
        this.treeViewService.selectNode(node);
        this.nodeSelect.emit(node);
      } else {
        this.toggleExpanded(event);
      }
    }
  }
  /**
   * Calculate the node offset
   * @returns Number
   */
  calculateOffset() {
    if (this.children.length && this.icon) {
      return this.depth + 1 + this.depth * 0.5;
    }
    if (this.children.length) {
      return this.depth + 1;
    }
    if (this.icon) {
      return this.depth + 2 + this.depth * 0.5;
    }
    return this.depth + this.gap + 2.5;
  }
  emitFocusEvent(event) {
    const node = {
      id: this.id,
      label: this.label,
      value: this.value
    };
    this.nodeFocus.emit({
      node,
      event
    });
    this.treeViewService.focusNode(node);
  }
  emitBlurEvent(event) {
    this.nodeBlur.emit({
      node: {
        id: this.id,
        label: this.label,
        value: this.value
      },
      event
    });
  }
  /**
   * Expand children if not disabled
   * @param event: Event
   */
  toggleExpanded(event) {
    if (!this.disabled) {
      this.nodetoggle.emit({
        node: {
          id: this.id,
          label: this.label,
          value: this.value
        },
        event
      });
      this.expanded = !this.expanded;
      event.stopPropagation();
    }
  }
  /**
   * Manages the keyboard accessibility for children expansion & selection
   */
  navigateTree(event) {
    if (event.key === "ArrowLeft" || event.key === "ArrowRight" || event.key === "Enter") {
      event.stopPropagation();
    }
    if (event.key === "ArrowLeft") {
      if (this.expanded && this.children) {
        this.toggleExpanded(event);
      }
    }
    if (event.key === "ArrowRight") {
      if (!this.expanded && this.children) {
        this.toggleExpanded(event);
      }
    }
    if (event.key === "Enter") {
      event.preventDefault();
      this.nodeClick(event);
    }
  }
  isTemplate(value) {
    return value instanceof TemplateRef;
  }
  isProjected() {
    return this.treeViewService.contentProjected;
  }
};
TreeNodeComponent.treeNodeCount = 0;
TreeNodeComponent.ɵfac = function TreeNodeComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TreeNodeComponent)(ɵɵdirectiveInject(TreeViewService));
};
TreeNodeComponent.ɵcmp = ɵɵdefineComponent({
  type: TreeNodeComponent,
  selectors: [["cds-tree-node"]],
  inputs: {
    id: "id",
    active: "active",
    disabled: "disabled",
    selectable: "selectable",
    expanded: "expanded",
    label: "label",
    labelContext: "labelContext",
    selected: "selected",
    value: "value",
    icon: "icon",
    iconContext: "iconContext",
    gap: "gap",
    children: "children",
    depth: "depth",
    node: "node"
  },
  outputs: {
    nodeFocus: "nodeFocus",
    nodeBlur: "nodeBlur",
    nodeSelect: "nodeSelect",
    nodetoggle: "nodetoggle"
  },
  standalone: false,
  ngContentSelectors: _c041,
  decls: 4,
  vars: 17,
  consts: [["notProjected", ""], ["role", "treeitem", 1, "cds--tree-node", 3, "focus", "blur", "keydown", "id", "ngClass"], ["class", "cds--tree-node__label", 3, "padding-inline-start", "margin-inline-start", "click", 4, "ngIf"], ["class", "cds--tree-node__label", "role", "group", 3, "padding-inline-start", "margin-inline-start", "click", 4, "ngIf"], ["role", "group", "class", "cds--tree-node__children", 4, "ngIf"], [1, "cds--tree-node__label", 3, "click"], [4, "ngIf"], ["size", "16", 1, "cds--tree-node__icon", 3, "cdsIcon"], [3, "ngTemplateOutlet"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["role", "group", 1, "cds--tree-node__label", 3, "click"], [1, "cds--tree-parent-node__toggle", 3, "click"], ["ibmIcon", "caret--down", "size", "16", 1, "cds--tree-parent-node__toggle-icon", 3, "ngClass"], [1, "cds--tree-node__label__details"], ["role", "group", 1, "cds--tree-node__children"], [4, "ngIf", "ngIfElse"], [3, "node", "depth", "disabled", "nodetoggle", 4, "ngFor", "ngForOf"], [3, "nodetoggle", "node", "depth", "disabled"]],
  template: function TreeNodeComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 1);
      ɵɵlistener("focus", function TreeNodeComponent_Template_div_focus_0_listener($event) {
        return ctx.emitFocusEvent($event);
      })("blur", function TreeNodeComponent_Template_div_blur_0_listener($event) {
        return ctx.emitBlurEvent($event);
      })("keydown", function TreeNodeComponent_Template_div_keydown_0_listener($event) {
        return ctx.navigateTree($event);
      });
      ɵɵtemplate(1, TreeNodeComponent_div_1_Template, 5, 8, "div", 2)(2, TreeNodeComponent_div_2_Template, 8, 12, "div", 3)(3, TreeNodeComponent_div_3_Template, 4, 2, "div", 4);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("id", ctx.id)("ngClass", ɵɵpureFunction6(10, _c140, ctx.active, ctx.disabled, ctx.selected, !ctx.children.length, ctx.children.length, ctx.icon));
      ɵɵattribute("aria-expanded", ctx.expanded || null)("aria-current", ctx.active || null)("aria-selected", ctx.disabled ? null : ctx.selected)("aria-disabled", ctx.disabled)("tabindex", ctx.selected ? 0 : -1);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.children.length);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.children.length);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.expanded);
    }
  },
  dependencies: [NgClass, NgForOf, NgIf, NgTemplateOutlet, IconDirective, TreeNodeComponent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TreeNodeComponent, [{
    type: Component,
    args: [{
      selector: "cds-tree-node",
      template: `
		<div
			[id]="id"
			class="cds--tree-node"
			[ngClass]="{
				'cds--tree-node--active': active,
				'cds--tree-node--disabled': disabled,
				'cds--tree-node--selected': selected,
				'cds--tree-leaf-node': !children.length,
				'cds--tree-parent-node': children.length,
				'cds--tree-node--with-icon': icon
			}"
			[attr.aria-expanded]="expanded || null"
			[attr.aria-current]="active || null"
			[attr.aria-selected]="disabled ? null : selected"
			[attr.aria-disabled]="disabled"
			role="treeitem"
			[attr.tabindex]="selected ? 0 : -1"
			(focus)="emitFocusEvent($event)"
			(blur)="emitBlurEvent($event)"
			(keydown)="navigateTree($event)">
			<div
				*ngIf="!children.length"
				class="cds--tree-node__label"
				[style.padding-inline-start.rem]="offset"
				[style.margin-inline-start.rem]="-offset"
				(click)="nodeClick($event)">
				<!-- Icon -->
				<ng-container *ngIf="icon && !isTemplate(icon)">
					<svg
						class="cds--tree-node__icon"
						[cdsIcon]="icon"
						size="16">
					</svg>
				</ng-container>
				<ng-template *ngIf="isTemplate(icon)" [ngTemplateOutlet]="icon"></ng-template>
				<ng-container *ngIf="!isTemplate(label)">{{label}}</ng-container>
				<ng-template
					*ngIf="isTemplate(label)"
					[ngTemplateOutlet]="label"
					[ngTemplateOutletContext]="{ $implicit: labelContext }">
				</ng-template>
			</div>
			<div
				*ngIf="children.length"
				class="cds--tree-node__label"
				[style.padding-inline-start.rem]="offset"
				[style.margin-inline-start.rem]="-offset"
				role="group"
				(click)="nodeClick($event)">
				<span
					class="cds--tree-parent-node__toggle"
					[attr.disabled]="disabled || null"
					(click)="toggleExpanded($event)">
					<svg
						class="cds--tree-parent-node__toggle-icon"
						[ngClass]="{'cds--tree-parent-node__toggle-icon--expanded' : expanded}"
						ibmIcon="caret--down"
						size="16">
					</svg>
				</span>
				<span class="cds--tree-node__label__details">
					<!-- Icon -->
					<ng-container *ngIf="icon && !isTemplate(icon)">
						<svg
							class="cds--tree-node__icon"
							[cdsIcon]="icon"
							size="16">
						</svg>
					</ng-container>
					<ng-template
						*ngIf="isTemplate(icon)"
						[ngTemplateOutlet]="icon"
						[ngTemplateOutletContext]="{ $implicit: iconContext }">
					</ng-template>
					<ng-container *ngIf="!isTemplate(label)">{{label}}</ng-container>
					<ng-template
						*ngIf="isTemplate(label)"
						[ngTemplateOutlet]="label"
						[ngTemplateOutletContext]="{ $implicit: labelContext }">
					</ng-template>
				</span>
			</div>
			<div
				*ngIf="expanded"
				role="group"
				class="cds--tree-node__children">
				<ng-container *ngIf="isProjected(); else notProjected">
					<ng-content></ng-content>
				</ng-container>
				<ng-template #notProjected>
					<cds-tree-node
						*ngFor="let childNode of children"
						[node]="childNode"
						[depth]="depth + 1"
						[disabled]="disabled"
						(nodetoggle)="nodetoggle.emit($event)">
					</cds-tree-node>
				</ng-template>
			</div>
		</div>
	`
    }]
  }], function() {
    return [{
      type: TreeViewService
    }];
  }, {
    id: [{
      type: Input
    }],
    active: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    selectable: [{
      type: Input
    }],
    expanded: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    labelContext: [{
      type: Input
    }],
    selected: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    icon: [{
      type: Input
    }],
    iconContext: [{
      type: Input
    }],
    gap: [{
      type: Input
    }],
    children: [{
      type: Input
    }],
    depth: [{
      type: Input
    }],
    node: [{
      type: Input
    }],
    nodeFocus: [{
      type: Output
    }],
    nodeBlur: [{
      type: Output
    }],
    nodeSelect: [{
      type: Output
    }],
    nodetoggle: [{
      type: Output
    }]
  });
})();
var TreeViewComponent = class _TreeViewComponent {
  constructor(document2, treeViewService, elementRef) {
    this.document = document2;
    this.treeViewService = treeViewService;
    this.elementRef = elementRef;
    this.id = `tree-view-${_TreeViewComponent.treeViewCount++}`;
    this.size = "sm";
    this.select = new EventEmitter();
    this.toggle = new EventEmitter();
    this._tree = [];
  }
  /**
   * Pass `Node[]` array to have tree view render the nodes
   * Passing value will disregard projected content
   */
  set tree(treeNodes) {
    this._tree = treeNodes.map((node) => this.copyNode(node));
    this.treeViewService.contentProjected = false;
  }
  get tree() {
    return this._tree;
  }
  /**
   * **Experimental** - Enable to select multiple nodes
   */
  set isMultiSelect(isMulti) {
    this.treeViewService.isMultiSelect = isMulti;
  }
  /**
   * Subscribe for node selection
   */
  ngOnInit() {
    this.subscription = this.treeViewService.selectionObservable.subscribe((nodesMap) => {
      const nodes = [...nodesMap.values()];
      this.select.emit(this.treeViewService.isMultiSelect ? nodes : nodes[0]);
    });
    this.subscription.add(this.treeViewService.focusNodeObservable.subscribe((node) => this.onNodeFocusChange(node)));
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
  /**
   * Initialize tree walker to support keyboard navigation
   */
  ngAfterViewInit() {
    this.treeWalker = this.document.createTreeWalker(this.root.nativeElement, NodeFilter.SHOW_ELEMENT, {
      acceptNode: function(node) {
        if (node.classList.contains(`cds--tree-node--disabled`)) {
          return NodeFilter.FILTER_REJECT;
        }
        if (node.matches(`div.cds--tree-node`)) {
          return NodeFilter.FILTER_ACCEPT;
        }
        return NodeFilter.FILTER_SKIP;
      }
    });
  }
  /**
   * Navigate tree using tree walker
   * @param event - KeyboardEvent
   */
  navigateTree(event) {
    if (event.key === "ArrowUp") {
      this.treeWalker.previousNode()?.focus();
    }
    if (event.key === "ArrowDown") {
      this.treeWalker.nextNode()?.focus();
    }
  }
  /**
   * Propagate node toggle event
   * @param eventOnNode - EventOnNode
   */
  onNodeToggle(eventOnNode) {
    if (!eventOnNode) {
      return;
    }
    this.toggle.emit(eventOnNode.node);
  }
  /**
   * Node focus change
   * @param node - Node
   */
  onNodeFocusChange(node) {
    if (!node) {
      this.treeWalker.currentNode = this.treeWalker.root;
      return;
    }
    this.treeWalker.currentNode = this.elementRef.nativeElement.querySelector(`#${CSS.escape(node.id)}`);
  }
  isTemplate(value) {
    return value instanceof TemplateRef;
  }
  isProjected() {
    return this.treeViewService.contentProjected;
  }
  copyNode(node) {
    const copiedNode = Object.assign({}, node);
    if (node.children) {
      copiedNode.children = node.children.map((child) => this.copyNode(child));
    }
    return copiedNode;
  }
};
TreeViewComponent.treeViewCount = 0;
TreeViewComponent.ɵfac = function TreeViewComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TreeViewComponent)(ɵɵdirectiveInject(DOCUMENT), ɵɵdirectiveInject(TreeViewService), ɵɵdirectiveInject(ElementRef));
};
TreeViewComponent.ɵcmp = ɵɵdefineComponent({
  type: TreeViewComponent,
  selectors: [["cds-tree-view"]],
  viewQuery: function TreeViewComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c417, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.root = _t.first);
    }
  },
  inputs: {
    tree: "tree",
    id: "id",
    label: "label",
    labelContext: "labelContext",
    size: "size",
    isMultiSelect: "isMultiSelect"
  },
  outputs: {
    select: "select",
    toggle: "toggle"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([TreeViewService])],
  ngContentSelectors: _c041,
  decls: 6,
  vars: 10,
  consts: [["treeWrapper", ""], ["notProjected", ""], ["class", "cds--label", 3, "id", 4, "ngIf"], ["role", "tree", 1, "cds--tree", 3, "keydown", "ngClass"], [4, "ngIf", "ngIfElse"], [1, "cds--label", 3, "id"], [4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "node", "nodetoggle", 4, "ngFor", "ngForOf"], [3, "nodetoggle", "node"]],
  template: function TreeViewComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵprojectionDef();
      ɵɵtemplate(0, TreeViewComponent_label_0_Template, 3, 3, "label", 2);
      ɵɵelementStart(1, "div", 3, 0);
      ɵɵlistener("keydown", function TreeViewComponent_Template_div_keydown_1_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.navigateTree($event));
      });
      ɵɵtemplate(3, TreeViewComponent_ng_container_3_Template, 2, 0, "ng-container", 4)(4, TreeViewComponent_ng_template_4_Template, 1, 1, "ng-template", null, 1, ɵɵtemplateRefExtractor);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      const notProjected_r5 = ɵɵreference(5);
      ɵɵproperty("ngIf", ctx.label);
      ɵɵadvance();
      ɵɵproperty("ngClass", ɵɵpureFunction2(7, _c514, ctx.size === "sm", ctx.size === "xs"));
      ɵɵattribute("aria-label", ctx.label ? ctx.label : null)("aria-labelledby", !ctx.label ? ctx.id : null)("aria-multiselectable", ctx.isMultiSelect || null);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.isProjected())("ngIfElse", notProjected_r5);
    }
  },
  dependencies: [NgClass, NgForOf, NgIf, NgTemplateOutlet, TreeNodeComponent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TreeViewComponent, [{
    type: Component,
    args: [{
      selector: "cds-tree-view",
      template: `
		<label
			*ngIf="label"
			[id]="id"
			class="cds--label">
			<ng-container *ngIf="!isTemplate(label)">{{label}}</ng-container>
			<ng-template
				*ngIf="isTemplate(label)"
				[ngTemplateOutlet]="label"
				[ngTemplateOutletContext]="{ $implicit: labelContext }">
			</ng-template>
		</label>
		<div
			class="cds--tree"
			[ngClass]="{
				'cds--tree--sm': size === 'sm',
				'cds--tree--xs': size === 'xs'
			}"
			[attr.aria-label]="label ? label : null"
			[attr.aria-labelledby]="!label ? id : null"
			[attr.aria-multiselectable]="isMultiSelect || null"
			role="tree"
			(keydown)="navigateTree($event)"
			#treeWrapper>
			<ng-container *ngIf="isProjected(); else notProjected">
				<ng-content></ng-content>
			</ng-container>
			<ng-template #notProjected>
				<cds-tree-node
					*ngFor="let node of tree"
					[node]="node"
					(nodetoggle)="onNodeToggle($event)">
				</cds-tree-node>
			</ng-template>
		</div>
	`,
      providers: [TreeViewService]
    }]
  }], function() {
    return [{
      type: Document,
      decorators: [{
        type: Inject,
        args: [DOCUMENT]
      }]
    }, {
      type: TreeViewService
    }, {
      type: ElementRef
    }];
  }, {
    tree: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    labelContext: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    isMultiSelect: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    toggle: [{
      type: Output
    }],
    root: [{
      type: ViewChild,
      args: ["treeWrapper"]
    }]
  });
})();
var TreeviewModule = class {
};
TreeviewModule.ɵfac = function TreeviewModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TreeviewModule)();
};
TreeviewModule.ɵmod = ɵɵdefineNgModule({
  type: TreeviewModule,
  declarations: [TreeViewComponent, TreeNodeComponent],
  imports: [CommonModule, IconModule],
  exports: [TreeViewComponent, TreeNodeComponent]
});
TreeviewModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, IconModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TreeviewModule, [{
    type: NgModule,
    args: [{
      declarations: [TreeViewComponent, TreeNodeComponent],
      exports: [TreeViewComponent, TreeNodeComponent],
      imports: [CommonModule, IconModule]
    }]
  }], null, null);
})();

// node_modules/lodash-es/_baseTimes.js
function baseTimes(n, iteratee) {
  var index = -1, result = Array(n);
  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}
var baseTimes_default = baseTimes;

// node_modules/lodash-es/_freeGlobal.js
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal_default = freeGlobal;

// node_modules/lodash-es/_root.js
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal_default || freeSelf || Function("return this")();
var root_default = root;

// node_modules/lodash-es/_Symbol.js
var Symbol = root_default.Symbol;
var Symbol_default = Symbol;

// node_modules/lodash-es/_getRawTag.js
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
  try {
    value[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
var getRawTag_default = getRawTag;

// node_modules/lodash-es/_objectToString.js
var objectProto2 = Object.prototype;
var nativeObjectToString2 = objectProto2.toString;
function objectToString(value) {
  return nativeObjectToString2.call(value);
}
var objectToString_default = objectToString;

// node_modules/lodash-es/_baseGetTag.js
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
}
var baseGetTag_default = baseGetTag;

// node_modules/lodash-es/isObjectLike.js
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_default = isObjectLike;

// node_modules/lodash-es/_baseIsArguments.js
var argsTag = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == argsTag;
}
var baseIsArguments_default = baseIsArguments;

// node_modules/lodash-es/isArguments.js
var objectProto3 = Object.prototype;
var hasOwnProperty2 = objectProto3.hasOwnProperty;
var propertyIsEnumerable = objectProto3.propertyIsEnumerable;
var isArguments = baseIsArguments_default(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments_default : function(value) {
  return isObjectLike_default(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments_default = isArguments;

// node_modules/lodash-es/isArray.js
var isArray = Array.isArray;
var isArray_default = isArray;

// node_modules/lodash-es/stubFalse.js
function stubFalse() {
  return false;
}
var stubFalse_default = stubFalse;

// node_modules/lodash-es/isBuffer.js
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer = moduleExports ? root_default.Buffer : void 0;
var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse_default;
var isBuffer_default = isBuffer;

// node_modules/lodash-es/_isIndex.js
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}
var isIndex_default = isIndex;

// node_modules/lodash-es/isLength.js
var MAX_SAFE_INTEGER2 = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
}
var isLength_default = isLength;

// node_modules/lodash-es/_baseIsTypedArray.js
var argsTag2 = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var funcTag = "[object Function]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var objectTag = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag = "[object String]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray(value) {
  return isObjectLike_default(value) && isLength_default(value.length) && !!typedArrayTags[baseGetTag_default(value)];
}
var baseIsTypedArray_default = baseIsTypedArray;

// node_modules/lodash-es/_baseUnary.js
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var baseUnary_default = baseUnary;

// node_modules/lodash-es/_nodeUtil.js
var freeExports2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule2 = freeExports2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
var freeProcess = moduleExports2 && freeGlobal_default.process;
var nodeUtil = function() {
  try {
    var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
}();
var nodeUtil_default = nodeUtil;

// node_modules/lodash-es/isTypedArray.js
var nodeIsTypedArray = nodeUtil_default && nodeUtil_default.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary_default(nodeIsTypedArray) : baseIsTypedArray_default;
var isTypedArray_default = isTypedArray;

// node_modules/lodash-es/_arrayLikeKeys.js
var objectProto4 = Object.prototype;
var hasOwnProperty3 = objectProto4.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray_default(value), isArg = !isArr && isArguments_default(value), isBuff = !isArr && !isArg && isBuffer_default(value), isType = !isArr && !isArg && !isBuff && isTypedArray_default(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes_default(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty3.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex_default(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var arrayLikeKeys_default = arrayLikeKeys;

// node_modules/lodash-es/_isPrototype.js
var objectProto5 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto5;
  return value === proto;
}
var isPrototype_default = isPrototype;

// node_modules/lodash-es/_overArg.js
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var overArg_default = overArg;

// node_modules/lodash-es/_nativeKeys.js
var nativeKeys = overArg_default(Object.keys, Object);
var nativeKeys_default = nativeKeys;

// node_modules/lodash-es/_baseKeys.js
var objectProto6 = Object.prototype;
var hasOwnProperty4 = objectProto6.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype_default(object)) {
    return nativeKeys_default(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty4.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var baseKeys_default = baseKeys;

// node_modules/lodash-es/isObject.js
function isObject(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_default = isObject;

// node_modules/lodash-es/isFunction.js
var asyncTag = "[object AsyncFunction]";
var funcTag2 = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == funcTag2 || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_default = isFunction;

// node_modules/lodash-es/isArrayLike.js
function isArrayLike(value) {
  return value != null && isLength_default(value.length) && !isFunction_default(value);
}
var isArrayLike_default = isArrayLike;

// node_modules/lodash-es/keys.js
function keys(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object) : baseKeys_default(object);
}
var keys_default = keys;

// node_modules/carbon-components-angular/fesm2020/carbon-components-angular-ui-shell.mjs
var _c042 = [[["cds-hamburger"], ["ibm-hamburger"]], "*"];
var _c141 = ["cds-hamburger,ibm-hamburger", "*"];
function Header_a_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 4);
    ɵɵtext(1);
    ɵɵpipe(2, "async");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("href", ctx_r0.skipTo, ɵɵsanitizeUrl);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind1(2, 2, ctx_r0.i18n.get("UI_SHELL.SKIP_TO")), " ");
  }
}
function Header_3_ng_template_0_Template(rf, ctx) {
}
function Header_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, Header_3_ng_template_0_Template, 0, 0, "ng-template", 5);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.brand);
  }
}
function Header_ng_container_4_a_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 9);
    ɵɵlistener("click", function Header_ng_container_4_a_1_Template_a_click_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.navigate($event));
    });
    ɵɵelementStart(1, "span", 10);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵtext(3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("href", ctx_r0.href, ɵɵsanitizeUrl);
    ɵɵadvance(2);
    ɵɵtextInterpolate1("", ctx_r0.brand, " ");
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.name, " ");
  }
}
function Header_ng_container_4_a_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 11)(1, "span", 10);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵtext(3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("routerLink", ctx_r0.route);
    ɵɵadvance(2);
    ɵɵtextInterpolate1("", ctx_r0.brand, " ");
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.name, " ");
  }
}
function Header_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0, 6);
    ɵɵtemplate(1, Header_ng_container_4_a_1_Template, 4, 3, "a", 7)(2, Header_ng_container_4_a_2_Template, 4, 3, "a", 8);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngSwitch", ctx_r0.useRouter);
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", false);
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", true);
  }
}
var _c231 = ["*"];
var _c324 = (a0) => ({
  "cds--header__menu-item--current": a0
});
var _c418 = () => ["cds--header__menu-item--current"];
function HeaderItem_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
function HeaderItem_a_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function HeaderItem_a_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 4);
    ɵɵlistener("click", function HeaderItem_a_3_Template_a_click_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.navigate($event));
    });
    ɵɵtemplate(1, HeaderItem_a_3_ng_container_1_Template, 1, 0, "ng-container", 5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const content_r3 = ɵɵreference(2);
    ɵɵproperty("ngClass", ɵɵpureFunction1(3, _c324, ctx_r1.isCurrentPage))("href", ctx_r1.href, ɵɵsanitizeUrl);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", content_r3);
  }
}
function HeaderItem_a_4_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function HeaderItem_a_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 6);
    ɵɵtemplate(1, HeaderItem_a_4_ng_container_1_Template, 1, 0, "ng-container", 5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const content_r3 = ɵɵreference(2);
    ɵɵproperty("routerLinkActive", ɵɵpureFunction0(5, _c418))("ngClass", ɵɵpureFunction1(6, _c324, ctx_r1.isCurrentPage))("routerLink", ctx_r1.route)("routerLinkActive", ctx_r1.activeLinkClass);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", content_r3);
  }
}
function HeaderMenu_2_ng_template_0_Template(rf, ctx) {
}
function HeaderMenu_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, HeaderMenu_2_ng_template_0_Template, 0, 0, "ng-template", 5);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.icon);
  }
}
function HeaderMenu_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "svg", 6);
    ɵɵelement(1, "path", 7);
    ɵɵelementEnd();
  }
}
function HeaderMenu_ng_container_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "cds-header-item", 8);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const headerItem_r3 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("href", headerItem_r3.href)("route", headerItem_r3.route)("routeExtras", headerItem_r3.routeExtras);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", headerItem_r3.content, " ");
  }
}
function HeaderNavigation_ng_container_3_cds_header_item_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "cds-header-item", 5);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const navigationItem_r1 = ɵɵnextContext().$implicit;
    ɵɵproperty("href", navigationItem_r1.href)("route", navigationItem_r1.route)("routeExtras", navigationItem_r1.routeExtras)("isCurrentPage", !!navigationItem_r1.isCurrentPage);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", navigationItem_r1.content, " ");
  }
}
function HeaderNavigation_ng_container_3_cds_header_menu_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-header-menu", 6);
  }
  if (rf & 2) {
    const navigationItem_r1 = ɵɵnextContext().$implicit;
    ɵɵproperty("href", navigationItem_r1.href)("title", navigationItem_r1.title)("trigger", navigationItem_r1.trigger ? navigationItem_r1.trigger : "click")("headerItems", navigationItem_r1.menuItems);
  }
}
function HeaderNavigation_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, HeaderNavigation_ng_container_3_cds_header_item_1_Template, 2, 5, "cds-header-item", 3)(2, HeaderNavigation_ng_container_3_cds_header_menu_2_Template, 1, 4, "cds-header-menu", 4);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const navigationItem_r1 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", navigationItem_r1.type === "item");
    ɵɵadvance();
    ɵɵproperty("ngIf", navigationItem_r1.type === "menu");
  }
}
var _c515 = (a0) => ({
  "cds--header__action": true,
  "cds--header__action--active": a0
});
var _c611 = (a0) => ({
  "aria-label": a0
});
var _c78 = (a0) => ({
  "cds--header__action--active": a0
});
function Hamburger__svg_svg_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 3);
  }
}
function Hamburger__svg_svg_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 4);
  }
}
var _c88 = ["*", [["svg"], ["", "icon", ""]]];
var _c97 = ["*", "svg, [icon]"];
var _c106 = (a0) => ({
  "cds--side-nav__item--active": a0
});
function SideNavItem_a_0_ng_template_1_Template(rf, ctx) {
}
function SideNavItem_a_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 3);
    ɵɵlistener("click", function SideNavItem_a_0_Template_a_click_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.navigate($event));
    });
    ɵɵtemplate(1, SideNavItem_a_0_ng_template_1_Template, 0, 0, "ng-template", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const sidenavItemContentTpl_r3 = ɵɵreference(4);
    ɵɵproperty("ngClass", ɵɵpureFunction1(5, _c106, ctx_r1.active))("href", ctx_r1.href, ɵɵsanitizeUrl);
    ɵɵattribute("aria-current", ctx_r1.active ? "page" : null)("title", ctx_r1.title ? ctx_r1.title : null);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", sidenavItemContentTpl_r3);
  }
}
function SideNavItem_ng_template_1_ng_template_1_Template(rf, ctx) {
}
function SideNavItem_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 5);
    ɵɵtemplate(1, SideNavItem_ng_template_1_ng_template_1_Template, 0, 0, "ng-template", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const sidenavItemContentTpl_r3 = ɵɵreference(4);
    ɵɵproperty("routerLink", ctx_r1.route)("routeExtras", ctx_r1.routeExtras);
    ɵɵattribute("title", ctx_r1.title ? ctx_r1.title : null);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", sidenavItemContentTpl_r3);
  }
}
function SideNavItem_ng_template_3_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 8);
    ɵɵprojection(1, 1);
    ɵɵelementEnd();
  }
}
function SideNavItem_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, SideNavItem_ng_template_3_div_0_Template, 2, 0, "div", 6);
    ɵɵelementStart(1, "span", 7);
    ɵɵprojection(2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngIf", !ctx_r1.isSubMenu);
  }
}
var _c1112 = [[["svg"], ["", "icon", ""]], "*"];
var _c1211 = ["svg, [icon]", "*"];
function SideNavMenu_ng_container_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "cds-sidenav-item", 8);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const menuItem_r1 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("href", menuItem_r1.href)("route", menuItem_r1.route)("routeExtras", menuItem_r1.routeExtras)("useRouter", ctx_r1.useRouter)("isSubMenu", true);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", menuItem_r1.content, " ");
  }
}
var _c1310 = [[["cds-sidenav-header"], ["ibm-sidenav-header"]], "*"];
var _c143 = ["cds-sidenav-header,ibm-sidenav-header", "*"];
function SideNav_ng_container_4_cds_sidenav_item_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "cds-sidenav-item", 8);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const navigationItem_r1 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("href", navigationItem_r1.href)("route", navigationItem_r1.route)("routeExtras", navigationItem_r1.routeExtras)("useRouter", ctx_r1.useRouter)("title", navigationItem_r1.title);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", navigationItem_r1.content, " ");
  }
}
function SideNav_ng_container_4_cds_sidenav_menu_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-sidenav-menu", 9);
  }
  if (rf & 2) {
    const navigationItem_r1 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("title", navigationItem_r1.title)("useRouter", ctx_r1.useRouter)("menuItems", navigationItem_r1.menuItems);
  }
}
function SideNav_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, SideNav_ng_container_4_cds_sidenav_item_1_Template, 2, 6, "cds-sidenav-item", 6)(2, SideNav_ng_container_4_cds_sidenav_menu_2_Template, 1, 3, "cds-sidenav-menu", 7);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const navigationItem_r1 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", navigationItem_r1.type === "item");
    ɵɵadvance();
    ɵɵproperty("ngIf", navigationItem_r1.type === "menu");
  }
}
function SideNav_button_7__svg_svg_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "svg", 14);
    ɵɵelement(1, "path", 15);
    ɵɵelementEnd();
  }
}
function SideNav_button_7__svg_svg_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "svg", 14);
    ɵɵelement(1, "path", 16);
    ɵɵelementEnd();
  }
}
function SideNav_button_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 10);
    ɵɵpipe(1, "async");
    ɵɵlistener("click", function SideNav_button_7_Template_button_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.toggle());
    });
    ɵɵelementStart(2, "div", 11);
    ɵɵtemplate(3, SideNav_button_7__svg_svg_3_Template, 2, 0, "svg", 12)(4, SideNav_button_7__svg_svg_4_Template, 2, 0, "svg", 12);
    ɵɵelementEnd();
    ɵɵelementStart(5, "span", 13);
    ɵɵtext(6);
    ɵɵpipe(7, "async");
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("title", ɵɵpipeBind1(1, 4, ctx_r1.expanded ? ctx_r1.i18n.get("UI_SHELL.SIDE_NAV.TOGGLE_CLOSE") : ctx_r1.i18n.get("UI_SHELL.SIDE_NAV.TOGGLE_OPEN")));
    ɵɵadvance(3);
    ɵɵproperty("ngIf", ctx_r1.expanded);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.expanded);
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ɵɵpipeBind1(7, 6, ctx_r1.expanded ? ctx_r1.i18n.get("UI_SHELL.SIDE_NAV.TOGGLE_CLOSE") : ctx_r1.i18n.get("UI_SHELL.SIDE_NAV.TOGGLE_OPEN")), " ");
  }
}
var _c153 = (a0) => ({
  "cds--header-panel--expanded": a0
});
var _c163 = (a0) => ({
  "cds--switcher__item-link--selected": a0
});
var Header = class {
  constructor(i18n, domSanitizer, router) {
    this.i18n = i18n;
    this.domSanitizer = domSanitizer;
    this.router = router;
    this.brand = "IBM";
    this.useRouter = false;
    this.navigation = new EventEmitter();
    this._href = "#";
  }
  /**
   * Optional link for the header
   */
  set href(v) {
    this._href = v;
  }
  get href() {
    return this.domSanitizer.bypassSecurityTrustUrl(this._href);
  }
  isTemplate(value) {
    return value instanceof TemplateRef;
  }
  navigate(event) {
    if (this.router && this.route) {
      event.preventDefault();
      const status = this.router.navigate(this.route, this.routeExtras);
      this.navigation.emit(status);
    } else if (this._href === "#") {
      event.preventDefault();
    }
  }
};
Header.ɵfac = function Header_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Header)(ɵɵdirectiveInject(I18n), ɵɵdirectiveInject(DomSanitizer), ɵɵdirectiveInject(Router, 8));
};
Header.ɵcmp = ɵɵdefineComponent({
  type: Header,
  selectors: [["cds-header"], ["ibm-header"]],
  inputs: {
    skipTo: "skipTo",
    name: "name",
    brand: "brand",
    href: "href",
    route: "route",
    routeExtras: "routeExtras",
    useRouter: "useRouter"
  },
  outputs: {
    navigation: "navigation"
  },
  standalone: false,
  ngContentSelectors: _c141,
  decls: 6,
  vars: 4,
  consts: [[1, "cds--header"], ["class", "cds--skip-to-content", "tabindex", "0", 3, "href", 4, "ngIf"], [4, "ngIf"], [3, "ngSwitch", 4, "ngIf"], ["tabindex", "0", 1, "cds--skip-to-content", 3, "href"], [3, "ngTemplateOutlet"], [3, "ngSwitch"], ["class", "cds--header__name", 3, "href", "click", 4, "ngSwitchCase"], ["class", "cds--header__name", 3, "routerLink", 4, "ngSwitchCase"], [1, "cds--header__name", 3, "click", "href"], [1, "cds--header__name--prefix"], [1, "cds--header__name", 3, "routerLink"]],
  template: function Header_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c042);
      ɵɵelementStart(0, "header", 0);
      ɵɵtemplate(1, Header_a_1_Template, 3, 4, "a", 1);
      ɵɵprojection(2);
      ɵɵtemplate(3, Header_3_Template, 1, 1, null, 2)(4, Header_ng_container_4_Template, 3, 3, "ng-container", 3);
      ɵɵprojection(5, 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵattribute("aria-label", ctx.brand + " " + ctx.name);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.skipTo);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.isTemplate(ctx.brand));
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.isTemplate(ctx.brand));
    }
  },
  dependencies: [NgIf, NgTemplateOutlet, NgSwitch, NgSwitchCase, RouterLink, AsyncPipe],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Header, [{
    type: Component,
    args: [{
      selector: "cds-header, ibm-header",
      template: `
		<header
			class="cds--header"
			[attr.aria-label]="brand + ' ' + name">
			<a
				*ngIf="skipTo"
				class="cds--skip-to-content"
				[href]="skipTo"
				tabindex="0">
				{{ i18n.get("UI_SHELL.SKIP_TO") | async }}
			</a>
			<ng-content select="cds-hamburger,ibm-hamburger"></ng-content>
			<ng-template
				*ngIf="isTemplate(brand)"
				[ngTemplateOutlet]="brand">
			</ng-template>
			<ng-container *ngIf="!isTemplate(brand)" [ngSwitch]="useRouter">
				<a
					*ngSwitchCase="false"
					class="cds--header__name"
					[href]="href"
					(click)="navigate($event)">
					<span class="cds--header__name--prefix">{{brand}}&nbsp;</span>
					{{name}}
				</a>
				<a
					*ngSwitchCase="true"
					class="cds--header__name"
					[routerLink]="route">
					<span class="cds--header__name--prefix">{{brand}}&nbsp;</span>
					{{name}}
				</a>
			</ng-container>
			<ng-content></ng-content>
		</header>
	`
    }]
  }], function() {
    return [{
      type: I18n
    }, {
      type: DomSanitizer
    }, {
      type: Router,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    skipTo: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    brand: [{
      type: Input
    }],
    href: [{
      type: Input
    }],
    route: [{
      type: Input
    }],
    routeExtras: [{
      type: Input
    }],
    useRouter: [{
      type: Input
    }],
    navigation: [{
      type: Output
    }]
  });
})();
var HeaderItem = class {
  constructor(domSanitizer, router) {
    this.domSanitizer = domSanitizer;
    this.router = router;
    this.role = "listitem";
    this.useRouter = false;
    this.navigation = new EventEmitter();
    this._href = "#";
  }
  set href(v) {
    if (v === void 0) {
      return;
    }
    this._href = v;
  }
  get href() {
    return this.domSanitizer.bypassSecurityTrustUrl(this._href);
  }
  navigate(event) {
    if (this.router && this.route) {
      event.preventDefault();
      const status = this.router.navigate(this.route, this.routeExtras);
      this.navigation.emit(status);
    } else if (this._href === "#") {
      event.preventDefault();
    }
  }
};
HeaderItem.ɵfac = function HeaderItem_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || HeaderItem)(ɵɵdirectiveInject(DomSanitizer), ɵɵdirectiveInject(Router, 8));
};
HeaderItem.ɵcmp = ɵɵdefineComponent({
  type: HeaderItem,
  selectors: [["cds-header-item"], ["ibm-header-item"]],
  hostVars: 1,
  hostBindings: function HeaderItem_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", ctx.role);
    }
  },
  inputs: {
    href: "href",
    useRouter: "useRouter",
    activeLinkClass: "activeLinkClass",
    isCurrentPage: "isCurrentPage",
    route: "route",
    routeExtras: "routeExtras"
  },
  outputs: {
    navigation: "navigation"
  },
  standalone: false,
  ngContentSelectors: _c231,
  decls: 5,
  vars: 3,
  consts: [["content", ""], [3, "ngSwitch"], ["class", "cds--header__menu-item", "tabindex", "0", 3, "ngClass", "href", "click", 4, "ngSwitchCase"], ["class", "cds--header__menu-item", "tabindex", "0", 3, "routerLinkActive", "ngClass", "routerLink", 4, "ngSwitchCase"], ["tabindex", "0", 1, "cds--header__menu-item", 3, "click", "ngClass", "href"], [4, "ngTemplateOutlet"], ["tabindex", "0", 1, "cds--header__menu-item", 3, "routerLinkActive", "ngClass", "routerLink"]],
  template: function HeaderItem_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementContainerStart(0, 1);
      ɵɵtemplate(1, HeaderItem_ng_template_1_Template, 1, 0, "ng-template", null, 0, ɵɵtemplateRefExtractor)(3, HeaderItem_a_3_Template, 2, 5, "a", 2)(4, HeaderItem_a_4_Template, 2, 8, "a", 3);
      ɵɵelementContainerEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngSwitch", ctx.useRouter);
      ɵɵadvance(3);
      ɵɵproperty("ngSwitchCase", false);
      ɵɵadvance();
      ɵɵproperty("ngSwitchCase", true);
    }
  },
  dependencies: [NgClass, NgTemplateOutlet, NgSwitch, NgSwitchCase, RouterLink, RouterLinkActive],
  styles: ["[_nghost-%COMP%]{display:list-item}"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeaderItem, [{
    type: Component,
    args: [{
      selector: "cds-header-item, ibm-header-item",
      template: `
		<ng-container [ngSwitch]="useRouter">
			<ng-template #content><ng-content></ng-content></ng-template>
			<a
				*ngSwitchCase="false"
				class="cds--header__menu-item"
				tabindex="0"
				[ngClass]="{'cds--header__menu-item--current' : isCurrentPage}"
				[href]="href"
				(click)="navigate($event)">
				<ng-container *ngTemplateOutlet="content"></ng-container>
			</a>
			<a
				*ngSwitchCase="true"
				class="cds--header__menu-item"
				[routerLinkActive]="['cds--header__menu-item--current']"
				tabindex="0"
				[ngClass]="{'cds--header__menu-item--current' : isCurrentPage}"
				[routerLink]="route"
				[routerLinkActive]="activeLinkClass">
				<ng-container *ngTemplateOutlet="content"></ng-container>
			</a>
		</ng-container>
	`,
      styles: [":host{display:list-item}\n"]
    }]
  }], function() {
    return [{
      type: DomSanitizer
    }, {
      type: Router,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    href: [{
      type: Input
    }],
    useRouter: [{
      type: Input
    }],
    activeLinkClass: [{
      type: Input
    }],
    isCurrentPage: [{
      type: Input
    }],
    route: [{
      type: Input
    }],
    routeExtras: [{
      type: Input
    }],
    navigation: [{
      type: Output
    }]
  });
})();
var HeaderMenu = class {
  constructor(domSanitizer, elementRef) {
    this.domSanitizer = domSanitizer;
    this.elementRef = elementRef;
    this.subMenu = true;
    this.role = "listitem";
    this.trigger = "click";
    this.expanded = false;
    this._href = "#";
  }
  set href(v) {
    if (v === void 0) {
      return;
    }
    this._href = v;
  }
  get href() {
    return this.domSanitizer.bypassSecurityTrustUrl(this._href);
  }
  onClick() {
    if (this.trigger === "click") {
      this.expanded = !this.expanded;
    }
  }
  onMouseOver() {
    if (this.trigger === "mouseover") {
      this.expanded = true;
    }
  }
  onMouseOut() {
    if (this.trigger === "mouseover") {
      this.expanded = false;
    }
  }
  onFocusOut(event) {
    if (!this.elementRef.nativeElement.contains(event.relatedTarget)) {
      this.expanded = false;
    }
  }
  navigate(event) {
    if (this._href === "#") {
      event.preventDefault();
    }
  }
};
HeaderMenu.ɵfac = function HeaderMenu_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || HeaderMenu)(ɵɵdirectiveInject(DomSanitizer), ɵɵdirectiveInject(ElementRef));
};
HeaderMenu.ɵcmp = ɵɵdefineComponent({
  type: HeaderMenu,
  selectors: [["cds-header-menu"], ["ibm-header-menu"]],
  hostVars: 3,
  hostBindings: function HeaderMenu_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function HeaderMenu_click_HostBindingHandler() {
        return ctx.onClick();
      })("mouseover", function HeaderMenu_mouseover_HostBindingHandler() {
        return ctx.onMouseOver();
      })("mouseout", function HeaderMenu_mouseout_HostBindingHandler() {
        return ctx.onMouseOut();
      })("focusout", function HeaderMenu_focusout_HostBindingHandler($event) {
        return ctx.onFocusOut($event);
      });
    }
    if (rf & 2) {
      ɵɵattribute("role", ctx.role);
      ɵɵclassProp("cds--header__submenu", ctx.subMenu);
    }
  },
  inputs: {
    title: "title",
    href: "href",
    trigger: "trigger",
    headerItems: "headerItems",
    icon: "icon"
  },
  standalone: false,
  ngContentSelectors: _c231,
  decls: 8,
  vars: 7,
  consts: [["defaultIcon", ""], ["tabindex", "0", "aria-haspopup", "menu", 1, "cds--header__menu-item", "cds--header__menu-title", 3, "click", "href"], [4, "ngIf", "ngIfElse"], [1, "cds--header__menu"], [4, "ngFor", "ngForOf"], [3, "ngTemplateOutlet"], ["width", "12", "height", "7", "aria-hidden", "true", 1, "cds--header__menu-arrow"], ["d", "M6.002 5.55L11.27 0l.726.685L6.003 7 0 .685.726 0z"], [3, "href", "route", "routeExtras"]],
  template: function HeaderMenu_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵprojectionDef();
      ɵɵelementStart(0, "a", 1);
      ɵɵlistener("click", function HeaderMenu_Template_a_click_0_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.navigate($event));
      });
      ɵɵtext(1);
      ɵɵtemplate(2, HeaderMenu_2_Template, 1, 1, null, 2)(3, HeaderMenu_ng_template_3_Template, 2, 0, "ng-template", null, 0, ɵɵtemplateRefExtractor);
      ɵɵelementEnd();
      ɵɵelementStart(5, "div", 3);
      ɵɵprojection(6);
      ɵɵtemplate(7, HeaderMenu_ng_container_7_Template, 3, 4, "ng-container", 4);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      const defaultIcon_r4 = ɵɵreference(4);
      ɵɵproperty("href", ctx.href, ɵɵsanitizeUrl);
      ɵɵattribute("aria-expanded", ctx.expanded);
      ɵɵadvance();
      ɵɵtextInterpolate1(" ", ctx.title, " ");
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.icon)("ngIfElse", defaultIcon_r4);
      ɵɵadvance(3);
      ɵɵattribute("aria-label", ctx.title);
      ɵɵadvance(2);
      ɵɵproperty("ngForOf", ctx.headerItems);
    }
  },
  dependencies: [NgForOf, NgIf, NgTemplateOutlet, HeaderItem],
  styles: ["[_nghost-%COMP%]{display:list-item}"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeaderMenu, [{
    type: Component,
    args: [{
      selector: "cds-header-menu, ibm-header-menu",
      template: `
		<a
			class="cds--header__menu-item cds--header__menu-title"
			[href]="href"
			tabindex="0"
			aria-haspopup="menu"
			[attr.aria-expanded]="expanded"
			(click)="navigate($event)">
			{{title}}
			<ng-template *ngIf="icon; else defaultIcon" [ngTemplateOutlet]="icon"></ng-template>
			<ng-template #defaultIcon>
				<svg class="cds--header__menu-arrow" width="12" height="7" aria-hidden="true">
					<path d="M6.002 5.55L11.27 0l.726.685L6.003 7 0 .685.726 0z" />
				</svg>
			</ng-template>
		</a>
		<div class="cds--header__menu" [attr.aria-label]="title">
			<ng-content></ng-content>
			<ng-container *ngFor="let headerItem of headerItems">
				<cds-header-item
					[href]="headerItem.href"
					[route]="headerItem.route"
					[routeExtras]="headerItem.routeExtras">
					{{ headerItem.content }}
				</cds-header-item>
			</ng-container>
		</div>
	`,
      styles: [":host{display:list-item}\n"]
    }]
  }], function() {
    return [{
      type: DomSanitizer
    }, {
      type: ElementRef
    }];
  }, {
    subMenu: [{
      type: HostBinding,
      args: ["class.cds--header__submenu"]
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    title: [{
      type: Input
    }],
    href: [{
      type: Input
    }],
    trigger: [{
      type: Input
    }],
    headerItems: [{
      type: Input
    }],
    icon: [{
      type: Input
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }],
    onMouseOver: [{
      type: HostListener,
      args: ["mouseover"]
    }],
    onMouseOut: [{
      type: HostListener,
      args: ["mouseout"]
    }],
    onFocusOut: [{
      type: HostListener,
      args: ["focusout", ["$event"]]
    }]
  });
})();
var HeaderNavigation = class {
  constructor() {
    this.height = 100;
  }
};
HeaderNavigation.ɵfac = function HeaderNavigation_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || HeaderNavigation)();
};
HeaderNavigation.ɵcmp = ɵɵdefineComponent({
  type: HeaderNavigation,
  selectors: [["cds-header-navigation"], ["ibm-header-navigation"]],
  hostVars: 2,
  hostBindings: function HeaderNavigation_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵstyleProp("height", ctx.height, "%");
    }
  },
  inputs: {
    ariaLabel: "ariaLabel",
    navigationItems: "navigationItems"
  },
  standalone: false,
  ngContentSelectors: _c231,
  decls: 4,
  vars: 2,
  consts: [[1, "cds--header__nav"], ["role", "list", 1, "cds--header__menu-bar"], [4, "ngFor", "ngForOf"], [3, "href", "route", "routeExtras", "isCurrentPage", 4, "ngIf"], [3, "href", "title", "trigger", "headerItems", 4, "ngIf"], [3, "href", "route", "routeExtras", "isCurrentPage"], [3, "href", "title", "trigger", "headerItems"]],
  template: function HeaderNavigation_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "nav", 0)(1, "div", 1);
      ɵɵprojection(2);
      ɵɵtemplate(3, HeaderNavigation_ng_container_3_Template, 3, 2, "ng-container", 2);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵattribute("aria-label", ctx.ariaLabel);
      ɵɵadvance(3);
      ɵɵproperty("ngForOf", ctx.navigationItems);
    }
  },
  dependencies: [NgForOf, NgIf, HeaderItem, HeaderMenu],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeaderNavigation, [{
    type: Component,
    args: [{
      selector: "cds-header-navigation, ibm-header-navigation",
      template: `
		<nav class="cds--header__nav" [attr.aria-label]="ariaLabel">
			<div class="cds--header__menu-bar" role="list">
				<ng-content></ng-content>
				<ng-container *ngFor="let navigationItem of navigationItems">
					<cds-header-item
						*ngIf="navigationItem.type === 'item'"
						[href]="navigationItem.href"
						[route]="navigationItem.route"
						[routeExtras]="navigationItem.routeExtras"
						[isCurrentPage]="!!navigationItem.isCurrentPage">
						{{ navigationItem.content }}
					</cds-header-item>
					<cds-header-menu
						*ngIf="navigationItem.type === 'menu'"
						[href]="navigationItem.href"
						[title]="navigationItem.title"
						[trigger]="navigationItem.trigger ? navigationItem.trigger : 'click'"
						[headerItems]="navigationItem.menuItems">
					</cds-header-menu>
				</ng-container>
			</div>
		</nav>
	`
    }]
  }], null, {
    height: [{
      type: HostBinding,
      args: ["style.height.%"]
    }],
    ariaLabel: [{
      type: Input
    }],
    navigationItems: [{
      type: Input
    }]
  });
})();
var HeaderGlobal = class {
  constructor() {
    this.hostClass = true;
  }
};
HeaderGlobal.ɵfac = function HeaderGlobal_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || HeaderGlobal)();
};
HeaderGlobal.ɵcmp = ɵɵdefineComponent({
  type: HeaderGlobal,
  selectors: [["cds-header-global"], ["ibm-header-global"]],
  hostVars: 2,
  hostBindings: function HeaderGlobal_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--header__global", ctx.hostClass);
    }
  },
  standalone: false,
  ngContentSelectors: _c231,
  decls: 1,
  vars: 0,
  template: function HeaderGlobal_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeaderGlobal, [{
    type: Component,
    args: [{
      selector: "cds-header-global, ibm-header-global",
      template: `
		<ng-content></ng-content>
	`
    }]
  }], null, {
    hostClass: [{
      type: HostBinding,
      args: ["class.cds--header__global"]
    }]
  });
})();
var HeaderAction = class extends BaseIconButton {
  constructor() {
    super(...arguments);
    this.active = false;
    this.activeChange = new EventEmitter();
    this.selected = new EventEmitter();
  }
  onClick() {
    this.active = !this.active;
    this.selected.emit(this.active);
    this.activeChange.emit(this.active);
  }
};
HeaderAction.ɵfac = /* @__PURE__ */ (() => {
  let ɵHeaderAction_BaseFactory;
  return function HeaderAction_Factory(__ngFactoryType__) {
    return (ɵHeaderAction_BaseFactory || (ɵHeaderAction_BaseFactory = ɵɵgetInheritedFactory(HeaderAction)))(__ngFactoryType__ || HeaderAction);
  };
})();
HeaderAction.ɵcmp = ɵɵdefineComponent({
  type: HeaderAction,
  selectors: [["cds-header-action"], ["ibm-header-action"]],
  inputs: {
    description: "description",
    ariaLabel: "ariaLabel",
    active: "active"
  },
  outputs: {
    activeChange: "activeChange",
    selected: "selected"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c231,
  decls: 2,
  vars: 14,
  consts: [[3, "click", "buttonNgClass", "align", "caret", "dropShadow", "highContrast", "isOpen", "enterDelayMs", "leaveDelayMs", "description", "buttonAttributes"]],
  template: function HeaderAction_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "cds-icon-button", 0);
      ɵɵlistener("click", function HeaderAction_Template_cds_icon_button_click_0_listener() {
        return ctx.onClick();
      });
      ɵɵprojection(1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("buttonNgClass", ɵɵpureFunction1(10, _c515, ctx.active))("align", ctx.align)("caret", ctx.caret)("dropShadow", ctx.dropShadow)("highContrast", ctx.highContrast)("isOpen", ctx.isOpen)("enterDelayMs", ctx.enterDelayMs)("leaveDelayMs", ctx.leaveDelayMs)("description", ctx.description)("buttonAttributes", ɵɵpureFunction1(12, _c611, ctx.ariaLabel));
    }
  },
  dependencies: [IconButton],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeaderAction, [{
    type: Component,
    args: [{
      selector: "cds-header-action, ibm-header-action",
      template: `
		<cds-icon-button
			[buttonNgClass]="{
				'cds--header__action': true,
				'cds--header__action--active': active
			}"
			(click)="onClick()"
			[align]="align"
			[caret]="caret"
			[dropShadow]="dropShadow"
			[highContrast]="highContrast"
			[isOpen]="isOpen"
			[enterDelayMs]="enterDelayMs"
			[leaveDelayMs]="leaveDelayMs"
			[description]="description"
			[buttonAttributes]="{
				'aria-label': ariaLabel
			}">
			<ng-content></ng-content>
		</cds-icon-button>
	`
    }]
  }], null, {
    description: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    active: [{
      type: Input
    }],
    activeChange: [{
      type: Output
    }],
    selected: [{
      type: Output
    }]
  });
})();
var Hamburger = class {
  constructor(i18n) {
    this.i18n = i18n;
    this.active = false;
    this.activeTitle = this.i18n.get().UI_SHELL.HEADER.CLOSE_MENU;
    this.inactiveTitle = this.i18n.get().UI_SHELL.HEADER.OPEN_MENU;
    this.selected = new EventEmitter();
  }
  /**
   * Emit the Hamburger click event upwards.
   */
  doClick() {
    this.selected.emit(this.active);
  }
};
Hamburger.ɵfac = function Hamburger_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Hamburger)(ɵɵdirectiveInject(I18n));
};
Hamburger.ɵcmp = ɵɵdefineComponent({
  type: Hamburger,
  selectors: [["cds-hamburger"], ["ibm-hamburger"]],
  inputs: {
    active: "active",
    activeTitle: "activeTitle",
    inactiveTitle: "inactiveTitle"
  },
  outputs: {
    selected: "selected"
  },
  standalone: false,
  decls: 3,
  vars: 7,
  consts: [["type", "button", 1, "cds--header__menu-trigger", "cds--header__action", "cds--header__menu-toggle", 3, "click", "ngClass"], ["cdsIcon", "menu", "size", "20", 4, "ngIf"], ["cdsIcon", "close", "size", "20", 4, "ngIf"], ["cdsIcon", "menu", "size", "20"], ["cdsIcon", "close", "size", "20"]],
  template: function Hamburger_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "button", 0);
      ɵɵlistener("click", function Hamburger_Template_button_click_0_listener() {
        return ctx.doClick();
      });
      ɵɵtemplate(1, Hamburger__svg_svg_1_Template, 1, 0, "svg", 1)(2, Hamburger__svg_svg_2_Template, 1, 0, "svg", 2);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngClass", ɵɵpureFunction1(5, _c78, ctx.active));
      ɵɵattribute("aria-label", ctx.active ? ctx.activeTitle : ctx.inactiveTitle)("title", ctx.active ? ctx.activeTitle : ctx.inactiveTitle);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.active);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.active);
    }
  },
  dependencies: [NgClass, NgIf, IconDirective],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Hamburger, [{
    type: Component,
    args: [{
      selector: "cds-hamburger, ibm-hamburger",
      template: `
		<button
			type="button"
			(click)="doClick()"
			[ngClass]="{'cds--header__action--active': active}"
			class="cds--header__menu-trigger cds--header__action cds--header__menu-toggle"
			[attr.aria-label]="active ? activeTitle : inactiveTitle"
			[attr.title]="active ? activeTitle : inactiveTitle">
			<svg *ngIf="!active" cdsIcon="menu" size="20"></svg>
			<svg *ngIf="active" cdsIcon="close" size="20"></svg>
		</button>
	`
    }]
  }], function() {
    return [{
      type: I18n
    }];
  }, {
    active: [{
      type: Input
    }],
    activeTitle: [{
      type: Input
    }],
    inactiveTitle: [{
      type: Input
    }],
    selected: [{
      type: Output
    }]
  });
})();
var HeaderModule = class {
};
HeaderModule.ɵfac = function HeaderModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || HeaderModule)();
};
HeaderModule.ɵmod = ɵɵdefineNgModule({
  type: HeaderModule,
  declarations: [Header, HeaderItem, HeaderMenu, HeaderNavigation, HeaderGlobal, HeaderAction, Hamburger],
  imports: [CommonModule, ButtonModule, I18nModule, IconModule, RouterModule],
  exports: [Header, HeaderItem, HeaderMenu, HeaderNavigation, HeaderGlobal, HeaderAction, Hamburger]
});
HeaderModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ButtonModule, I18nModule, IconModule, RouterModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeaderModule, [{
    type: NgModule,
    args: [{
      declarations: [Header, HeaderItem, HeaderMenu, HeaderNavigation, HeaderGlobal, HeaderAction, Hamburger],
      imports: [CommonModule, ButtonModule, I18nModule, IconModule, RouterModule],
      exports: [Header, HeaderItem, HeaderMenu, HeaderNavigation, HeaderGlobal, HeaderAction, Hamburger]
    }]
  }], null, null);
})();
var RouterLinkExtendedDirective = class extends RouterLink {
  ngOnChanges(changes) {
    if (changes.routeExtras && this.routeExtras) {
      keys_default(this.routeExtras).forEach((routeExtraProperty) => this[routeExtraProperty] = this.routeExtras[routeExtraProperty]);
    }
    super.ngOnChanges(changes);
  }
};
RouterLinkExtendedDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵRouterLinkExtendedDirective_BaseFactory;
  return function RouterLinkExtendedDirective_Factory(__ngFactoryType__) {
    return (ɵRouterLinkExtendedDirective_BaseFactory || (ɵRouterLinkExtendedDirective_BaseFactory = ɵɵgetInheritedFactory(RouterLinkExtendedDirective)))(__ngFactoryType__ || RouterLinkExtendedDirective);
  };
})();
RouterLinkExtendedDirective.ɵdir = ɵɵdefineDirective({
  type: RouterLinkExtendedDirective,
  selectors: [["", "routerLink", ""]],
  inputs: {
    routeExtras: "routeExtras"
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterLinkExtendedDirective, [{
    type: Directive,
    args: [{
      // tslint:disable-next-line
      selector: "[routerLink]"
    }]
  }], null, {
    routeExtras: [{
      type: Input
    }]
  });
})();
var SideNavItem = class {
  constructor(domSanitizer, router) {
    this.domSanitizer = domSanitizer;
    this.router = router;
    this.useRouter = false;
    this.active = false;
    this.isSubMenu = false;
    this.navigation = new EventEmitter();
    this.selected = new EventEmitter();
    this.role = "listitem";
    this._href = "#";
  }
  /**
   * Link for the item. NOTE: *do not* pass unsafe or untrusted values, this has the potential to open you up to XSS attacks
   */
  set href(v) {
    if (v === void 0) {
      return;
    }
    this._href = v;
  }
  get href() {
    return this.domSanitizer.bypassSecurityTrustUrl(this._href);
  }
  get sideNav() {
    return !this.isSubMenu;
  }
  get menuItem() {
    return this.isSubMenu;
  }
  ngOnChanges(changes) {
    if (changes.active) {
      this.selected.emit(this.active);
    }
  }
  navigate(event) {
    if (this.router && this.route) {
      event.preventDefault();
      const status = this.router.navigate(this.route, this.routeExtras);
      this.navigation.emit(status);
    } else if (this._href === "#") {
      event.preventDefault();
    }
  }
};
SideNavItem.ɵfac = function SideNavItem_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || SideNavItem)(ɵɵdirectiveInject(DomSanitizer), ɵɵdirectiveInject(Router, 8));
};
SideNavItem.ɵcmp = ɵɵdefineComponent({
  type: SideNavItem,
  selectors: [["cds-sidenav-item"], ["ibm-sidenav-item"]],
  hostVars: 5,
  hostBindings: function SideNavItem_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", ctx.role);
      ɵɵclassProp("cds--side-nav__item", ctx.sideNav)("cds--side-nav__menu-item", ctx.menuItem);
    }
  },
  inputs: {
    href: "href",
    useRouter: "useRouter",
    active: "active",
    route: "route",
    isSubMenu: "isSubMenu",
    routeExtras: "routeExtras",
    title: "title"
  },
  outputs: {
    navigation: "navigation",
    selected: "selected"
  },
  standalone: false,
  features: [ɵɵNgOnChangesFeature],
  ngContentSelectors: _c97,
  decls: 5,
  vars: 2,
  consts: [["sidenavItemRouterTpl", ""], ["sidenavItemContentTpl", ""], ["class", "cds--side-nav__link", 3, "ngClass", "href", "click", 4, "ngIf", "ngIfElse"], [1, "cds--side-nav__link", 3, "click", "ngClass", "href"], [3, "ngTemplateOutlet"], ["routerLinkActive", "cds--side-nav__item--active", "ariaCurrentWhenActive", "page", 1, "cds--side-nav__link", 3, "routerLink", "routeExtras"], ["class", "cds--side-nav__icon", 4, "ngIf"], [1, "cds--side-nav__link-text"], [1, "cds--side-nav__icon"]],
  template: function SideNavItem_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c88);
      ɵɵtemplate(0, SideNavItem_a_0_Template, 2, 7, "a", 2)(1, SideNavItem_ng_template_1_Template, 2, 4, "ng-template", null, 0, ɵɵtemplateRefExtractor)(3, SideNavItem_ng_template_3_Template, 3, 1, "ng-template", null, 1, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      const sidenavItemRouterTpl_r4 = ɵɵreference(2);
      ɵɵproperty("ngIf", !ctx.useRouter)("ngIfElse", sidenavItemRouterTpl_r4);
    }
  },
  dependencies: [NgClass, NgIf, NgTemplateOutlet, RouterLink, RouterLinkActive, RouterLinkExtendedDirective],
  styles: ["[_nghost-%COMP%]{display:list-item}"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SideNavItem, [{
    type: Component,
    args: [{
      selector: "cds-sidenav-item, ibm-sidenav-item",
      template: `
		<a *ngIf="!useRouter; else sidenavItemRouterTpl"
			class="cds--side-nav__link"
			[ngClass]="{
				'cds--side-nav__item--active': active
			}"
			[href]="href"
			[attr.aria-current]="(active ? 'page' : null)"
			[attr.title]="title ? title : null"
			(click)="navigate($event)">
			<ng-template [ngTemplateOutlet]="sidenavItemContentTpl"></ng-template>
		</a>

		<ng-template #sidenavItemRouterTpl>
			<a
				[attr.title]="title ? title : null"
				[routerLink]="route"
				[routeExtras]="routeExtras"
				routerLinkActive="cds--side-nav__item--active"
				ariaCurrentWhenActive="page"
				class="cds--side-nav__link">
				<ng-template [ngTemplateOutlet]="sidenavItemContentTpl"></ng-template>
			</a>
		</ng-template>

		<ng-template #sidenavItemContentTpl>
			<div *ngIf="!isSubMenu" class="cds--side-nav__icon">
				<ng-content select="svg, [icon]"></ng-content>
			</div>
			<span class="cds--side-nav__link-text">
				<ng-content></ng-content>
			</span>
		</ng-template>
	`,
      styles: [":host{display:list-item}\n"]
    }]
  }], function() {
    return [{
      type: DomSanitizer
    }, {
      type: Router,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    href: [{
      type: Input
    }],
    useRouter: [{
      type: Input
    }],
    sideNav: [{
      type: HostBinding,
      args: ["class.cds--side-nav__item"]
    }],
    menuItem: [{
      type: HostBinding,
      args: ["class.cds--side-nav__menu-item"]
    }],
    active: [{
      type: Input
    }],
    route: [{
      type: Input
    }],
    isSubMenu: [{
      type: Input
    }],
    routeExtras: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    navigation: [{
      type: Output
    }],
    selected: [{
      type: Output
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }]
  });
})();
var SideNavMenu = class {
  constructor() {
    this.navItem = true;
    this.navItemIcon = true;
    this.role = "listitem";
    this.useRouter = false;
    this.expanded = false;
    this.hasActiveChild = false;
    this.activeItemsSubscription = new Subscription();
  }
  get navItemActive() {
    return this.hasActiveChild;
  }
  ngAfterContentInit() {
    setTimeout(() => {
      this.sidenavItems.forEach((item) => {
        item.isSubMenu = true;
        this.findActiveChildren();
        const activeItemSubscription = item.selected.subscribe(() => {
          this.findActiveChildren();
        });
        this.activeItemsSubscription.add(activeItemSubscription);
      });
      this.sidenavItems.changes.subscribe(() => {
        this.sidenavItems.forEach((item) => {
          item.isSubMenu = true;
          this.findActiveChildren();
          const activeItemSubscription = item.selected.subscribe(() => {
            this.findActiveChildren();
          });
          this.activeItemsSubscription.add(activeItemSubscription);
        });
      });
    });
  }
  ngOnDestroy() {
    this.activeItemsSubscription.unsubscribe();
  }
  toggle() {
    this.expanded = !this.expanded;
  }
  findActiveChildren() {
    this.hasActiveChild = this.sidenavItems.some((item) => item.active);
  }
};
SideNavMenu.ɵfac = function SideNavMenu_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || SideNavMenu)();
};
SideNavMenu.ɵcmp = ɵɵdefineComponent({
  type: SideNavMenu,
  selectors: [["cds-sidenav-menu"], ["ibm-sidenav-menu"]],
  contentQueries: function SideNavMenu_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, SideNavItem, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.sidenavItems = _t);
    }
  },
  hostVars: 7,
  hostBindings: function SideNavMenu_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", ctx.role);
      ɵɵclassProp("cds--side-nav__item", ctx.navItem)("cds--side-nav__item--icon", ctx.navItemIcon)("cds--side-nav__item--active", ctx.navItemActive);
    }
  },
  inputs: {
    useRouter: "useRouter",
    title: "title",
    expanded: "expanded",
    hasActiveChild: "hasActiveChild",
    menuItems: "menuItems"
  },
  standalone: false,
  ngContentSelectors: _c1211,
  decls: 11,
  vars: 3,
  consts: [["aria-haspopup", "true", "type", "button", 1, "cds--side-nav__submenu", 3, "click"], [1, "cds--side-nav__icon"], [1, "cds--side-nav__submenu-title"], [1, "cds--side-nav__icon", "cds--side-nav__icon--small", "cds--side-nav__submenu-chevron"], ["focusable", "false", "preserveAspectRatio", "xMidYMid meet", "xmlns", "http://www.w3.org/2000/svg", "width", "20", "height", "20", "viewBox", "0 0 32 32", "aria-hidden", "true", 2, "will-change", "transform"], ["d", "M16 22L6 12l1.4-1.4 8.6 8.6 8.6-8.6L26 12z"], ["role", "list", 1, "cds--side-nav__menu"], [4, "ngFor", "ngForOf"], [3, "href", "route", "routeExtras", "useRouter", "isSubMenu"]],
  template: function SideNavMenu_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c1112);
      ɵɵelementStart(0, "button", 0);
      ɵɵlistener("click", function SideNavMenu_Template_button_click_0_listener() {
        return ctx.toggle();
      });
      ɵɵelementStart(1, "div", 1);
      ɵɵprojection(2);
      ɵɵelementEnd();
      ɵɵelementStart(3, "span", 2);
      ɵɵtext(4);
      ɵɵelementEnd();
      ɵɵelementStart(5, "div", 3);
      ɵɵnamespaceSVG();
      ɵɵelementStart(6, "svg", 4);
      ɵɵelement(7, "path", 5);
      ɵɵelementEnd()()();
      ɵɵnamespaceHTML();
      ɵɵelementStart(8, "div", 6);
      ɵɵprojection(9, 1);
      ɵɵtemplate(10, SideNavMenu_ng_container_10_Template, 3, 6, "ng-container", 7);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵattribute("aria-expanded", ctx.expanded);
      ɵɵadvance(4);
      ɵɵtextInterpolate(ctx.title);
      ɵɵadvance(6);
      ɵɵproperty("ngForOf", ctx.menuItems);
    }
  },
  dependencies: [NgForOf, SideNavItem],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SideNavMenu, [{
    type: Component,
    args: [{
      selector: "cds-sidenav-menu, ibm-sidenav-menu",
      template: `
		<button
			(click)="toggle()"
			class="cds--side-nav__submenu"
			aria-haspopup="true"
			[attr.aria-expanded]="expanded"
			type="button">
			<div class="cds--side-nav__icon">
				<ng-content select="svg, [icon]"></ng-content>
			</div>
			<span class="cds--side-nav__submenu-title">{{title}}</span>
			<div class="cds--side-nav__icon cds--side-nav__icon--small cds--side-nav__submenu-chevron">
				<svg
					focusable="false"
					preserveAspectRatio="xMidYMid meet"
					style="will-change: transform;"
					xmlns="http://www.w3.org/2000/svg"
					width="20"
					height="20"
					viewBox="0 0 32 32"
					aria-hidden="true">
					<path d="M16 22L6 12l1.4-1.4 8.6 8.6 8.6-8.6L26 12z"></path>
				</svg>
			</div>
		</button>
		<div class="cds--side-nav__menu" role="list">
			<ng-content></ng-content>
			<ng-container *ngFor="let menuItem of menuItems">
				<cds-sidenav-item
					[href]="menuItem.href"
					[route]="menuItem.route"
					[routeExtras]="menuItem.routeExtras"
					[useRouter]="useRouter"
					[isSubMenu]="true">
					{{ menuItem.content }}
				</cds-sidenav-item>
			</ng-container>
		</div>
	`
    }]
  }], null, {
    navItem: [{
      type: HostBinding,
      args: ["class.cds--side-nav__item"]
    }],
    navItemIcon: [{
      type: HostBinding,
      args: ["class.cds--side-nav__item--icon"]
    }],
    navItemActive: [{
      type: HostBinding,
      args: ["class.cds--side-nav__item--active"]
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    useRouter: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    expanded: [{
      type: Input
    }],
    hasActiveChild: [{
      type: Input
    }],
    menuItems: [{
      type: Input
    }],
    sidenavItems: [{
      type: ContentChildren,
      args: [SideNavItem]
    }]
  });
})();
var SideNav = class {
  constructor(i18n) {
    this.i18n = i18n;
    this.hostClass = true;
    this.ariaLabel = "Side navigation";
    this.expanded = true;
    this.hidden = false;
    this.rail = false;
    this.ux = true;
    this.allowExpansion = false;
    this.useRouter = false;
  }
  toggle() {
    this.expanded = !this.expanded;
  }
};
SideNav.ɵfac = function SideNav_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || SideNav)(ɵɵdirectiveInject(I18n));
};
SideNav.ɵcmp = ɵɵdefineComponent({
  type: SideNav,
  selectors: [["cds-sidenav"], ["ibm-sidenav"]],
  hostVars: 10,
  hostBindings: function SideNav_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cds--side-nav", ctx.hostClass)("cds--side-nav--expanded", ctx.expanded)("cds--side-nav--hidden", ctx.hidden)("cds--side-nav--rail", ctx.rail)("cds--side-nav__navigation", ctx.ux);
    }
  },
  inputs: {
    ariaLabel: "ariaLabel",
    expanded: "expanded",
    hidden: "hidden",
    rail: "rail",
    allowExpansion: "allowExpansion",
    navigationItems: "navigationItems",
    useRouter: "useRouter"
  },
  standalone: false,
  ngContentSelectors: _c143,
  decls: 8,
  vars: 3,
  consts: [[1, "cds--side-nav__items"], ["role", "list"], [1, "cds--side-nav__header-navigation", "cds--side-nav__header-divider"], [4, "ngFor", "ngForOf"], [1, "cds--side-nav__footer"], ["class", "cds--side-nav__toggle", "type", "button", 3, "title", "click", 4, "ngIf"], [3, "href", "route", "routeExtras", "useRouter", "title", 4, "ngIf"], [3, "title", "useRouter", "menuItems", 4, "ngIf"], [3, "href", "route", "routeExtras", "useRouter", "title"], [3, "title", "useRouter", "menuItems"], ["type", "button", 1, "cds--side-nav__toggle", 3, "click", "title"], [1, "cds--side-nav__icon"], ["focusable", "false", "preserveAspectRatio", "xMidYMid meet", "style", "will-change: transform;", "xmlns", "http://www.w3.org/2000/svg", "width", "20", "height", "20", "viewBox", "0 0 32 32", "aria-hidden", "true", 4, "ngIf"], [1, "cds--assistive-text"], ["focusable", "false", "preserveAspectRatio", "xMidYMid meet", "xmlns", "http://www.w3.org/2000/svg", "width", "20", "height", "20", "viewBox", "0 0 32 32", "aria-hidden", "true", 2, "will-change", "transform"], ["d", "M24 9.4L22.6 8 16 14.6 9.4 8 8 9.4l6.6 6.6L8 22.6 9.4 24l6.6-6.6 6.6 6.6 1.4-1.4-6.6-6.6L24 9.4z"], ["d", "M22 16L12 26l-1.4-1.4 8.6-8.6-8.6-8.6L12 6z"]],
  template: function SideNav_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c1310);
      ɵɵelementStart(0, "nav", 0);
      ɵɵprojection(1);
      ɵɵelementStart(2, "div", 1)(3, "div", 2);
      ɵɵtemplate(4, SideNav_ng_container_4_Template, 3, 2, "ng-container", 3);
      ɵɵelementEnd();
      ɵɵprojection(5, 1);
      ɵɵelementEnd();
      ɵɵelementStart(6, "footer", 4);
      ɵɵtemplate(7, SideNav_button_7_Template, 8, 8, "button", 5);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵattribute("aria-label", ctx.ariaLabel);
      ɵɵadvance(4);
      ɵɵproperty("ngForOf", ctx.navigationItems);
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.allowExpansion);
    }
  },
  dependencies: [NgForOf, NgIf, SideNavItem, SideNavMenu, AsyncPipe],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SideNav, [{
    type: Component,
    args: [{
      selector: "cds-sidenav, ibm-sidenav",
      template: `
		<nav class="cds--side-nav__items" [attr.aria-label]="ariaLabel">
			<ng-content select="cds-sidenav-header,ibm-sidenav-header"></ng-content>
			<div role="list">
				<div class="cds--side-nav__header-navigation cds--side-nav__header-divider">
					<ng-container *ngFor="let navigationItem of navigationItems">
						<cds-sidenav-item
							*ngIf="navigationItem.type === 'item'"
							[href]="navigationItem.href"
							[route]="navigationItem.route"
							[routeExtras]="navigationItem.routeExtras"
							[useRouter]="useRouter"
							[title]="navigationItem.title">
							{{ navigationItem.content }}
						</cds-sidenav-item>
						<cds-sidenav-menu
							*ngIf="navigationItem.type === 'menu'"
							[title]="navigationItem.title"
							[useRouter]="useRouter"
							[menuItems]="navigationItem.menuItems">
						</cds-sidenav-menu>
					</ng-container>
				</div>
				<ng-content></ng-content>
			</div>
			<footer class="cds--side-nav__footer">
				<button
					*ngIf="allowExpansion"
					class="cds--side-nav__toggle"
					type="button"
					[title]="(expanded ? i18n.get('UI_SHELL.SIDE_NAV.TOGGLE_CLOSE') : i18n.get('UI_SHELL.SIDE_NAV.TOGGLE_OPEN')) | async"
					(click)="toggle()">
					<div class="cds--side-nav__icon">
						<svg
							*ngIf="expanded"
							focusable="false"
							preserveAspectRatio="xMidYMid meet"
							style="will-change: transform;"
							xmlns="http://www.w3.org/2000/svg"
							width="20"
							height="20"
							viewBox="0 0 32 32"
							aria-hidden="true">
							<path d="M24 9.4L22.6 8 16 14.6 9.4 8 8 9.4l6.6 6.6L8 22.6 9.4 24l6.6-6.6 6.6 6.6 1.4-1.4-6.6-6.6L24 9.4z"></path>
						</svg>
						<svg
							*ngIf="!expanded"
							focusable="false"
							preserveAspectRatio="xMidYMid meet"
							style="will-change: transform;"
							xmlns="http://www.w3.org/2000/svg"
							width="20"
							height="20"
							viewBox="0 0 32 32"
							aria-hidden="true">
							<path d="M22 16L12 26l-1.4-1.4 8.6-8.6-8.6-8.6L12 6z"></path>
						</svg>
					</div>
					<span class="cds--assistive-text">
						{{(expanded ? i18n.get('UI_SHELL.SIDE_NAV.TOGGLE_CLOSE') : i18n.get('UI_SHELL.SIDE_NAV.TOGGLE_OPEN')) | async}}
					</span>
				</button>
			</footer>
		</nav>
	`,
      encapsulation: ViewEncapsulation.None
    }]
  }], function() {
    return [{
      type: I18n
    }];
  }, {
    hostClass: [{
      type: HostBinding,
      args: ["class.cds--side-nav"]
    }],
    ariaLabel: [{
      type: Input
    }],
    expanded: [{
      type: HostBinding,
      args: ["class.cds--side-nav--expanded"]
    }, {
      type: Input
    }],
    hidden: [{
      type: HostBinding,
      args: ["class.cds--side-nav--hidden"]
    }, {
      type: Input
    }],
    rail: [{
      type: HostBinding,
      args: ["class.cds--side-nav--rail"]
    }, {
      type: Input
    }],
    ux: [{
      type: HostBinding,
      args: ["class.cds--side-nav__navigation"]
    }],
    allowExpansion: [{
      type: Input
    }],
    navigationItems: [{
      type: Input
    }],
    useRouter: [{
      type: Input
    }]
  });
})();
var SideNavModule = class {
};
SideNavModule.ɵfac = function SideNavModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || SideNavModule)();
};
SideNavModule.ɵmod = ɵɵdefineNgModule({
  type: SideNavModule,
  declarations: [SideNav, SideNavItem, SideNavMenu, RouterLinkExtendedDirective],
  imports: [CommonModule, I18nModule, RouterModule],
  exports: [SideNav, SideNavItem, SideNavMenu]
});
SideNavModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, I18nModule, RouterModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SideNavModule, [{
    type: NgModule,
    args: [{
      declarations: [SideNav, SideNavItem, SideNavMenu, RouterLinkExtendedDirective],
      imports: [CommonModule, I18nModule, RouterModule],
      exports: [SideNav, SideNavItem, SideNavMenu]
    }]
  }], null, null);
})();
var Panel = class {
  constructor() {
    this.expanded = false;
  }
};
Panel.ɵfac = function Panel_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Panel)();
};
Panel.ɵcmp = ɵɵdefineComponent({
  type: Panel,
  selectors: [["cds-panel"], ["ibm-panel"]],
  inputs: {
    expanded: "expanded",
    ariaLabel: "ariaLabel"
  },
  standalone: false,
  ngContentSelectors: _c231,
  decls: 2,
  vars: 4,
  consts: [[1, "cds--header-panel", 3, "ngClass"]],
  template: function Panel_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 0);
      ɵɵprojection(1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngClass", ɵɵpureFunction1(2, _c153, ctx.expanded));
      ɵɵattribute("aria-label", ctx.ariaLabel);
    }
  },
  dependencies: [NgClass],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Panel, [{
    type: Component,
    args: [{
      selector: "cds-panel, ibm-panel",
      template: `
		<div
			class="cds--header-panel"
			[attr.aria-label]="ariaLabel"
			[ngClass]="{
				'cds--header-panel--expanded': expanded
			}">
			<ng-content></ng-content>
		</div>
	`
    }]
  }], null, {
    expanded: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }]
  });
})();
var SwitcherList = class {
  constructor() {
    this.switcher = true;
    this.role = "list";
  }
};
SwitcherList.ɵfac = function SwitcherList_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || SwitcherList)();
};
SwitcherList.ɵcmp = ɵɵdefineComponent({
  type: SwitcherList,
  selectors: [["cds-switcher-list"], ["ibm-switcher-list"]],
  hostVars: 3,
  hostBindings: function SwitcherList_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", ctx.role);
      ɵɵclassProp("cds--switcher", ctx.switcher);
    }
  },
  standalone: false,
  ngContentSelectors: _c231,
  decls: 1,
  vars: 0,
  template: function SwitcherList_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  styles: ["[_nghost-%COMP%]{display:block}"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SwitcherList, [{
    type: Component,
    args: [{
      selector: "cds-switcher-list, ibm-switcher-list",
      template: `
			<ng-content></ng-content>
	`,
      styles: [":host{display:block}\n"]
    }]
  }], null, {
    switcher: [{
      type: HostBinding,
      args: ["class.cds--switcher"]
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }]
  });
})();
var SwitcherListItem = class {
  constructor(domSanitizer, router) {
    this.domSanitizer = domSanitizer;
    this.router = router;
    this.active = false;
    this.navigation = new EventEmitter();
    this.itemClass = true;
    this.itemRole = "listitem";
    this._href = "#";
    this._target = "";
  }
  /**
   * Optional link for the underlying anchor.
   */
  set href(value) {
    this._href = value;
  }
  get href() {
    return this.domSanitizer.bypassSecurityTrustUrl(this._href);
  }
  /**
   * Optional target for the underlying anchor.
   */
  set target(value) {
    this._target = value;
  }
  get target() {
    return this._target;
  }
  navigate(event) {
    if (this.router && this.route) {
      event.preventDefault();
      const status = this.router.navigate(this.route, this.routeExtras);
      this.navigation.emit(status);
    } else if (this._href === "#") {
      event.preventDefault();
    }
  }
};
SwitcherListItem.ɵfac = function SwitcherListItem_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || SwitcherListItem)(ɵɵdirectiveInject(DomSanitizer), ɵɵdirectiveInject(Router, 8));
};
SwitcherListItem.ɵcmp = ɵɵdefineComponent({
  type: SwitcherListItem,
  selectors: [["cds-switcher-list-item"], ["ibm-switcher-list-item"]],
  hostVars: 3,
  hostBindings: function SwitcherListItem_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", ctx.itemRole);
      ɵɵclassProp("cds--switcher__item", ctx.itemClass);
    }
  },
  inputs: {
    active: "active",
    route: "route",
    routeExtras: "routeExtras",
    href: "href",
    target: "target"
  },
  outputs: {
    navigation: "navigation"
  },
  standalone: false,
  ngContentSelectors: _c231,
  decls: 2,
  vars: 5,
  consts: [[1, "cds--switcher__item-link", 3, "click", "ngClass", "href", "target"]],
  template: function SwitcherListItem_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "a", 0);
      ɵɵlistener("click", function SwitcherListItem_Template_a_click_0_listener($event) {
        return ctx.navigate($event);
      });
      ɵɵprojection(1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngClass", ɵɵpureFunction1(3, _c163, ctx.active))("href", ctx.href, ɵɵsanitizeUrl)("target", ctx.target);
    }
  },
  dependencies: [NgClass],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SwitcherListItem, [{
    type: Component,
    args: [{
      selector: "cds-switcher-list-item, ibm-switcher-list-item",
      template: `
		<a
			class="cds--switcher__item-link"
			[ngClass]="{
				'cds--switcher__item-link--selected': active
			}"
			[href]="href"
			[target]="target"
			(click)="navigate($event)">
			<ng-content></ng-content>
		</a>
	`
    }]
  }], function() {
    return [{
      type: DomSanitizer
    }, {
      type: Router,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    active: [{
      type: Input
    }],
    route: [{
      type: Input
    }],
    routeExtras: [{
      type: Input
    }],
    href: [{
      type: Input
    }],
    navigation: [{
      type: Output
    }],
    target: [{
      type: Input
    }],
    itemClass: [{
      type: HostBinding,
      args: ["class.cds--switcher__item"]
    }],
    itemRole: [{
      type: HostBinding,
      args: ["attr.role"]
    }]
  });
})();
var PanelModule = class {
};
PanelModule.ɵfac = function PanelModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || PanelModule)();
};
PanelModule.ɵmod = ɵɵdefineNgModule({
  type: PanelModule,
  declarations: [Panel, SwitcherList, SwitcherListItem],
  imports: [CommonModule, I18nModule],
  exports: [Panel, SwitcherList, SwitcherListItem]
});
PanelModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, I18nModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PanelModule, [{
    type: NgModule,
    args: [{
      declarations: [Panel, SwitcherList, SwitcherListItem],
      imports: [CommonModule, I18nModule],
      exports: [Panel, SwitcherList, SwitcherListItem]
    }]
  }], null, null);
})();
var UIShellModule = class {
};
UIShellModule.ɵfac = function UIShellModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || UIShellModule)();
};
UIShellModule.ɵmod = ɵɵdefineNgModule({
  type: UIShellModule,
  imports: [CommonModule, I18nModule, HeaderModule, SideNavModule, PanelModule],
  exports: [HeaderModule, SideNavModule, PanelModule]
});
UIShellModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, I18nModule, HeaderModule, SideNavModule, PanelModule, HeaderModule, SideNavModule, PanelModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UIShellModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, I18nModule, HeaderModule, SideNavModule, PanelModule],
      exports: [HeaderModule, SideNavModule, PanelModule]
    }]
  }], null, null);
})();
export {
  ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER,
  ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER_FACTORY,
  AbstractDropdownView,
  Accordion,
  AccordionItem,
  AccordionModule,
  ActionableButton,
  ActionableNotification,
  ActionableSubtitle,
  ActionableTitle,
  AlertModal,
  AlertModalType,
  AnimationFrameService,
  AnimationFrameServiceSingleton,
  BaseIconButton,
  BaseModal,
  BaseModalService,
  BaseNotification,
  BaseTabHeader,
  Breadcrumb,
  BreadcrumbItemComponent,
  BreadcrumbModule,
  Button,
  ButtonModule,
  ButtonSet,
  Checkbox,
  CheckboxModule,
  CheckboxState,
  ClickableTile,
  ClickableTileIconDirective,
  CloseReasons,
  CodeSnippet,
  CodeSnippetModule,
  ColumnDirective,
  ComboBox,
  ComboBoxModule,
  ContainedList,
  ContainedListItem,
  ContainedListKind,
  ContainedListModule,
  ContainedListSize,
  ContentSwitcher,
  ContentSwitcherModule,
  ContentSwitcherOption,
  ContextMenuComponent,
  ContextMenuDividerComponent,
  ContextMenuGroupComponent,
  ContextMenuItemComponent,
  ContextMenuModule,
  DEFAULT_TOOLTIP_CONFIG,
  DOCUMENT_SERVICE_PROVIDER,
  DOCUMENT_SERVICE_PROVIDER_FACTORY,
  DataGridInteractionModel,
  DatePicker,
  DatePickerInput,
  DatePickerInputModule,
  DatePickerModule,
  Dialog,
  DialogDirective,
  DialogModule,
  DialogService,
  DocumentService,
  Dropdown,
  DropdownList,
  DropdownModule,
  DropdownService,
  EXPERIMENTAL_SERVICE_PROVIDER,
  EXPERIMENTAL_SERVICE_PROVIDER_FACTORY,
  ElementService,
  EventService,
  ExpandableTile,
  ExpandableTileAboveFoldDirective,
  ExpandableTileBelowFoldDirective,
  ExpandedRowHover,
  ExperimentalModule,
  ExperimentalService,
  FileComponent,
  FileUploader,
  FileUploaderModule,
  GridDirective,
  GridModule,
  GridService,
  Hamburger,
  HcModeChecker,
  Header,
  HeaderAction,
  HeaderGlobal,
  HeaderItem,
  HeaderMenu,
  HeaderModule,
  HeaderNavigation,
  I18N_SERVICE_PROVIDER,
  I18N_SERVICE_PROVIDER_FACTORY,
  I18n,
  I18nModule,
  ICON_SERVICE_PROVIDER,
  ICON_SERVICE_PROVIDER_FACTORY,
  IconButton,
  IconCache,
  IconDirective,
  IconMemoryCache,
  IconModule,
  IconNameNotFoundError,
  IconService,
  IconSizeNotFoundError,
  InlineLoading,
  InlineLoadingModule,
  InlineLoadingState,
  InputModule,
  Label,
  LayerDirective,
  LayerModule,
  LayoutModule,
  Link,
  LinkIconDirective,
  LinkModule,
  List,
  ListColumn,
  ListHeader,
  ListItemDirective,
  ListModule,
  ListRow,
  Loading,
  LoadingModule,
  MenuButtonComponent,
  MenuButtonModule,
  Modal,
  ModalButtonType,
  ModalContent,
  ModalContentText,
  ModalFooter,
  ModalHeader,
  ModalHeaderHeading,
  ModalHeaderLabel,
  ModalModule,
  ModalService,
  NFormsModule,
  Notification,
  NotificationDisplayService,
  NotificationModule,
  NotificationService,
  NotificationSubtitle,
  NotificationTitle,
  NumberComponent as Number,
  NumberChange,
  NumberComponent,
  NumberModule,
  OptGroup,
  Option,
  OverflowMenu,
  OverflowMenuCustomPane,
  OverflowMenuDirective,
  OverflowMenuOption,
  OverflowMenuPane,
  Overlay,
  Overridable,
  PLACEHOLDER_SERVICE_PROVIDER,
  PLACEHOLDER_SERVICE_PROVIDER_FACTORY,
  PLACEMENTS,
  Pagination,
  PaginationModel,
  PaginationModule,
  PaginationNav,
  PaginationNavItem,
  PaginationOverflow,
  Panel,
  PanelModule,
  PasswordInput,
  PasswordInputLabelComponent,
  Placeholder,
  PlaceholderModule,
  PlaceholderService,
  PopoverContainer,
  PopoverContent,
  PopoverModule,
  Position,
  ProgressBar,
  ProgressBarModule,
  ProgressIndicator,
  ProgressIndicatorModule,
  Radio,
  RadioChange,
  RadioGroup,
  RadioModule,
  ReplacePipe,
  RowDirective,
  ScrollableList,
  Search,
  SearchModule,
  Select,
  SelectModule,
  SelectionTile,
  SideNav,
  SideNavItem,
  SideNavMenu,
  SideNavModule,
  SkeletonModule,
  SkeletonPlaceholder,
  SkeletonText,
  Slider,
  SliderModule,
  SnippetType,
  StackDirective,
  StructuredList,
  StructuredListModule,
  SwitcherList,
  SwitcherListItem,
  Tab,
  TabHeader,
  TabHeaderGroup,
  TabHeaders,
  TabSkeleton,
  Table,
  TableAdapter,
  TableBody,
  TableCellAdapter,
  TableCheckbox,
  TableContainer,
  TableData,
  TableDirective,
  TableDomAdapter,
  TableExpandButton,
  TableExpandedRow,
  TableHead,
  TableHeadCell,
  TableHeadCellLabel,
  TableHeadCheckbox,
  TableHeadExpand,
  TableHeader,
  TableHeaderDescription,
  TableHeaderItem,
  TableHeaderTitle,
  TableItem,
  TableModel,
  TableModule,
  TableRadio,
  TableRow,
  TableRowAdapter,
  TableRowComponent,
  TableToolbar,
  TableToolbarActions,
  TableToolbarContent,
  TableToolbarSearch,
  Tabs,
  TabsModule,
  Tag,
  TagFilter,
  TagIconDirective,
  TagModule,
  TagOperationalComponent,
  TagSelectableComponent,
  TextArea,
  TextInput,
  TextInputLabelComponent,
  TextareaLabelComponent,
  ThemeDirective,
  ThemeModule,
  Tile,
  TileGroup,
  TilesModule,
  TimePicker,
  TimePickerModule,
  TimePickerSelect,
  TimePickerSelectModule,
  Toast,
  ToastCaption,
  ToastSubtitle,
  ToastTitle,
  Toggle,
  ToggleModule,
  ToggleState,
  Toggletip,
  ToggletipAction,
  ToggletipButton,
  ToggletipContent,
  ToggletipLabel,
  ToggletipModule,
  Tooltip,
  TooltipDefinition,
  TooltipModule,
  TreeNodeComponent,
  TreeViewComponent,
  TreeViewService,
  TreeviewModule,
  UIShellModule,
  UtilsModule,
  clone,
  closestAttr,
  defaultPositions,
  findNextElem,
  findPrevElem,
  focusNextElem,
  focusNextTree,
  focusPrevElem,
  getEventObservable,
  getScrollableParents,
  getScrollbarWidth,
  hasScrollableParents,
  isScrollableElement,
  isVisibleInContainer,
  merge2 as merge,
  position,
  replace,
  scrollableParentsObservable
};
/*! Bundled license information:

flatpickr/dist/plugins/rangePlugin.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
    Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

flatpickr/dist/l10n/index.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
    Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

@angular/forms/fesm2022/forms.mjs:
  (**
   * @license Angular v19.2.3
   * (c) 2010-2025 Google LLC. https://angular.io/
   * License: MIT
   *)
*/
//# sourceMappingURL=carbon-components-angular.js.map
